
 (char-name (read-from-string (let ((*print-readably* t)) (write-to-string #\Space))))
(subtypep '(or (vector t 10) (vector t 5)) '(vector t))

(map '(vector t 10) #'identity '(1 2 3 4 5)) 
(map '(vector t 5) #'identity '(1 2 3 4 5)) 

(map '(or (vector t 10)(vector t 5)) #'identity '(1 2 3 4 5))


#(1 2 3 4 5))

(REINITIALIZE-INSTANCE.ERROR.1
DEFGENERIC.ERROR.20
DEFGENERIC.ERROR.21
DEFGENERIC.30
CALL-NEXT-METHOD.ERROR.1
CALL-NEXT-METHOD.ERROR.2
DEFMETHOD.ERROR.14
DEFMETHOD.ERROR.15
MAKE-CONDITION.3
MAKE-CONDITION.4
DELETE-PACKAGE.5
DELETE-PACKAGE.6
MAP.48
TYPE-OF.1
TYPE-OF.4
CHAR-UPCASE.2
CHAR-DOWNCASE.2
ENSURE-DIRECTORIES-EXIST.8
FRESH-LINE.5
PRINT.RANDOM-STATE.1
PPRINT-FILL.14
PPRINT-FILL.15
PPRINT-LINEAR.14
PPRINT-TABULAR.13
PPRINT-LOGICAL-BLOCK.17
PPRINT-POP.7
PPRINT-POP.8
FORMAT.LOGICAL-BLOCK.CIRCLE.1
FORMAT.LOGICAL-BLOCK.CIRCLE.2
FORMAT.LOGICAL-BLOCK.CIRCLE.3
FORMAT.JUSTIFY.30
FORMAT.JUSTIFY.32)

(REINITIALIZE-INSTANCE.ERROR.1
DEFGENERIC.ERROR.20
DEFGENERIC.ERROR.21
DEFGENERIC.30
CALL-NEXT-METHOD.ERROR.1
CALL-NEXT-METHOD.ERROR.2
DEFMETHOD.ERROR.14
DEFMETHOD.ERROR.15
MAKE-CONDITION.3
MAKE-CONDITION.4
DELETE-PACKAGE.5
DELETE-PACKAGE.6
MAP.48
TYPE-OF.1
TYPE-OF.4
CHAR-UPCASE.2
CHAR-DOWNCASE.2
ENSURE-DIRECTORIES-EXIST.8
FRESH-LINE.5
PRINT.RANDOM-STATE.1
PPRINT-FILL.14
PPRINT-FILL.15
PPRINT-LINEAR.14
PPRINT-TABULAR.13
PPRINT-LOGICAL-BLOCK.17
PPRINT-POP.7
PPRINT-POP.8
FORMAT.LOGICAL-BLOCK.CIRCLE.1
FORMAT.LOGICAL-BLOCK.CIRCLE.2
FORMAT.LOGICAL-BLOCK.CIRCLE.3
FORMAT.JUSTIFY.30
FORMAT.JUSTIFY.32
WITH-STANDARD-IO-SYNTAX.23)



WITH-STANDARD-IO-SYNTAX.23 TYPE-OF.4 
FORMAT.C.4A FORMATTER.C.4A PRINT-LEVEL.1 


Test FORMAT.JUSTIFY.30 failed
Form: (WITH-STANDARD-IO-SYNTAX (LET ((*PRINT-PRETTY* T) (*PRINT-ESCAPE* NIL) (*PRINT-READABLY* NIL) (*PRINT-RIGHT-MARGIN* 100) (*PACKAGE* #<PACKAGE "CL-TEST">) (*PRINT-LENGTH* NIL) (*PRINT-MISER-WIDTH* NIL) (*PRINT-CIRCLE* NIL)) (FORMAT NIL "~%X ~<~%X ~0,3:;AAA~>~<~%X ~0,3:;BBB~>~<~%X ~0,3:;CCC~>")))
Expected value:
          "
X
X AAA
X BBB
X CCC"
Actual value:
          "
X
X AAA
X BBB
X CCC"
 FORMAT.JUSTIFY.31
Test FORMAT.JUSTIFY.32 failed
Form: (WITH-STANDARD-IO-SYNTAX (LET ((*PRINT-PRETTY* T) (*PRINT-ESCAPE* NIL) (*PRINT-READABLY* NIL) (*PRINT-RIGHT-MARGIN* 100) (*PACKAGE* #<PACKAGE "CL-TEST">) (*PRINT-LENGTH* NIL) (*PRINT-MISER-WIDTH* NIL) (*PRINT-CIRCLE* NIL)) (FORMAT NIL "~%X ~<~%X ~0,3:;AAA~>,~<~%X ~0,3:;BBB~>,~<~%X ~0,3:;CCC~>")))
Expected value:
          "
X
X AAA,
X BBB,
X CCC"
Actual value:
          "
X
X AAA,
X BBB,
X CCC"


Test MAP.48 failed
Form: (LET ((TYPE (QUOTE (OR (VECTOR T 10) (VECTOR T 5))))) (IF (SUBTYPEP TYPE (QUOTE (VECTOR T))) (EQUALPT (MAP TYPE (FUNCTION IDENTITY) (QUOTE (1 2 3 4 5))) #(1 2 3 4 5)) T))
Expected value:
          T
Actual value:
          #<SIMPLE-TYPE-ERROR {A069435}> [(OR (VECTOR T 10) (VECTOR T 5)) is not a sequence type.]
 MAP.ERROR.1 MAP.ERROR.1A MAP.ERROR.2 MAP.ERROR.3 MAP.ERROR.4
 MAP.ERROR.5 MAP.ERROR.6 MAP.ERROR.7 MAP.ERROR.8 MAP.ERROR.9
 MAP.ERROR.10 MAP.ERROR.11 MAP.ERROR.12 MAP.ERROR.13 MAP.FILL.1
 MAP.FILL.2 MAP.FILL.3 MAP.FILL.4 MAP.FILL.5 MAP.FILL.6
 MAP.SPECIALIZED-STRING.1 MAP.SPECIALIZED-STRING.2
Test MAP.SPECIALIZED-STRING.3 failed
Form: (LET ((S (MAP (QUOTE BASE-STRING) (FUNCTION IDENTITY) (QUOTE (#\a #\b #\c))))) (ASSERT (TYPEP S (QUOTE                    BASE-STRING))) S)
Expected value:
          "abc"
Actual value:
          #<SIMPLE-ERROR {35EC28B7}> [The assertion (TYPEP S (QUOTE BASE-STRING)) failed.]
 MAP.SPECIALIZED-VECTOR.1 MAP.SPECIALIZED-VECTOR.2


Test FRESH-LINE.5 failed
Form: (LET (RESULT) (VALUES (WITH-OUTPUT-TO-STRING (S) (WRITE-CHAR #\  S) (SETQ RESULT (LIST (MULTIPLE-VALUE-LIST (NOTNOT-MV (FRESH-LINE S))) (MULTIPLE-VALUE-LIST (FRESH-LINE S)) (MULTIPLE-VALUE-LIST (FRESH-LINE S)))))                    RESULT))
Expected values:
          "
"
          ((T) (NIL) (NIL))
Actual values:
          "
"
          ((T) (NIL) (NIL))



Test PPRINT-FILL.14 failed
Form: (MY-WITH-STANDARD-IO-SYNTAX (LET ((*PRINT-PRETTY* T) (*PRINT-READABLY* NIL) (*PRINT-RIGHT-MARGIN* 100) (*PACKAGE* (FIND-PACKAGE "CL-TEST")) (*PRINT-LENGTH* NIL) (*PRINT-CIRCLE* T)) (WITH-OUTPUT-TO-STRING (S) (PPRINT-FILL S (LET ((X (LIST (QUOTE A)))) (LIST X X))))))
Expected value:
          "(#1=(A) #1#)"
Actual value:
          "((A) )"
Test PPRINT-FILL.15 failed
Form: (MY-WITH-STANDARD-IO-SYNTAX (LET ((*PRINT-PRETTY* T) (*PRINT-READABLY* NIL) (*PRINT-RIGHT-MARGIN* 100) (*PACKAGE* (FIND-PACKAGE "CL-TEST")) (*PRINT-LENGTH* 500) (*PRINT-CIRCLE* T)) (WITH-OUTPUT-TO-STRING (S) (PPRINT-FILL S (LET ((X (LIST (QUOTE A)))) (SETF (CDR X) X) X)))))
Expected value:
          "#1=(A . #1#)"
Actual value:
          "(A A . )"


Test PRINT.RANDOM-STATE.1 failed
Form: (LOOP REPEAT 100 DO (LOOP REPEAT 50 DO (RANDOM 1000)) NCONC (LET* ((RS1 (MAKE-RANDOM-STATE *RANDOM-STATE*)) (RS2 (WITH-STANDARD-IO-SYNTAX (READ-FROM-STRING (WRITE-TO-STRING RS1 :READABLY T)))) (RESULT (LIST (NOTNOT (RANDOM-STATE-P RS2)) (IS-SIMILAR RS1 RS2)))) (UNLESS (EQUAL RESULT (QUOTE (T T))) (LIST RESULT RS1 RS2))))
Expected value:
          NIL
Actual value:
          #<READER-ERROR {69AA9AD1}> [Illegal # macro character: #\<]


Test FRESH-LINE.5 failed
Form: (LET (RESULT) (VALUES (WITH-OUTPUT-TO-STRING (S) (WRITE-CHAR #\  S) (SETQ RESULT (LIST (MULTIPLE-VALUE-LIST (NOTNOT-MV (FRESH-LINE S))) (MULTIPLE-VALUE-LIST (FRESH-LINE S)) (MULTIPLE-VALUE-LIST (FRESH-LINE S))))) RESULT))
Expected values:
          "
"
          ((T) (NIL) (NIL))
Actual values:
          "
"
          ((T) (NIL) (NIL))


Test CHAR-UPCASE.2 failed
Form: (CHAR-UPCASE.2.BODY)
Expected value:
          T
Actual value:
          NIL
 CHAR-UPCASE.3 CHAR-UPCASE.4 CHAR-UPCASE.ORDER.1 CHAR-UPCASE.ERROR.1
 CHAR-UPCASE.ERROR.2 CHAR-DOWNCASE.1
Test CHAR-DOWNCASE.2 failed
Form: (CHAR-DOWNCASE.2.BODY)
Expected value:
          T
Actual value:
          NIL


CL-TEST(8): (disassemble #'CHAR-UPCASE.2.BODY)
; Couldn't fully decompile method execute
; // Decompiled by Jad v1.5.8e. Copyright 2001 Pavel Kouznetsov.
; // Jad home page: http://www.geocities.com/kpdus/jad.html
; // Decompiler options: packimports(3) annotate
; // Source File Name:   char-aux.lsp
;
; package org.armedbear.lisp;
;
;
; // Referenced classes of package org.armedbear.lisp:
; //            Primitive, LispThread, Fixnum, LispInteger,
; //            Lisp, LispObject, Symbol, Nil
;
; public class char_aux_33 extends Primitive
; {
;
;     public LispObject execute()
;     {
;         LispThread lispthread;
;         Object obj;
;         lispthread = LispThread.currentThread();
;     //    0    0:invokestatic    #15  <Method LispThread LispThread.currentThread()>
;     //    1    3:astore_1
;         obj = Fixnum.ZERO;
;     //    2    4:getstatic       #21  <Field Fixnum Fixnum.ZERO>
;     //    3    7:astore_2
;         0x10000;
;     //    4    8:ldc1            #3   <Int 0x10000>
;         0x10000;
;     //    5   10:dup
;         0x10000;
;     //    6   11:ldc1            #3   <Int 0x10000>
;         JVM INSTR dup_x1 ;
;     //    7   13:dup_x1
;         JVM INSTR icmplt 18;
;     //    8   14:icmplt          18
;            goto _L1 _L2
; _L1:
;         JVM INSTR swap ;
;     //    9   17:swap
; _L2:
;         JVM INSTR pop ;
;     //   10   18:pop
;         LispInteger.getInstance();
;     //   11   19:invokestatic    #27  <Method LispInteger LispInteger.getInstance(int)>
;         LispInteger lispinteger;
;         lispinteger;
;     //   12   22:astore_3
;         LispObject lispobject = Lisp.NIL;
;     //   13   23:getstatic       #33  <Field LispObject Lisp.NIL>
;     //   14   26:astore          4
; _L13:
;         Object obj1;
;         if(((LispObject) (obj)).isGreaterThanOrEqualTo(lispinteger))
;     //*  15   28:aload_2
;     //*  16   29:aload_3
;     //*  17   30:invokeinterface #39  <Method boolean LispObject.isGreaterThanOrEqualTo(LispObject)>
;     //*  18   35:ifeq            50
;         {
;             if(Lisp.interrupted)
;     //*  19   38:getstatic       #43  <Field boolean Lisp.interrupted>
;     //*  20   41:ifeq            47
;                 Lisp.handleInterrupt();
;     //   21   44:invokestatic    #47  <Method void Lisp.handleInterrupt()>
;             break; /* Loop/switch isn't completed */
;     //   22   47:goto            208
;         }
;         lispobject = lispthread.execute(Symbol.CODE_CHAR, ((LispObject) (obj)));
;     //   23   50:aload_1
;     //   24   51:getstatic       #52  <Field Symbol Symbol.CODE_CHAR>
;     //   25   54:aload_2
;     //   26   55:invokevirtual   #55  <Method LispObject LispThread.execute(LispObject, LispObject)>
;     //   27   58:astore          4
;         obj1 = lispobject == Lisp.NIL ? ((Object) (Lisp.T)) : ((Object) (Lisp.NIL));
;     //   28   60:aload           4
;     //   29   62:getstatic       #33  <Field LispObject Lisp.NIL>
;     //   30   65:if_acmpeq       74
;     //   31   68:getstatic       #33  <Field LispObject Lisp.NIL>
;     //   32   71:goto            77
;     //   33   74:getstatic       #58  <Field Symbol Lisp.T>
;     //   34   77:dup
;         obj1;
;         if(obj1 != Lisp.NIL) goto _L4; else goto _L3
;     //   35   78:getstatic       #33  <Field LispObject Lisp.NIL>
;     //   36   81:if_acmpne       169
; _L3:
;         JVM INSTR pop ;
;     //   37   84:pop
;         LispObject lispobject1;
;         LispObject lispobject2;
;         lispobject1 = lispthread.execute(Symbol.CHAR_UPCASE, lispobject);
;     //   38   85:aload_1
;     //   39   86:getstatic       #61  <Field Symbol Symbol.CHAR_UPCASE>
;     //   40   89:aload           4
;     //   41   91:invokevirtual   #55  <Method LispObject LispThread.execute(LispObject, LispObject)>
;     //   42   94:astore          5
;         lispobject2 = lispthread.execute(Symbol.LOWER_CASE_P, lispobject);
;     //   43   96:aload_1
;     //   44   97:getstatic       #64  <Field Symbol Symbol.LOWER_CASE_P>
;     //   45  100:aload           4
;     //   46  102:invokevirtual   #55  <Method LispObject LispThread.execute(LispObject, LispObject)>
;     //   47  105:dup
;         lispobject2;
;         if(lispobject2 != Lisp.NIL) goto _L6; else goto _L5
;     //   48  106:getstatic       #33  <Field LispObject Lisp.NIL>
;     //   49  109:if_acmpne       132
; _L5:
;         JVM INSTR pop ;
;     //   50  112:pop
;         (lispthread.execute(SYM47932_EQLT, lispobject1, lispobject) instanceof Nil) ^ true;
;     //   51  113:aload_1
;     //   52  114:getstatic       #68  <Field Symbol SYM47932_EQLT>
;     //   53  117:aload           5
;     //   54  119:aload           4
;     //   55  121:invokevirtual   #71  <Method LispObject LispThread.execute(LispObject, LispObject, LispObject)>
;     //   56  124:instanceof      #73  <Class Nil>
;     //   57  127:iconst_1
;     //   58  128:ixor
;           goto _L7
;     //*  59  129:goto            137
; _L6:
;         JVM INSTR instanceof #73  <Class Nil>;
;     //   60  132:instanceof      #73  <Class Nil>
;         true;
;     //   61  135:iconst_1
;         JVM INSTR ixor ;
;     //   62  136:ixor
; _L7:
;         lispthread._values = null;
;     //   63  137:aload_1
;     //   64  138:aconst_null
;     //   65  139:putfield        #77  <Field LispObject[] LispThread._values>
;         JVM INSTR ifeq 166;
;     //   66  142:ifeq            166
;            goto _L8 _L9
; _L8:
;         lispthread.execute(SYM47932_EQLT, lispobject1, lispthread.execute(Symbol.CHAR_UPCASE, lispobject1));
;     //   67  145:aload_1
;     //   68  146:getstatic       #68  <Field Symbol SYM47932_EQLT>
;     //   69  149:aload           5
;     //   70  151:aload_1
;     //   71  152:getstatic       #61  <Field Symbol Symbol.CHAR_UPCASE>
;     //   72  155:aload           5
;     //   73  157:invokevirtual   #55  <Method LispObject LispThread.execute(LispObject, LispObject)>
;     //   74  160:invokevirtual   #71  <Method LispObject LispThread.execute(LispObject, LispObject, LispObject)>
;           goto _L4
;     //*  75  163:goto            169
; _L9:
;         Lisp.NIL;
;     //   76  166:getstatic       #33  <Field LispObject Lisp.NIL>
; _L4:
;         lispthread._values = null;
;     //   77  169:aload_1
;     //   78  170:aconst_null
;     //   79  171:putfield        #77  <Field LispObject[] LispThread._values>
;         Lisp.NIL;
;     //   80  174:getstatic       #33  <Field LispObject Lisp.NIL>
;         JVM INSTR if_acmpne 189;
;     //   81  177:if_acmpne       189
;            goto _L10 _L11
; _L10:
;         break MISSING_BLOCK_LABEL_180;
; _L11:
;         break MISSING_BLOCK_LABEL_189;
;         lispthread._values = null;
;     //   82  180:aload_1
;     //   83  181:aconst_null
;     //   84  182:putfield        #77  <Field LispObject[] LispThread._values>
;         return Lisp.NIL;
;     //   85  185:getstatic       #33  <Field LispObject Lisp.NIL>
;     //   86  188:areturn
;         obj = ((LispObject) (obj)).incr();
;     //   87  189:aload_2
;     //   88  190:invokeinterface #80  <Method LispObject LispObject.incr()>
;     //   89  195:astore_2
;         if(Lisp.interrupted)
;     //*  90  196:getstatic       #43  <Field boolean Lisp.interrupted>
;     //*  91  199:ifeq            205
;             Lisp.handleInterrupt();
;     //   92  202:invokestatic    #47  <Method void Lisp.handleInterrupt()>
;         if(true) goto _L13; else goto _L12
;     //   93  205:goto            28
; _L12:
;         lispthread._values = null;
;     //   94  208:aload_1
;     //   95  209:aconst_null
;     //   96  210:putfield        #77  <Field LispObject[] LispThread._values>
;         return Lisp.T;
;     //   97  213:getstatic       #58  <Field Symbol Lisp.T>
;     //   98  216:areturn
;     }
;
;     public char_aux_33()
;     {
;         super(Lisp.internInPackage("CHAR-UPCASE.2.BODY", "CL-TEST"), Lisp.NIL);
;     //    0    0:aload_0
;     //    1    1:ldc1            #85  <String "CHAR-UPCASE.2.BODY">
;     //    2    3:ldc1            #9   <String "CL-TEST">
;     //    3    5:invokestatic    #89  <Method Symbol Lisp.internInPackage(String, String)>
;     //    4    8:getstatic       #33  <Field LispObject Lisp.NIL>
;     //    5   11:invokespecial   #92  <Method void Primitive(LispObject, LispObject)>
;     //    6   14:ldc1            #7   <String "EQLT">
;     //    7   16:ldc1            #9   <String "CL-TEST">
;     //    8   18:invokestatic    #89  <Method Symbol Lisp.internInPackage(String, String)>
;     //    9   21:putstatic       #68  <Field Symbol SYM47932_EQLT>
;     //   10   24:return
;     }
;
;     private static final Symbol SYM47932_EQLT = Lisp.internInPackage("EQLT", "CL-TEST");
; }
NIL
CL-TEST(9):

(defun notnot (x) (not (not x)))

(defun eqlt (x y)
  "Like EQL, but guaranteed to return T for true."
  (apply #'values (mapcar #'notnot (multiple-value-list (eql x y)))))


(defmacro notnot-mv (form)
  `(notnot-mv-fn (multiple-value-list ,form)))

(defun notnot-mv-fn (results)
  (if (null results)
      (values)
    (apply #'values
           (not (not (first results)))
           (rest results))))

(defmacro not-mv (form)
  `(not-mv-fn (multiple-value-list ,form)))

(defun not-mv-fn (results)
  (if (null results)
      (values)
    (apply #'values
           (not (first results))
           (rest results))))

(declaim (ftype (function (t) function) to-function))



(defun char-downcase.2.body ()
  (loop for i from 0 below (min 65536 char-code-limit)
        for x = (code-char i)
        always
        (or (not x)
            (let ((u (char-downcase x)))
              (and
               (or (upper-case-p x) (eqlt u x))
               (eqlt u (char-downcase u)))))))


(defun eqlt (x y)
  "Like EQL, but guaranteed to return T for true."
  (apply #'values (mapcar #'notnot (multiple-value-list (eql x y)))))

(defun char-upcase.22.body ()
  (loop for i from 0 below (min 65536 char-code-limit)
        for x = (code-char i)
        always
        (unless (char-passes x)
	  (throw x))))

(defun char-passes (x)
        (or (not x)
            (let ((u (char-upcase x)))
              (and
               (or (lower-case-p x) (eqlt u x))
               (eqlt u (char-upcase u))))))



(with-output-to-string (s)  (write-string "some text" s) (fresh-line s)(WRITE-CHAR #\  s)(fresh-line s) (write-string "more text" s))


#\Ñ


Test MAKE-CONDITION.3 failed
Form: (LET* ((TP (QUOTE (OR PROGRAM-ERROR TYPE-ERROR))) (C (MAKE-CONDITION TP))) (OR (NOT (AND (SUBTYPEP TP (QUOTE CONDITION)) (OR (SUBTYPEP (QUOTE PROGRAM-ERROR) TP) (SUBTYPEP (QUOTE TYPE-ERROR) TP)))) (NOTNOT-MV (TYPEP C TP))))
Expected value:
          T
Actual value:
          #<SIMPLE-ERROR {7F1C3366}> [There is no applicable method for the generic function #<STANDARD-GENERIC-FUNCTION MAKE-INSTANCE {41E8E144}> when called with arguments ((OR PROGRAM-ERROR TYPE-ERROR)).]
Test MAKE-CONDITION.4 failed
Form: (LET* ((TP (QUOTE (AND SIMPLE-ERROR TYPE-ERROR))) (C (MAKE-CONDITION TP))) (OR (NOT (AND (SUBTYPEP (QUOTE SIMPLE-ERROR) TP) (SUBTYPEP (QUOTE TYPE-ERROR) TP) (SUBTYPEP TP (QUOTE CONDITION)))) (NOTNOT-MV (TYPEP C TP))))
Expected value:
          T
Actual value:
          #<SIMPLE-ERROR {1472AEBC}> [There is no applicable method for the generic function #<STANDARD-GENERIC-FUNCTION MAKE-INSTANCE {41E8E144}> when called with arguments ((AND SIMPLE-ERROR TYPE-ERROR)).]
 MAKE-CONDITION.ERROR.1 CONS-OF-SYMBOLS CONS-WITH-NIL CONS-EQ-EQUAL



 DELETE-PACKAGE.1 DELETE-PACKAGE.2 DELETE-PACKAGE.3 DELETE-PACKAGE.4
Test DELETE-PACKAGE.5 failed
Form: (PROG (P1 S1 P2 S2 P3) (DECLARE (IGNORABLE P1 P2 P3 S1 S2)) (SAFELY-DELETE-PACKAGE "P3") (SAFELY-DELETE-PACKAGE "P2") (SAFELY-DELETE-PACKAGE "P1") (SETQ P1 (MAKE-PACKAGE "P1" :USE NIL)) (SETQ S1 (INTERN "S1" P1)) 
 (EXPORT S1 "P1") (SETQ P2 (MAKE-PACKAGE "P2" :USE (QUOTE ("P1")))) (SETQ S2 (INTERN "S2" P2)) 
 (EXPORT S1 P2) (EXPORT S2 "P2") (SETF P3 (MAKE-PACKAGE "P3" :USE (QUOTE ("P2")))) 
 (LET ((OUTER-RESTARTS (COMPUTE-RESTARTS))) (HANDLER-BIND ((PACKAGE-ERROR 
  (FUNCTION (LAMBDA (C) (LET ((MY-RESTARTS (REMOVE (QUOTE ABORT) (SET-DIFFERENCE (COMPUTE-RESTARTS C) OUTER-RESTARTS) 
  :KEY (FUNCTION RESTART-NAME)))) (ASSERT MY-RESTARTS) (WHEN (FIND (QUOTE CONTINUE) MY-RESTARTS :KEY (FUNCTION RESTART-NAME)) 
  (CONTINUE C)) (RETURN T)))))) (DELETE-PACKAGE P2))) (UNLESS (AND (EQUAL (PACKAGE-NAME P1) "P1") (NULL (PACKAGE-NAME P2)) 
  (EQUAL (PACKAGE-NAME P3) "P3")) (RETURN (QUOTE FAIL1))) (UNLESS (EQT (SYMBOL-PACKAGE S1) P1) (RETURN (QUOTE FAIL2)))
   (UNLESS (EQUAL (PRIN1-TO-STRING S1) "P1:S1") (RETURN (QUOTE FAIL3))) (UNLESS (EQUAL (MULTIPLE-VALUE-LIST (FIND-SYMBOL "S1" P3)) (QUOTE (NIL NIL))) 
   (RETURN (QUOTE FAIL4))) (UNLESS (EQUAL (MULTIPLE-VALUE-LIST (FIND-SYMBOL "S2" P3)) (QUOTE (NIL NIL))) (RETURN (QUOTE FAIL5))) 
   (UNLESS (AND (NULL (PACKAGE-USED-BY-LIST P1)) (NULL (PACKAGE-USED-BY-LIST P3))) (RETURN (QUOTE FAIL6))) (UNLESS (AND (PACKAGEP P1) (PACKAGEP P2) 
   (PACKAGEP P3)) (RETURN (QUOTE FAIL7))) (UNLESS (AND (NULL (PACKAGE-USE-LIST P1)) (NULL (PACKAGE-USE-LIST P3))) 
   (RETURN (QUOTE FAIL8))) (SAFELY-DELETE-PACKAGE P3) (SAFELY-DELETE-PACKAGE P1) (RETURN T))
Expected value:
          T
Actual value:
          FAIL6
Test DELETE-PACKAGE.6 failed
Form: (BLOCK DONE (LET ((OUTER-RESTARTS (COMPUTE-RESTARTS))) (SAFELY-DELETE-PACKAGE "TEST-20") (HANDLER-BIND ((PACKAGE-ERROR (FUNCTION (LAMBDA (C) (ASSERT (SET-DIFFERENCE (COMPUTE-RESTARTS C) OUTER-RESTARTS)) (RETURN-FROM DONE :GOOD))))) (DELETE-PACKAGE "TEST-20"))))
Expected value:
          :GOOD
Actual value:
          #<SIMPLE-ERROR {1342E4A}> [The assertion (SET-DIFFERENCE (COMPUTE-RESTARTS C) OUTER-RESTARTS) failed.]
 DELETE-PACKAGE.7 DELETE-PACKAGE.8 DELETE-PACKAGE.9 DELETE-PACKAGE.10
 DELETE-PACKAGE.11 DELETE-PACKAGE.12 DELETE-PACKAGE.13
 DELETE-PACKAGE.ERROR.1 DELETE-PACKAGE.ERROR.2 MAKE-PACKAGE.1
 MAKE-PACKAGE.2 MAKE-PACKAGE.3 MAKE-PACKAGE.4 MAKE-PACKAGE.5
 MAKE-PACKAGE.6 MAKE-PACKAGE.7 MAKE-PACKAGE.7A MAKE-PACKAGE.7B
 MAKE-PACKAGE.8 MAKE-PACKAGE.8A MAKE-PACKAGE.8B MAKE-PACKAGE.9



