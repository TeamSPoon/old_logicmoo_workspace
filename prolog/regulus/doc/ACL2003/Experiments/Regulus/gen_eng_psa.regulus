
%--------------------------------------------------------------------------------------------------

feature_value_space(yes_no, [[y, n]]).
feature_value_space(wh_vals, [[y, n, rel]]).
feature_value_space(agr_vals, [[1, 2, 3], [sing, plur]]).
feature_value_space(vforms, [[base, imperative, finite, ing, en, to, none]]).
feature_value_space(nforms, [[normal, there, it]]).
feature_value_space(toptypes, [[user_command, system_response]]).
feature_value_space(stypes, [[imp, dcl, ynq, whq, embedded_dcl, embedded_q, ellipsis, none]]).
feature_value_space(subcat_type, 
                    [[nx0v, nx0vnx1, nx0vnx1_passivised, nx0vnx1_be, nx0vnx1_there_is, nx0vnx1x2, nx0vnx1x2_passivised, 
                      nx0vpnx1, nx0vnx1pnx2, nx0vnx1pnx2_passivised, nx0vnx1pl, nx0vplnx1, 
                      nx0vvx1_modal, nx0vvx1_nonmodal, nx0vvx1_passive, nx0vvx1_to, 
                      nx0vs1, nx0vsq1, nx0va1, nx0vx1a1, nx0vnx1_measure]]).
feature_value_space(n_type, [[loc, agent, device, numeric, date, time, unit, timeunit, none]]).
%feature_value_space(num_type, [[digit, twoplace, threeplace, fourplace, none]]).
feature_value_space(pp_type, [[passive_by, loc, to, from, attribution, about, with, duration, date, time, compare, cost, none]]).
feature_value_space(p_type, [[onoff, updown, normal, none]]).
feature_value_space(times, [[hour, minute, second, dayofmonth, none]]).
feature_value_space(number_types, [[a, zero, digit, oh_digit, ten, teen, '20_to_99', hundred, three_figure, decimal, none]]).
feature_value_space(det_types, [[numeric, def, indef, quant, ordinal, null, none]]).
feature_value_space(interjection_type, [[yn, stop_continue, whatever, correction]]).
feature_value_space(adjpos_types, [[prenom, postnom, pred]]).
feature_value_space(advpos_types, [[postv, postvp, fronted, wh_fronted]]).
feature_value_space(adv_types, [[temporal, none]]).
feature_value_space(politeness_pos_types, [[pre, post]]).
feature_value_space(post_mod_types, [[nominal, verbal, ellipsis]]).
feature_value_space(case_types, [[subj, nonsubj]]).
feature_value_space(syn_types, [[conj_np, np_with_noun, name, pronoun, number, plain_det, ordinal_det, special, none]]).

% Simple treatment of gaps
feature_value_space(gap_types, [[null, np_gap, pp_gap, adjp_gap, advp_gap]]).

% More or less useless legacy feature left over from Gemini - PSA feature
feature(toptype, toptypes).

% Categorises utterances as declarative, imperative, whq, ynq, ellipsis etc - PSA feature
feature(stype, stypes).

% The usual WH feature - PSA feature
feature(wh, wh_vals).

% Categorises verbs (and projections) as finite, imperative, ing, etc. Similar to corresponding CLE feature - PSA feature
feature(vform, vforms).

% Categorises NPs as impersonal "it", impersonal "there" or normal. Similar to corresponding CLE feature - PSA feature
feature(nform, nforms).
lexical_feature_default(nform, normal).

% Categorises subject NP as impersonal "it", impersonal "there" or normal. Similar to corresponding CLE feature - PSA feature
feature(subj_nform, nforms).
lexical_feature_default(subj_nform, normal).

% Categorises verb as inverted or uninverted - PSA feature
feature(inv, yes_no).

% Categorises clause as using/not using WH movement - PSA feature
feature(whmoved, yes_no).

% Mediates agreement between relative clause and NP it attaches to. Similar to corresponding CLE feature - PSA feature
feature(relagr, agr_vals).

% Mediates sortal agreement between relative clause and NP it attaches to - PSA feature
feature(rel_sem_n_type, n_type).
lexical_feature_default(rel_sem_n_type, none).

% Categorises clauses as wrapped/not wrapped in sentence-level operator, e.g. dcl, whq etc - PSA feature
feature(operator_wrapped, yes_no).

% Next two features do gap-threading - PSA features
feature(gapsin, gap_types).
feature(gapsout, gap_types).

% Different kinds of interjections. We particularly want to distinguish yes/no and corrections - PSA feature
feature(interjection_type, interjection_type).

% Agreement - PSA feature
feature(agr, agr_vals).

% Sortal type of subject - PSA feature
feature(subj_sem_n_type, n_type).

% We only want gap modifiers to attach in one place, otherwise we get spurious ambiguity - PSA feature
feature(takes_gap_mod, yes_no).

% Loc PP mod allowed or not - PSA feature
feature(takes_loc_pp, yes_no).
lexical_feature_default(takes_loc_pp, n).

% From PP mod allowed or not - TravelDeals feature
feature(takes_from_pp, yes_no).
lexical_feature_default(takes_from_pp, n).

% To PP mod allowed or not - PSA feature
feature(takes_to_pp, yes_no).
lexical_feature_default(takes_to_pp, n).

% With PP mod allowed or not - TravelDeals feature
feature(takes_with_pp, yes_no).
lexical_feature_default(takes_with_pp, n).

% Duration PP mod allowed or not - Med feature
feature(takes_duration_pp, yes_no).
lexical_feature_default(takes_duration_pp, n).

% Date PP mod allowed or not - TravelDeals feature
feature(takes_date_pp, yes_no).
lexical_feature_default(takes_date_pp, n).

% Time PP mod allowed or not - PSA feature
feature(takes_time_pp, yes_no).
lexical_feature_default(takes_time_pp, n).

% Attribution PP mod allowed or not - PSA feature
feature(takes_attrib_pp, yes_no).
lexical_feature_default(takes_attrib_pp, n).

% About PP mod allowed or not - TravelDeals feature
feature(takes_about_pp, yes_no).
lexical_feature_default(takes_about_pp, n).

% Cost PP mod allowed or not - TravelDeals feature
feature(takes_cost_pp, yes_no).
lexical_feature_default(takes_cost_pp, n).

% Passive by PP mod allowed or not - Med feature
feature(takes_passive_by_pp, yes_no).
lexical_feature_default(takes_passive_by_pp, n).

% Subcategorization type of verb - PSA feature
feature(subcat, subcat_type).

% Vform of subcategoried VP, for higher verb - PSA feature
feature(vp_vform, vforms).
lexical_feature_default(vp_vform, none).

% VP consists/does not include a passive auxiliary - Med feature
feature(vp_passivised, yes_no).
lexical_feature_default(vp_passivised, n).

% Sortal type of direct object - PSA feature
feature(obj_sem_n_type, n_type).
lexical_feature_default(obj_sem_n_type, none).

% Sortal type of indirect object - TravelDeals feature
feature(indobj_sem_n_type, n_type).
lexical_feature_default(indobj_sem_n_type, none).

% Sortal type of subcategorised PP - PSA feature
feature(pp_sem_pp_type, pp_type).
lexical_feature_default(pp_sem_pp_type, none).

% Sortal type of subcategorised P - PSA feature
feature(sem_p_type, p_type).
lexical_feature_default(sem_p_type, none).

% Sortal type of noun - PSA feature
feature(sem_n_type, n_type).
lexical_feature_default(sem_n_type, none).

% Sortal type of PP - PSA feature
feature(sem_pp_type, pp_type).
lexical_feature_default(sem_pp_type, none).

% Categorises constituent as gap or non-gap - PSA feature
feature(gap, yes_no).

% Categories P as preposition or postposition - PSA feature
feature(postposition, yes_no).
lexical_feature_default(postposition, n).

% Categorises constituent as conjoined or not - PSA feature
feature(conj, yes_no).
lexical_feature_default(conj, n).

% Sortal type of pre-nominal N mod - House feature
feature(n_pre_mod_type, n_type).
lexical_feature_default(n_pre_mod_type, none).

% Sortal type of post-nominal N mod, e.g. "scenario two", "location okra" - PSA feature
feature(n_post_mod_type, n_type).
lexical_feature_default(n_post_mod_type, none).

% Sortal type of "of" PP mod - Med feature
feature(n_of_mod_type, n_type).
lexical_feature_default(n_of_mod_type, none).

% Types of det that can combine with N - PSA feature
feature(takes_det_type, det_types).

% Categorises types of det - PSA feature
feature(det_type, det_types).

% Det can/cannot combine with number, e.g. "all three" - PSA feature
feature(prenumber, yes_no).

% Categorises types of number - PSA feature
feature(num_type, number_types).

% Categorises types of time - PSA feature
feature(time_type, times).

% Possible positions for ADJP, e.g. pre-nominal, predicative - PSA feature
feature(adjpos, adjpos_types).

% Possible positions for ADVP, e.g. initial, post-verbal - Med feature
feature(advpos, advpos_types).

% Possible positions for politenss word, e.g. initial or final - TravelDeals feature
feature(politeness_pos, politeness_pos_types).

% Whether or not constituent may take post-mods - PSA feature [in effect]
feature(takes_post_mods, yes_no).
lexical_feature_default(takes_post_mods, y).

% Categorises NP (etc) as definite/indefinite - House feature
feature(def, yes_no).

% Definiteness of subject NP - House feature
feature(subj_def, yes_no).
lexical_feature_default(subj_def, y).

% Definiteness of object NP - House feature
feature(obj_def, yes_no).
lexical_feature_default(obj_def, y).

% Definiteness of indirect object NP - TravelDeals feature
feature(indobj_def, yes_no).
lexical_feature_default(indobj_def, y).

% Whether post-mods attach to NP, VP, or appear free - TravelDeals feature
feature(post_mod_type, post_mod_types).

% Whether or not name can be used as a nominal pre-mod - TravelDeals feature
feature(can_be_premod, yes_no).
lexical_feature_default(can_be_premod, y).

% Whether or not V can take advp postmod - Med feature
feature(takes_advp, yes_no).
lexical_feature_default(takes_advp, n).

% Whether or not main verb in VP is passivised - Med feature
feature(passivised, yes_no).
lexical_feature_default(passivised, n).

% Whether or not subject of VP is passive - Med feature
feature(passive_subj, yes_no).
lexical_feature_default(passive_subj, n).

% Whether or not det can be used as NP - Checklist feature
feature(can_be_np, yes_no).
lexical_feature_default(can_be_np, n).

% Case of NP - Checklist feature 
feature(case, case_types).

% Sortal type of ADVP - Checklist feature 
feature(adv_type, adv_types).

% Sortal type of modifying ADVP - Checklist feature 
feature(takes_adv_type, adv_types).
lexical_feature_default(takes_adv_type, temporal).

% Categorises NP as pronoun/not pronoun - Checklist feature 
feature(pronoun, yes_no).

% "Syntactic type" of NP etc, e.g. NP with noun; pronoun; name; conjoined NP, etc - Checklist feature 
feature(syn_type, syn_types).
lexical_feature_default(syn_type, plain_det).

% "Syntactic type" of subject NP - Checklist feature 
feature(subj_syn_type, syn_types).

% "Syntactic type" of object NP - Checklist feature 
feature(obj_syn_type, syn_types).
lexical_feature_default(obj_syn_type, none).

% "Syntactic type" of indirect object NP - Checklist feature 
feature(indobj_syn_type, syn_types).
lexical_feature_default(indobj_syn_type, none).

feature_instantiation_schedule(
	[[toptype, stype, politeness_pos, interjection_type], 
         [wh, vform, inv, whmoved, operator_wrapped, gap, subcat, vp_vform, vp_passivised, passivised, passive_subj],
	 [postposition, conj, prenumber, adjpos, advpos], 
	 [case],
         [takes_post_mods, post_mod_type, can_be_premod, takes_advp],
	 [gapsin, gapsout], 
	 [nform, subj_nform],
	 [pronoun],
	 [agr], [relagr],
	 [num_type], [time_type], [can_be_np],
	 [sem_pp_type], [pp_sem_pp_type], [sem_p_type], [takes_gap_mod],
	 [takes_loc_pp], 
	 [takes_from_pp], 
	 [takes_to_pp], 
	 [takes_with_pp], 
	 [takes_duration_pp], 
	 [takes_date_pp], 
	 [takes_time_pp], 
	 [takes_attrib_pp], 
	 [takes_about_pp], 
	 [takes_cost_pp],
         [takes_passive_by_pp],
	 [def, subj_def, obj_def, indobj_def],
	 [adv_type],
	 [takes_adv_type],
	 [det_type],
	 [takes_det_type],
	 [sem_n_type], 
	 [subj_sem_n_type], 
	 [obj_sem_n_type], 
	 [indobj_sem_n_type], 
	 [rel_sem_n_type], 
	 [n_pre_mod_type],
	 [n_post_mod_type],
	 [n_of_mod_type],
	 [syn_type],
	 [subj_syn_type],
	 [obj_syn_type],
	 [indobj_syn_type]
     ]).

category('.MAIN', [gsem]).
category(top, [sem, toptype]).
category(politeness, [sem, politeness_pos, stype]).
category(utterance, [sem, stype]).
category(s, [sem, stype, wh, vform, inv, whmoved, relagr, rel_sem_n_type, takes_adv_type, operator_wrapped, gapsin, gapsout]).
category(interjection, [sem, interjection_type, stype]).
category(utterance_intro, [sem, stype]).
category(utterance_coda, [sem, stype]).
category(vp, [sem, agr, inv, vform, passivised, passive_subj, subj_def, subj_syn_type, subj_nform, subj_sem_n_type, 
              takes_post_mods, takes_adv_type, @pp_feats, gapsin, gapsout]).
category(post_mods, [sem, post_mod_type, takes_gap_mod, n_of_mod_type, takes_adv_type, gap, @pp_feats, gapsin, gapsout]).
category(vbar, [sem, agr, subcat, inv, vform, passivised, passive_subj, vp_vform, vp_passivised, subj_nform, subj_sem_n_type, obj_sem_n_type, indobj_sem_n_type, pp_sem_pp_type, sem_p_type, @pp_feats, subj_def, subj_syn_type, obj_def, obj_syn_type, indobj_def, indobj_syn_type, takes_advp, takes_adv_type]).
category(v, [sem, agr, subcat, inv, vform, passivised, passive_subj, vp_vform, vp_passivised, subj_nform, subj_sem_n_type, obj_sem_n_type, indobj_sem_n_type, pp_sem_pp_type, sem_p_type, @pp_feats, subj_def, subj_syn_type, obj_def, obj_syn_type, indobj_def, indobj_syn_type, takes_advp, takes_adv_type]).
category(rel, [sem, agr, sem_n_type]).
category(pp, [sem, wh, sem_pp_type, gap, gapsin, gapsout, conj]).
category(ppconj, [sem, wh, sem_pp_type]).
category(of_pp, [sem, wh, sem_n_type]).
category(p, [sem, postposition, sem_pp_type, obj_sem_n_type, sem_p_type, def]).
category(p_with_agr, [sem, agr, postposition, sem_pp_type, obj_sem_n_type, sem_p_type, def]).
category(location, []).
category(np, [sem, agr, wh, nform, sem_n_type, conj, gapsin, gapsout, takes_post_mods, n_of_mod_type, @pp_feats, def, case, pronoun, syn_type]).
category(npconj, [sem, sem_n_type, def, case]).
category(measure_phrase, [sem, sem_n_type]).
category(np_after, []).
category(n, [sem, agr, sem_n_type, n_pre_mod_type, n_post_mod_type, n_of_mod_type, @pp_feats, takes_det_type]).
category(nbar, [sem, agr, sem_n_type, n_pre_mod_type, n_post_mod_type, n_of_mod_type, @pp_feats, takes_det_type]).
category(name, [sem, agr, can_be_premod, sem_n_type]).
category(pronoun, [sem, agr, wh, sem_n_type, case]).
category(d, [sem, agr, wh, det_type, prenumber, def, can_be_np, syn_type]).
category(conj, []).
category(np_gap, [sem_n_type]).
category(pp_gap, [sem_pp_type]).
category(number, [sem, num_type, time_type, agr]).
category(ordinal, [sem, num_type, time_type]).
category(time, [sem, time_type]).
category(date, [sem]).
category(month, [sem]).
category(comp, [sem, stype]).
category(adjp, [sem, wh, adjpos, subj_sem_n_type, @pp_feats, conj, gap, gapsin, gapsout]).
category(adj, [sem, adjpos, subj_sem_n_type, @pp_feats]).
category(advp, [sem, wh, advpos, adv_type, conj, gap, gapsin, gapsout]).
category(adv, [sem, advpos, adv_type]).
category(numcompare, [sem]).
category(possessive, [sem]).

top_level_category('.MAIN').

%--------------------------------------------------------------------------------------------------

% General grammar macros

macro(subj_feats_for_vp([SubjType, NForm, SubjDef, SubjSynType]),
      [subj_nform=NForm, subj_sem_n_type=SubjType, subj_def=SubjDef, subj_syn_type=SubjSynType]).

macro(subj_feats_for_np([SubjType, NForm, SubjDef, SubjSynType]),
      [nform=NForm, sem_n_type=SubjType, def=SubjDef, syn_type=SubjSynType]).

macro(v_feats_for_vp([Agr, Inv, VForm]),
      [agr=Agr, inv=Inv, vform=VForm]).

macro(vbar_feats_for_vp([Subj, V, PPs, AdvpType, Passivised, PassiveSubj]),
      [@subj_feats_for_vp(Subj), @v_feats_for_vp(V), @takes_pps(PPs), takes_adv_type=AdvpType, 
       passivised=Passive, passive_subj=PassiveSubj]).

macro(pp_feats, [takes_loc_pp, takes_from_pp, takes_to_pp, takes_with_pp, takes_duration_pp, takes_date_pp, takes_time_pp, takes_attrib_pp, takes_about_pp, takes_cost_pp, takes_passive_by_pp]).

macro(takes_pps_except_passive_by([Loc, From, To, With, Duration, Date, Time, Attrib, About, Cost]), 
      [takes_loc_pp=Loc, takes_from_pp=From, takes_to_pp=To, takes_with_pp=With, takes_duration_pp=Duration, takes_date_pp=Date, takes_time_pp=Time, takes_attrib_pp=Attrib, takes_about_pp=About, takes_cost_pp=Cost]).

macro(takes_pps([Loc, From, To, With, Duration, Date, Time, Attrib, About, Cost, PassiveBy]), 
      [takes_loc_pp=Loc, takes_from_pp=From, takes_to_pp=To, takes_with_pp=With, takes_duration_pp=Duration, takes_date_pp=Date, takes_time_pp=Time, takes_attrib_pp=Attrib, takes_about_pp=About, takes_cost_pp=Cost, takes_passive_by_pp=PassiveBy]).

macro(takes_no_pps, 
      [takes_loc_pp=n, takes_from_pp=n, takes_to_pp=n, takes_with_pp=n, takes_duration_pp=n, takes_date_pp=n, takes_time_pp=n, takes_attrib_pp=n, takes_about_pp=n, takes_cost_pp=n, takes_passive_by_pp=n]).

macro(takes_all_pps, 
      [takes_loc_pp=y, takes_from_pp=y, takes_to_pp=y, takes_with_pp=y, takes_duration_pp=y, takes_date_pp=y, takes_time_pp=y, takes_attrib_pp=y, takes_about_pp=y, takes_cost_pp=y, takes_passive_by_pp=y]).

%--------------------------------------------------------------------------------------------------

% Formal top rule, needed to define top-level Nuance rule
'.MAIN':[gsem=[value=Sem]]-->
top:[sem=Sem, toptype=user_command].

% Utterance consisting of lone intro - PSA rule
% [yes], [please], [yes please]
top:[sem= Intro, toptype=user_command] -->
utterance_intro:[sem=Intro, stype=none].

% Intro consisting of lone interjection - PSA rule
% [yes], [no]
utterance_intro:[sem=Sem, stype=SType] -->
interjection:[sem=Sem, stype=SType].

% Intro consisting of lone politeness word - PSA rule
% [please] give me flights
utterance_intro:[sem=Sem, stype=SType] -->
politeness:[sem=Sem, politeness_pos=pre, stype=SType].

% Top-level rule that allows optional intro and coda to be added to other consituents - PSA rule [in effect]
top:[sem= @intro_and_coda_sem(Intro, Utt, Coda), toptype=user_command] -->
utterance_intro:[sem=Intro, stype=SType],
utterance:[sem=Utt, stype=SType, stype=dcl\/imp\/ynq\/whq\/ellipsis],
utterance_coda:[sem=Coda, stype=SType].

% Null intro - PSA rule [in effect]
utterance_intro:[sem= @null_sem] --> [].

% Null coda - PSA rule [in effect]
utterance_coda:[sem= @null_sem] --> [].

%--------------------------------------------------------------------------------------------------

% utterance_s_and_s
% Conjoined s as utterance - PSA rule
% [go to flight deck and measure pressure]
utterance:[sem= @conj_list_sem(s_and, [S1, S2]), stype=SType] -->
s:[sem=S1, stype=SType, operator_wrapped=y, gapsin=null, gapsout=null],
conj:[],
s:[sem=S2, stype=SType, operator_wrapped=y, gapsin=null, gapsout=null].

% utterance_s
% S as utterance - PSA rule
% [go to flight deck]
utterance:[sem=Sem, stype=imp\/dcl\/ynq\/whq, stype=SType] -->
	   s:[sem=Sem, stype=SType, operator_wrapped=y, gapsin=null, gapsout=null].

% utterance_np
% NP as utterance - PSA rule
% [flight deck]
utterance:[sem= @elliptical_utt_sem(Sem), stype=ellipsis] -->
	   np:[sem=Sem, nform=normal, takes_post_mods=n, @takes_no_pps, gapsin=null, gapsout=null, case=nonsubj].

% utterance_np_np_after
% NP + post-NP phrase as utterance - PSA rule
% [flight deck too]
utterance:[sem= @elliptical_utt_sem(Sem), stype=ellipsis] -->
           np:[sem=Sem, nform=normal, takes_post_mods=n, @takes_no_pps, gapsin=null, gapsout=null, case=nonsubj], 
           np_after:[].

% Lone list of post-mods as utterance - PSA rule [in effect]
% [to barbados before may tenth]
utterance:[sem= @elliptical_utt_sem(Sem), stype=ellipsis] -->
           post_mods:[sem=Sem, post_mod_type=ellipsis, takes_gap_mod=n, n_of_mod_type=none, gap=n, @takes_all_pps, gapsin=null, gapsout=null].

%-----------------------------------------------------------------------------------------------------

% S rules 1 - wrapping operators

% "i measured the pressure", "i said [i measured the pressure]"
%
% Thread gaps to get "when did you say [you measured the pressure _]?"

% s_s_Declarative - PSA rule
s:[sem= @dcl_sem(Sem), stype=dcl\/embedded_dcl, wh=n, vform=finite, inv=n, operator_wrapped=y, gapsin=GIn, gapsout=GOut] -->
s:[sem=Sem, wh=n, vform=finite, inv=n, operator_wrapped=n, gapsin=GIn, gapsout=GOut].

% "i said [that i measured the pressure]"

% s_comp_s_EmbeddedDeclarative - PSA rule
s:[sem= @dcl_sem(Sem), stype=embedded_dcl, wh=n, vform=finite, inv=n, operator_wrapped=y, gapsin=GIn, gapsout=GOut] -->
comp:[stype=embedded_dcl], 
s:[sem=Sem, wh=n, vform=finite, inv=n, operator_wrapped=n, gapsin=GIn, gapsout=GOut].

% "who measured the pressure", "tell me [who measured the pressure]"

% s_s_WhSubjQ - PSA rule
s:[sem= @whq_sem(Sem), stype=whq\/embedded_q, wh=y, vform=finite, inv=n, operator_wrapped=y, gapsin=null, gapsout=null] -->
s:[sem=Sem, wh=y, vform=finite, inv=n, whmoved=n, operator_wrapped=n, gapsin=null, gapsout=null].

% "where are you"

% s_s_WhNonSubjQ - PSA rule
s:[sem= @whq_sem(Sem), stype=whq, wh=y, vform=finite, inv=y, operator_wrapped=y, gapsin=null, gapsout=null] -->
s:[sem=Sem, wh=y, vform=finite, inv=y, whmoved=y, operator_wrapped=n, gapsin=null, gapsout=null].

% "tell me [where you are]"

% s_s_EmbeddedWhNonSubjQ - PSA rule
s:[sem= @whq_sem(Sem), stype=embedded_q, wh=y, vform=finite, inv=n, operator_wrapped=y, gapsin=null, gapsout=null] -->
s:[sem=Sem, wh=y, vform=finite, inv=n, whmoved=y, operator_wrapped=n, gapsin=null, gapsout=null].

% "are you measuring the pressure?"

% s_s_YNQ - PSA rule
s:[sem= @ynq_sem(Sem), stype=ynq, wh=n, vform=finite, inv=y, operator_wrapped=y, gapsin=null, gapsout=null] -->
s:[sem=Sem, wh=n, vform=finite, inv=y, whmoved=n, operator_wrapped=n, gapsin=null, gapsout=null].

% "tell me [if you are measuring the pressure]"

% s_comp_s_EmbeddedYNQ - PSA rule
s:[sem= @ynq_sem(Sem), stype=embedded_q, wh=n, vform=finite, inv=n, operator_wrapped=y, gapsin=null, gapsout=null] -->
comp:[stype=embedded_q], 
s:[sem=Sem, wh=n, vform=finite, inv=n, whmoved=n, operator_wrapped=n, gapsin=null, gapsout=null].

% "measure the pressure!" - PSA rule

% s_s_Imperative
s:[sem= @imperative_sem(Sem), stype=imp, wh=n, vform=imperative, inv=n, operator_wrapped=y, gapsin=null, gapsout=null] -->
s:[sem=Sem, wh=n, vform=imperative, inv=n, whmoved=n, operator_wrapped=n, gapsin=null, gapsout=null].

%----------------------------------------------------------------------

% S rules 2 - fronting rules

% Simplify gaps

% s_np_s_WhMovement - PSA rule
% what pressure did you measure?
s:[sem= @fronting_sem(NP, S), wh=y\/rel, wh=Wh, vform=VForm, inv=Inv, whmoved=y, relagr=Agr, 
   rel_sem_n_type=ObjSemType, operator_wrapped=n, takes_adv_type=none, 
   gapsin=null, gapsout=null] -->
np:[sem=NP, nform=normal, agr=Agr, wh=Wh, sem_n_type=SubjSemType, takes_post_mods=n, @takes_no_pps, gapsin=null, gapsout=null], 
s:[sem=S, wh=n, vform=VForm, inv=Inv, whmoved=n, operator_wrapped=n, gapsin=np_gap, gapsout=null].

% s_pp_s_WhMovement - PSA rule
% when did the pressure start increasing?
s:[sem= @fronting_sem(PP, S), wh=y\/rel, wh=Wh, vform=VForm, inv=Inv, whmoved=y, operator_wrapped=n, takes_adv_type=none, gapsin=null, gapsout=null] -->
pp:[sem=PP, wh=Wh, gapsin=null, gapsout=null], 
s:[sem=S, wh=n, vform=VForm, inv=Inv, whmoved=n, operator_wrapped=n, gapsin=pp_gap, gapsout=null].

%----------------------------------------------------------------------

% S rules 3 - formation of S from VP

% s_np_vp - PSA rule
% basic S -> NP VP rule
s:[sem= @np_vp_sem(Np, Vp), 
   wh=Wh, vform=finite, inv=n, whmoved=n, relagr=Agr, rel_sem_n_type=SubjType, operator_wrapped=n, takes_adv_type=AdvpType, 
   gapsin=GIn, gapsout=GOut] -->
np:[sem=Np, nform=normal,
    agr=Agr, wh=Wh, sem_n_type=SubjType, @subj_feats_for_np(Subj), 
    takes_post_mods=n, @takes_no_pps, gapsin=null, gapsout=null, case=subj], 
vp:[sem=Vp, agr=Agr, inv=n, vform=finite, @subj_feats_for_vp(Subj), 
    takes_post_mods=n, passive_subj=n, takes_adv_type=AdvpType, 
    gapsin=GIn, gapsout=GOut].

% s_np_vp_Imperative - PSA rule
% Imperative with explicit subject
% p s a go to flight deck
s:[sem= @np_vp_imperative_sem(Np, Vp), wh=n, vform=imperative, inv=n, whmoved=n, operator_wrapped=n, 
   takes_adv_type=AdvpType, gapsin=null, gapsout=null] -->
np:[sem=Np, agr=(\(1)), wh=n, sem_n_type=agent, nform=normal, def=y, 
    takes_post_mods=n, @takes_no_pps, gapsin=null, gapsout=null, case=subj], 
vp:[sem=Vp, agr=2, inv=n, vform=base, subj_nform=normal, subj_sem_n_type=agent, 
    subj_def=y, subj_syn_type=pronoun, takes_post_mods=n, 
    passive_subj=n, takes_adv_type=AdvpType, 
    gapsin=null, gapsout=null].

% s_vp_YNQ - PSA rule
% Basic inversion rule 
% did the pressure increase?
s:[sem=Sem, wh=n, vform=finite, inv=y, whmoved=n, operator_wrapped=n, takes_adv_type=AdvpType, gapsin=GIn, gapsout=GOut] -->
vp:[sem=Sem, inv=y, vform=finite, takes_post_mods=n, takes_adv_type=AdvpType, gapsin=GIn, gapsout=GOut].

% s_vp_Imperative - PSA rule
% Basic imperative rule
% go to flight deck
s:[sem= @s_vp_imperative_sem(Vp), wh=n, vform=imperative, inv=n, whmoved=n, operator_wrapped=n, 
   takes_adv_type=AdvpType, gapsin=null, gapsout=null] -->
vp:[sem=Vp, inv=n, subj_nform=normal, vform=base, takes_post_mods=n, passive_subj=n, takes_adv_type=AdvpType, gapsin=null, gapsout=null].

%-----------------------------------------------------------------------------------------------------

% VBAR as requested by P. Sells...

% vbar_v - PSA rule
% Simple VBAR rule
vbar:[sem=Sem, 
      agr=Agr, subcat=Sub, inv=n, vform=VForm, vp_vform=VPVform, vp_passivised=VPPassive, 
      @subj_feats_for_vp(Subj), @takes_pps(PPs), 
      obj_sem_n_type=ObjSem, indobj_sem_n_type=IndObjSem, 
      pp_sem_pp_type=PPSem, sem_p_type=PSem, 
      obj_def=ObjDef, obj_syn_type=ObjSynType, indobj_def=IndObjDef, indobj_syn_type=IndObjSynType, 
      takes_advp=TakesAdvp, takes_adv_type=AdvpType, passivised=Passive, passive_subj=PassiveSubj] -->
v:[sem=Sem, agr=Agr, subcat=Sub, inv=n, vform=VForm, vp_vform=VPVform, vp_passivised=VPPassive,
   @subj_feats_for_vp(Subj), @takes_pps(PPs),
   obj_sem_n_type=ObjSem, indobj_sem_n_type=IndObjSem,
   pp_sem_pp_type=PPSem, sem_p_type=PSem, 
   obj_def=ObjDef, obj_syn_type=ObjSynType, indobj_def=IndObjDef, indobj_syn_type=IndObjSynType, takes_advp=TakesAdvp, takes_adv_type=AdvpType, 
   passivised=Passive, passive_subj=PassiveSubj].

% vbar_v_np_InvertedSubject - PSA rule
% VBAR consisting of V and inverted subject. Some linguists think this is a hack!
% [did the pressure] increase
vbar:[sem= @inverted_subj_sem(V, Np),
      agr=Agr, subcat=Sub, inv=y, vform=VForm, vp_vform=VPVform, vp_passivised=n,
      @subj_feats_for_vp(Subj), @takes_pps(PPs),
      obj_sem_n_type=ObjSem, indobj_sem_n_type=IndObjSem, 
      pp_sem_pp_type=PPSem, sem_p_type=PSem, 
      obj_def=ObjDef, obj_syn_type=ObjSynType, indobj_def=IndObjDef, indobj_syn_type=IndObjSynType, takes_advp=TakesAdvp, takes_adv_type=AdvpType, passivised=n, passive_subj=n] -->
v:[sem=V,
   agr=Agr, subcat=Sub, inv=y, passivised=n, vform=VForm, vp_vform=VPVform, vp_passivised=n,
   @subj_feats_for_vp(Subj), @takes_pps(PPs),
   obj_sem_n_type=ObjSem, indobj_sem_n_type=IndObjSem, 
   pp_sem_pp_type=PPSem, sem_p_type=PSem, 
   obj_def=ObjDef, obj_syn_type=ObjSynType, indobj_def=IndObjDef, indobj_syn_type=IndObjSynType, takes_advp=TakesAdvp, takes_adv_type=AdvpType, passivised=n, passive_subj=n], 
np:[sem=Np, nform=normal,
    agr=Agr, wh=n, @subj_feats_for_np(Subj), takes_post_mods=n, @takes_no_pps, gapsin=null, gapsout=null, case=subj].

%-----------------------------------------------------------------------------------------------------

% VP rules

% vp_v - PSA rule
% intransitive
% increase
vp:[sem= @vp_v_sem(Verb), @vbar_feats_for_vp(Feats), takes_post_mods=y, 
    gapsin=GIn, gapsout=GIn] -->
vbar:[sem=Verb, subcat=nx0v, @vbar_feats_for_vp(Feats)].

% vp_v_pp
% verb taking PP complement - PSA rule
% go to flight deck 
vp:[sem= @vp_v_pp_sem(Verb, PP), @vbar_feats_for_vp(Feats), takes_post_mods=y, 
    gapsin=GIn, gapsout=GOut] -->
vbar:[sem=Verb, subcat=nx0vpnx1, @vbar_feats_for_vp(Feats), pp_sem_pp_type=PPSem], 
pp:[sem=PP, wh=n, sem_pp_type=PPSem, 
    gapsin=GIn, gapsout=GOut].

% vp_v_np - PSA rule
% transitive vps
% measure pressure
vp:[sem= @vp_v_np_sem(Verb, NP), @vbar_feats_for_vp(Feats), takes_post_mods=y,
    gapsin=GIn, gapsout=GOut] -->
vbar:[sem=Verb, subcat=nx0vnx1, @vbar_feats_for_vp(Feats), obj_sem_n_type=ObjSem, obj_def=ObjDef, obj_syn_type=ObjSynType], 
np:[sem=NP, wh=n, nform=normal, sem_n_type=ObjSem, def=ObjDef, 
    takes_post_mods=n, @takes_no_pps, gapsin=GIn, gapsout=GOut, case=nonsubj, syn_type=ObjSynType].

% vp_v_np(be) - PSA rule
% equative & predicative be
% is the pressure
vp:[sem= @vp_v_np_sem(Verb, NP), @vbar_feats_for_vp(Feats), takes_post_mods=y,
    gapsin=GIn, gapsout=GOut] -->
vbar:[sem=Verb, subcat=nx0vnx1_be, @vbar_feats_for_vp(Feats), obj_sem_n_type=ObjSem, obj_def=ObjDef, obj_syn_type=ObjSynType], 
np:[sem=NP, wh=n, nform=normal, sem_n_type=ObjSem, def=ObjDef, 
    takes_post_mods=n, @takes_no_pps, gapsin=GIn, gapsout=GOut, syn_type=ObjSynType].

% vp_v_vp_Modal - PSA rules
% vps with modal verbs
% can measure pressure
vp:[sem=concat(Verb, VP),
    @v_feats_for_vp(Feats), @subj_feats_for_vp(Subj), passivised=VPPassive, passive_subj=PassiveSubj,
    takes_post_mods=n, @takes_no_pps, 
    gapsin=GIn, gapsout=GOut] -->
vbar:[sem=Verb, @v_feats_for_vp(Feats), @subj_feats_for_vp(Subj), @takes_no_pps,
      subcat=nx0vvx1_modal, vp_vform=VForm, vp_passivised=VPPassive, passive_subj=PassiveSubj],
vp:[sem=VP, inv=n, vform=VForm, passivised=VPPassive, passive_subj=PassiveSubj,
    @subj_feats_for_vp(Subj), takes_post_mods=n, 
    gapsin=GIn, gapsout=GOut].

% vp_v_vp_NonModal - PSA rule
% non-modals that take vp complements
% stop increasing
vp:[sem= @vp_v_vp_nonmodal_sem(Verb, VP), 
    @vbar_feats_for_vp(Feats), @subj_feats_for_vp(Subj), takes_post_mods=y, 
    gapsin=GIn, gapsout=GOut] -->
vbar:[sem=Verb, @vbar_feats_for_vp(Feats), @subj_feats_for_vp(Subj), 
      subcat=nx0vvx1_nonmodal, vp_vform=V1], 
vp:[sem=VP, inv=n, vform=V1, passivised=n, @subj_feats_for_vp(Subj), takes_post_mods=n, 
    gapsin=GIn, gapsout=GOut].

% vp_v_s_Propp  - PSA rule
% verbs that take clausal complements
% say that the pressure is increasing
vp:[sem= @vp_v_s_prop_sem(Verb, S),
    @vbar_feats_for_vp(Feats),
    takes_post_mods=y, 
    gapsin=GIn, gapsout=GOut] -->
vbar:[sem=Verb, 
      subcat=nx0vs1, 
      @vbar_feats_for_vp(Feats)], 
s:[sem=S, 
   stype=embedded_dcl, operator_wrapped=y, gapsin=GIn, gapsout=GOut].

% vp_v_s_EmbeddedQ - PSA rule
% say what the pressure is
vp:[sem= @vp_v_s_embedded_q_sem(Verb, S),
    @vbar_feats_for_vp(Feats),
    takes_post_mods=y, 
    gapsin=GIn, gapsout=GIn] -->
vbar:[sem=Verb, subcat=nx0vsq1, 
      @vbar_feats_for_vp(Feats)], 
s:[sem=S, stype=embedded_q, operator_wrapped=y, gapsin=null, gapsout=null].

% is hot - PSA rule
vp:[sem= @vp_v_adj_sem(Verb, Adj),
    @vbar_feats_for_vp(Feats), subj_sem_n_type=SubjSem, 
    takes_post_mods=y, 
    gapsin=GIn, gapsout=GOut] -->
vbar:[sem=Verb,
      subcat=nx0va1, 
      @vbar_feats_for_vp(Feats)], 
adjp:[sem=Adj, 
      adjpos=pred, subj_sem_n_type=SubjSem, gapsin=GIn, gapsout=GOut].

% vp_v_np_p - PSA rule
% particle verb with particle movement
% switch it off
vp:[sem= @vp_v_np_p_sem(Verb, NP, P), 
    @vbar_feats_for_vp(Feats),
    takes_post_mods=y, 
    gapsin=GIn, gapsout=GOut] -->
vbar:[sem=Verb, 
      subcat=nx0vnx1pl, 
      @vbar_feats_for_vp(Feats),
      obj_sem_n_type=ObjSem, obj_def=ObjDef, obj_syn_type=ObjSynType,
      sem_p_type=PSem], 
np:[sem=NP, wh=n, nform=normal, sem_n_type=ObjSem, def=ObjDef, syn_type=ObjSynType, takes_post_mods=n, @takes_no_pps, gapsin=GIn, gapsout=GOut, case=nonsubj], 
p:[sem=P, sem_p_type=PSem].

% vp_v_p_np - PSA rule
% particle verb no particle movement
% switch off the light
vp:[sem= @vp_v_np_p_sem(Verb, NP, P), 
    @vbar_feats_for_vp(Feats),
    takes_post_mods=y, 
    gapsin=GIn, gapsout=GOut] -->
vbar:[sem=Verb, subcat=nx0vplnx1, 
      @vbar_feats_for_vp(Feats),
      obj_sem_n_type=ObjSem, obj_def=Def, obj_syn_type=ObjSynType,
      sem_p_type=PSem], 
p:[sem=P, sem_p_type=PSem], 
np:[sem=NP, wh=n, nform=normal, sem_n_type=ObjSem, syn_type=ObjSynType, def=Def, takes_post_mods=n, @takes_no_pps, gapsin=GIn, gapsout=GOut, case=nonsubj, pronoun=n].

%----------------------------------------------------------------------

% vp_vp_postmod - PSA rule
% zero or more post-modifiers after a vp
vp:[sem= @vp_vp_mods_sem(VP, Mods), 
    @subj_feats_for_vp(Subj), @v_feats_for_vp(VFeats), passivised=Passive, passive_subj=PassiveSubj,
    takes_post_mods=n, @takes_no_pps, takes_adv_type=AdvpType, 
    gapsin=GIn, gapsout=GOut] -->
vp:[sem=VP, 
    @subj_feats_for_vp(Subj), @v_feats_for_vp(VFeats), passivised=Passive, passive_subj=PassiveSubj,
    @takes_pps(PPs), 
    takes_post_mods=y, takes_adv_type=AdvpType, 
    gapsin=GIn, gapsout=GNext],
post_mods:[sem=Mods, 
           post_mod_type=verbal, 
	   takes_gap_mod=y, n_of_mod_type=none, @takes_pps(PPs), takes_adv_type=AdvpType, 
           gapsin=GNext, gapsout=GOut].

%----------------------------------------------------------------------

% no post modifier - PSA rule
post_mods:[sem= @null_sem, gap=y,
           takes_gap_mod=Gap, @takes_pps(PPs),
           gapsin=GIn, gapsout=GIn] --> [].

% gapped PP post mods - PSA rule
post_mods:[sem= @mods_mod_mods_sem(PP, Mods), gap=n, post_mod_type=NominalOrVerbal,
           takes_gap_mod=y, n_of_mod_type=OfType, @takes_pps(PPs), takes_adv_type=AdvpType, 
           gapsin=GIn, gapsout=GOut] -->
pp:[sem=PP, wh=n, sem_pp_type=Type, gap=y, gapsin=GIn, gapsout=GNext],
post_mods:[sem=Mods, post_mod_type=NominalOrVerbal,
           takes_gap_mod=n, n_of_mod_type=OfType, @takes_pps(PPs), takes_adv_type=AdvpType, 
           gapsin=GNext, gapsout=GOut]. 

% relative clauses - PSA rule
% e.g. the door that is open
post_mods:[sem= @mods_mod_mods_sem(Rel, Mods), gap=n, post_mod_type=nominal,
           takes_gap_mod=Gap, @takes_pps(PPs), takes_adv_type=AdvpType, 
           gapsin=GIn, gapsout=GOut] -->
rel:[sem=Rel],
post_mods:[sem=Mods, post_mod_type=nominal,
           takes_gap_mod=n, n_of_mod_type=none, @takes_pps(PPs), takes_adv_type=AdvpType, 
           gapsin=GIn, gapsout=GOut].

macro(post_mods_pp_rule(PPType, PPsIn, PPsOut),
      ( post_mods:[sem= @mods_mod_mods_sem(PP, Mods), gap=n, post_mod_type=NominalOrVerbal,
                   takes_gap_mod=Gap, @takes_pps(PPsIn), takes_adv_type=AdvpType, 
                   gapsin=GIn, gapsout=GOut] -->
        pp:[sem=PP, wh=n, sem_pp_type=PPType, gap=n, gapsin=GIn, gapsout=GNext],
        post_mods:[sem=Mods, post_mod_type=NominalOrVerbal,
                   takes_gap_mod=n, n_of_mod_type=none, 
	           @takes_pps(PPsOut), takes_adv_type=AdvpType, 
                   gapsin=GNext, gapsout=GOut]
      )).

% loc PP mod - PSA rule
% e.g. measure the pressure [at flight deck]
@post_mods_pp_rule(loc, 
                   [y, From, To, With, Duration, Date, Time, Attrib, About, Cost, PassiveBy], 
                   [n, From, To, With, Duration, Date, Time, Attrib, About, Cost, PassiveBy]).

% to PP mod - PSA rule
% e.g. go [to flight deck]
@post_mods_pp_rule(to, 
                   [Loc, From, y, With, Duration, Date, Time, Attrib, About, Cost, PassiveBy], 
                   [Loc, From, n, With, Duration, Date, Time, Attrib, About, Cost, PassiveBy]).

% time PP mod - PSA rule
% e.g. what was the pressure [at fifteen oh three]
@post_mods_pp_rule(time, 
                   [Loc, From, To, With, Duration, Date, y, Attrib, About, Cost, PassiveBy], 
                   [Loc, From, To, With, Duration, Date, n, Attrib, About, Cost, PassiveBy]).

% attribution PP mod - PSA rule
% e.g. what is the pressure [according to the fixed sensors]
@post_mods_pp_rule(attribution, 
                   [Loc, From, To, With, Duration, Date, Time, y, About, Cost, PassiveBy], 
                   [Loc, From, To, With, Duration, Date, Time, n, About, Cost, PassiveBy]).

%----------------------------------------------------------------------

% PP rules

% pp_p_np
% Basic PP - PSA rule
% e.g. at flight deck
pp:[sem= @pp_p_np_sem(P, NP), wh=y\/n, wh=Wh, sem_pp_type=PPType, gap=n, gapsin=GIn, gapsout=GOut, conj=n] -->
	p:[sem=P, postposition=n, sem_pp_type=PPType, def=Def, obj_sem_n_type=NPType], 
	np:[sem=NP, nform=normal, wh=Wh, sem_n_type=NPType, def=Def, 
            takes_post_mods=n, @takes_no_pps, gapsin=GIn, gapsout=GOut, case=nonsubj].

% pp_np_p
% PP with postposition - PSA rule
% e.g. the pressure [five minutes ago]
pp:[sem= @pp_p_np_sem(P, NP), wh=y\/n, wh=Wh, sem_pp_type=PPType, gap=n, gapsin=GIn, gapsout=GOut, conj=n] -->
	np:[sem=NP, nform=normal, wh=Wh, sem_n_type=NPType, sem_n_type=timeunit,
            def=Def, takes_post_mods=n, @takes_no_pps, gapsin=GIn, gapsout=GOut, case=nonsubj], 
	p:[sem=P, postposition=y, sem_pp_type=PPType, obj_sem_n_type=NPType, def=Def].

% pp_np_Temporal - PSA rule
% e.g. the pressure [now]
pp:[sem= @pp_np_date_sem(NP), wh=y\/n, wh=Wh, sem_pp_type=date, gap=n, gapsin=GIn, gapsout=GIn, conj=Conj] -->
	np:[sem=NP, nform=normal, wh=Wh, sem_n_type=date, takes_post_mods=n, @takes_no_pps, 
            gapsin=GIn, gapsout=GIn, pronoun=n, conj=Conj].

%----------------------------------------------------------------------

% NP rules

% np_d_n
% Basic NP with det - PSA rule
% e.g. the pressure
np:[sem= @np_d_nbar_sem(Det, N), agr=3, agr=Agr, wh=Wh, nform=normal, sem_n_type=(\(numeric)),
    sem_n_type=Type, def=Def, conj=n, gapsin=GIn, gapsout=GIn, pronoun=n, 
    takes_post_mods=y, n_of_mod_type=OfMod, @takes_pps(PPs), syn_type=np_with_noun] -->
d:[sem=Det, agr=Agr, wh=Wh, def=Def, det_type=DetType], 
nbar:[sem=N, agr=Agr, sem_n_type=Type, n_of_mod_type=OfMod, @takes_pps(PPs), takes_det_type=DetType].

% np_n
% Basic NP without det - PSA rule
% e.g. pressure
np:[sem= @np_nbar_sem(N), agr=3, agr=Agr, wh=n, nform=normal, sem_n_type=(\(numeric)),
    sem_n_type=Type, conj=n, gapsin=GIn, gapsout=GIn, pronoun=n, 
    takes_post_mods=y, n_of_mod_type=OfMod, @takes_pps(PPs), syn_type=np_with_noun] -->
nbar:[sem=N, agr=Agr, sem_n_type=Type, 
      n_of_mod_type=OfMod, @takes_pps(PPs), takes_det_type=null].

% np_pronoun
% Pronoun as NP - PSA rule
% close [it]
np:[sem= @np_pronoun_sem(Pro), agr=Agr, wh=Wh, nform=normal, sem_n_type=Type, def=y, conj=n, 
    gapsin=GIn, gapsout=GIn, pronoun=y, 
    takes_post_mods=n, n_of_mod_type=none, @takes_no_pps, case=Case, syn_type=pronoun] -->
pronoun:[sem=Pro, agr=Agr, wh=Wh, sem_n_type=Type, case=Case].

% np_time
% Time as NP - PSA rule
% e.g. the pressure at [fifteen oh three]
np:[sem= @np_time_sem(Time), agr=3/\sing, wh=n, nform=normal, sem_n_type=time, def=y,
    conj=n, gapsin=GIn, gapsout=GIn, pronoun=n, 
    takes_post_mods=n, n_of_mod_type=none, @takes_no_pps, syn_type=special] -->
time:[sem=Time].

%Noun-noun modifiers 

% Postmodifying number - PSA rule
% np_n_n_postmod
% e.g. scenario two 
np:[sem= @np_nbar_nbar_postmod_sem(N1, N2), nform=normal, sem_n_type=Type, gapsin=GIn, gapsout=GIn, pronoun=n, 
    takes_post_mods=y, n_of_mod_type=none, @takes_pps(PPs), agr=(3/\sing), syn_type=np_with_noun] -->
nbar:[sem=N1, sem_n_type=Type, n_post_mod_type=ModType, @takes_pps(PPs), agr=(3/\sing)], 
nbar:[sem=N2, sem_n_type=ModType].

% Nominal PP modifiers - PSA rule [in effect]
% e.g. flights [to barbados leaving from Stansted]
np:[sem= @np_np_postmods_sem(NP, Mods), agr=Agr, wh=Wh, nform=normal, sem_n_type=Type, def=Def, conj=n,
    gapsin=GIn, gapsout=GOut, pronoun=Pronoun,
    takes_post_mods=n, n_of_mod_type=none, @takes_no_pps, case=Case, syn_type=SynType] -->
np:[sem=NP, agr=Agr, wh=Wh, nform=normal, sem_n_type=Type, def=Def, conj=n,
    gapsin=GIn, gapsout=GOut, pronoun=Pronoun, 
    takes_post_mods=y, n_of_mod_type=OfMod, @takes_pps(PPs), case=Case, syn_type=SynType], 
post_mods:[sem=Mods, 
           post_mod_type=nominal, takes_gap_mod=n, n_of_mod_type=OfMod, @takes_pps(PPs), takes_adv_type=none,
           gapsin=null, gapsout=null].

% np_d
% Det as NP - really Checklist rule, but we have to make it a PSA rule to get "what" as an NP
% e.g. tell me [more]
np:[sem= @np_d_sem(D), agr=Agr, agr=3, wh=Wh, nform=normal, sem_n_type= @thing_type, def=Def, conj=n, 
    gapsin=GIn, gapsout=GIn, pronoun=n, 
    takes_post_mods=n, n_of_mod_type=none, @takes_no_pps, syn_type=SynType] -->
d:[sem=D, can_be_np=y, agr=Agr, wh=Wh, def=Def, syn_type=SynType].


%----------------------------------------------------------------------

% NBAR rules

% N as NBAR - PSA rule [in effect]
% e.g. Stansted [flights]
nbar:[sem= @nbar_n_sem(N), agr=Agr, sem_n_type=Type, 
      @takes_pps(PPs), 
      n_pre_mod_type=PreModType, n_post_mod_type=PostModType, n_of_mod_type=OfMod,
      takes_det_type=DetType] -->
n:[sem=N, agr=Agr, sem_n_type=Type, 
   @takes_pps(PPs), 
   n_pre_mod_type=PreModType, n_post_mod_type=PostModType, n_of_mod_type=OfMod,
   takes_det_type=DetType].

% nbar_number - PSA rule
% e.g. scenario [two]
nbar:[sem= @nbar_number_sem(N), sem_n_type=numeric, n_pre_mod_type=none, n_post_mod_type=none, n_of_mod_type=none] -->
number:[sem=N, num_type=(\(a)), time_type=none, agr=3].

%----------------------------------------------------------------------

% ADJP rules

% ADJ as ADJP - PSA rule [in effect]
adjp:[sem=Adj, wh=n, conj=n, adjpos=AdjPos, subj_sem_n_type=SubjType, @takes_pps(PPs), 
      gap=n, gapsin=GIn, gapsout=GIn] -->
adj:[sem=Adj, adjpos=AdjPos, subj_sem_n_type=SubjType, @takes_pps(PPs)].

%----------------------------------------------------------------------

% Conjunction rules

% Conjoined NPs - PSA rule
% Currently, conjoined NPs don't take post-modifiers
% e.g. go to [flight deck and mid deck]

% np_npconj
np:[sem= @conj_list_sem(np_and, Sem), agr=3/\plur, wh=n, nform=normal, sem_n_type=Type, conj=y, def=Def,
    gapsin=GIn, gapsout=GIn, pronoun=n, 
    takes_post_mods=n, n_of_mod_type=none, @takes_no_pps, case=Case, syn_type=conj_np] -->
npconj:[sem=Sem, sem_n_type=Type, def=Def, case=Case].

% npconj_np_conj_np
npconj:[sem= @conjlist_item_item_sem(NP1, NP2), sem_n_type=Type, def=Def,case=Case] -->
np:[sem=NP1, wh=n, nform=normal, sem_n_type=Type, def=Def, conj=n, takes_post_mods=n, @takes_no_pps, gapsin=GIn, gapsout=GIn, case=Case], 
conj:[], 
np:[sem=NP2, wh=n, nform=normal, sem_n_type=Type, def=Def, conj=n, takes_post_mods=n, @takes_no_pps, gapsin=GIn, gapsout=GIn, case=Case].

% npconj_np_npconj
npconj:[sem= @conjlist_item_conjlist_sem(NP, Conj), sem_n_type=Type, def=Def, case=Case] -->
np:[sem=NP, wh=n, nform=normal, sem_n_type=Type, def=Def, conj=n, takes_post_mods=n, @takes_no_pps, gapsin=GIn, gapsout=GIn, case=Case], 
npconj:[sem=Conj, sem_n_type=Type, case=Case].

%----------------------------------------------------------------------

% Gap rules

% Simplify gaps to allow only one gap per clause - this to help compilation to CFG form

% np_Gap - PSA rule
% e.g. what do the fixed sensors say the pressure is []?
np:[sem= @np_gap_sem, wh=n, nform=normal, sem_n_type=Type, conj=n, takes_post_mods=y,  n_of_mod_type=none, @takes_all_pps, pronoun=n, 
    gapsin=np_gap, gapsout=null, syn_type=special] --> [].

% pp_Gap - PSA rule
% e.g. where are you []?
pp:[sem= @pp_gap_sem, wh=n, gap=y, sem_pp_type=Type, gapsin=pp_gap, gapsout=null] --> [].

%----------------------------------------------------------------------

% rel_s
% Basic relative clause - PSA rule
% e.g. the pressure [that you measured]
rel:[sem= @rel_s_sem(Sem)] -->
s:[sem=Sem, wh=rel, vform=finite, inv=n, operator_wrapped=n, gapsin=null, gapsout=null].

%----------------------------------------------------------------------

% Time rules

% oh five hundred, fifteen hundred, eleven hundred, twenty four hundred etc 

% time_number_hundred - PSA rule
% e.g. fifteen hundred
time:[sem= @time_number_hundred_sem(H)] -->
number:[sem=H, num_type=(oh_digit\/ten\/teen\/'20_to_99'), time_type=hour], 
hundred,
?hours.

% Main time rule - PSA rule
% e.g. oh five fifty, oh nine fifteen, five fifty, nine fifteen,
% fifteen fifty, fourteen thirteen, fifteen oh four, twenty two oh five,
% oh oh thirty, zero zero fifteen 

% time_number_number
time:[sem= @time_hours_minutes_sem(H, M)] -->
number:[sem=H, time_type=hour], 
number:[sem=M, time_type=minute].

%----------------------------------------------------------------------

% DET rules

% number as D - PSA rule
% d_number 
% e.g. when did the pressure reach [fifteen] p s i
d:[sem= @det_number_sem(N), agr=Agr, wh=n, det_type=numeric, prenumber=n, can_be_np=y, syn_type=number] -->
number:[sem=N, num_type=(\(oh_digit\/a)), agr=Agr].

% D composed of D and number - PSA rule
% d_d_number
% e.g. [all three] doors
d:[sem= @det_det_number_sem(D, N), agr=plur, wh=n, det_type=numeric, prenumber=n, can_be_np=y, syn_type=number] -->
d:[sem=D, prenumber=y], 
number:[sem=N, num_type=(\(oh_digit\/a)), agr=plur].


