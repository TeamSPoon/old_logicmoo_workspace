/** <module> 
% ===================================================================
% File 'dbase_i_cyc.pl'
% Purpose: Emulation of OpenCyc for SWI-Prolog
% Maintainer: Douglas Miles
% Contact: $Author: dmiles $@users.sourceforge.net ;
% Version: 'interface.pl' 1.0.0
% Revision:  $Revision: 1.9 $
% Revised At:   $Date: 2002/06/27 14:13:20 $
% ===================================================================
% File used as storage place for all predicates which make us more like Cyc
%
% Dec 13, 2035
% Douglas Miles
*/
%:- module(tiny_kb,['TINYKB-ASSERTION'/5, 'TINYKB-ASSERTION'/6]).

:-if_file_exists(user_ensure_loaded(logicmoo(ext/moo_ext_cyc_new))).


dbase_to_cyc(tCol,'#$Collection').
dbase_to_cyc(ttFormatType,'#$CycLExpressionType').
dbase_to_cyc(tPred,'#$Predicate').
dbase_to_cyc(tFunction,'#$Function-Denotational').
dbase_to_cyc(ftVar,'#$CycLVariable').


dbase_to_cyc(D,C):-var(D),dbase_t_type(C),atom_concat('t',C,D).
dbase_to_cyc(D,C):-nonvar(D),atom_concat('t',C,D),dbase_t_type(C).

dbase_t_type('#$Relation').

cyc_to_pfc_idiom(different,dif).
cyc_to_pfc_idiom(equiv,(<=>)).
cyc_to_pfc_idiom(implies,(=>)).
cyc_to_pfc_idiom([Conj|MORE],Out):-not(is_ftVar(Conj)),!,cyc_to_pfc_sent_idiom_2(Conj,Pred,_),
  with_assertions(thocal:outer_pred_expansion(Conj,MORE),
    ( maplist(cyc_to_pfc_expansion,MORE,MOREL), 
       with_assertions(thocal:outer_pred_expansion(Pred,MOREL),       
         list_to_ops(Pred,MOREL,Out)))),!.

cyc_to_pfc_sent_idiom_2(and,(','),trueSentence).

list_to_ops(_,V,V):-is_ftVar(V),!.
list_to_ops(Pred,[],Out):-cyc_to_pfc_sent_idiom_2(_,Pred,Out),!.
list_to_ops(Pred,In,Out):-not(is_list(In)),!,cyc_to_pfc_expansion(In,Mid),cyc_to_pfc_sent_idiom_2(_,Pred,ArityOne),Out=..[ArityOne,Mid].
list_to_ops(_,[In],Out):-!,cyc_to_pfc_expansion(In,Out).
list_to_ops(Pred,[H,T],Body):-!,
    cyc_to_pfc_expansion(H,HH),
    cyc_to_pfc_expansion(T,TT),
    (is_list(TT)-> Body=..[Pred,HH|TT]; Body=..[Pred,HH,TT]).

list_to_ops(Pred,[H|T],Body):-!,
    list_to_ops(Pred,H,HH),
    list_to_ops(Pred,T,TT),
    (is_list(TT)-> Body=..[Pred,HH|TT]; Body=..[Pred,HH,TT]).



:-thread_local thocal:outer_pred_expansion/2.

cyc_to_pfc_expansion_entry(I,O):-fail,cyc_to_pfc_expansion(I,M),!,must((functor(I,FI,_),functor(M,MF,_),FI==MF)),O=M.

cyc_to_pfc_expansion(V,V):-is_ftVar(V),!.
cyc_to_pfc_expansion(I,O):-cyc_to_pfc_idiom(I,O),!.
cyc_to_pfc_expansion(V,V):-not(compound(V)),!.
cyc_to_pfc_expansion([H|T],[HH|TT]):-!,cyc_to_pfc_expansion(H,HH),cyc_to_pfc_expansion(T,TT),!.
cyc_to_pfc_expansion(HOLDS,HOLDSOUT):-HOLDS=..[F|HOLDSL],
  with_assertions(thocal:outer_pred_expansion(F,HOLDSL),cyc_to_pfc_expansion([F|HOLDSL],HOLDSOUTL)),!,
  (is_list(HOLDSOUTL)-> must(HOLDSOUT=..HOLDSOUTL) ; HOLDSOUT=HOLDSOUTL),!.

sterm_to_pterm(VAR,'$VAR'(V)):-atom(VAR),atom_concat('?',_,VAR),clip_qm(VAR,V),!.
sterm_to_pterm(VAR,kw((V))):-atom(VAR),atom_concat(':',V2,VAR),clip_qm(V2,V),!.
sterm_to_pterm(VAR,VAR):-is_ftVar(VAR),!.
sterm_to_pterm([VAR],VAR):-is_ftVar(VAR),!.
sterm_to_pterm([X],Y):-!,nonvar(X),sterm_to_pterm(X,Y).

sterm_to_pterm([S|TERM],dot_holds(PTERM)):- not(is_list(TERM)),!,sterm_to_pterm_list([S|TERM],(PTERM)),!.
sterm_to_pterm([S|TERM],PTERM):-is_ftVar(S),
            sterm_to_pterm_list(TERM,PLIST),            
            PTERM=..[holds,S|PLIST].

sterm_to_pterm([S|TERM],PTERM):-number(S),!,
            sterm_to_pterm_list([S|TERM],PTERM).            
	    
sterm_to_pterm([S|TERM],PTERM):-nonvar(S),atomic(S),!,
            sterm_to_pterm_list(TERM,PLIST),            
            PTERM=..[S|PLIST].

sterm_to_pterm([S|TERM],PTERM):-!,  atomic(S),
            sterm_to_pterm_list(TERM,PLIST),            
            PTERM=..[holds,S|PLIST].

sterm_to_pterm(VAR,VAR):-!.

sterm_to_pterm_list(VAR,VAR):-is_ftVar(VAR),!.
sterm_to_pterm_list([],[]):-!.
sterm_to_pterm_list([S|STERM],[P|PTERM]):-!,
              sterm_to_pterm(S,P),
              sterm_to_pterm_list(STERM,PTERM).
sterm_to_pterm_list(VAR,[VAR]).

clip_us(A,AO):-concat_atom(L,'-',A),concat_atom(L,'_',AO).
clip_qm(QA,AO):-atom_concat('??',A1,QA),!,atom_concat('_',A1,A),clip_us(A,AO).
clip_qm(QA,AO):-atom_concat('?',A,QA),!,clip_us(A,AO).
clip_qm(A,AO):-clip_us(A,AO).

fixvars(P,_,[],P):-!.
fixvars(P,N,[V|VARS],PO):-  
     atom_string(Name,V),clip_qm(Name,NB),Var = '$VAR'(NB),
     subst(P,'$VAR'(N),Var,PM0),
     subst(PM0,'$VAR'(Name),Var,PM),
   %  nb_getval('$variable_names', Vs),
  %   append(Vs,[Name=Var],NVs),
  %   nb_setval('$variable_names', NVs),
     N2 is N + 1,fixvars(PM,N2,VARS,PO).

tinyKB(PO,MT,STR):-fwc,(tUndressedMt(MT);tDressedMt(MT)),(STR=vStrMon;STR=vStrDef),
   tiny_kb_ASSERTION(PLISTIn,PROPS),
        once((sterm_to_pterm(PLISTIn,P),
               memberchk(amt(MT),PROPS),
               memberchk(str(STR),PROPS), 
              (member(vars(VARS),PROPS)->(nb_setval('$variable_names', []),fixvars(P,0,VARS,PO));PO=P ))).

tinyKB(P):-tUndressedMt(MT),tinyKB(P,MT).
tinyKB(ist(MT,P)):-tDressedMt(MT),tinyKB(P,MT).

tinyKB(P,MT):-tinyKB(P,MT,vStrMon).
tinyKB(P,MT):-tinyKB(P,MT,vStrDef).

tinyKB:-forall(tinyKB(P,MT,STR),print_assertion(P,MT,STR)).

print_assertion(P,MT,STR):- P=..PL,append([assertedTinyKB|PL],[MT,STR],PPL),PP=..PPL, portray_clause(current_output,PP,[numbervars(false)]).


tUndressedMt('UniversalVocabularyImplementationMt').
tUndressedMt('LogicalTruthImplementationMt').
tUndressedMt('CoreCycLImplementationMt').
tUndressedMt('UniversalVocabularyMt').
tUndressedMt('LogicalTruthMt').
tUndressedMt('CoreCycLMt').
tUndressedMt('BaseKB').
tDressedMt('BookkeepingMt').
tDressedMt('EnglishParaphraseMt').
tDressedMt('TemporaryEnglishParaphraseMt').

tinyAssertion(V):-var(V),!,tinyAssertion0(W),into_mpred_form(W,V).
tinyAssertion(V):-into_functor_form(dbase_t,V,W),!,tinyAssertion0(W).
tinyAssertion0(dbase_t(A,B,C,D,E)):-assertedTinyKB(A,B,C,D,E,_MT,_STR).
tinyAssertion0(dbase_t(A,B,C,D)):-assertedTinyKB(A,B,C,D,_MT,_STR).
tinyAssertion0(dbase_t(A,B,C)):-assertedTinyKB(A,B,C,_MT,_STR).
tinyAssertion0(dbase_t(A,B)):-assertedTinyKB(A,B,_MT,_STR).

loadTinyAssertions:-forall(tinyAssertion(V),hooked_asserta(V)).


% :-onEachLoad(loadTinyAssertions).

% ============================================
% DBASE to Cyc Predicate Mapping
% ============================================
/*
mpred_arity('abbreviationString-PN', 2).

typical_mtvars([_,_]).

% arity 1 person
make_functorskel(Person,1,fskel(Person,hasInstance(Person,A),Call,A,[],MtVars,Call2)):-typical_mtvars(MtVars),Call=..[Person,A],Call2=..[Person,A|MtVars]. 
% arity 2 likes
make_functorskel(Likes,2,fskel(Likes,dbase_t(Likes,A,B),Call,A,B,MtVars,Call2)):- typical_mtvars(MtVars),Call=..[Likes,A,B],Call2=..[Likes,A,B|MtVars]. 
% arity 3 between
make_functorskel(Between,3,fskel(Between,dbase_t(Between,A,B,C),Call,A,[B,C],MtVars,Call2)):- typical_mtvars(MtVars),Call=..[Between,A,B,C],Call2=..[Between,A,B,C|MtVars]. 
% arity 4 xyz
make_functorskel(Xyz,4,fskel(Xyz,dbase_t(Xyz,I,X,Y,Z),Call,I,[X,Y,Z],MtVars,Call2)):- typical_mtvars(MtVars),Call=..[Xyz,I,X,Y,Z],Call2=..[Xyz,I,X,Y,Z|MtVars]. 
% arity 5 rxyz
make_functorskel(RXyz,5,fskel(RXyz,dbase_t(RXyz,I,R,X,Y,Z),Call,I,[R,X,Y,Z],MtVars,Call2)):-typical_mtvars(MtVars),Call=..[RXyz,I,R,X,Y,Z],Call2=..[RXyz,I,R,X,Y,Z|MtVars]. 
% arity >6 
make_functorskel(F,N,fskel(F,DBASE,Call,I,NList,MtVars,Call2)):-typical_mtvars(MtVars),functor(Call,F,N),Call=..[F,I|NList],DBASE=..[dbase_t,F,I|NList],append([F,I|NList],MtVars,CALL2List),Call2=..CALL2List.

*/

% ============================================
% Prolog to Cyc Predicate Mapping
%
%  the following will all do the same things:
%
% :- decl_mpred('BaseKB':isa/2). 
% :- decl_mpred('BaseKB':isa(_,_)). 
% :- decl_mpred(isa(_,_),'BaseKB'). 
% :- decl_mpred('BaseKB',isa,2). 
%
%  Will make calls 
% :- isa(X,Y)
%  Query into #$BaseKB for (#$isa ?X ?Y) 
%
% decl_mpred/N
%
% ============================================

:-dynamic(isCycUnavailable_known/1).
:-dynamic(isCycAvailable_known/0).

:-export(isCycAvailable/0).
isCycAvailable:-isCycUnavailable_known(_),!,fail.
isCycAvailable:-isCycAvailable_known,!.
isCycAvailable:-checkCycAvailablity,isCycAvailable.

:-export(isCycUnavailable/0).
isCycUnavailable:-isCycUnavailable_known(_),!.
isCycUnavailable:-isCycAvailable_known,!,fail.
isCycUnavailable:-checkCycAvailablity,isCycUnavailable.

:-export(checkCycAvailablity/0).
checkCycAvailablity:- (isCycAvailable_known;isCycUnavailable_known(_)),!.
checkCycAvailablity:- ccatch((ignore((invokeSubL("(+ 1 1)",R))),(R==2->assert_if_new(isCycAvailable_known);assert_if_new(isCycUnavailable_known(R)))),E,assert_if_new(isCycUnavailable_known(E))),!.

% ===================================================================
% OPERATOR PRECEDANCE
% ===================================================================
:- dynamic((assertedTinyKB/4,assertedTinyKB/5,assertedTinyKB/6,assertedTinyKB/7)).
:-style_check(-singleton).
:-style_check(-discontiguous).
% :-style_check(-atom).
% :-style_check(-string).
:-set_prolog_flag(double_quotes,string).
assertedTinyKB(unitMultiplicationFactor, '$VAR'('UNIT'), '$VAR'('UNIT'), 1, 'BaseKB', vStrMon).
assertedTinyKB(trueRule, 'NART'(['CollectionRuleTemplateFn', 'ArgIsaPredicate']), and(implies(arg6Isa('$VAR'('RELN'), '$VAR'('COL')), argIsa('$VAR'('RELN'), 6, '$VAR'('COL'))), implies(argIsa('$VAR'('RELN'), 6, '$VAR'('COL')), arg6Isa('$VAR'('RELN'), '$VAR'('COL')))), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(trueRule, 'NART'(['CollectionRuleTemplateFn', 'ArgIsaPredicate']), and(implies(arg5Isa('$VAR'('RELN'), '$VAR'('COL')), argIsa('$VAR'('RELN'), 5, '$VAR'('COL'))), implies(argIsa('$VAR'('RELN'), 5, '$VAR'('COL')), arg5Isa('$VAR'('RELN'), '$VAR'('COL')))), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(trueRule, 'NART'(['CollectionRuleTemplateFn', 'ArgIsaPredicate']), and(implies(arg4Isa('$VAR'('RELN'), '$VAR'('COL')), argIsa('$VAR'('RELN'), 4, '$VAR'('COL'))), implies(argIsa('$VAR'('RELN'), 4, '$VAR'('COL')), arg4Isa('$VAR'('RELN'), '$VAR'('COL')))), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(trueRule, 'NART'(['CollectionRuleTemplateFn', 'ArgIsaPredicate']), and(implies(arg3Isa('$VAR'('RELN'), '$VAR'('COL')), argIsa('$VAR'('RELN'), 3, '$VAR'('COL'))), implies(argIsa('$VAR'('RELN'), 3, '$VAR'('COL')), arg3Isa('$VAR'('RELN'), '$VAR'('COL')))), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(trueRule, 'NART'(['CollectionRuleTemplateFn', 'ArgIsaPredicate']), and(implies(arg2Isa('$VAR'('RELN'), '$VAR'('COL')), argIsa('$VAR'('RELN'), 2, '$VAR'('COL'))), implies(argIsa('$VAR'('RELN'), 2, '$VAR'('COL')), arg2Isa('$VAR'('RELN'), '$VAR'('COL')))), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(trueRule, 'NART'(['CollectionRuleTemplateFn', 'ArgIsaPredicate']), and(implies(arg1Isa('$VAR'('RELN'), '$VAR'('COL')), argIsa('$VAR'('RELN'), 1, '$VAR'('COL'))), implies(argIsa('$VAR'('RELN'), 1, '$VAR'('COL')), arg1Isa('$VAR'('RELN'), '$VAR'('COL')))), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, subsetOf, subsetOf, 1, 'BaseKB', vStrMon).
assertedTinyKB(transitiveViaArgInverse, sentenceDesignationArgnum, genlPreds, 1, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(transitiveViaArgInverse, requiredArg2Pred, genls, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, requiredArg1Pred, genls, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, relationInstanceAll, genls, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, relationExistsMinAll, genls, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, relationExistsMaxAll, genls, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, relationExistsMaxAll, genls, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, relationExistsMaxAll, genlPreds, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, relationExistsAll, genls, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, relationAllInstance, quantitySubsumes, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, relationAllInstance, genls, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(transitiveViaArgInverse, relationAllExistsMin, genls, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, relationAllExistsMax, genls, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, relationAllExistsMax, genls, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, relationAllExistsMax, genlPreds, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, relationAllExistsCount, genls, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, relationAllExists, genls, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, relationAll, genls, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(transitiveViaArgInverse, negationPreds, genlPreds, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(transitiveViaArgInverse, negationPreds, genlPreds, 1, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(transitiveViaArgInverse, microtheoryDesignationArgnum, genlPreds, 1, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(transitiveViaArgInverse, ist, genlMt, 1, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(transitiveViaArgInverse, interArgResultIsa, genls, 3, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(transitiveViaArgInverse, genls, genls, 1, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(transitiveViaArgInverse, genlInverse, genlPreds, 1, 'BaseKB', vStrDef).
assertedTinyKB(transitiveViaArgInverse, disjointWith, genls, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, disjointWith, genls, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, defnNecessary, genls, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, admittedAllArgument, genls, 1, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa5-4', genls, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa5-4', genls, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa5-4', genlPreds, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa5-3', genls, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa5-3', genls, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa5-3', genlPreds, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa5-2', genls, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa5-2', genls, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa5-2', genlPreds, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa5-1', genls, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa5-1', genls, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa5-1', genlPreds, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa4-5', genls, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa4-5', genls, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa4-5', genlPreds, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa4-3', genls, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa4-3', genls, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa4-3', genlPreds, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa4-2', genls, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa4-2', genls, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa4-2', genlPreds, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa4-1', genls, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa4-1', genls, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa4-1', genlPreds, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa3-5', genls, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa3-5', genls, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa3-5', genlPreds, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa3-4', genls, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa3-4', genls, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa3-4', genlPreds, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa3-2', genls, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa3-2', genls, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa3-2', genlPreds, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa3-1', genls, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa3-1', genls, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa3-1', genlPreds, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa2-5', genls, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa2-5', genls, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa2-5', genlPreds, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa2-4', genls, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa2-4', genls, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa2-4', genlPreds, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa2-3', genls, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa2-3', genls, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa2-3', genlPreds, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa2-1', genls, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa2-1', genlPreds, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa1-5', genls, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa1-5', genls, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa1-5', genlPreds, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa1-4', genls, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa1-4', genls, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa1-4', genlPreds, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa1-3', genls, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa1-3', genls, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa1-3', genlPreds, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa1-2', genls, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArgInverse, 'interArgIsa1-2', genlPreds, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArg, subsetOf, subsetOf, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArg, subsetOf, subsetOf, 2, 'BaseKB', vStrMon).
assertedTinyKB(transitiveViaArg, resultIsa, genls, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(transitiveViaArg, resultGenl, genls, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(transitiveViaArg, requiredArg2Pred, genlPreds, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArg, requiredArg1Pred, genlPreds, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArg, relationMemberInstance, genlPreds, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArg, relationInstanceMember, genlPreds, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArg, relationInstanceExists, genls, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArg, relationInstanceExists, genlPreds, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArg, relationInstanceAll, genlPreds, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArg, relationExistsMinAll, genls, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArg, relationExistsMinAll, genlPreds, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArg, relationExistsInstance, genls, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArg, relationExistsInstance, genlPreds, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArg, relationExistsCountAll, genls, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArg, relationExistsAll, genls, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArg, relationExistsAll, genlPreds, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArg, relationAllInstance, genlPreds, 1, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(transitiveViaArg, relationAllExistsMin, genls, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArg, relationAllExistsMin, genlPreds, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArg, relationAllExists, genls, 3, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(transitiveViaArg, relationAllExists, genlPreds, 1, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(transitiveViaArg, relationAll, genlPreds, 1, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(transitiveViaArg, quotedIsa, genls, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(transitiveViaArg, isa, genls, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(transitiveViaArg, holdsIn, sentenceImplies, 2, 'BaseKB', vStrMon).
assertedTinyKB(transitiveViaArg, greaterThan, quantitySubsumes, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(transitiveViaArg, genls, genls, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(transitiveViaArg, genlInverse, genlPreds, 2, 'BaseKB', vStrDef).
assertedTinyKB(transitiveViaArg, defnSufficient, genls, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArg, canonicalizerDirectiveForArgAndRest, genlCanonicalizerDirectives, 3, 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(transitiveViaArg, canonicalizerDirectiveForArg, genlCanonicalizerDirectives, 3, 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(transitiveViaArg, canonicalizerDirectiveForAllArgs, genlCanonicalizerDirectives, 2, 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(transitiveViaArg, argsIsa, genls, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(transitiveViaArg, argsIsa, genls, 2, 'BaseKB', vStrMon).
assertedTinyKB(transitiveViaArg, argsGenl, genls, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(transitiveViaArg, argsGenl, genls, 2, 'BaseKB', vStrMon).
assertedTinyKB(transitiveViaArg, argIsa, genls, 3, 'BaseKB', vStrMon).
assertedTinyKB(transitiveViaArg, argAndRestIsa, genls, 3, 'BaseKB', vStrMon).
assertedTinyKB(transitiveViaArg, argAndRestGenl, genls, 3, 'BaseKB', vStrDef).
assertedTinyKB(transitiveViaArg, arg6SometimesIsa, genls, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(transitiveViaArg, arg6Isa, genls, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(transitiveViaArg, arg6Isa, genls, 2, 'BaseKB', vStrMon).
assertedTinyKB(transitiveViaArg, arg6Genl, genls, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(transitiveViaArg, arg6Genl, genls, 2, 'BaseKB', vStrMon).
assertedTinyKB(transitiveViaArg, arg5SometimesIsa, genls, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(transitiveViaArg, arg5Isa, genls, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(transitiveViaArg, arg5Isa, genls, 2, 'BaseKB', vStrMon).
assertedTinyKB(transitiveViaArg, arg5Genl, genls, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(transitiveViaArg, arg5Genl, genls, 2, 'BaseKB', vStrMon).
assertedTinyKB(transitiveViaArg, arg4SometimesIsa, genls, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(transitiveViaArg, arg4Isa, genls, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(transitiveViaArg, arg4Isa, genls, 2, 'BaseKB', vStrMon).
assertedTinyKB(transitiveViaArg, arg4Genl, genls, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(transitiveViaArg, arg4Genl, genls, 2, 'BaseKB', vStrMon).
assertedTinyKB(transitiveViaArg, arg3SometimesIsa, genls, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(transitiveViaArg, arg3Isa, genls, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(transitiveViaArg, arg3Isa, genls, 2, 'BaseKB', vStrMon).
assertedTinyKB(transitiveViaArg, arg3Genl, genls, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(transitiveViaArg, arg3Genl, genls, 2, 'BaseKB', vStrMon).
assertedTinyKB(transitiveViaArg, arg2SometimesIsa, genls, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(transitiveViaArg, arg2Isa, genls, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(transitiveViaArg, arg2Isa, genls, 2, 'BaseKB', vStrMon).
assertedTinyKB(transitiveViaArg, arg2Genl, genls, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(transitiveViaArg, arg2Genl, genls, 2, 'BaseKB', vStrMon).
assertedTinyKB(transitiveViaArg, arg1SometimesIsa, genls, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(transitiveViaArg, arg1Isa, genls, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(transitiveViaArg, arg1Isa, genls, 2, 'BaseKB', vStrMon).
assertedTinyKB(transitiveViaArg, arg1Genl, genls, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(transitiveViaArg, arg1Genl, genls, 2, 'BaseKB', vStrMon).
assertedTinyKB(transitiveViaArg, admittedAllArgument, genlPreds, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(transitiveViaArg, 'interArgIsa5-4', genls, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArg, 'interArgIsa5-3', genls, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArg, 'interArgIsa5-2', genls, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArg, 'interArgIsa5-1', genls, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArg, 'interArgIsa4-5', genls, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArg, 'interArgIsa4-3', genls, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArg, 'interArgIsa4-2', genls, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArg, 'interArgIsa4-1', genls, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArg, 'interArgIsa3-5', genls, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArg, 'interArgIsa3-4', genls, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArg, 'interArgIsa3-2', genls, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArg, 'interArgIsa3-1', genls, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArg, 'interArgIsa2-5', genls, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArg, 'interArgIsa2-4', genls, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArg, 'interArgIsa2-3', genls, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArg, 'interArgIsa2-1', genls, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArg, 'interArgIsa1-5', genls, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArg, 'interArgIsa1-4', genls, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArg, 'interArgIsa1-3', genls, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(transitiveViaArg, 'interArgIsa1-2', genls, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(termOfUnit, 'NART'(['CollectionRuleTemplateFn', 'HypotheticalContext']), 'CollectionRuleTemplateFn'('HypotheticalContext'), 'BaseKB', vStrMon).
assertedTinyKB(termOfUnit, 'NART'(['CollectionRuleTemplateFn', 'ArgIsaPredicate']), 'CollectionRuleTemplateFn'('ArgIsaPredicate'), 'BaseKB', vStrMon).
assertedTinyKB(subsetOf, 'TheEmptySet', '$VAR'('SET'), 'BaseKB', vStrMon).
assertedTinyKB(singleEntryFormatInArgs, unitMultiplicationFactor, 3, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(singleEntryFormatInArgs, unitMultiplicationFactor, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(singleEntryFormatInArgs, unitMultiplicationFactor, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(singleEntryFormatInArgs, sentenceTruth, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(singleEntryFormatInArgs, rewriteOf, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(singleEntryFormatInArgs, pointQuantValue, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(singleEntryFormatInArgs, operatorFormulas, 1, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(singleEntryFormatInArgs, myCreationPurpose, 2, 'BookkeepingMt', vStrDef).
assertedTinyKB(singleEntryFormatInArgs, multiplicationUnits, 3, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(singleEntryFormatInArgs, multiplicationUnits, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(singleEntryFormatInArgs, multiplicationUnits, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(singleEntryFormatInArgs, minQuantValue, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(singleEntryFormatInArgs, means, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(singleEntryFormatInArgs, maxQuantValue, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(singleEntryFormatInArgs, expresses, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(singleEntryFormatInArgs, expansion, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(singleEntryFormatInArgs, evaluationDefn, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(singleEntryFormatInArgs, cycTacticID, 3, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(singleEntryFormatInArgs, cycProofID, 3, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(singleEntryFormatInArgs, cycProblemStoreProofCount, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(singleEntryFormatInArgs, cycProblemStoreProblemCount, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(singleEntryFormatInArgs, cycProblemStoreLinkCount, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(singleEntryFormatInArgs, cycProblemStoreInferenceCount, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(singleEntryFormatInArgs, cycProblemStoreID, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(singleEntryFormatInArgs, cycProblemQuerySentence, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(singleEntryFormatInArgs, cycProblemProvabilityStatus, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(singleEntryFormatInArgs, cycProblemLinkID, 3, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(singleEntryFormatInArgs, cycProblemID, 3, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(singleEntryFormatInArgs, cycInferenceAnswerLink, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(singleEntryFormatInArgs, cycInferenceAnswerLink, 1, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(sentenceDesignationArgnum, ist, 2, 'BaseKB', vStrDef).
assertedTinyKB(sentenceDesignationArgnum, 'TLAssertionFn', 2, 'BaseKB', vStrDef).
assertedTinyKB(sentenceDesignationArgnum, 'ist-Asserted', 2, 'BaseKB', vStrDef).
assertedTinyKB(scopingArg, thereExists, 1, 'BaseKB', vStrDef).
assertedTinyKB(scopingArg, thereExistExactly, 2, 'BaseKB', vStrDef).
assertedTinyKB(scopingArg, thereExistAtMost, 2, 'BaseKB', vStrDef).
assertedTinyKB(scopingArg, thereExistAtLeast, 2, 'BaseKB', vStrDef).
assertedTinyKB(scopingArg, forAll, 1, 'BaseKB', vStrDef).
assertedTinyKB(scopingArg, 'TheSetOf', 1, 'BaseKB', vStrDef).
assertedTinyKB(scopingArg, 'TheCollectionOf', 1, 'BaseKB', vStrDef).
assertedTinyKB(scopingArg, 'Kappa', 1, 'BaseKB', vStrDef).
assertedTinyKB(ruleTemplateDirection, 'NART'(['CollectionRuleTemplateFn', 'HypotheticalContext']), 'Forward-AssertionDirection', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(ruleTemplateDirection, 'NART'(['CollectionRuleTemplateFn', 'ArgIsaPredicate']), 'Forward-AssertionDirection', 'BaseKB', vStrMon).
assertedTinyKB(rewriteOf, 'TheEmptySet', 'TheSet', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(resultQuotedIsa, 'RelationInstanceExistsFn', 'IndeterminateTerm', 'BaseKB', vStrDef).
assertedTinyKB(resultQuotedIsa, 'RelationExistsInstanceFn', 'IndeterminateTerm', 'BaseKB', vStrDef).
assertedTinyKB(resultQuotedIsa, 'RelationExistsAllFn', 'IndeterminateTerm', 'BaseKB', vStrDef).
assertedTinyKB(resultQuotedIsa, 'RelationAllExistsFn', 'IndeterminateTerm', 'BaseKB', vStrDef).
assertedTinyKB(resultIsaArgIsa, 'IntervalMinFn', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsaArgIsa, 'IntervalMaxFn', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsaArg, 'RelationInstanceExistsFn', 3, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(resultIsaArg, 'RelationExistsInstanceFn', 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(resultIsaArg, 'RelationExistsAllFn', 3, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(resultIsaArg, 'RelationAllExistsFn', 4, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(resultIsa, 'Unity', 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'UnitProductFn', 'UnitOfMeasure', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'UncanonicalizerAssertionFn', 'CycLAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'TLVariableFn', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'TLVariableFn', 'SubLAtom', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'TLReifiedNatFn', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'TLReifiedNatFn', 'CycLReifiableDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'TLAssertionFn', 'CycLAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'TimesFn', 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'TheSetOf', 'Set-Mathematical', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'TheSet', 'Set-Mathematical', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'TheList', 'List', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'TheCollectionOf', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'SkolemFunctionFn', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'SkolemFuncNFn', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'RoundUpFn', 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'RoundDownFn', 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'RoundClosestFn', 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'RelationInstanceExistsFn', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'RelationExistsInstanceFn', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'RelationExistsAllFn', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'RelationAllExistsFn', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'QuotientFn', 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'Quote', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'Quote', 'CycLTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'Quote', 'CycLTerm', 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(resultIsa, 'QuasiQuote', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'QuasiQuote', 'CycLTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'QuasiQuote', 'CycLTerm', 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(resultIsa, 'QuantityConversionFn', 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'PlusFn', 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'PlusAll', 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'PerFn', 'UnitOfMeasure', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'Percent', 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'MtUnionFn', 'ProblemSolvingCntxt', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'MtTimeWithGranularityDimFn', 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'MtTimeDimFn', 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'MtSpace', 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'ModuloFn', 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'MinRangeFn', 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'Minimum', 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'MeaningInSystemFn', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'MaxRangeFn', 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'Maximum', 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'LogFn', 'RealNumber', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'Kappa', tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'IntervalMinFn', 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'IntervalMaxFn', 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'FunctionToArg', 'EvaluatableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'FormulaArityFn', 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'FormulaArgSetFn', 'Set-Mathematical', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'FormulaArgListFn', 'List', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'FormulaArgFn', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'FOL-TermFn', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'FOL-PredicateFn', tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'FOL-FunctionFn', tFunction, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'ExpFn', 'ScalarPointValue', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'EvaluateSubLFn', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'EscapeQuote', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'EscapeQuote', 'CycLTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'EscapeQuote', 'CycLTerm', 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(resultIsa, 'DifferenceFn', 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'DateEncodeStringFn', 'CharacterString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'DateDecodeStringFn', 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'CycTacticFn', 'CycTactic', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'CycProofFn', 'CycProof', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'CycProblemStoreFn', 'CycProblemStore', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'CycProblemLinkFn', 'CycProblemLink', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'CycProblemFn', 'CycProblem', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'CycInferenceFn', 'CycInference', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'CollectionRuleTemplateFn', 'RuleTemplate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'Average', 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(resultIsa, 'AbsoluteValueFn', 'NonNegativeScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(requiredArg1Pred, 'TernaryRelation', arg3Isa, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(requiredArg1Pred, 'TernaryRelation', arg2Isa, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(requiredArg1Pred, 'SetOrCollection', subsetOf, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(requiredArg1Pred, 'ScopingRelation', scopingArg, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(requiredArg1Pred, tRelation, genFormat, 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(requiredArg1Pred, 'QuintaryRelation', arg5Isa, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(requiredArg1Pred, 'QuintaryRelation', arg4Isa, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(requiredArg1Pred, 'QuintaryRelation', arg3Isa, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(requiredArg1Pred, 'QuintaryRelation', arg2Isa, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(requiredArg1Pred, 'QuaternaryRelation', arg4Isa, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(requiredArg1Pred, 'QuaternaryRelation', arg3Isa, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(requiredArg1Pred, 'QuaternaryRelation', arg2Isa, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(requiredArg1Pred, tPred, arity, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(requiredArg1Pred, tPred, argIsa, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(requiredArg1Pred, tFunction, resultIsa, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(requiredArg1Pred, 'FixedArityRelation', arity, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(requiredArg1Pred, 'FixedArityRelation', argIsa, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(requiredArg1Pred, 'FixedArityRelation', arg1Isa, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(requiredArg1Pred, 'EvaluatableRelation', evaluationDefn, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(requiredArg1Pred, 'CycLAssertion', assertionDirection, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(requiredArg1Pred, 'CollectionDenotingFunction', resultGenl, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(requiredArg1Pred, 'BinaryRelation', arg2Isa, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(relationInstanceAll, subsetOf, 'TheEmptySet', 'SetOrCollection', 'BaseKB', vStrDef).
assertedTinyKB(relationAllInstance, resultIsa, 'UnitOfMeasure', 'ScalarInterval', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(relationAllInstance, resultIsa, 'CollectionDenotingFunction', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(relationAllInstance, genls, tCol, 'Thing', 'BaseKB', vStrMon).
assertedTinyKB(relationAllInstance, genlPreds, 'IrreflexiveBinaryPredicate', different, 'BaseKB', vStrMon).
assertedTinyKB(relationAllInstance, genlMt, 'Microtheory', 'BaseKB', 'BaseKB', vStrDef).
assertedTinyKB(relationAllInstance, definingMt, 'Microtheory', 'BaseKB', 'BaseKB', vStrDef).
assertedTinyKB(relationAllInstance, collectionConventionMt, 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(relationAllInstance, assertionDirection, 'CycLRuleAssertion', 'Backward-AssertionDirection', 'BaseKB', vStrDef).
assertedTinyKB(relationAllInstance, assertionDirection, 'CycLGAFAssertion', 'Forward-AssertionDirection', 'BaseKB', vStrDef).
assertedTinyKB(relationAllInstance, arityMin, 'UnitOfMeasure', 1, 'BaseKB', vStrDef).
assertedTinyKB(relationAllInstance, arityMax, 'UnitOfMeasure', 2, 'BaseKB', vStrDef).
assertedTinyKB(relationAllInstance, arity, 'UnaryRelation', 1, 'BaseKB', vStrMon).
assertedTinyKB(relationAllInstance, arity, 'TernaryRelation', 3, 'BaseKB', vStrMon).
assertedTinyKB(relationAllInstance, arity, 'QuintaryRelation', 5, 'BaseKB', vStrMon).
assertedTinyKB(relationAllInstance, arity, 'QuaternaryRelation', 4, 'BaseKB', vStrMon).
assertedTinyKB(relationAllInstance, arity, 'BinaryRelation', 2, 'CoreCycLMt', vStrMon).
assertedTinyKB(relationAllInstance, arg3Isa, 'ArgIsaTernaryPredicate', tCol, 'BaseKB', vStrDef).
assertedTinyKB(relationAllInstance, arg3Isa, 'ArgGenlTernaryPredicate', tCol, 'BaseKB', vStrDef).
assertedTinyKB(relationAllInstance, arg2Isa, 'ArgTypeTernaryPredicate', 'NonNegativeInteger', 'BaseKB', vStrDef).
assertedTinyKB(relationAllInstance, arg2Isa, 'ArgIsaBinaryPredicate', tCol, 'BaseKB', vStrDef).
assertedTinyKB(relationAllInstance, arg2Isa, 'ArgGenlBinaryPredicate', tCol, 'BaseKB', vStrDef).
assertedTinyKB(relationAllInstance, arg1Isa, 'ArgTypeTernaryPredicate', tRelation, 'BaseKB', vStrDef).
assertedTinyKB(relationAllInstance, arg1Isa, 'ArgTypeBinaryPredicate', tRelation, 'BaseKB', vStrDef).
assertedTinyKB(relationAllExists, natFunction, 'CycLNonAtomicTerm-ClosedFunctor', 'ReifiableFunction', 'BaseKB', vStrMon).
assertedTinyKB(relationAllExists, cycProblemStoreInferences, 'CycProblemStore', 'CycInference', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(relationAllExists, cycProblemStoreID, 'CycProblemStore', 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(relationAllExists, constantID, 'CycLConstant', 'NonNegativeInteger', 'BaseKB', vStrMon).
assertedTinyKB(relationAllExists, arity, tPred, 'PositiveInteger', 'BaseKB', vStrDef).
assertedTinyKB(relationAll, minimizeExtent, 'BookkeepingPredicate', 'BaseKB', vStrDef).
assertedTinyKB(relationAll, decontextualizedCollection, 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(relationAll, assertedSentence, 'CycLAssertion', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(quotedIsa, unknownSentence, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, trueSentence, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, transitiveViaArgInverse, 'RemovalModuleSupportedPredicate-Generic', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, transitiveViaArg, 'RemovalModuleSupportedPredicate-Generic', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, transitiveViaArg, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, termOfUnit, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, termExternalIDString, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, termChosen, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, subsetOf, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, skolemizeForward, 'InferenceSupportedPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, siblingDisjointExceptions, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, sentenceImplies, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, sentenceEquiv, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, ruleAfterRemoving, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, ruleAfterAdding, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, relationInstanceExists, 'RemovalModuleSupportedPredicate-Generic', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, relationInstanceAll, 'RemovalModuleSupportedPredicate-Generic', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, relationExistsInstance, 'RemovalModuleSupportedPredicate-Generic', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, relationExistsAll, 'RemovalModuleSupportedPredicate-Generic', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, relationAllInstance, 'RemovalModuleSupportedPredicate-Generic', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, relationAllExists, 'RemovalModuleSupportedPredicate-Generic', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, relationAll, 'RemovalModuleSupportedPredicate-Generic', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, quotedIsa, 'InferenceSupportedPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, quotedArgument, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, pragmaticRequirement, 'InferenceSupportedPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, performSubL, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, operatorFormulas, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, nthSmallestElement, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, nthLargestElement, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, negationPreds, 'TransformationModuleSupportedPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, negationPreds, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, negationPreds, 'RemovalModuleSupportedPredicate-Generic', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, negationInverse, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, nearestIsa, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, nearestGenls, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, nearestGenlPreds, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, nearestGenlMt, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, nearestDifferentIsa, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, nearestDifferentGenls, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, nearestCommonSpecs, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, nearestCommonIsa, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, nearestCommonGenls, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, nearestCommonGenlMt, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, natFunction, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, natArgumentsEqual, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, natArgument, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, myCreator, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, myCreator, 'DocumentationConstant', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, myCreationTime, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, myCreationTime, 'DocumentationConstant', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, myCreationSecond, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, myCreationSecond, 'DocumentationConstant', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, myCreationPurpose, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, myCreationPurpose, 'DocumentationConstant', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, minQuantValue, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, minimizeExtent, 'RemovalModuleSupportedPredicate-Generic', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, maxQuantValue, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, knownSentence, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, ist, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, isa, 'TransformationModuleSupportedPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, isa, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, isa, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, interArgDifferent, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, integerBetween, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, indexicalReferent, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, hlPrototypicalInstance, 'InferenceSupportedPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, genls, 'TransformationModuleSupportedPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, genls, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, genls, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, genlPreds, 'TransformationModuleSupportedPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, genlPreds, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, genlPreds, 'RemovalModuleSupportedPredicate-Generic', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, genlPreds, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, genlMt, 'TransformationModuleSupportedPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, genlMt, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, genlInverse, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, genlInverse, 'RemovalModuleSupportedPredicate-Generic', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, genlInverse, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, forwardNonTriggerLiteral, 'InferenceSupportedPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, formulaArity, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, extentCardinality, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, exactlyAssertedSentence, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, evaluationDefn, 'RemovalModuleSupportedPredicate-Generic', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, evaluate, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, equalSymbols, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, equals, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, elInverse, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, elementOf, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, disjointWith, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, disjointWith, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, differentSymbols, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, different, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, cycTransformationProofRule, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, cycTransformationProofBindings, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, cycProblemStoreTerms, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, cycProblemStoreProofCount, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, cycProblemStoreProblems, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, cycProblemStoreProblemCount, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, cycProblemStoreLinkCount, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, cycProblemStoreInferenceCount, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, cycProblemQueryTerms, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, cycProblemQuerySentence, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, cycProblemProvabilityStatus, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, constantName, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, constantID, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, constantGUID, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, consistent, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, conceptuallyRelated, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, completeExtentEnumerableForValueInArg, 'RemovalModuleSupportedPredicate-Generic', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, completeExtentEnumerableForArg, 'RemovalModuleSupportedPredicate-Generic', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, completeExtentEnumerable, 'RemovalModuleSupportedPredicate-Generic', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, completeExtentDecidableForValueInArg, 'RemovalModuleSupportedPredicate-Generic', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, completeExtentDecidable, 'RemovalModuleSupportedPredicate-Generic', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, completeExtentAssertedForValueInArg, 'RemovalModuleSupportedPredicate-Generic', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, completeExtentAsserted, 'RemovalModuleSupportedPredicate-Generic', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, comment, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, assertionDirection, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, assertedTermSentences, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, assertedSentence, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, assertedPredicateArg, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, arityMax, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, arity, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, argAndRestIsa, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, afterAdding, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, admittedSentence, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, admittedArgument, 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, 'True', 'CycLTruthValueSentence', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, 'True', 'CycLTruthValueSentence', 'CoreCycLMt', vStrDef).
assertedTinyKB(quotedIsa, 'True', 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, 'TransitiveBinaryPredicate', 'RemovalModuleSupportedCollection-Generic', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, 'TheUser', 'TheTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, 'ThePrototypicalTransitiveBinaryPredicate', 'HLPrototypicalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, 'ThePrototypicalCollection', 'HLPrototypicalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, 'ThePrototypicalBinaryPredicate', 'HLPrototypicalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, 'TheCollectionOf', 'InferenceSupportedTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, 'SymmetricBinaryPredicate', 'TransformationModuleSupportedCollection', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, 'SymmetricBinaryPredicate', 'RemovalModuleSupportedCollection-Generic', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, 'SubLPositiveInteger', 'InferenceSupportedCollection', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, 'ReflexiveBinaryPredicate', 'RemovalModuleSupportedCollection-Generic', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, 'Quote', 'InferenceSupportedTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, 'Quote', 'CycLExpression', 'LogicalTruthMt', vStrDef).
assertedTinyKB(quotedIsa, 'QueryMt', 'IndeterminateTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, 'QuasiQuote', 'InferenceSupportedTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, 'Kappa', 'InferenceSupportedFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, 'ist-Asserted', 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, 'IrreflexiveBinaryPredicate', 'RemovalModuleSupportedCollection-Generic', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, 'Guest', 'IndeterminateTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, 'genls-SpecDenotesGenlInstances', tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, 'genls-GenlDenotesSpecInstances', tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, 'False', 'CycLTruthValueSentence', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, 'False', 'CycLTruthValueSentence', 'CoreCycLMt', vStrDef).
assertedTinyKB(quotedIsa, 'EscapeQuote', 'InferenceSupportedTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, 'EscapeQuote', 'CycLExpression', 'LogicalTruthMt', vStrDef).
assertedTinyKB(quotedIsa, 'equalStrings-CaseInsensitive', 'RemovalModuleSupportedPredicate-Specific', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, 'DocumentationPredicate', 'DocumentationConstant', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, 'CycAdministrator', 'IndeterminateTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, 'AsymmetricBinaryPredicate', 'TransformationModuleSupportedCollection', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedIsa, 'AsymmetricBinaryPredicate', 'RemovalModuleSupportedCollection-Generic', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'SubLSymbol', 'SubLQuoteFn'('SYMBOLP'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'SubLSymbol', 'SubLQuoteFn'('SYMBOLP'), 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'SubLString', 'SubLQuoteFn'('CYC-SYSTEM-STRING-P'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'SubLSExpression', 'SubLQuoteFn'('CYC-SUBL-EXPRESSION'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'SubLRealNumber', 'SubLQuoteFn'('CYC-SYSTEM-REAL-NUMBER-P'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'SubLPositiveInteger', 'SubLQuoteFn'('CYC-POSITIVE-INTEGER'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'SubLPositiveInteger', 'SubLQuoteFn'('CYC-POSITIVE-INTEGER'), 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'SubLNonVariableSymbol', 'SubLQuoteFn'('CYC-SYSTEM-NON-VARIABLE-SYMBOL-P'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'SubLNonVariableNonKeywordSymbol', 'SubLQuoteFn'('SUBL-NON-VARIABLE-NON-KEYWORD-SYMBOL-P'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'SubLNonNegativeInteger', 'SubLQuoteFn'('CYC-NON-NEGATIVE-INTEGER'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'SubLNonNegativeInteger', 'SubLQuoteFn'('CYC-NON-NEGATIVE-INTEGER'), 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'SubLList', 'SubLQuoteFn'('LISTP'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'SubLKeyword', 'SubLQuoteFn'('KEYWORDP'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'SubLInteger', 'SubLQuoteFn'('CYC-SYSTEM-INTEGER'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'SubLCharacter', 'SubLQuoteFn'('CYC-SYSTEM-CHARACTER-P'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'SubLAtomicTerm', 'SubLQuoteFn'('CYC-SYSTEM-TERM-P'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'SubLAtom', 'SubLQuoteFn'('CYC-SYSTEM-ATOM'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, ftVar, 'SubLQuoteFn'('CYCL-VARIABLE-P'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'CycLTerm', 'SubLQuoteFn'('CYCL-EXPRESSION?'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'CycLSentence-Assertible', 'SubLQuoteFn'('CYCL-SENTENCE-ASSERTIBLE?'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'CycLSentence-Askable', 'SubLQuoteFn'('CYCL-SENTENCE-ASKABLE?'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'CycLSentence', 'SubLQuoteFn'('CYCL-SENTENCE?'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'CycLRuleAssertion', 'SubLQuoteFn'('CYCL-RULE-ASSERTION?'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'CycLRepresentedTerm', 'SubLQuoteFn'('CYCL-REPRESENTED-TERM?'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'CycLRepresentedAtomicTerm', 'SubLQuoteFn'('CYCL-REPRESENTED-ATOMIC-TERM-P'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'CycLReifiedDenotationalTerm', 'SubLQuoteFn'('CYCL-REIFIED-DENOTATIONAL-TERM?'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'CycLReifiableNonAtomicTerm', 'SubLQuoteFn'('CYCL-REIFIABLE-NON-ATOMIC-TERM?'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'CycLReifiableNonAtomicTerm', 'SubLQuoteFn'('CYCL-REIFIABLE-NON-ATOMIC-TERM?'), 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'CycLReifiableDenotationalTerm', 'SubLQuoteFn'('CYCL-REIFIABLE-DENOTATIONAL-TERM?'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'CycLPropositionalSentence', 'SubLQuoteFn'('CYCL-PROPOSITIONAL-SENTENCE?'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'CycLOpenSentence', 'SubLQuoteFn'('CYCL-OPEN-SENTENCE?'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'CycLOpenNonAtomicTerm', 'SubLQuoteFn'('CYCL-OPEN-NON-ATOMIC-TERM?'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'CycLOpenFormula', 'SubLQuoteFn'('CYCL-OPEN-FORMULA?'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'CycLOpenExpression', 'SubLQuoteFn'('CYCL-OPEN-EXPRESSION?'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'CycLOpenDenotationalTerm', 'SubLQuoteFn'('CYCL-OPEN-DENOTATIONAL-TERM?'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'CycLNonAtomicTerm-Assertible', 'SubLQuoteFn'('CYCL-NON-ATOMIC-TERM-ASSERTIBLE?'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'CycLNonAtomicTerm-Askable', 'SubLQuoteFn'('CYCL-NON-ATOMIC-TERM-ASKABLE?'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'CycLNonAtomicTerm', 'SubLQuoteFn'('CYCL-NON-ATOMIC-TERM?'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'CycLNonAtomicReifiedTerm', 'SubLQuoteFn'('CYCL-NON-ATOMIC-REIFIED-TERM?'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'CycLIndexedTerm', 'SubLQuoteFn'('CYCL-INDEXED-TERM?'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'CycLGenericRelationFormula', 'SubLQuoteFn'('CYCL-UNBOUND-RELATION-FORMULA-P'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'CycLGAFAssertion', 'SubLQuoteFn'('CYCL-GAF-ASSERTION?'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'CycLFormula', 'SubLQuoteFn'('CYCL-FORMULA?'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'CycLExpression-Assertible', 'SubLQuoteFn'('CYCL-EXPRESSION-ASSERTIBLE?'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'CycLExpression-Askable', 'SubLQuoteFn'('CYCL-EXPRESSION-ASKABLE?'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'CycLExpression', 'SubLQuoteFn'('CYCL-EXPRESSION?'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'CycLExpression', 'SubLQuoteFn'('CYCL-EXPRESSION?'), 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'CycLDenotationalTerm', 'SubLQuoteFn'('CYCL-DENOTATIONAL-TERM-P'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'CycLDeducedAssertion', 'SubLQuoteFn'('CYCL-DEDUCED-ASSERTION?'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'CycLConstant', 'SubLQuoteFn'('CYCL-CONSTANT-P'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'CycLClosedSentence', 'SubLQuoteFn'('CYCL-CLOSED-SENTENCE?'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'CycLClosedNonAtomicTerm', 'SubLQuoteFn'('CYCL-CLOSED-NON-ATOMIC-TERM?'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'CycLClosedFormula', 'SubLQuoteFn'('CYCL-CLOSED-FORMULA?'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'CycLClosedExpression', 'SubLQuoteFn'('CYCL-CLOSED-EXPRESSION?'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'CycLClosedDenotationalTerm', 'SubLQuoteFn'('CYCL-CLOSED-DENOTATIONAL-TERM?'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'CycLClosedAtomicTerm', 'SubLQuoteFn'('CYCL-CLOSED-ATOMIC-TERM-P'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'CycLClosedAtomicSentence', 'SubLQuoteFn'('CYCL-CLOSED-ATOMIC-SENTENCE?'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'CycLAtomicTerm', 'SubLQuoteFn'('CYCL-ATOMIC-TERM-P'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'CycLAtomicSentence', 'SubLQuoteFn'('CYCL-ATOMIC-SENTENCE?'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'CycLAtomicAssertion', 'SubLQuoteFn'('CYCL-ATOMIC-ASSERTION?'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'CycLAssertion', 'SubLQuoteFn'('CYCL-ASSERTION?'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedDefnIff, 'CycLAssertedAssertion', 'SubLQuoteFn'('CYCL-ASSERTED-ASSERTION?'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, xor, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, xor, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, unknownSentence, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, trueSubL, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, trueSentence, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, trueRule, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, thereExists, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, thereExists, 1, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(quotedArgument, thereExistExactly, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, thereExistExactly, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, thereExistAtMost, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, thereExistAtMost, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, thereExistAtLeast, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, thereExistAtLeast, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, termOfUnit, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, termOfUnit, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, termExternalIDString, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, termDependsOn, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(quotedArgument, termDependsOn, 1, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(quotedArgument, skolemizeForward, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, skolem, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, sharedNotes, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, sharedNotes, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, sentenceImplies, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, sentenceImplies, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, sentenceEquiv, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, sentenceEquiv, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, salientAssertions, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, salientAssertions, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, ruleAfterRemoving, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, ruleAfterAdding, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, rewriteOf, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(quotedArgument, rewriteOf, 1, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(quotedArgument, relationExpansion, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, reformulatorRuleProperties, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, reformulatorRule, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, reformulatorRule, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, reformulatorEquiv, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, reformulatorEquiv, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, reformulatorEquals, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, reformulatorEquals, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, reformulationPrecondition, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, reformulationDirectionInMode, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, quotedIsa, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, quotedDefnSufficient, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, quotedDefnNecessary, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, quotedDefnIff, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, quotedArgument, 1, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(quotedArgument, querySentence, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, prettyString, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, pragmaticRequirement, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, pragmaticRequirement, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, pragmaticallyNormal, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, pointQuantValue, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, performSubL, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, overlappingExternalConcept, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, or, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, operatorFormulas, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, operatorFormulas, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, opaqueArgument, 1, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(quotedArgument, oldConstantName, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, oldConstantName, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, not, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, natFunction, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, natArgumentsEqual, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, natArgumentsEqual, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, natArgument, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, myCreator, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, myCreationTime, 1, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(quotedArgument, myCreationSecond, 1, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(quotedArgument, myCreationPurpose, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, minimize, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, meetsPragmaticRequirement, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, knownSentence, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, knownAntecedentRule, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, ist, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, irrelevantTerm, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, irrelevantPredAssertion, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, irrelevantAssertion, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, indexicalReferent, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, implies, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, implies, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, hypotheticalTerm, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, holdsIn, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, hlPrototypicalInstance, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, highlyRelevantTerm, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, highlyRelevantPredAssertion, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, highlyRelevantAssertion, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, genMassNoun, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, genlRules, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, genlRules, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, genKeyword, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, genKeyword, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, genFormat, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, genFormat, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, forwardNonTriggerLiteral, 1, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(quotedArgument, formulaArity, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, forAll, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, forAll, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, expansionDefn, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, expansion, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, exceptWhen, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, exceptWhen, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, exceptFor, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, exceptFor, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, except, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, exampleAssertions, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, exampleAssertions, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, exactlyAssertedSentence, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, evaluationDefn, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, evaluate, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(quotedArgument, equiv, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, equiv, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, equalSymbols, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(quotedArgument, equalSymbols, 1, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(quotedArgument, ephemeralTerm, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, differentSymbols, 5, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(quotedArgument, differentSymbols, 4, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(quotedArgument, differentSymbols, 3, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(quotedArgument, differentSymbols, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(quotedArgument, differentSymbols, 1, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(quotedArgument, differentSymbols, '$VAR'('ALL'), 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(quotedArgument, defnSufficient, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, defnNecessary, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, defnIff, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, definingMt, 1, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(quotedArgument, cycTransformationProofRule, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, cycProblemStoreTerms, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, cycProblemQueryTerms, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, cycProblemQuerySentence, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, constraint, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, constantName, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, constantName, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, constantID, 1, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(quotedArgument, constantGUID, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, consistent, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, comment, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(quotedArgument, comment, 1, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(quotedArgument, collectionExpansion, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, assertionUtility, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, assertionDirection, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, assertedTermSentences, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(quotedArgument, assertedTermSentences, 1, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(quotedArgument, assertedSentence, 1, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(quotedArgument, arity, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, argSometimesIsa, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, argIsa, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, argAndRestIsa, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, and, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, afterRemoving, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, afterAdding, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, admittedSentence, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, admittedNAT, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, abnormal, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, 'UncanonicalizerAssertionFn', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, 'TLVariableFn', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, 'TLAssertionFn', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, 'TheSetOf', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, 'TheSetOf', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, 'TheCollectionOf', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, 'TheCollectionOf', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, 'SubLQuoteFn', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, 'SkolemFunctionFn', 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, 'SkolemFunctionFn', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, 'SkolemFunctionFn', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, 'SkolemFuncNFn', 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, 'SkolemFuncNFn', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, 'SkolemFuncNFn', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, 'Quote', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, 'QuasiQuote', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, 'prettyString-Canonical', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, 'Kappa', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, 'Kappa', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, 'ist-Asserted', 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(quotedArgument, 'FormulaArityFn', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, 'FormulaArgSetFn', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, 'FormulaArgListFn', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, 'FormulaArgFn', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, 'ExpandSubLFn', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, 'ExpandSubLFn', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, 'EvaluateSubLFn', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, 'EscapeQuote', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(quotedArgument, 'assertionUtility-1', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(predicateConventionMt, termOfUnit, 'BaseKB', 'BaseKB', vStrDef).
assertedTinyKB(predicateConventionMt, quotedArgument, 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(predicateConventionMt, predicateConventionMt, 'BaseKB', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(predicateConventionMt, predicateConventionMt, 'BaseKB', 'BaseKB', vStrMon).
assertedTinyKB(predicateConventionMt, notAssertibleMt, 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(predicateConventionMt, nearestGenlMt, 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(predicateConventionMt, ist, 'BaseKB', 'BaseKB', vStrMon).
assertedTinyKB(predicateConventionMt, genlMt, 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(predicateConventionMt, definingMt, 'BaseKB', 'BaseKB', vStrMon).
assertedTinyKB(predicateConventionMt, decontextualizedPredicate, 'BaseKB', 'BaseKB', vStrMon).
assertedTinyKB(predicateConventionMt, decontextualizedCollection, 'BaseKB', 'BaseKB', vStrDef).
assertedTinyKB(predicateConventionMt, collectionConventionMt, 'BaseKB', 'BaseKB', vStrMon).
assertedTinyKB(predicateConventionMt, canonicalizerDirectiveForArgAndRest, 'UniversalVocabularyImplementationMt', 'BaseKB', vStrMon).
assertedTinyKB(predicateConventionMt, canonicalizerDirectiveForArg, 'UniversalVocabularyImplementationMt', 'BaseKB', vStrMon).
assertedTinyKB(predicateConventionMt, canonicalizerDirectiveForAllArgs, 'UniversalVocabularyImplementationMt', 'BaseKB', vStrMon).
assertedTinyKB(predicateConventionMt, assertionDirection, 'BaseKB', 'BaseKB', vStrMon).
assertedTinyKB(predicateConventionMt, arityMin, 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(predicateConventionMt, arityMax, 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(predicateConventionMt, arity, 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(predicateConventionMt, 'ist-Asserted', 'BaseKB', 'BaseKB', vStrMon).
assertedTinyKB(or, trueSentence('$VAR'('SENT')), sentenceTruth('$VAR'('SENT'), 'False'), 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(or, different('$VAR'('THING1'), '$VAR'('THING2')), equals('$VAR'('THING1'), '$VAR'('THING2')), 'BaseKB', vStrDef).
assertedTinyKB(openEntryFormatInArgs, rewriteOf, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(openEntryFormatInArgs, pointQuantValue, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(openEntryFormatInArgs, operatorFormulas, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(openEntryFormatInArgs, myCreationPurpose, 1, 'BookkeepingMt', vStrDef).
assertedTinyKB(openEntryFormatInArgs, minQuantValue, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(openEntryFormatInArgs, maxQuantValue, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(openEntryFormatInArgs, followingValue, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(openEntryFormatInArgs, followingValue, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(openEntryFormatInArgs, expresses, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(openEntryFormatInArgs, evaluationDefn, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(openEntryFormatInArgs, cycTransformationProofBindings, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(openEntryFormatInArgs, completelyEnumerableCollection, 1, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(openEntryFormatInArgs, completelyDecidableCollection, 1, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(openEntryFormatInArgs, completeExtentEnumerable, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(openEntryFormatInArgs, completeExtentDecidable, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(openEntryFormatInArgs, completeExtentAsserted, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(openEntryFormatInArgs, argSometimesIsa, 3, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(openEntryFormatInArgs, argSometimesIsa, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(openEntryFormatInArgs, argSometimesIsa, 1, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(openEntryFormatInArgs, admittedAllArgument, 3, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(openEntryFormatInArgs, admittedAllArgument, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(openEntryFormatInArgs, admittedAllArgument, 1, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(opaqueArgument, conceptuallyRelated, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(opaqueArgument, conceptuallyRelated, 1, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(omitArgIsa, thereExists, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(omitArgIsa, thereExists, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(omitArgIsa, forAll, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(omitArgIsa, forAll, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(omitArgIsa, 'SubLQuoteFn', 1, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(oldConstantName, unknownSentence, "unknownFormula", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, trueSentence, "trueFormula", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, thereExists, "ThereExists", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, thereExistExactly, "ThereExistExactly", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, thereExistAtMost, "ThereExistAtMost", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, thereExistAtLeast, "ThereExistAtLeast", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, sentenceImplies, "formulaImplies", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, sentenceEquiv, "formulaEquiv", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, sentenceDesignationArgnum, "formulaDesignationArgnum", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, resultIsa, "resultType", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, resultGenl, "usesAreSpecsOf", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, relationAllExistsCount, "relationTypeCount", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, pragmaticRequirement, "pragmaticImplies", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, or, "LogOr", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, numericallyEquals, "numericallyEqual", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, not, "LogNot", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, knownSentence, "knownFormula", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, isa, "instanceOf", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, interArgResultGenl, "interArgResultGenls", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, implies, "LogImplication", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, genlMt, "baseMt", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, forAll, "ForAll", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, except, "exceptedAssertion", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, evaluationDefn, "lispDefun", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, equalSymbols, "equals-Symbols", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, disjointWith, "mutuallyDisjointWith", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, differentSymbols, "different-Symbols", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, defnSufficient, "defn", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, defnIff, "necessaryDefn", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, conceptuallyRelated, "mysteryLink", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, completelyEnumerableCollection, "completeCollectionExtent", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, completeExtentEnumerableForValueInArg, "completeExtentKnownForArg", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, completeExtentEnumerable, "completeExtentKnown", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, commutativeInArgs, "symmetricInArgs", 'BookkeepingMt', vStrMon).
assertedTinyKB(oldConstantName, comment, "english", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, collectionCompletelyEnumerableViaBackchain, "collectionCompletelyEnumerableViaBackchains", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, assertedTermSentences, "assertedTermFormulas", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, assertedSentence, "assertedFormula", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, arity, "expressionArity", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, argsIsa, "argumentTypes", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, arg5Isa, "argumentFiveType", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, arg4Isa, "argumentFourType", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, arg3Isa, "argumentThreeType", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, arg3Genl, "argumentThreeGenls", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, arg2Isa, "argumentTwoType", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, arg2Genl, "argumentTwoGenls", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, arg1Isa, "argumentOneType", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, arg1Genl, "argumentOneGenls", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, and, "LogAnd", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, admittedSentence, "admittedFormula", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'Unknown-HLTruthValue', "Unknown-TruthValue", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'TransitiveBinaryPredicate', "TransitiveSlot", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'TimesFn', "Times", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'SubLSymbol', "LispSymbol", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'SubLSymbol', "CycSystemSymbol", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'SubLString', "CycSystemString", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'SubLSExpression', "SubLExpression", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'SubLRealNumber', "LispRealNumber", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'SubLRealNumber', "CycSystemRealNumber", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'SubLList', "CycSystemList", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'SubLKeyword', "CycSystemKeyword", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'SubLInteger', "CycSystemInteger", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'SubLAtom', "LispAtom", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'SubLAtom', "CycSystemAtom", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'SiblingDisjointAttributeType', "MutuallyDisjointAttributeType", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'SententialRelation', "NonPredicateTruthFunction", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, tRelation, "Relationship", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'QuotientFn', "Quotient", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'PlusFn', "Plus", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'MtTimeWithGranularityDimFn', "MtTimeDimWithGranularityFn", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'LogicalTruthImplementationMt', "CycInferenceMt", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'LogFn', "Log", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'List', "List", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'LeaveSomeTermsAtELAndAllowKeywordVariables', "CanonicalizeForNL", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'IntervalMinFn', "IntervalMin", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'IntervalMaxFn', "IntervalMax", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'InferencePSC', "ForwardInferencePSC", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'HLAssertedArgumentKeywordDatastructure', "HLAssertedArgumentKeyword", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'FormulaArityFn', "RelationExpressionArityFn", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'FormulaArgSetFn', "RelationArgSetFn", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'FormulaArgListFn', "RelationArgsListFn", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'FormulaArgFn', "RelationArgFn", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'ExpFn', "Exp", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'ExceptionPredicate', "ExceptionRelation", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'EvaluatableRelation', "EvaluatableRelationship", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'equalStrings-CaseInsensitive', "equals-CaseInsensitive", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'ELRelation-Reversible', "ELRelation-SemiReversible", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'DifferenceFn', "Difference", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'CycSupportDatastructure', "CycLSupportDatastructure", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'CycLTerm', "CycTerm", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'CycLSentence', "CycSyntacticFormula", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'CycLSentence', "ConstraintLanguageExpression", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'CycLRuleAssertion', "RuleAssertion", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'CycLReifiableNonAtomicTerm', "ReifiableNAT", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'CycLReifiableDenotationalTerm', "ReifiableTerm", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'CycLOpenExpression', "CycOpenTerm", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'CycLNonAtomicTerm', "NonAtomicTerm", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'CycLIndexedTerm', "CycIndexedTerm", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'CycLGAFAssertion', "GAFAssertion", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'CycLFormula', "RelationExpression", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'CycLDeducedAssertion', "DeducedAssertion", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'CycLConstant', "CycConstant", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'CycLClosedExpression', "CycClosedTerm", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'CycLAtomicSentence', "CycAtomicFormula", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'CycLAssertion', "Assertion", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'CycLAssertedAssertion', "AssertedAssertion", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'CycKBDatastructure', "CycLKBDatastructure", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'CycHLTruthValue', "CyclTruthValue", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'CycDeductionDatastructure', "CycLDeductionDatastructure", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'CycArgumentDatastructure', "CycLArgumentDatastructure", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'CurrentWorldDataCollectorMt-NonHomocentric', "CurrentWorldDataCollectorMtt-NonHomocentric", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'ArgGenlQuantityBinaryPredicate', "ArgGenlQuanityBinaryPredicate", 'BookkeepingMt', vStrDef).
assertedTinyKB(oldConstantName, 'AbsoluteValueFn', "AbsoluteValue", 'BookkeepingMt', vStrDef).
assertedTinyKB(notAssertibleMt, 'LogicalTruthMt', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(notAssertibleMt, 'InferencePSC', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(notAssertibleMt, 'EverythingPSC', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(notAssertibleCollection, 'ELRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(notAssertibleCollection, 'CycLTruthValueSentence', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(notAssertibleCollection, 'CanonicalizerDirective', 'BookkeepingMt', vStrMon).
assertedTinyKB(notAssertible, unknownSentence, 'BaseKB', vStrMon).
assertedTinyKB(notAssertible, trueSubL, 'BaseKB', vStrMon).
assertedTinyKB(notAssertible, trueSentence, 'BaseKB', vStrMon).
assertedTinyKB(notAssertible, termExternalIDString, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(notAssertible, termChosen, 'BaseKB', vStrMon).
assertedTinyKB(notAssertible, sentenceTruth, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(notAssertible, sentenceImplies, 'BaseKB', vStrMon).
assertedTinyKB(notAssertible, sentenceEquiv, 'BaseKB', vStrMon).
assertedTinyKB(notAssertible, relationExpansion, 'BaseKB', vStrMon).
assertedTinyKB(notAssertible, querySentence, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(notAssertible, operatorFormulas, 'BaseKB', vStrMon).
assertedTinyKB(notAssertible, nearestIsa, 'BaseKB', vStrMon).
assertedTinyKB(notAssertible, nearestGenls, 'BaseKB', vStrMon).
assertedTinyKB(notAssertible, nearestGenlPreds, 'BaseKB', vStrMon).
assertedTinyKB(notAssertible, nearestGenlMt, 'BaseKB', vStrMon).
assertedTinyKB(notAssertible, nearestDifferentIsa, 'BaseKB', vStrMon).
assertedTinyKB(notAssertible, nearestDifferentGenls, 'BaseKB', vStrMon).
assertedTinyKB(notAssertible, nearestCommonSpecs, 'BaseKB', vStrMon).
assertedTinyKB(notAssertible, nearestCommonIsa, 'BaseKB', vStrMon).
assertedTinyKB(notAssertible, nearestCommonGenls, 'BaseKB', vStrMon).
assertedTinyKB(notAssertible, nearestCommonGenlMt, 'BaseKB', vStrMon).
assertedTinyKB(notAssertible, natFunction, 'BaseKB', vStrMon).
assertedTinyKB(notAssertible, natArgumentsEqual, 'BaseKB', vStrMon).
assertedTinyKB(notAssertible, natArgument, 'BaseKB', vStrMon).
assertedTinyKB(notAssertible, knownSentence, 'BaseKB', vStrMon).
assertedTinyKB(notAssertible, integerBetween, 'BaseKB', vStrMon).
assertedTinyKB(notAssertible, genlCanonicalizerDirectives, 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(notAssertible, forwardNonTriggerLiteral, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(notAssertible, exactlyAssertedSentence, 'BaseKB', vStrMon).
assertedTinyKB(notAssertible, evaluate, 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(notAssertible, cycTransformationProofRule, 'BaseKB', vStrMon).
assertedTinyKB(notAssertible, cycTransformationProofBindings, 'BaseKB', vStrMon).
assertedTinyKB(notAssertible, constantID, 'BaseKB', vStrMon).
assertedTinyKB(notAssertible, constantGUID, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(notAssertible, consistent, 'BaseKB', vStrMon).
assertedTinyKB(notAssertible, assertedSentence, 'BaseKB', vStrMon).
assertedTinyKB(notAssertible, assertedPredicateArg, 'BaseKB', vStrMon).
assertedTinyKB(notAssertible, admittedSentence, 'BaseKB', vStrMon).
assertedTinyKB(notAssertible, admittedNAT, 'BaseKB', vStrMon).
assertedTinyKB(notAssertible, admittedArgument, 'BaseKB', vStrMon).
assertedTinyKB(notAssertible, admittedAllArgument, 'BaseKB', vStrMon).
assertedTinyKB(notAssertible, 'ist-Asserted', 'BaseKB', vStrMon).
assertedTinyKB(not, quotedIsa(thereExistExactly, 'InferenceSupportedTerm'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, quotedIsa(thereExistAtMost, 'InferenceSupportedTerm'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, quotedIsa(thereExistAtLeast, 'InferenceSupportedTerm'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, quotedIsa('False', 'CycLSentence-Assertible'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa(subsetOf, 'SymmetricBinaryPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa(subsetOf, 'AntiSymmetricBinaryPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa(siblingDisjointExceptions, 'TransitiveBinaryPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa(quotedIsa, 'TransitiveBinaryPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa(quotedIsa, 'ReflexiveBinaryPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa(quotedIsa, 'IrreflexiveBinaryPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa(quotedDefnSufficient, 'InferenceSupportedPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa(quotedDefnNecessary, 'InferenceSupportedPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa(quotedDefnIff, 'InferenceSupportedPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa(quantityIntersects, 'TransitiveBinaryPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa(quantityIntersects, 'AntiSymmetricBinaryPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa(negationPreds, 'TransitiveBinaryPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa(negationInverse, 'TransitiveBinaryPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa(negationInverse, 'IrreflexiveBinaryPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa(knownAntecedentRule, 'InferenceSupportedPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa(isa, 'TransitiveBinaryPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa(isa, 'ReflexiveBinaryPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa(isa, 'IrreflexiveBinaryPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa(genls, 'SymmetricBinaryPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa(genls, 'AsymmetricBinaryPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa(genls, 'AntiSymmetricBinaryPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa(genlPreds, 'AntiSymmetricBinaryPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa(genlMt, 'AntiSymmetricBinaryPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa(genlInverse, 'TransitiveBinaryPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa(genlInverse, 'SymmetricBinaryPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa(genlInverse, 'ReflexiveBinaryPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa(genlInverse, 'IrreflexiveBinaryPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa(genlInverse, 'AsymmetricBinaryPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa(genlInverse, 'AntiSymmetricBinaryPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa(evaluationResultQuotedIsa, 'WFFSupportedPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa(evaluate, 'SymmetricBinaryPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa(elementOf, 'TransitiveBinaryPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa(elementOf, 'SymmetricBinaryPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa(elementOf, 'ReflexiveBinaryPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa(elementOf, 'IrreflexiveBinaryPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa(elementOf, 'AsymmetricBinaryPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa(elementOf, 'AntiSymmetricBinaryPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa(disjointWith, 'TransitiveBinaryPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa(disjointWith, 'IrreflexiveBinaryPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa(disjointWith, 'AntiSymmetricBinaryPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa(constraint, 'WFFSupportedPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa(conceptuallyRelated, 'TransitiveBinaryPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa(conceptuallyRelated, 'SymmetricBinaryPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa(arg6SometimesIsa, 'WFFSupportedPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa(arg5SometimesIsa, 'WFFSupportedPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa(arg4SometimesIsa, 'WFFSupportedPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa(arg3SometimesIsa, 'WFFSupportedPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa(arg2SometimesIsa, 'WFFSupportedPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa(arg1SometimesIsa, 'WFFSupportedPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa('IntervalEntry', 'WFFSupportedTerm'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa('genls-SpecDenotesGenlInstances', 'WFFSupportedPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa('genls-SpecDenotesGenlInstances', 'TransitiveBinaryPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa('genls-SpecDenotesGenlInstances', 'SymmetricBinaryPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa('genls-SpecDenotesGenlInstances', 'ReflexiveBinaryPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa('genls-SpecDenotesGenlInstances', 'AsymmetricBinaryPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa('genls-SpecDenotesGenlInstances', 'AntiSymmetricBinaryPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa('genls-GenlDenotesSpecInstances', 'WFFSupportedPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa('genls-GenlDenotesSpecInstances', 'TransitiveBinaryPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa('genls-GenlDenotesSpecInstances', 'SymmetricBinaryPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa('genls-GenlDenotesSpecInstances', 'ReflexiveBinaryPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa('genls-GenlDenotesSpecInstances', 'AsymmetricBinaryPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, isa('genls-GenlDenotesSpecInstances', 'AntiSymmetricBinaryPredicate'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, genls('CommutativeRelation', 'PartiallyCommutativeRelation'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, genls('CollectionDenotingFunction', 'ReifiableFunction'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, genlPreds(reformulatorEquals, equals), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, genlPreds(hlPrototypicalInstance, isa), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, equals('$VAR'('_SET'), 'TheSetOf'('$VAR'('X'), and(isa('$VAR'('X'), 'Set-Mathematical'), not(elementOf('$VAR'('X'), '$VAR'('X')))))), 'BaseKB', vStrMon).
assertedTinyKB(not, elementOf('$VAR'('X'), 'TheEmptySet'), 'BaseKB', vStrMon).
assertedTinyKB(not, different('$VAR'('OBJ'), '$VAR'('OBJ')), 'BaseKB', vStrMon).
assertedTinyKB(not, commutativeInArgsAndRest('$VAR'('REL'), 1, 2, 3), 'BaseKB', vStrDef).
assertedTinyKB(not, commutativeInArgsAndRest('$VAR'('REL'), 1, 2), 'BaseKB', vStrDef).
assertedTinyKB(not, commutativeInArgsAndRest('$VAR'('REL'), 1), 'BaseKB', vStrDef).
assertedTinyKB(not, arg2Isa(evaluate, 'CycLNonAtomicTerm-Askable'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, and(trueSentence('$VAR'('VALUE')), equals('False', '$VAR'('VALUE'))), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, and(trueSentence('$VAR'('SENT')), sentenceTruth('$VAR'('SENT'), 'False')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, and(scopingArg('$VAR'('RELN'), '$VAR'('N')), arity('$VAR'('RELN'), '$VAR'('ARITY')), greaterThan('$VAR'('N'), '$VAR'('ARITY'))), 'BaseKB', vStrDef).
assertedTinyKB(not, and(resultGenlArg('$VAR'('FUNC'), '$VAR'('ARGNUM')), arity('$VAR'('FUNC'), '$VAR'('ARITY')), greaterThan('$VAR'('ARGNUM'), '$VAR'('ARITY'))), 'BaseKB', vStrMon).
assertedTinyKB(not, and(relationAllInstance('$VAR'('PRED'), '$VAR'('COL'), '$VAR'('THING')), trueSentence(thereExists('$VAR'('INST'), and(isa('$VAR'('INST'), '$VAR'('COL')), not(holds('$VAR'('PRED'), '$VAR'('INST'), '$VAR'('THING'))))))), 'BaseKB', vStrDef).
assertedTinyKB(not, and(relationAllInstance('$VAR'('PRED'), '$VAR'('COL'), '$VAR'('THING')), trueSentence(thereExists('$VAR'('COLINST'), and(isa('$VAR'('COLINST'), '$VAR'('COL')), not(holds('$VAR'('PRED'), '$VAR'('COLINST'), '$VAR'('THING'))))))), 'BaseKB', vStrDef).
assertedTinyKB(not, and(relationAllExists('$VAR'('RELATION'), '$VAR'('COL1'), '$VAR'('COL2')), relationAllExistsCount('$VAR'('RELATION'), '$VAR'('COL1'), '$VAR'('COL2'), 0)), 'BaseKB', vStrDef).
assertedTinyKB(not, and(quantitySubsumes('$VAR'('SUPER'), '$VAR'('SUB')), maxQuantValue('$VAR'('SUPER'), '$VAR'('SUPERMAX')), greaterThan('$VAR'('SUBMAX'), '$VAR'('SUPERMAX')), maxQuantValue('$VAR'('SUB'), '$VAR'('SUBMAX'))), 'BaseKB', vStrDef).
assertedTinyKB(not, and(opaqueArgument('$VAR'('REL'), '$VAR'('N')), arity('$VAR'('REL'), '$VAR'('ARITY')), greaterThan('$VAR'('N'), '$VAR'('ARITY'))), 'BaseKB', vStrDef).
assertedTinyKB(not, and(omitArgIsa('$VAR'('RELN'), '$VAR'('N')), argIsa('$VAR'('RELN'), '$VAR'('N'), '$VAR'('_THING'))), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, and(notAssertible('$VAR'('PRED')), isa('$VAR'('PRED'), 'DistributingMetaKnowledgePredicate')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, and(negationPreds('$VAR'('NEGPRED'), '$VAR'('PRED')), relationAllInstance('$VAR'('PRED'), '$VAR'('COL'), '$VAR'('THING')), trueSentence(thereExists('$VAR'('INST'), and(isa('$VAR'('INST'), '$VAR'('COL')), holds('$VAR'('NEGPRED'), '$VAR'('INST'), '$VAR'('THING')))))), 'BaseKB', vStrMon).
assertedTinyKB(not, and(negationPreds('$VAR'('NEGPRED'), '$VAR'('PRED')), isa('$VAR'('INST'), '$VAR'('COL')), holds('$VAR'('NEGPRED'), '$VAR'('INST'), '$VAR'('THING')), relationAllInstance('$VAR'('PRED'), '$VAR'('COL'), '$VAR'('THING'))), 'BaseKB', vStrMon).
assertedTinyKB(not, and(negationPreds('$VAR'('NEG_PRED'), '$VAR'('PRED')), holds('$VAR'('NEG_PRED'), '$VAR'('ARG1'), '$VAR'('ARG2'), '$VAR'('ARG3'), '$VAR'('ARG4'), '$VAR'('ARG5')), holds('$VAR'('PRED'), '$VAR'('ARG1'), '$VAR'('ARG2'), '$VAR'('ARG3'), '$VAR'('ARG4'), '$VAR'('ARG5'))), 'BaseKB', vStrMon).
assertedTinyKB(not, and(negationPreds('$VAR'('NEG_PRED'), '$VAR'('PRED')), holds('$VAR'('NEG_PRED'), '$VAR'('ARG1'), '$VAR'('ARG2'), '$VAR'('ARG3'), '$VAR'('ARG4')), holds('$VAR'('PRED'), '$VAR'('ARG1'), '$VAR'('ARG2'), '$VAR'('ARG3'), '$VAR'('ARG4'))), 'BaseKB', vStrMon).
assertedTinyKB(not, and(negationPreds('$VAR'('NEG_PRED'), '$VAR'('PRED')), holds('$VAR'('NEG_PRED'), '$VAR'('ARG1'), '$VAR'('ARG2'), '$VAR'('ARG3')), holds('$VAR'('PRED'), '$VAR'('ARG1'), '$VAR'('ARG2'), '$VAR'('ARG3'))), 'BaseKB', vStrMon).
assertedTinyKB(not, and(negationPreds('$VAR'('NEG_PRED'), '$VAR'('PRED')), holds('$VAR'('NEG_PRED'), '$VAR'('ARG1'), '$VAR'('ARG2')), holds('$VAR'('PRED'), '$VAR'('ARG1'), '$VAR'('ARG2'))), 'BaseKB', vStrMon).
assertedTinyKB(not, and(negationPreds('$VAR'('NEG_PRED'), '$VAR'('PRED')), holds('$VAR'('NEG_PRED'), '$VAR'('ARG1')), holds('$VAR'('PRED'), '$VAR'('ARG1'))), 'BaseKB', vStrMon).
assertedTinyKB(not, and(negationInverse('$VAR'('BINPRED1'), '$VAR'('BINPRED2')), holds('$VAR'('BINPRED1'), '$VAR'('ARG1'), '$VAR'('ARG2')), holds('$VAR'('BINPRED2'), '$VAR'('ARG2'), '$VAR'('ARG1'))), 'BaseKB', vStrDef).
assertedTinyKB(not, and(minQuantValue('$VAR'('SUPER'), '$VAR'('SUPERMIN')), quantitySubsumes('$VAR'('SUPER'), '$VAR'('SUB')), minQuantValue('$VAR'('SUB'), '$VAR'('SUBMIN')), greaterThan('$VAR'('SUPERMIN'), '$VAR'('SUBMIN'))), 'BaseKB', vStrDef).
assertedTinyKB(not, and(minQuantValue('$VAR'('INTERVAL1'), '$VAR'('MIN1')), quantityIntersects('$VAR'('INTERVAL1'), '$VAR'('INTERVAL2')), maxQuantValue('$VAR'('INTERVAL2'), '$VAR'('MAX2')), greaterThan('$VAR'('MIN1'), '$VAR'('MAX2'))), 'BaseKB', vStrDef).
assertedTinyKB(not, and(microtheoryDesignationArgnum('$VAR'('RELN'), '$VAR'('NUM')), sentenceDesignationArgnum('$VAR'('RELN'), '$VAR'('NUM'))), 'BaseKB', vStrDef).
assertedTinyKB(not, and(isa('$VAR'('X'), 'TernaryPredicate'), arg4Isa('$VAR'('X'), '$VAR'('Y'))), 'BaseKB', vStrDef).
assertedTinyKB(not, and(isa('$VAR'('REL'), 'PartiallyCommutativeRelation'), arity('$VAR'('REL'), 5), different('$VAR'('J'), '$VAR'('K'), '$VAR'('L'), '$VAR'('M'), '$VAR'('N')), commutativeInArgs('$VAR'('REL'), '$VAR'('J'), '$VAR'('K'), '$VAR'('L'), '$VAR'('M'), '$VAR'('N'))), 'BaseKB', vStrDef).
assertedTinyKB(not, and(isa('$VAR'('REL'), 'PartiallyCommutativeRelation'), arity('$VAR'('REL'), 4), different('$VAR'('K'), '$VAR'('L'), '$VAR'('M'), '$VAR'('N')), commutativeInArgs('$VAR'('REL'), '$VAR'('K'), '$VAR'('L'), '$VAR'('M'), '$VAR'('N'))), 'BaseKB', vStrDef).
assertedTinyKB(not, and(isa('$VAR'('REL'), 'PartiallyCommutativeRelation'), arity('$VAR'('REL'), 3), different('$VAR'('L'), '$VAR'('M'), '$VAR'('N')), commutativeInArgs('$VAR'('REL'), '$VAR'('L'), '$VAR'('M'), '$VAR'('N'))), 'BaseKB', vStrDef).
assertedTinyKB(not, and(isa('$VAR'('REL'), 'PartiallyCommutativeRelation'), arity('$VAR'('REL'), 2), different('$VAR'('M'), '$VAR'('N')), commutativeInArgs('$VAR'('REL'), '$VAR'('M'), '$VAR'('N'))), 'BaseKB', vStrDef).
assertedTinyKB(not, and(isa('$VAR'('PRED'), 'IrreflexiveBinaryPredicate'), holds('$VAR'('PRED'), '$VAR'('OBJ'), '$VAR'('OBJ'))), 'BaseKB', vStrMon).
assertedTinyKB(not, and(isa('$VAR'('PRED'), 'IrreflexiveBinaryPredicate'), equals('$VAR'('OBJ1'), '$VAR'('OBJ2')), holds('$VAR'('PRED'), '$VAR'('OBJ1'), '$VAR'('OBJ2'))), 'BaseKB', vStrMon).
assertedTinyKB(not, and(isa('$VAR'('PRED'), 'AsymmetricBinaryPredicate'), isa('$VAR'('PRED'), 'SymmetricBinaryPredicate'), holds('$VAR'('PRED'), '$VAR'('ANYTHING1'), '$VAR'('ANYTHING2'))), 'BaseKB', vStrMon).
assertedTinyKB(not, and(isa('$VAR'('PRED'), 'AsymmetricBinaryPredicate'), holds('$VAR'('PRED'), '$VAR'('ARG1'), '$VAR'('ARG2')), holds('$VAR'('PRED'), '$VAR'('ARG2'), '$VAR'('ARG1'))), 'BaseKB', vStrMon).
assertedTinyKB(not, and(isa('$VAR'('PRED'), 'AntiTransitiveBinaryPredicate'), isa('$VAR'('PRED'), 'TransitiveBinaryPredicate'), holds('$VAR'('PRED'), '$VAR'('_A'), '$VAR'('B')), holds('$VAR'('PRED'), '$VAR'('B'), '$VAR'('_C'))), 'BaseKB', vStrDef).
assertedTinyKB(not, and(isa('$VAR'('PRED'), 'AntiTransitiveBinaryPredicate'), holds('$VAR'('PRED'), '$VAR'('X'), '$VAR'('Y')), holds('$VAR'('PRED'), '$VAR'('X'), '$VAR'('Z')), holds('$VAR'('PRED'), '$VAR'('Y'), '$VAR'('Z'))), 'BaseKB', vStrDef).
assertedTinyKB(not, and(isa('$VAR'('PRED'), 'AntiSymmetricBinaryPredicate'), admittedArgument('$VAR'('ARG1'), 1, '$VAR'('PRED')), admittedArgument('$VAR'('ARG1'), 2, '$VAR'('PRED')), different('$VAR'('ARG1'), '$VAR'('ARG2')), holds('$VAR'('PRED'), '$VAR'('ARG2'), '$VAR'('ARG1')), holds('$VAR'('PRED'), '$VAR'('ARG1'), '$VAR'('ARG2')), admittedArgument('$VAR'('ARG2'), 1, '$VAR'('PRED')), admittedArgument('$VAR'('ARG2'), 2, '$VAR'('PRED'))), 'BaseKB', vStrDef).
assertedTinyKB(not, and(isa('$VAR'('OBJ'), '$VAR'('COL1')), isa('$VAR'('OBJ'), '$VAR'('COL2')), genls('$VAR'('COL2'), '$VAR'('COL3')), disjointWith('$VAR'('COL1'), '$VAR'('COL3'))), 'BaseKB', vStrDef).
assertedTinyKB(not, and(isa('$VAR'('OBJ'), '$VAR'('COL1')), isa('$VAR'('OBJ'), '$VAR'('COL2')), disjointWith('$VAR'('COL1'), '$VAR'('COL2'))), 'BaseKB', vStrMon).
assertedTinyKB(not, and(isa('$VAR'('INST_1'), '$VAR'('COL1')), isa('$VAR'('INST_2A'), '$VAR'('COL2')), different('$VAR'('INST_2A'), '$VAR'('INST_2B')), isa('$VAR'('INST_2B'), '$VAR'('COL2')), holds('$VAR'('PRED'), '$VAR'('INST_1'), '$VAR'('INST_2B')), holds('$VAR'('PRED'), '$VAR'('INST_1'), '$VAR'('INST_2A')), relationAllExistsMax('$VAR'('PRED'), '$VAR'('COL1'), '$VAR'('COL2'), 1)), 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(not, and(isa('$VAR'('INST1'), '$VAR'('TYPE1')), isa('$VAR'('INST2'), '$VAR'('TYPE2')), holds('$VAR'('PRED'), '$VAR'('INST1'), '$VAR'('INST2')), relationAllExistsCount('$VAR'('PRED'), '$VAR'('TYPE1'), '$VAR'('TYPE2'), 0)), 'BaseKB', vStrDef).
assertedTinyKB(not, and(holdsIn('$VAR'('TIME'), '$VAR'('PROP')), holdsIn('$VAR'('TIME'), not('$VAR'('PROP')))), 'BaseKB', vStrDef).
assertedTinyKB(not, and(greaterThan('$VAR'('INTERVAL1'), '$VAR'('INTERVAL2')), quantityIntersects('$VAR'('INTERVAL1'), '$VAR'('INTERVAL2'))), 'BaseKB', vStrDef).
assertedTinyKB(not, and(genlPreds('$VAR'('SPEC'), '$VAR'('GENL')), arity('$VAR'('SPEC'), '$VAR'('SPEC_ARITY')), different('$VAR'('GENL_ARITY'), '$VAR'('SPEC_ARITY')), arity('$VAR'('GENL'), '$VAR'('GENL_ARITY'))), 'BaseKB', vStrMon).
assertedTinyKB(not, and(disjointWith('$VAR'('COL1'), '$VAR'('COL2')), trueSentence(thereExists('$VAR'('THING'), and(isa('$VAR'('THING'), '$VAR'('COL1')), isa('$VAR'('THING'), '$VAR'('COL2')))))), 'BaseKB', vStrMon).
assertedTinyKB(not, and(disjointWith('$VAR'('ARGTYPE1'), '$VAR'('ARGTYPE2')), argIsa('$VAR'('PRED'), '$VAR'('ARGNUM'), '$VAR'('ARGTYPE1')), argIsa('$VAR'('PRED'), '$VAR'('ARGNUM'), '$VAR'('ARGTYPE2'))), 'BaseKB', vStrMon).
assertedTinyKB(not, and(differentSymbols('$VAR'('A'), '$VAR'('B')), equalSymbols('$VAR'('A'), '$VAR'('B'))), 'BaseKB', vStrMon).
assertedTinyKB(not, and(different('$VAR'('THING1'), '$VAR'('THING2')), equals('$VAR'('THING1'), '$VAR'('THING2'))), 'BaseKB', vStrDef).
assertedTinyKB(not, and(backchainForbiddenWhenUnboundInArg('$VAR'('PRED'), '$VAR'('N')), arity('$VAR'('PRED'), '$VAR'('M')), greaterThan('$VAR'('N'), '$VAR'('M'))), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(not, and(arity('$VAR'('REL'), 5), different('$VAR'('J'), '$VAR'('K'), '$VAR'('L'), '$VAR'('M'), '$VAR'('N')), commutativeInArgsAndRest('$VAR'('REL'), '$VAR'('J'), '$VAR'('K'), '$VAR'('L'), '$VAR'('M'), '$VAR'('N'))), 'BaseKB', vStrDef).
assertedTinyKB(not, and(arity('$VAR'('REL'), 4), different('$VAR'('K'), '$VAR'('L'), '$VAR'('M'), '$VAR'('N')), commutativeInArgsAndRest('$VAR'('REL'), '$VAR'('K'), '$VAR'('L'), '$VAR'('M'), '$VAR'('N'))), 'BaseKB', vStrDef).
assertedTinyKB(not, and(arity('$VAR'('REL'), 3), different('$VAR'('L'), '$VAR'('M'), '$VAR'('N')), commutativeInArgsAndRest('$VAR'('REL'), '$VAR'('L'), '$VAR'('M'), '$VAR'('N'))), 'BaseKB', vStrDef).
assertedTinyKB(not, and(arity('$VAR'('REL'), 2), different('$VAR'('M'), '$VAR'('N')), commutativeInArgsAndRest('$VAR'('REL'), '$VAR'('M'), '$VAR'('N'))), 'BaseKB', vStrDef).
assertedTinyKB(not, and(arity('$VAR'('REL'), 1), commutativeInArgsAndRest('$VAR'('REL'), '$VAR'('M'), '$VAR'('N'))), 'BaseKB', vStrDef).
assertedTinyKB(not, and(arity('$VAR'('REL'), 1), commutativeInArgs('$VAR'('REL'), '$VAR'('M'), '$VAR'('N'))), 'BaseKB', vStrDef).
assertedTinyKB(not, and(arg2Isa('$VAR'('PRED'), '$VAR'('COL1')), disjointWith('$VAR'('COL1'), '$VAR'('COL2')), isa('$VAR'('INST'), '$VAR'('COL2')), holds('$VAR'('PRED'), '$VAR'('_X'), '$VAR'('INST'))), 'BaseKB', vStrMon).
assertedTinyKB(not, and(arg2Isa('$VAR'('PRED'), '$VAR'('ARG2ISA')), disjointWith('$VAR'('ARG2ISA'), '$VAR'('ARG2TYPE')), relationExistsAll('$VAR'('PRED'), '$VAR'('ARG1TYPE'), '$VAR'('ARG2TYPE'))), 'BaseKB', vStrMon).
assertedTinyKB(not, and(arg2Isa('$VAR'('PRED'), '$VAR'('ARG2ISA')), disjointWith('$VAR'('ARG2ISA'), '$VAR'('ARG2TYPE')), relationAllExists('$VAR'('PRED'), '$VAR'('ARG1TYPE'), '$VAR'('ARG2TYPE'))), 'BaseKB', vStrMon).
assertedTinyKB(not, and(arg2Genl('$VAR'('PRED'), '$VAR'('ARG2TYPE')), disjointWith('$VAR'('ARG2TYPE'), '$VAR'('GROUPMEMBERTYPE')), relationAllInstance('$VAR'('PRED'), '$VAR'('GROUPTYPE'), '$VAR'('GROUPMEMBERTYPE'))), 'BaseKB', vStrMon).
assertedTinyKB(not, and(arg1Isa('$VAR'('PRED'), '$VAR'('ARG1ISA')), disjointWith('$VAR'('ARG1ISA'), '$VAR'('ARG1TYPE')), relationAllExists('$VAR'('PRED'), '$VAR'('ARG1TYPE'), '$VAR'('ARG2TYPE'))), 'BaseKB', vStrMon).
assertedTinyKB(negationPreds, unknownSentence, trueSentence, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(negationPreds, unknownSentence, knownSentence, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(negationPreds, unknownSentence, knownSentence, 'BaseKB', vStrMon).
assertedTinyKB(negationPreds, highlyRelevantPredAssertion, irrelevantPredAssertion, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(negationPreds, highlyRelevantMt, irrelevantMt, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(negationPreds, highlyRelevantAssertion, irrelevantAssertion, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(negationPreds, conceptuallyRelated, genls, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(negationInverse, nearestGenlPreds, nearestGenlPreds, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(negationInverse, nearestGenlMt, nearestGenlMt, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(negationInverse, means, means, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(negationInverse, greaterThan, greaterThan, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(negationInverse, followingValue, followingValue, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(negationInverse, elInverse, elInverse, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(negationInverse, denotes, denotes, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(negationInverse, conceptuallyRelated, isa, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(negationInverse, conceptuallyRelated, genls, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(multiplicationUnits, 'Unity', '$VAR'('UNIT'), '$VAR'('UNIT'), 'BaseKB', vStrMon).
assertedTinyKB(minimizeExtent, termOfUnit, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(minimizeExtent, natFunction, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(minimizeExtent, isa, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(minimizeExtent, genls, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(minimizeExtent, genlPreds, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(minimizeExtent, genlMt, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(minimizeExtent, equals, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(minimizeExtent, abnormal, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(minimize, disjointWith('$VAR'('COL'), '$VAR'('COL')), 'BaseKB', vStrDef).
assertedTinyKB(microtheoryDesignationArgnum, ist, 1, 'BaseKB', vStrDef).
assertedTinyKB(microtheoryDesignationArgnum, 'TLAssertionFn', 1, 'BaseKB', vStrDef).
assertedTinyKB(microtheoryDesignationArgnum, 'ist-Asserted', 1, 'BaseKB', vStrDef).
assertedTinyKB(isa, xor, 'LogicalConnective', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, xor, 'ELRelation-OneWay', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, xor, 'CommutativeRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, xor, 'BinaryRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, xor, 'AssociativeRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, unknownSentence, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, unitMultiplicationFactor, 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, trueSubL, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, trueSubL, 'EvaluatablePredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, trueSubL, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, trueSentence, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, trueRule, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, transitiveViaArgInverse, 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, transitiveViaArgInverse, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, transitiveViaArg, 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, transitiveViaArg, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, thereExists, 'Quantifier', 'LogicalTruthMt', vStrDef).
assertedTinyKB(isa, thereExists, 'ExistentialQuantifier', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, thereExists, 'BinaryRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, thereExistExactly, 'ExistentialQuantifier-Bounded', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, thereExistAtMost, 'ExistentialQuantifier-Bounded', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, thereExistAtLeast, 'ExistentialQuantifier-Bounded', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, termOfUnit, 'ReformulatorIrrelevantFORT', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, termOfUnit, tPred, 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(isa, termOfUnit, 'InferenceRelatedBookkeepingPredicate', 'BaseKB', vStrDef).
assertedTinyKB(isa, termOfUnit, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, termOfUnit, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, termExternalIDString, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, termDependsOn, 'InferenceRelatedBookkeepingPredicate', 'BaseKB', vStrDef).
assertedTinyKB(isa, termDependsOn, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, termChosen, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, termChosen, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, synonymousExternalConcept, 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, substring, 'TransitiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, substring, 'ReflexiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, substring, 'EvaluatablePredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, substring, 'AntiSymmetricBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, subsetOf, 'TransitiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, subsetOf, 'ReflexiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, skolemizeForward, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, skolem, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, skolem, 'InferenceRelatedBookkeepingPredicate', 'BaseKB', vStrDef).
assertedTinyKB(isa, singleEntryFormatInArgs, 'WFFSupportedPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, singleEntryFormatInArgs, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, singleEntryFormatInArgs, 'ArgConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, siblingDisjointExceptions, 'SymmetricBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, siblingDisjointExceptions, 'IrreflexiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, sharedNotes, 'DocumentationPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, sharedNotes, 'DistributingMetaKnowledgePredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, sharedNotes, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, sentenceTruth, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, sentenceImplies, 'TransitiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, sentenceImplies, 'ReflexiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, sentenceEquiv, 'TransitiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, sentenceEquiv, 'SymmetricBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, sentenceEquiv, 'ReflexiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, sentenceEquiv, 'AssociativeRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, sentenceDesignationArgnum, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, scopingArg, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, salientAssertions, 'DocumentationPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, salientAssertions, 'DistributingMetaKnowledgePredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, salientAssertions, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, ruleTemplateDirection, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, ruleTemplateDirection, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, ruleAfterRemoving, tPred, 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(isa, ruleAfterRemoving, 'InferenceRelatedBookkeepingPredicate', 'BaseKB', vStrDef).
assertedTinyKB(isa, ruleAfterRemoving, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, ruleAfterAdding, tPred, 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(isa, ruleAfterAdding, 'InferenceRelatedBookkeepingPredicate', 'BaseKB', vStrDef).
assertedTinyKB(isa, ruleAfterAdding, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, rewriteOf, 'TransitiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, rewriteOf, 'ReformulatorDirectivePredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, rewriteOf, 'IrreflexiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, rewriteOf, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, rewriteOf, 'CycLReformulationRulePredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, resultQuotedIsa, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, resultQuotedIsa, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, resultIsaArgIsa, 'WFFSupportedPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, resultIsaArgIsa, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, resultIsaArgIsa, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, resultIsaArg, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, resultIsaArg, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, resultIsa, 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, resultIsa, tPred, 'LogicalTruthMt', vStrDef).
assertedTinyKB(isa, resultIsa, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, resultIsa, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, resultGenlArg, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, resultGenlArg, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, resultGenl, 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, resultGenl, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, resultGenl, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, requiredArg3Pred, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, requiredArg2Pred, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, requiredArg1Pred, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, relationMemberInstance, 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, relationInstanceMember, 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, relationInstanceExists, 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, relationInstanceAll, 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, relationExpansion, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, relationExistsMinAll, 'QuaternaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, relationExistsMaxAll, 'QuaternaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, relationExistsInstance, 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, relationExistsCountAll, 'QuaternaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, relationExistsAll, 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, relationAllInstance, 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, relationAllExistsMin, 'QuaternaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, relationAllExistsMax, 'QuaternaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, relationAllExistsCount, 'QuaternaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, relationAllExists, 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, relationAll, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, reformulatorRuleProperties, 'ReformulatorDirectivePredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, reformulatorRuleProperties, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, reformulatorRule, 'ReformulatorDirectivePredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, reformulatorRule, 'IrreflexiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, reformulatorRule, 'CycLReformulationRulePredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, reformulatorEquiv, 'ReformulatorDirectivePredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, reformulatorEquiv, 'IrreflexiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, reformulatorEquiv, 'CycLReformulationRulePredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, reformulatorEquals, 'ReformulatorDirectivePredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, reformulatorEquals, 'IrreflexiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, reformulatorEquals, 'CycLReformulationRulePredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, reformulationPrecondition, 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, reformulationPrecondition, 'ReformulatorDirectivePredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, reformulationDirectionInMode, 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, reformulationDirectionInMode, 'ReformulatorDirectivePredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, ratioOfTo, 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, quotedIsa, 'WFFConstraintSatisfactionPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, quotedIsa, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, quotedIsa, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, quotedDefnSufficient, 'WFFConstraintSatisfactionPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, quotedDefnSufficient, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, quotedDefnNecessary, 'WFFConstraintSatisfactionPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, quotedDefnNecessary, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, quotedDefnIff, 'WFFConstraintSatisfactionPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, quotedDefnIff, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, quotedArgument, 'WFFSupportedPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, quotedArgument, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, querySentence, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, quantitySubsumes, 'TransitiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, quantitySubsumes, 'ReflexiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, quantitySubsumes, 'EvaluatablePredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, quantitySubsumes, 'AntiSymmetricBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, quantityIntersects, 'SymmetricBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, quantityIntersects, 'ReflexiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, quantityIntersects, 'EvaluatablePredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, prettyString, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, preservesGenlsInArg, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, predicateConventionMt, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, predicateConventionMt, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, pragmaticRequirement, 'WFFSupportedPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, pragmaticRequirement, 'ExceptionPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, pragmaticRequirement, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, pragmaticRequirement, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, pragmaticallyNormal, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, pragmaticallyNormal, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, pointQuantValue, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, performSubL, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, performSubL, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, overlappingExternalConcept, 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, or, 'VariableArityRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, or, 'VariableArityRelation', 'LogicalTruthMt', vStrDef).
assertedTinyKB(isa, or, 'LogicalConnective', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, or, 'LogicalConnective', 'LogicalTruthMt', vStrDef).
assertedTinyKB(isa, or, 'CommutativeRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, or, 'AssociativeRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, operatorFormulas, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, openEntryFormatInArgs, 'WFFSupportedPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, openEntryFormatInArgs, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, openEntryFormatInArgs, 'ArgConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, opaqueArgument, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, omitArgIsa, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, oldConstantName, 'DocumentationPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, oldConstantName, 'BookkeepingPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, oldConstantName, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, numericallyEquals, 'TransitiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, numericallyEquals, 'SymmetricBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, numericallyEquals, 'ReflexiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, numericallyEquals, 'EvaluatablePredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, nthSmallestElement, 'QuaternaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, nthLargestElement, 'QuaternaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, notAssertibleMt, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, notAssertibleMt, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, notAssertibleCollection, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, notAssertibleCollection, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, notAssertible, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, notAssertible, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, not, 'UnaryRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, not, 'LogicalConnective', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, not, 'LogicalConnective', 'LogicalTruthMt', vStrDef).
assertedTinyKB(isa, not, 'FixedArityRelation', 'LogicalTruthMt', vStrDef).
assertedTinyKB(isa, nonAbducibleWithValueInArg, 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, negationPreds, 'WFFConstraintSatisfactionPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, negationPreds, 'SymmetricBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, negationPreds, 'IrreflexiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, negationPreds, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, negationMt, 'SymmetricBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, negationMt, 'IrreflexiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, negationInverse, 'WFFConstraintSatisfactionPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, negationInverse, 'SymmetricBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, nearestIsa, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, nearestGenls, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, nearestGenlPreds, 'AsymmetricBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, nearestGenlMt, 'AsymmetricBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, nearestDifferentIsa, 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, nearestDifferentGenls, 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, nearestCommonSpecs, 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, nearestCommonIsa, 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, nearestCommonGenls, 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, nearestCommonGenlMt, 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, natFunction, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, natFunction, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, natArgumentsEqual, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, natArgument, 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, natArgument, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, myCreator, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, myCreator, 'BookkeepingPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, myCreator, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, myCreationTime, 'BookkeepingPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, myCreationTime, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, myCreationSecond, 'BookkeepingPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, myCreationSecond, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, myCreationPurpose, 'BookkeepingPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, myCreationPurpose, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, multiplicationUnits, 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, multiplicationUnits, 'PartiallyCommutativeRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, mtVisible, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, mtVisible, 'EvaluatablePredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, minQuantValue, 'ReflexiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, minimizeExtent, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, minimize, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, microtheoryDesignationArgnum, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, meetsPragmaticRequirement, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, meetsPragmaticRequirement, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, means, tPred, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, means, 'AsymmetricBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, means, 'AntiTransitiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, maxQuantValue, 'ReflexiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, knownSentence, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, knownAntecedentRule, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, knownAntecedentRule, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, ist, tPred, 'LogicalTruthMt', vStrDef).
assertedTinyKB(isa, ist, 'MicrotheoryDesignatingRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, ist, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, isa, 'WFFConstraintSatisfactionPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, isa, 'ReformulatorIrrelevantFORT', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, isa, tPred, 'LogicalTruthMt', vStrDef).
assertedTinyKB(isa, isa, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, isa, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, irrelevantTerm, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, irrelevantPredAssertion, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, irrelevantMt, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, irrelevantAssertion, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, interArgResultIsaReln, 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, interArgResultIsaReln, 'QuintaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, interArgResultIsa, 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, interArgResultIsa, 'QuaternaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, interArgResultGenlReln, 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, interArgResultGenlReln, 'QuintaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, interArgResultGenl, 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, interArgResultGenl, 'QuaternaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, interArgIsa, 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, interArgIsa, 'QuintaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, interArgIsa, 'InterArgIsaPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, interArgDifferent, 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, interArgDifferent, 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, interArgDifferent, 'PartiallyCommutativeRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, interArgDifferent, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, interArgDifferent, 'ArgConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, integerBetween, 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, instanceElementType, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, instanceElementType, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, indexicalReferent, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, independentArg, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, implies, 'LogicalConnective', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, implies, 'LogicalConnective', 'LogicalTruthMt', vStrDef).
assertedTinyKB(isa, implies, 'FixedArityRelation', 'LogicalTruthMt', vStrDef).
assertedTinyKB(isa, implies, 'BinaryRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, hypotheticalTerm, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, hypotheticalTerm, 'BookkeepingPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, holdsIn, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, hlPrototypicalInstance, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, highlyRelevantTerm, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, highlyRelevantPredAssertion, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, highlyRelevantMt, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, highlyRelevantAssertion, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, greaterThanOrEqualTo, 'TransitiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, greaterThanOrEqualTo, 'ReflexiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, greaterThanOrEqualTo, 'EvaluatablePredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, greaterThanOrEqualTo, 'AntiSymmetricBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, greaterThan, 'TransitiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, greaterThan, 'EvaluatablePredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, greaterThan, 'AsymmetricBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, genMassNoun, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, genls, 'WFFConstraintSatisfactionPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, genls, 'TransitiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, genls, 'ReformulatorIrrelevantFORT', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, genls, 'ReflexiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, genls, tPred, 'LogicalTruthMt', vStrDef).
assertedTinyKB(isa, genls, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, genlRules, 'TransitiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, genlPreds, 'WFFConstraintSatisfactionPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, genlPreds, 'TransitiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, genlPreds, 'ReflexiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, genlPreds, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, genlMt, 'WFFConstraintSatisfactionPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, genlMt, 'TransitiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, genlMt, 'ReflexiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, genlMt, tPred, 'LogicalTruthMt', vStrDef).
assertedTinyKB(isa, genlMt, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, genlInverse, 'WFFConstraintSatisfactionPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, genlInverse, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, genlInverse, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, genlCanonicalizerDirectives, 'TransitiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, genKeyword, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, genFormat, 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, forwardNonTriggerLiteral, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, formulaArity, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, forAll, 'Quantifier', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, forAll, 'Quantifier', 'LogicalTruthMt', vStrDef).
assertedTinyKB(isa, forAll, 'BinaryRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, followingValue, 'TransitiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, followingValue, 'AsymmetricBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, fanOutArg, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, fanOutArg, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, extentCardinality, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, extConceptOverlapsColAndReln, 'QuaternaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, expresses, tPred, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, expresses, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, expansionDefn, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, expansion, 'ReformulatorDirectivePredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, expansion, 'CycLReformulationRulePredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, expansion, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, exceptWhen, 'ExceptionPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, exceptWhen, 'BinaryRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, exceptMt, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, exceptFor, 'ExceptionPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, exceptFor, 'BinaryRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, except, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, exampleAssertions, 'DocumentationPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, exampleAssertions, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, exactlyAssertedSentence, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, evaluationResultQuotedIsa, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, evaluationResultQuotedIsa, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, evaluationDefn, 'InferenceRelatedBookkeepingPredicate', 'BaseKB', vStrDef).
assertedTinyKB(isa, evaluationDefn, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, evaluationDefn, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, evaluateImmediately, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, evaluateAtEL, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, evaluate, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, equiv, 'LogicalConnective', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, equiv, 'ELRelation-OneWay', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, equiv, 'CommutativeRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, equiv, 'BinaryRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, equiv, 'AssociativeRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, equalSymbols, 'TransitiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, equalSymbols, 'SymmetricBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, equalSymbols, 'ReflexiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, equals, 'TransitiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, equals, 'SymmetricBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, equals, 'ReflexiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, equals, tPred, 'LogicalTruthMt', vStrDef).
assertedTinyKB(isa, equals, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, ephemeralTerm, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, ephemeralTerm, 'BookkeepingPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, elInverse, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, elInverse, 'AsymmetricBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, elInverse, 'AntiTransitiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, elementOf, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, distributesOutOfArg, 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, disjointWith, 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, disjointWith, 'SymmetricBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, disjointWith, tPred, 'LogicalTruthMt', vStrDef).
assertedTinyKB(isa, disjointWith, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, differentSymbols, 'VariableArityRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, differentSymbols, 'EvaluatablePredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, differentSymbols, 'CommutativeRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, different, 'VariableArityRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, different, 'EvaluatablePredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, different, 'CommutativeRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, denotes, tPred, 'LogicalTruthMt', vStrDef).
assertedTinyKB(isa, denotes, 'AsymmetricBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, denotes, 'AntiTransitiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, defnSufficient, 'WFFConstraintSatisfactionPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, defnSufficient, 'InferenceRelatedBookkeepingPredicate', 'BaseKB', vStrDef).
assertedTinyKB(isa, defnSufficient, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, defnNecessary, 'WFFConstraintSatisfactionPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, defnNecessary, 'InferenceRelatedBookkeepingPredicate', 'BaseKB', vStrDef).
assertedTinyKB(isa, defnNecessary, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, defnIff, 'WFFConstraintSatisfactionPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, defnIff, tPred, 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(isa, defnIff, 'InferenceRelatedBookkeepingPredicate', 'BaseKB', vStrDef).
assertedTinyKB(isa, defnIff, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, definingMt, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, definingMt, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, defaultReformulatorModePrecedence, 'VariableArityRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, defaultReformulatorModePrecedence, 'ReformulatorDirectivePredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, defaultReformulationDirectionInModeForPred, 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, defaultReformulationDirectionInModeForPred, 'ReformulatorDirectivePredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, decontextualizedPredicate, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, decontextualizedPredicate, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, decontextualizedCollection, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, cycTransformationProofRule, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, cycTransformationProofBindings, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, cycTacticID, 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, cycProofID, 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, cycProblemStoreTerms, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, cycProblemStoreProofs, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, cycProblemStoreProofCount, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, cycProblemStoreProblems, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, cycProblemStoreProblemCount, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, cycProblemStoreLinks, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, cycProblemStoreLinkCount, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, cycProblemStoreInferences, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, cycProblemStoreInferenceCount, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, cycProblemStoreID, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, cycProblemQueryTerms, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, cycProblemQuerySentence, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, cycProblemProvabilityStatus, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, cycProblemLinkID, 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, cycProblemID, 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, cycProblemDependentLinks, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, cycProblemArgumentLinks, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, cycInferenceRelevantProblems, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, cycInferenceAnswerLink, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, constraint, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, constrainsArg, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, constrainsArg, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, constantName, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, constantID, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, constantGUID, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, consistent, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, conceptuallyRelated, 'IrreflexiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, completelyEnumerableCollection, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, completelyDecidableCollection, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, completeExtentEnumerableViaBackchain, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, completeExtentEnumerableViaBackchain, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, completeExtentEnumerableForValueInArg, 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, completeExtentEnumerableForArg, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, completeExtentEnumerable, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, completeExtentEnumerable, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, completeExtentDecidableForValueInArg, 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, completeExtentDecidable, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, completeExtentAssertedForValueInArg, 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, completeExtentAsserted, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, commutativeInArgsAndRest, 'VariableArityRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, commutativeInArgsAndRest, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, commutativeInArgsAndRest, 'PartiallyCommutativeRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, commutativeInArgs, 'VariableArityRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, commutativeInArgs, 'PartiallyCommutativeRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, commutativeInArgs, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, comment, 'DocumentationPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, comment, 'DistributingMetaKnowledgePredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, comment, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, comment, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, collectionIsaBackchainRequired, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, collectionIsaBackchainRequired, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, collectionIsaBackchainEncouraged, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, collectionIsaBackchainEncouraged, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, collectionGenlsBackchainRequired, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, collectionGenlsBackchainRequired, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, collectionGenlsBackchainEncouraged, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, collectionGenlsBackchainEncouraged, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, collectionExpansion, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, collectionConventionMt, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, collectionCompletelyEnumerableViaBackchain, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, collectionBackchainRequired, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, collectionBackchainRequired, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, collectionBackchainEncouraged, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, collectionBackchainEncouraged, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, coExtensional, 'TransitiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, coExtensional, 'SymmetricBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, coExtensional, 'ReflexiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, canonicalizerDirectiveForArgAndRest, 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, canonicalizerDirectiveForArg, 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, canonicalizerDirectiveForAllArgs, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, backchainRequired, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, backchainRequired, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, backchainForbiddenWhenUnboundInArg, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, backchainForbidden, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, backchainForbidden, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, assertionUtility, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, assertionDirection, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, assertionDirection, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, assertedTermSentences, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, assertedSentence, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, assertedPredicateArg, 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arityMin, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arityMin, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arityMax, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arityMax, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arity, tPred, 'LogicalTruthMt', vStrDef).
assertedTinyKB(isa, arity, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arity, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, argsQuotedIsa, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, argsQuotedIsa, 'ArgQuotedIsaBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, argSometimesIsa, 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, argSometimesIsa, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, argSometimesIsa, 'ArgTypeTernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, argSometimesIsa, 'ArgSometimesIsaPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, argsIsa, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, argsIsa, 'ArgIsaBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, argsGenl, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, argsGenl, 'ArgGenlBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, argQuotedIsa, 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, argQuotedIsa, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, argQuotedIsa, 'ArgQuotedIsaTernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, argIsa, 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, argIsa, tPred, 'LogicalTruthMt', vStrDef).
assertedTinyKB(isa, argIsa, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, argIsa, 'ArgIsaTernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, argAndRestQuotedIsa, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, argAndRestQuotedIsa, 'ArgQuotedIsaTernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, argAndRestIsa, 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, argAndRestIsa, tPred, 'LogicalTruthMt', vStrDef).
assertedTinyKB(isa, argAndRestIsa, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, argAndRestIsa, 'ArgIsaTernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, argAndRestGenl, 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, argAndRestGenl, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, argAndRestGenl, 'ArgGenlTernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg6SometimesIsa, 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg6SometimesIsa, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg6SometimesIsa, 'ArgTypeBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg6SometimesIsa, 'ArgSometimesIsaPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg6QuotedIsa, 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg6QuotedIsa, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg6QuotedIsa, 'ArgQuotedIsaBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg6Isa, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg6Isa, 'ArgIsaBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg6Genl, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg6Genl, 'ArgGenlBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg6Format, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg6Format, 'ArgConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg5SometimesIsa, 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg5SometimesIsa, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg5SometimesIsa, 'ArgTypeBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg5SometimesIsa, 'ArgSometimesIsaPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg5QuotedIsa, 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg5QuotedIsa, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg5QuotedIsa, 'ArgQuotedIsaBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg5Isa, 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg5Isa, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg5Isa, 'ArgIsaBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg5Genl, 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg5Genl, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg5Genl, 'ArgGenlBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg5Format, 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg5Format, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg5Format, 'ArgConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg4SometimesIsa, 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg4SometimesIsa, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg4SometimesIsa, 'ArgTypeBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg4SometimesIsa, 'ArgSometimesIsaPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg4QuotedIsa, 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg4QuotedIsa, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg4QuotedIsa, 'ArgQuotedIsaBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg4Isa, 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg4Isa, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg4Isa, 'ArgIsaBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg4Genl, 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg4Genl, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg4Genl, 'ArgGenlBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg4Format, 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg4Format, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg4Format, 'ArgConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg3SometimesIsa, 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg3SometimesIsa, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg3SometimesIsa, 'ArgTypeBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg3SometimesIsa, 'ArgSometimesIsaPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg3QuotedIsa, 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg3QuotedIsa, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg3QuotedIsa, 'ArgQuotedIsaBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg3Isa, 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg3Isa, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg3Isa, 'ArgIsaBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg3Genl, 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg3Genl, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg3Genl, 'ArgGenlBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg3Format, 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg3Format, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg3Format, 'ArgConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg2SometimesIsa, 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg2SometimesIsa, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg2SometimesIsa, 'ArgTypeBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg2SometimesIsa, 'ArgSometimesIsaPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg2QuotedIsa, 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg2QuotedIsa, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg2QuotedIsa, 'ArgQuotedIsaBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg2Isa, 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg2Isa, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg2Isa, 'ArgIsaBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg2Genl, 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg2Genl, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg2Genl, 'ArgGenlBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg2Format, 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg2Format, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg2Format, 'ArgConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg1SometimesIsa, 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg1SometimesIsa, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg1SometimesIsa, 'ArgTypeBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg1SometimesIsa, 'ArgSometimesIsaPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg1QuotedIsa, 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg1QuotedIsa, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg1QuotedIsa, 'ArgQuotedIsaBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg1Isa, 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg1Isa, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg1Isa, 'ArgIsaBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg1Genl, 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg1Genl, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg1Genl, 'ArgGenlBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg1Format, 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg1Format, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, arg1Format, 'ArgConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, and, 'VariableArityRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, and, 'VariableArityRelation', 'LogicalTruthMt', vStrDef).
assertedTinyKB(isa, and, 'LogicalConnective', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, and, 'LogicalConnective', 'LogicalTruthMt', vStrDef).
assertedTinyKB(isa, and, 'CommutativeRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, and, 'AssociativeRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, afterRemoving, tPred, 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(isa, afterRemoving, 'InferenceRelatedBookkeepingPredicate', 'BaseKB', vStrDef).
assertedTinyKB(isa, afterRemoving, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, afterAdding, tPred, 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(isa, afterAdding, 'InferenceRelatedBookkeepingPredicate', 'BaseKB', vStrDef).
assertedTinyKB(isa, afterAdding, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, admittedSentence, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, admittedNAT, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, admittedArgument, 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, admittedAllArgument, 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, abnormal, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, abnormal, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'wsl-NonFunctionalParameter', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'wsl-ClassificationRoot', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'WFFSupportedTerm', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'WFFSupportedPredicate', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'WFFDirectivePredicate', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'WFFConstraintSatisfactionPredicate', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'WFFConstraintPredicate', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'Wednesday', 'DayOfWeekType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'VariableAritySkolemFunction', tCol, 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(isa, 'VariableAritySkolemFunction', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'VariableAritySkolemFuncN', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'VariableAritySkolemFuncN', tCol, 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(isa, 'VariableArityRelation', tCol, 'LogicalTruthMt', vStrDef).
assertedTinyKB(isa, 'VariableArityRelation', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'UnreifiableFunction', tCol, 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(isa, 'UnreifiableFunction', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'Unknown-HLTruthValue', 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'Unknown-HLTruthValue', 'CycHLTruthValue', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'UniversalVocabularyMt', 'BroadMicrotheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'UniversalVocabularyImplementationMt', 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'Unity', 'UnitOfMeasure', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'UnitProductFn', 'ReifiableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'UnitProductFn', 'CommutativeRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'UnitProductFn', 'BinaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'UnitProductFn', 'AssociativeRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'UnitOfMeasure', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'UnitOfMeasure', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'UncanonicalizerAssertionFn', 'UnreifiableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'UncanonicalizerAssertionFn', 'UnaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'UnaryRelation', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'UnaryRelation', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'UnaryPredicate', 'PredicateTypeByArity', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'UnaryPredicate', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'UnaryPredicate', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'UnaryFunction', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'UnaryFunction', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'Tuesday', 'DayOfWeekType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'TruthValue', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'TruthValue', tCol, 'LogicalTruthMt', vStrDef).
assertedTinyKB(isa, 'TruthFunction', tCol, 'LogicalTruthMt', vStrDef).
assertedTinyKB(isa, 'TruthFunction', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'True', 'TruthValue', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'True', 'TruthValue', 'LogicalTruthMt', vStrDef).
assertedTinyKB(isa, 'TransitiveBinaryPredicate', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'TransitiveBinaryPredicate', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'TransformationModuleSupportedPredicate', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'TransformationModuleSupportedPredicate', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'TransformationModuleSupportedCollection', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'TransformationModuleSupportedCollection', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'TLVariableFn', 'UnreifiableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'TLVariableFn', 'ELRelation-OneWay', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'TLVariableFn', 'BinaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'TLReifiedNatFn', 'UnaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'TLReifiedNatFn', 'ELRelation-OneWay', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'TLAssertionFn', 'UnreifiableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'TLAssertionFn', 'MicrotheoryDesignatingRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'TLAssertionFn', 'ELRelation-OneWay', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'TLAssertionFn', 'BinaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'TimesFn', 'VariableArityRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'TimesFn', 'EvaluatableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'TimesFn', 'CommutativeRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'TimesFn', 'AssociativeRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'Thursday', 'DayOfWeekType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'Thing', tCol, 'LogicalTruthMt', vStrDef).
assertedTinyKB(isa, 'Thing', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'TheUser', 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'TheUser', 'HumanCyclist', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'TheUser', 'Cyclist', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'TheTerm', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'TheTerm', tCol, 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(isa, 'TheTerm', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'TheSetOf', 'UnreifiableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'TheSetOf', 'ScopingRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'TheSetOf', 'BinaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'TheSet', 'VariableArityRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'TheSet', 'UnreifiableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'TheSet', 'CommutativeRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'ThePrototypicalTransitiveBinaryPredicate', 'TransitiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'ThePrototypicalCollection', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'ThePrototypicalBinaryPredicate', 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'TheList', 'VariableArityRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'TheList', 'UnreifiableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'TheEmptySet', 'Set-Mathematical', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'TheEmptyList', 'List', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'TheCollectionOf', 'ScopingRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'TheCollectionOf', 'ReifiableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'TheCollectionOf', 'ReifiableFunction', 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'TheCollectionOf', 'CollectionDenotingFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'TheCollectionOf', 'CollectionDenotingFunction', 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'TheCollectionOf', 'BinaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'TheCollectionOf', 'BinaryFunction', 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'TernaryRelation', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'TernaryRelation', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'TernaryPredicate', 'PredicateTypeByArity', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'TernaryPredicate', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'TernaryPredicate', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'TernaryFunction', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'TernaryFunction', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'TemporaryEnglishParaphraseMt', 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'TemporaryEnglishParaphraseMt', 'CycLTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'SymmetricBinaryPredicate', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'SymmetricBinaryPredicate', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'Sunday', 'DayOfWeekType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'substring-CaseInsensitive', 'TransitiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'substring-CaseInsensitive', 'ReflexiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'substring-CaseInsensitive', 'EvaluatablePredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'substring-CaseInsensitive', 'AntiSymmetricBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'SubLSymbol', 'SubLExpressionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'SubLSymbol', tCol, 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(isa, 'SubLSymbol', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'SubLString', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'SubLString', tCol, 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(isa, 'SubLString', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'SubLSExpression', 'SubLExpressionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'SubLSExpression', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'SubLRealNumber', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'SubLRealNumber', tCol, 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(isa, 'SubLRealNumber', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'SubLQuoteFn', 'UnreifiableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'SubLQuoteFn', 'UnaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'SubLPositiveInteger', 'SubLExpressionType', 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(isa, 'SubLPositiveInteger', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'SubLPositiveInteger', tCol, 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(isa, 'SubLPositiveInteger', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'SubLNonVariableSymbol', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'SubLNonVariableSymbol', tCol, 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(isa, 'SubLNonVariableSymbol', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'SubLNonVariableNonKeywordSymbol', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'SubLNonVariableNonKeywordSymbol', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'SubLNonNegativeInteger', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'SubLNonNegativeInteger', tCol, 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(isa, 'SubLNonNegativeInteger', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'SubLList', 'SubLExpressionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'SubLList', tCol, 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(isa, 'SubLList', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'SubLKeyword', 'SubLExpressionType', 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(isa, 'SubLKeyword', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'SubLKeyword', tCol, 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(isa, 'SubLKeyword', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'SubLInteger', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'SubLInteger', tCol, 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(isa, 'SubLInteger', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'SubLExpressionType', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'SubLCharacter', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'SubLCharacter', tCol, 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(isa, 'SubLCharacter', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'SubLAtomicTerm', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'SubLAtomicTerm', tCol, 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(isa, 'SubLAtomicTerm', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'SubLAtom', 'SubLExpressionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'SubLAtom', tCol, 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(isa, 'SubLAtom', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'SkolemFunctionFn', 'TernaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'SkolemFunctionFn', 'ReifiableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'SkolemFunctionFn', 'ReformulatorIrrelevantFORT', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'SkolemFunction', tCol, 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(isa, 'SkolemFunction', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'SkolemFuncNFn', 'QuaternaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'SkolemFuncN', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'SkolemFuncN', tCol, 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(isa, 'SingleEntry', 'WFFSupportedTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'SingleEntry', 'Format', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'SiblingDisjointCollectionType', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'SiblingDisjointCollectionType', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'SiblingDisjointAttributeType', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'SiblingDisjointAttributeType', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'SetTheFormat', 'WFFSupportedTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'SetTheFormat', 'Format', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'SetOrCollection', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'SetOrCollection', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'Set-Mathematical', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'Set-Mathematical', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'September', 'MonthOfYearType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'September', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'SententialRelation', tCol, 'LogicalTruthMt', vStrDef).
assertedTinyKB(isa, 'SententialRelation', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'ScopingRelation', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'ScopingRelation', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'ScalarPointValue', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'ScalarPointValue', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'ScalarInterval', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'ScalarInterval', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'ScalarIntegralValue', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'Saturday', 'DayOfWeekType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'RuleTemplate', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'RuleTemplate', tCol, 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(isa, 'RoundUpFn', 'UnaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'RoundUpFn', 'EvaluatableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'RoundDownFn', 'UnaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'RoundDownFn', 'EvaluatableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'RoundClosestFn', 'UnaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'RoundClosestFn', 'EvaluatableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'RemovalModuleSupportedPredicate-Specific', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'RemovalModuleSupportedPredicate-Specific', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'RemovalModuleSupportedPredicate-Generic', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'RemovalModuleSupportedPredicate-Generic', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'RemovalModuleSupportedCollection-Generic', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'RemovalModuleSupportedCollection-Generic', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'RelaxArgTypeConstraintsForVariables', 'WFFDirectivePredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'RelaxArgTypeConstraintsForVariables', 'CanonicalizerDirective', 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(isa, 'RelationInstanceExistsFn', 'UnreifiableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'RelationInstanceExistsFn', 'TernaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'RelationInstanceExistsFn', 'IndeterminateTermDenotingFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'RelationExistsInstanceFn', 'UnreifiableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'RelationExistsInstanceFn', 'TernaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'RelationExistsInstanceFn', 'IndeterminateTermDenotingFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'RelationExistsAllFn', 'UnreifiableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'RelationExistsAllFn', 'QuaternaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'RelationExistsAllFn', 'IndeterminateTermDenotingFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'RelationAllExistsFn', 'UnreifiableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'RelationAllExistsFn', 'QuaternaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'RelationAllExistsFn', 'IndeterminateTermDenotingFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, tRelation, tCol, 'LogicalTruthMt', vStrDef).
assertedTinyKB(isa, tRelation, 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'ReifiableFunction', tCol, 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(isa, 'ReifiableFunction', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'ReformulatorIrrelevantFORT', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'ReformulatorIrrelevantFORT', tCol, 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(isa, 'ReformulatorHighlyRelevantFORT', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'ReformulatorHighlyRelevantFORT', tCol, 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(isa, 'ReformulatorDirectivePredicate', tCol, 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(isa, 'ReformulatorDirectivePredicate', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'ReformulationNeitherDirection', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'ReformulationForwardDirection', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'ReformulationBackwardDirection', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'ReflexiveBinaryPredicate', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'ReflexiveBinaryPredicate', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'RealNumber', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'QuotientFn', 'EvaluatableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'QuotientFn', 'BinaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'Quote', 'WFFSupportedTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'Quote', 'UnreifiableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'Quote', 'UnreifiableFunction', 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(isa, 'Quote', 'UnaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'QuintaryRelation', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'QuintaryRelation', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'QuintaryPredicate', 'PredicateTypeByArity', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'QuintaryPredicate', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'QuintaryPredicate', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'QuintaryFunction', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'QuintaryFunction', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'QueryMt', 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'QuaternaryRelation', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'QuaternaryRelation', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'QuaternaryPredicate', 'PredicateTypeByArity', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'QuaternaryPredicate', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'QuaternaryPredicate', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'QuaternaryFunction', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'QuaternaryFunction', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'QuasiQuote', 'WFFSupportedTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'QuasiQuote', 'UnreifiableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'QuasiQuote', 'UnaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'QuasiQuote', tFunction, 'LogicalTruthMt', vStrDef).
assertedTinyKB(isa, 'QuantityConversionFn', 'EvaluatableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'QuantityConversionFn', 'BinaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'Quantifier', tCol, 'LogicalTruthMt', vStrDef).
assertedTinyKB(isa, 'Quantifier', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'ProblemSolvingCntxt', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'ProblemSolvingCntxt', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'prettyString-Canonical', 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'PredicateTypeByArity', 'DisjointCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, tPred, tCol, 'LogicalTruthMt', vStrDef).
assertedTinyKB(isa, tPred, 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'PositiveInteger', tCol, 'LogicalTruthMt', vStrDef).
assertedTinyKB(isa, 'PositiveInteger', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'PlusFn', 'VariableArityRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'PlusFn', 'EvaluatableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'PlusFn', 'CommutativeRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'PlusFn', 'AssociativeRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'PlusAll', 'EvaluatableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'PlusAll', 'BinaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'PerFn', 'ReifiableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'PerFn', 'BinaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'Percent', 'VariableArityRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'Percent', 'EvaluatableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'PartiallyCommutativeRelation', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'PartiallyCommutativeRelation', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'Open-InferenceProblemLinkStatus', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'October', 'MonthOfYearType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'October', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'November', 'MonthOfYearType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'November', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'NonNegativeScalarInterval', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'NonNegativeScalarInterval', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'NonNegativeInteger', tCol, 'LogicalTruthMt', vStrDef).
assertedTinyKB(isa, 'NonNegativeInteger', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'NoGood-ProblemProvabilityStatus', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'Neutral-ProblemProvabilityStatus', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'NART'(['CollectionRuleTemplateFn', 'HypotheticalContext']), 'RuleTemplate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'NART'(['CollectionRuleTemplateFn', 'HypotheticalContext']), 'RuleTemplate', 'BaseKB', vStrDef).
assertedTinyKB(isa, 'NART'(['CollectionRuleTemplateFn', 'HypotheticalContext']), 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'NART'(['CollectionRuleTemplateFn', 'ArgIsaPredicate']), 'RuleTemplate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'NART'(['CollectionRuleTemplateFn', 'ArgIsaPredicate']), 'RuleTemplate', 'BaseKB', vStrDef).
assertedTinyKB(isa, 'NART'(['CollectionRuleTemplateFn', 'ArgIsaPredicate']), 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'Multigraph', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'Multigraph', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'MtUnionFn', 'VariableArityRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'MtUnionFn', 'UnreifiableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'MtUnionFn', 'CommutativeRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'MtUnionFn', 'AssociativeRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'MtTimeWithGranularityDimFn', 'UnreifiableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'MtTimeWithGranularityDimFn', 'BinaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'MtTimeDimFn', 'UnreifiableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'MtTimeDimFn', 'UnaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'MtSpace', 'VariableArityRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'MtSpace', 'UnreifiableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'MtSpace', 'CommutativeRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'MonthOfYearType', 'SiblingDisjointCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'MonthOfYearType', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'MonthOfYearType', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'MonotonicallyTrue', 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'MonotonicallyTrue', 'CycHLTruthValue', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'MonotonicallyFalse', 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'MonotonicallyFalse', 'CycHLTruthValue', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'Monday', 'DayOfWeekType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'ModuloFn', 'EvaluatableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'ModuloFn', 'BinaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'MinRangeFn', 'VariableArityRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'MinRangeFn', 'EvaluatableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'MinRangeFn', 'CommutativeRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'MinRangeFn', 'AssociativeRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'Minimum', 'EvaluatableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'Minimum', 'BinaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'MicrotheoryDesignatingRelation', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'MicrotheoryDesignatingRelation', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'Microtheory', tCol, 'LogicalTruthMt', vStrDef).
assertedTinyKB(isa, 'Microtheory', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'MeaningInSystemFn', 'ReifiableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'MeaningInSystemFn', 'BinaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'May', 'MonthOfYearType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'May', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'MaxRangeFn', 'VariableArityRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'MaxRangeFn', 'EvaluatableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'MaxRangeFn', 'CommutativeRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'Maximum', 'EvaluatableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'Maximum', 'BinaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'March', 'MonthOfYearType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'March', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'LogicalTruthMt', 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'LogicalTruthMt', 'Microtheory', 'LogicalTruthMt', vStrDef).
assertedTinyKB(isa, 'LogicalTruthImplementationMt', 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'LogicalTruthImplementationMt', 'Microtheory', 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(isa, 'LogicalConnective', tCol, 'LogicalTruthMt', vStrDef).
assertedTinyKB(isa, 'LogicalConnective', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'LogFn', 'UnaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'LogFn', 'EvaluatableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'List', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'List', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'LeaveVariablesAtEL', 'CanonicalizerDirective', 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(isa, 'LeaveSomeTermsAtELAndAllowKeywordVariables', 'CanonicalizerDirective', 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(isa, 'LeaveSomeTermsAtEL', 'CanonicalizerDirective', 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(isa, 'larkc-VariableBinding', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'larkc-TriplePatternQuery', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'larkc-SPARQLQuery', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'larkc-SetOfStatements', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'larkc-Selecter', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'larkc-Scalability', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'larkc-Resource', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'larkc-Reasoner', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'larkc-RdfGraph', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'larkc-QueryTransformer', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'larkc-Query', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'larkc-pluginByDataConnectsTo', 'TransitiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'larkc-Plugin', 'wsl-ClassificationRoot', 'BaseKB', vStrDef).
assertedTinyKB(isa, 'larkc-Plugin', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'larkc-NaturalLanguageDocument', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'larkc-LabelledGroupOfStatements', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'larkc-KeywordQuery', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'larkc-InformationSetTransformer', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'larkc-InformationSet', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'larkc-Identifier', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'larkc-hasUri', 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'larkc-hasScalability', 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'larkc-hasOutputType', 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'larkc-hasInputType', 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'larkc-hasEndpoint', 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'larkc-hasCostPerInvocation', 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'larkc-GateTransformer', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'larkc-euro', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'larkc-Decider', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'larkc-DataSet', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'larkc-CycSelecter', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'larkc-CycReasoner', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'larkc-CycGateDecider', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'larkc-Cost', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'larkc-BooleanInformationSet', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'larkc-ArticleIdentifier', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'KnowledgeBase', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'KnowledgeBase', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'Kappa', 'UnreifiableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'Kappa', 'ScopingRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'Kappa', 'BinaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'June', 'MonthOfYearType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'June', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'July', 'MonthOfYearType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'July', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'January', 'MonthOfYearType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'January', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'ist-Asserted', 'MicrotheoryDesignatingRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'ist-Asserted', 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'IrreflexiveBinaryPredicate', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'IrreflexiveBinaryPredicate', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'IntervalMinFn', 'UnreifiableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'IntervalMinFn', 'UnaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'IntervalMaxFn', 'UnreifiableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'IntervalMaxFn', 'UnaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'IntervalEntry', 'Format', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'InterArgIsaPredicate', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'InterArgIsaPredicate', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa5-4', 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa5-4', 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa5-4', 'InterArgIsaPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa5-3', 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa5-3', 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa5-3', 'InterArgIsaPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa5-2', 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa5-2', 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa5-2', 'InterArgIsaPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa5-1', 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa5-1', 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa5-1', 'InterArgIsaPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa4-5', 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa4-5', 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa4-5', 'InterArgIsaPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa4-3', 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa4-3', 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa4-3', 'InterArgIsaPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa4-2', 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa4-2', 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa4-2', 'InterArgIsaPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa4-1', 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa4-1', 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa4-1', 'InterArgIsaPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa3-5', 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa3-5', 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa3-5', 'InterArgIsaPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa3-4', 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa3-4', 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa3-4', 'InterArgIsaPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa3-2', 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa3-2', 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa3-2', 'InterArgIsaPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa3-1', 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa3-1', 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa3-1', 'InterArgIsaPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa2-5', 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa2-5', 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa2-5', 'InterArgIsaPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa2-4', 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa2-4', 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa2-4', 'InterArgIsaPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa2-3', 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa2-3', 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa2-3', 'InterArgIsaPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa2-1', 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa2-1', 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa2-1', 'InterArgIsaPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa1-5', 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa1-5', 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa1-5', 'InterArgIsaPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa1-4', 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa1-4', 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa1-4', 'InterArgIsaPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa1-3', 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa1-3', 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa1-3', 'InterArgIsaPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa1-2', 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa1-2', 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgIsa1-2', 'InterArgIsaPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgGenl1-2', 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgGenl1-2', 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgGenl1-2', 'ArgTypePredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'InterArgFormatPredicate', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'InterArgFormatPredicate', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgFormat1-2', 'WFFConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'interArgFormat1-2', 'InterArgFormatPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'Integer', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'Integer', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'InferenceSupportedTerm', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'InferenceSupportedTerm', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'InferenceSupportedPredicate', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'InferenceSupportedPredicate', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'InferenceSupportedFunction', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'InferenceSupportedFunction', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'InferenceSupportedCollection', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'InferenceRelatedBookkeepingPredicate', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'InferenceRelatedBookkeepingPredicate', tCol, 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(isa, 'InferencePSC', 'ProblemSolvingCntxt', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'Individual', tCol, 'LogicalTruthMt', vStrDef).
assertedTinyKB(isa, 'Individual', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'IndeterminateTermDenotingFunction', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'IndeterminateTerm', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'HypotheticalContext', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'HypotheticalContext', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'HumanCyclist', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'HumanCyclist', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'HLPrototypicalTerm', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'HLExternalIDString', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'HLAssertedArgumentKeywordDatastructure', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'Guest', 'HumanCyclist', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'Good-ProblemProvabilityStatus', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'genls-SpecDenotesGenlInstances', 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'genls-SpecDenotesGenlInstances', 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'genls-GenlDenotesSpecInstances', 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'genls-GenlDenotesSpecInstances', 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'FunctionToArg', 'UnreifiableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'FunctionToArg', 'BinaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, tFunction, tCol, 'LogicalTruthMt', vStrDef).
assertedTinyKB(isa, tFunction, 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'Friday', 'DayOfWeekType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'Forward-AssertionDirection', 'CycLAssertionDirection', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'FormulaArityFn', 'UnaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'FormulaArityFn', 'EvaluatableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'FormulaArgSetFn', 'UnaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'FormulaArgSetFn', 'EvaluatableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'FormulaArgListFn', 'UnaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'FormulaArgListFn', 'EvaluatableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'FormulaArgFn', 'EvaluatableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'FormulaArgFn', 'BinaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'Format', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'Format', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'FOL-TermFn', 'UnreifiableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'FOL-TermFn', 'UnaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'FOL-PredicateFn', 'UnreifiableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'FOL-PredicateFn', 'BinaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'FOL-FunctionFn', 'UnreifiableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'FOL-FunctionFn', 'BinaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'FixedAritySkolemFunction', tCol, 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(isa, 'FixedAritySkolemFunction', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'FixedAritySkolemFuncN', tCol, 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(isa, 'FixedAritySkolemFuncN', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'FixedArityRelation', tCol, 'LogicalTruthMt', vStrDef).
assertedTinyKB(isa, 'FixedArityRelation', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'February', 'MonthOfYearType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'February', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'False', 'TruthValue', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'False', 'TruthValue', 'LogicalTruthMt', vStrDef).
assertedTinyKB(isa, 'ExpFn', 'UnaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'ExpFn', 'EvaluatableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'ExpandSubLFn', 'UnreifiableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'ExpandSubLFn', tFunction, 'LogicalTruthMt', vStrDef).
assertedTinyKB(isa, 'ExpandSubLFn', 'FixedArityRelation', 'LogicalTruthMt', vStrDef).
assertedTinyKB(isa, 'ExpandSubLFn', 'BinaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'ExistentialQuantifier-Bounded', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'ExistentialQuantifier', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'ExistentialQuantifier', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'ExceptionPredicate', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'ExceptionPredicate', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'EverythingPSC', 'ProblemSolvingCntxt', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'EvaluateSubLFn', 'UnaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'EvaluateSubLFn', 'EvaluatableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'EvaluatableRelation', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'EvaluatableRelation', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'EvaluatablePredicate', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'EvaluatableFunction', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'EvaluatableFunction', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'EscapeQuote', 'WFFSupportedTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'EscapeQuote', 'UnreifiableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'EscapeQuote', 'UnreifiableFunction', 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(isa, 'EscapeQuote', 'UnaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'equalStrings-CaseInsensitive', 'ReflexiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'EnglishParaphraseMt', 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'ELRelation-Reversible', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'ELRelation-OneWay', tCol, 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(isa, 'ELRelation-OneWay', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'ELRelation', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'DontReOrderCommutativeTerms', 'CanonicalizerDirective', 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(isa, 'DocumentationPredicate', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'DocumentationPredicate', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'DocumentationConstant', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'DocumentationConstant', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'DistributingMetaKnowledgePredicate', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'DistributingMetaKnowledgePredicate', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'DisjointCollectionType', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'DirectedMultigraph', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'DirectedMultigraph', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'DifferenceFn', 'EvaluatableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'DifferenceFn', 'BinaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'DefaultTrue', 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'DefaultTrue', 'CycHLTruthValue', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'DefaultMonotonicPredicate', tCol, 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(isa, 'DefaultMonotonicPredicate', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'DefaultFalse', 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'DefaultFalse', 'CycHLTruthValue', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'December', 'MonthOfYearType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'December', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'DayOfWeekType', 'SiblingDisjointCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'DateEncodeStringFn', 'EvaluatableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'DateEncodeStringFn', 'BinaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'DateDecodeStringFn', 'EvaluatableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'DateDecodeStringFn', 'BinaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycTransformationProof', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycTacticFn', 'UnreifiableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycTacticFn', 'BinaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycTactic', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycSupportDatastructure', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycProvabilityStatus', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycProofFn', 'UnreifiableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycProofFn', 'BinaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycProof', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycProblemStoreFn', 'UnreifiableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycProblemStoreFn', 'UnaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycProblemStore', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycProblemLinkFn', 'UnreifiableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycProblemLinkFn', 'BinaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycProblemLink-Union', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycProblemLink-Transformation', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycProblemLink-Structural', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycProblemLink-Split', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycProblemLink-Restriction', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycProblemLink-Removal', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycProblemLink-Logical', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycProblemLink-JoinOrdered', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycProblemLink-Join', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycProblemLink-Disjunctive', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycProblemLink-Content', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycProblemLink-Conjunctive', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycProblemLink-AnswerLink', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycProblemLink', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycProblemFn', 'UnreifiableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycProblemFn', 'BinaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycProblem', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, ftVar, ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, ftVar, tCol, 'LogicalTruthMt', vStrDef).
assertedTinyKB(isa, ftVar, tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, ftVar, 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLTruthValueSentence', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLTruthValueSentence', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'CycLTruthValueSentence', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLTerm', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLTerm', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'CycLTerm', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLSentence-ClosedPredicate', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLSentence-ClosedPredicate', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLSentence-ClosedPredicate', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'CycLSentence-Assertible', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLSentence-Assertible', tCol, 'LogicalTruthMt', vStrDef).
assertedTinyKB(isa, 'CycLSentence-Assertible', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'CycLSentence-Assertible', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLSentence-Askable', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLSentence-Askable', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'CycLSentence-Askable', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLSentence', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLSentence', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'CycLSentence', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLRuleAssertion', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLRuleAssertion', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'CycLRuleAssertion', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLRepresentedTerm', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLRepresentedTerm', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'CycLRepresentedTerm', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLRepresentedAtomicTerm', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLRepresentedAtomicTerm', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'CycLRepresentedAtomicTerm', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLReifiedDenotationalTerm', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLReifiedDenotationalTerm', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'CycLReifiedDenotationalTerm', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLReifiableNonAtomicTerm', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLReifiableNonAtomicTerm', tCol, 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(isa, 'CycLReifiableNonAtomicTerm', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLReifiableDenotationalTerm', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLReifiableDenotationalTerm', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'CycLReifiableDenotationalTerm', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLReformulationRulePredicate', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLReformulationRulePredicate', tCol, 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(isa, 'CycLPropositionalSentence', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLPropositionalSentence', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'CycLPropositionalSentence', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLOpenSentence', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLOpenSentence', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'CycLOpenSentence', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLOpenNonAtomicTerm', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLOpenNonAtomicTerm', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'CycLOpenNonAtomicTerm', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLOpenFormula', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLOpenFormula', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'CycLOpenFormula', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLOpenExpression', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLOpenExpression', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'CycLOpenExpression', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLOpenDenotationalTerm', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLOpenDenotationalTerm', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'CycLOpenDenotationalTerm', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLNonAtomicTerm-ClosedFunctor', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLNonAtomicTerm-ClosedFunctor', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLNonAtomicTerm-ClosedFunctor', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'CycLNonAtomicTerm-Assertible', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLNonAtomicTerm-Assertible', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'CycLNonAtomicTerm-Assertible', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLNonAtomicTerm-Askable', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLNonAtomicTerm-Askable', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'CycLNonAtomicTerm-Askable', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLNonAtomicTerm', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLNonAtomicTerm', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'CycLNonAtomicTerm', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLNonAtomicReifiedTerm', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLNonAtomicReifiedTerm', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'CycLNonAtomicReifiedTerm', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CyclistDefinitionalMt', 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'Cyclist', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'Cyclist', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'CycLIndexedTerm', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLIndexedTerm', tCol, 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(isa, 'CycLIndexedTerm', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLGenericRelationFormula', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLGenericRelationFormula', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'CycLGenericRelationFormula', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLGAFAssertion', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLGAFAssertion', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'CycLGAFAssertion', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLFormulaicSentence', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLFormulaicSentence', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'CycLFormulaicSentence', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLFormula', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLFormula', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'CycLFormula', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, ttFormatType, 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLExpression-Assertible', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLExpression-Assertible', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'CycLExpression-Assertible', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLExpression-Askable', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLExpression-Askable', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'CycLExpression-Askable', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLExpression', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLExpression', tCol, 'LogicalTruthMt', vStrDef).
assertedTinyKB(isa, 'CycLExpression', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLDenotationalTerm-Assertible', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLDenotationalTerm-Assertible', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLDenotationalTerm', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLDenotationalTerm', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'CycLDenotationalTerm', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLDeducedAssertion', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLDeducedAssertion', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'CycLDeducedAssertion', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLConstant', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLConstant', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'CycLConstant', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLClosedSentence', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLClosedSentence', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'CycLClosedSentence', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLClosedNonAtomicTerm', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLClosedNonAtomicTerm', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'CycLClosedNonAtomicTerm', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLClosedFormula', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLClosedFormula', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'CycLClosedFormula', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLClosedExpression', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLClosedExpression', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'CycLClosedExpression', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLClosedDenotationalTerm', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLClosedDenotationalTerm', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'CycLClosedDenotationalTerm', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLClosedAtomicTerm', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLClosedAtomicTerm', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'CycLClosedAtomicTerm', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLClosedAtomicSentence', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLClosedAtomicSentence', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'CycLClosedAtomicSentence', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLAtomicTerm', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLAtomicTerm', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'CycLAtomicTerm', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLAtomicSentence', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLAtomicSentence', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'CycLAtomicSentence', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLAtomicAssertion', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLAtomicAssertion', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'CycLAtomicAssertion', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLAssertionDirection', 'SiblingDisjointCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLAssertionDirection', tCol, 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(isa, 'CycLAssertionDirection', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLAssertion', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLAssertion', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'CycLAssertion', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLAssertedAssertion', ttFormatType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycLAssertedAssertion', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'CycLAssertedAssertion', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycKBDatastructure', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycInferenceProblemLinkStatus', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycInferenceFn', 'ReifiableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycInferenceFn', 'BinaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycInferenceDataStructure', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycInferenceBindingsDataStructure', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycInferenceAnswerJustification', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycInferenceAnswer', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycInference', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycHLTruthValue', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycHLTruthValue', tCol, 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(isa, 'CycHLSupportDatastructure', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycDeductionDatastructure', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycArgumentDatastructure', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CycAdministrator', 'HumanCyclist', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CurrentWorldDataCollectorMt-NonHomocentric', 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CoreCycLMt', 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CoreCycLImplementationMt', 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CommutativeRelation', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'CommutativeRelation', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CollectionRuleTemplateFn', 'UnaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CollectionRuleTemplateFn', 'ReifiableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CollectionDenotingFunction', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'CollectionDenotingFunction', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, tCol, tCol, 'LogicalTruthMt', vStrDef).
assertedTinyKB(isa, tCol, 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'Code-AssertionDirection', 'CycLAssertionDirection', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'Closed-InferenceProblemLinkStatus', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CharacterString', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'CanonicalizerDirective', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'BroadMicrotheory', tCol, 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(isa, 'BroadMicrotheory', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'BookkeepingPredicate', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'BookkeepingPredicate', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'BookkeepingMt', 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'BookkeepingMt', 'BroadMicrotheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'BinaryRelation', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'BinaryRelation', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'BinaryPredicate', 'PredicateTypeByArity', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'BinaryPredicate', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'BinaryPredicate', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'BinaryFunction', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'BinaryFunction', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'BaseKB', 'BroadMicrotheory', 'BaseKB', vStrDef).
assertedTinyKB(isa, 'Backward-AssertionDirection', 'CycLAssertionDirection', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'Average', 'EvaluatableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'Average', 'BinaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'August', 'MonthOfYearType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'August', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'AtemporalNecessarilyEssentialCollectionType', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'AsymmetricBinaryPredicate', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'AsymmetricBinaryPredicate', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'AssociativeRelation', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'AssociativeRelation', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'assertionUtility-1', 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'AssertedTrueMonotonic', 'HLAssertedArgumentKeywordDatastructure', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'AssertedTrueDefault', 'HLAssertedArgumentKeywordDatastructure', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'AssertedFalseMonotonic', 'HLAssertedArgumentKeywordDatastructure', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'AssertedFalseDefault', 'HLAssertedArgumentKeywordDatastructure', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'ArgTypeTernaryPredicate', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'ArgTypeTernaryPredicate', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'ArgTypePredicate', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'ArgTypePredicate', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'ArgTypeBinaryPredicate', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'ArgTypeBinaryPredicate', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'ArgSometimesIsaPredicate', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'ArgQuotedIsaTernaryPredicate', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'ArgQuotedIsaTernaryPredicate', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'ArgQuotedIsaPredicate', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'ArgQuotedIsaBinaryPredicate', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'ArgIsaTernaryPredicate', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'ArgIsaTernaryPredicate', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'ArgIsaPredicate', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'ArgIsaBinaryPredicate', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'ArgIsaBinaryPredicate', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'ArgGenlTernaryPredicate', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'ArgGenlTernaryPredicate', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'ArgGenlQuantityTernaryPredicate', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'ArgGenlQuantityTernaryPredicate', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'ArgGenlQuantityBinaryPredicate', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'ArgGenlQuantityBinaryPredicate', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'ArgGenlBinaryPredicate', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'ArgGenlBinaryPredicate', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'ArgConstraintPredicate', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'ArgConstraintPredicate', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'April', 'MonthOfYearType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'April', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'AntiTransitiveBinaryPredicate', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'AntiTransitiveBinaryPredicate', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'AntiSymmetricBinaryPredicate', tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(isa, 'AntiSymmetricBinaryPredicate', 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'AllowKeywordVariables', 'CanonicalizerDirective', 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(isa, 'AllowGenericArgVariables', 'CanonicalizerDirective', 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(isa, 'AbsoluteValueFn', 'UnaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, 'AbsoluteValueFn', 'EvaluatableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(isa, '$VAR'('OBJ'), 'Thing', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(interArgResultIsa, 'RoundUpFn', 1, 'ScalarPointValue', 'ScalarPointValue', 'BaseKB', vStrMon).
assertedTinyKB(interArgResultIsa, 'RoundUpFn', 1, 'RealNumber', 'Integer', 'BaseKB', vStrMon).
assertedTinyKB(interArgResultIsa, 'RoundDownFn', 1, 'ScalarPointValue', 'ScalarPointValue', 'BaseKB', vStrMon).
assertedTinyKB(interArgResultIsa, 'RoundDownFn', 1, 'RealNumber', 'Integer', 'BaseKB', vStrMon).
assertedTinyKB(interArgResultIsa, 'RoundClosestFn', 1, 'ScalarPointValue', 'ScalarPointValue', 'BaseKB', vStrMon).
assertedTinyKB(interArgResultIsa, 'RoundClosestFn', 1, 'RealNumber', 'Integer', 'BaseKB', vStrMon).
assertedTinyKB(interArgResultIsa, 'ModuloFn', 1, 'Integer', 'NonNegativeInteger', 'BaseKB', vStrMon).
assertedTinyKB(interArgResultIsa, 'IntervalMinFn', 1, 'NonNegativeScalarInterval', 'NonNegativeScalarInterval', 'BaseKB', vStrMon).
assertedTinyKB(interArgResultIsa, 'FunctionToArg', 2, 'TernaryPredicate', 'BinaryFunction', 'BaseKB', vStrDef).
assertedTinyKB(interArgResultIsa, 'FunctionToArg', 2, 'BinaryPredicate', 'UnaryFunction', 'BaseKB', vStrDef).
assertedTinyKB(interArgDifferent, interArgDifferent, 2, 3, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(interArgDifferent, commutativeInArgs, 4, 5, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(interArgDifferent, commutativeInArgs, 3, 5, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(interArgDifferent, commutativeInArgs, 3, 4, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(interArgDifferent, commutativeInArgs, 2, 5, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(interArgDifferent, commutativeInArgs, 2, 4, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(interArgDifferent, commutativeInArgs, 2, 3, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(instanceElementType, 'Set-Mathematical', 'Thing', 'BaseKB', vStrMon).
assertedTinyKB(independentArg, 'interArgIsa5-4', 5, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(independentArg, 'interArgIsa5-3', 5, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(independentArg, 'interArgIsa5-2', 5, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(independentArg, 'interArgIsa5-1', 5, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(independentArg, 'interArgIsa4-5', 4, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(independentArg, 'interArgIsa4-3', 4, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(independentArg, 'interArgIsa4-2', 4, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(independentArg, 'interArgIsa4-1', 4, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(independentArg, 'interArgIsa3-5', 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(independentArg, 'interArgIsa3-4', 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(independentArg, 'interArgIsa3-2', 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(independentArg, 'interArgIsa3-1', 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(independentArg, 'interArgIsa2-5', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(independentArg, 'interArgIsa2-4', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(independentArg, 'interArgIsa2-3', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(independentArg, 'interArgIsa2-1', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(independentArg, 'interArgIsa1-5', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(independentArg, 'interArgIsa1-4', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(independentArg, 'interArgIsa1-3', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(independentArg, 'interArgIsa1-2', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(independentArg, 'interArgGenl1-2', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(independentArg, 'interArgFormat1-2', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, unknownSentence(thereExists('$VAR'('SOME_MT'), predicateConventionMt('$VAR'('SPEC'), '$VAR'('SOME_MT')))), meetsPragmaticRequirement('TheList'('$VAR'('PRED'), '$VAR'('SPEC'), '$VAR'('MT')), 'TINYKB-ASSERTION'(':TRUE-MON', [[[decontextualizedPredicate, '$VAR'('PRED')], [different, '$VAR'('PRED'), '$VAR'('SPEC')], [genlInverse, '$VAR'('SPEC'), '$VAR'('PRED')], [predicateConventionMt, '$VAR'('PRED'), '$VAR'('MT')]], [[predicateConventionMt, '$VAR'('SPEC'), '$VAR'('MT')]]], 'BaseKB', ["?PRED", "?SPEC", "?MT"], [implies, [and, [decontextualizedPredicate, '$VAR'('PRED')], [different, '$VAR'('PRED'), '$VAR'('SPEC')], [genlInverse, '$VAR'('SPEC'), '$VAR'('PRED')], [predicateConventionMt, '$VAR'('PRED'), '$VAR'('MT')]], [predicateConventionMt, '$VAR'('SPEC'), '$VAR'('MT')]])), 'BaseKB', vStrMon).
assertedTinyKB(implies, unknownSentence(disjointWith('$VAR'('COL1'), '$VAR'('COL2'))), consistent(and(isa('$VAR'('THING'), '$VAR'('COL1')), isa('$VAR'('THING'), '$VAR'('COL2')))), 'BaseKB', vStrDef).
assertedTinyKB(implies, trueSentence(thereExists('$VAR'('X'), and(isa('$VAR'('X'), '$VAR'('COL')), unknownSentence(holds('$VAR'('GENL_PRED'), '$VAR'('X')))))), meetsPragmaticRequirement('TheList'('$VAR'('SPEC_PRED'), '$VAR'('GENL_PRED'), '$VAR'('COL')), 'TINYKB-ASSERTION'(':TRUE-DEF', [[[genlPreds, '$VAR'('SPEC_PRED'), '$VAR'('GENL_PRED')], [relationAll, '$VAR'('SPEC_PRED'), '$VAR'('COL')]], [[relationAll, '$VAR'('GENL_PRED'), '$VAR'('COL')]]], 'BaseKB', ["?SPEC-PRED", "?GENL-PRED", "?COL"], [implies, [and, [genlPreds, '$VAR'('SPEC_PRED'), '$VAR'('GENL_PRED')], [relationAll, '$VAR'('SPEC_PRED'), '$VAR'('COL')]], [relationAll, '$VAR'('GENL_PRED'), '$VAR'('COL')]])), 'BaseKB', vStrDef).
assertedTinyKB(implies, trueSentence(forAll('$VAR'('ISA_CONSTR'), implies(argIsa('$VAR'('PRED'), '$VAR'('N'), '$VAR'('ISA_CONSTR')), genls('$VAR'('ISA_CONSTR'), 'CycLTerm')))), quotedArgument('$VAR'('PRED'), '$VAR'('N')), 'BaseKB', vStrDef).
assertedTinyKB(implies, trueSentence(forAll('$VAR'('INST'), implies(isa('$VAR'('INST'), '$VAR'('COL')), admittedArgument('$VAR'('INST'), '$VAR'('NUM'), '$VAR'('RELN'))))), admittedAllArgument('$VAR'('COL'), '$VAR'('NUM'), '$VAR'('RELN')), 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(implies, trueSentence('$VAR'('SENT')), sentenceTruth('$VAR'('SENT'), 'True'), 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(implies, trueRule('$VAR'('TEMPLATE'), '$VAR'('FORMULA')), trueSentence('$VAR'('FORMULA')), 'BaseKB', vStrDef).
assertedTinyKB(implies, termOfUnit('$VAR'('UNITPRODUCTFN'), 'UnitProductFn'('$VAR'('X'), '$VAR'('Y'))), multiplicationUnits('$VAR'('X'), '$VAR'('Y'), '$VAR'('UNITPRODUCTFN')), 'BaseKB', vStrDef).
assertedTinyKB(implies, termOfUnit('$VAR'('PERFN'), 'PerFn'('$VAR'('UOM1'), '$VAR'('UOM2'))), multiplicationUnits('$VAR'('PERFN'), '$VAR'('UOM2'), '$VAR'('UOM1')), 'BaseKB', vStrDef).
assertedTinyKB(implies, termOfUnit('$VAR'('MEANINGINSYSTEMFN'), 'MeaningInSystemFn'('$VAR'('SYSTEM'), '$VAR'('STRING'))), synonymousExternalConcept('$VAR'('MEANINGINSYSTEMFN'), '$VAR'('SYSTEM'), '$VAR'('STRING')), 'BaseKB', vStrDef).
assertedTinyKB(implies, subsetOf('$VAR'('A'), '$VAR'('B')), genls('$VAR'('A'), '$VAR'('B')), 'BaseKB', vStrDef).
assertedTinyKB(implies, sentenceTruth('$VAR'('SENT'), 'True'), trueSentence('$VAR'('SENT')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, relationInstanceExists('$VAR'('PRED'), '$VAR'('THING'), '$VAR'('COLL')), isa('RelationInstanceExistsFn'('$VAR'('PRED'), '$VAR'('THING'), '$VAR'('COLL')), '$VAR'('COLL')), 'BaseKB', vStrMon).
assertedTinyKB(implies, relationInstanceExists('$VAR'('PRED'), '$VAR'('THING'), '$VAR'('COLL')), holds('$VAR'('PRED'), '$VAR'('THING'), 'RelationInstanceExistsFn'('$VAR'('PRED'), '$VAR'('THING'), '$VAR'('COLL'))), 'BaseKB', vStrMon).
assertedTinyKB(implies, relationInstanceExists('$VAR'('PRED'), '$VAR'('THING'), '$VAR'('COL')), trueSentence(thereExists('$VAR'('INST'), and(isa('$VAR'('INST'), '$VAR'('COL')), holds('$VAR'('PRED'), '$VAR'('THING'), '$VAR'('INST'))))), 'BaseKB', vStrDef).
assertedTinyKB(implies, relationInstanceAll('$VAR'('PRED'), '$VAR'('THING'), '$VAR'('COL')), trueSentence(implies(isa('$VAR'('INST'), '$VAR'('COL')), holds('$VAR'('PRED'), '$VAR'('THING'), '$VAR'('INST')))), 'BaseKB', vStrMon).
assertedTinyKB(implies, relationInstanceAll('$VAR'('PRED'), '$VAR'('INSTANCE'), '$VAR'('COLLECTION')), conceptuallyRelated('$VAR'('COLLECTION'), '$VAR'('INSTANCE')), 'BaseKB', vStrMon).
assertedTinyKB(implies, relationInstanceAll('$VAR'('PRED'), '$VAR'('COL1'), '$VAR'('COL2')), requiredArg2Pred('$VAR'('COL2'), '$VAR'('PRED')), 'BaseKB', vStrDef).
assertedTinyKB(implies, relationExistsInstance('$VAR'('PRED'), '$VAR'('COLL'), '$VAR'('THING')), isa('RelationExistsInstanceFn'('$VAR'('PRED'), '$VAR'('COLL'), '$VAR'('THING')), '$VAR'('COLL')), 'BaseKB', vStrMon).
assertedTinyKB(implies, relationExistsInstance('$VAR'('PRED'), '$VAR'('COLL'), '$VAR'('THING')), holds('$VAR'('PRED'), 'RelationExistsInstanceFn'('$VAR'('PRED'), '$VAR'('COLL'), '$VAR'('THING')), '$VAR'('THING')), 'BaseKB', vStrMon).
assertedTinyKB(implies, relationExistsInstance('$VAR'('PRED'), '$VAR'('COL'), '$VAR'('THING')), trueSentence(thereExists('$VAR'('INST'), and(isa('$VAR'('INST'), '$VAR'('COL')), holds('$VAR'('PRED'), '$VAR'('INST'), '$VAR'('THING'))))), 'BaseKB', vStrDef).
assertedTinyKB(implies, relationExistsAll('$VAR'('SLOT'), '$VAR'('UNIV_COL'), '$VAR'('EXIST_COL')), relationExistsMinAll('$VAR'('SLOT'), '$VAR'('UNIV_COL'), '$VAR'('EXIST_COL'), 1), 'BaseKB', vStrDef).
assertedTinyKB(implies, relationExistsAll('$VAR'('PRED'), '$VAR'('COL1'), '$VAR'('COL2')), requiredArg2Pred('$VAR'('COL2'), '$VAR'('PRED')), 'BaseKB', vStrDef).
assertedTinyKB(implies, relationAllInstance('$VAR'('PRED'), '$VAR'('COLLECTION'), '$VAR'('INSTANCE')), conceptuallyRelated('$VAR'('COLLECTION'), '$VAR'('INSTANCE')), 'BaseKB', vStrMon).
assertedTinyKB(implies, relationAllInstance('$VAR'('PRED'), '$VAR'('COL1'), '$VAR'('_COL2')), requiredArg1Pred('$VAR'('COL1'), '$VAR'('PRED')), 'BaseKB', vStrMon).
assertedTinyKB(implies, relationAllExists('$VAR'('SLOT'), '$VAR'('UNIV_COL'), '$VAR'('EXIST_COL')), relationAllExistsMin('$VAR'('SLOT'), '$VAR'('UNIV_COL'), '$VAR'('EXIST_COL'), 1), 'BaseKB', vStrDef).
assertedTinyKB(implies, relationAllExists('$VAR'('PRED'), '$VAR'('COL1'), '$VAR'('_COL2')), requiredArg1Pred('$VAR'('COL1'), '$VAR'('PRED')), 'BaseKB', vStrDef).
assertedTinyKB(implies, relationAll('$VAR'('PRED'), '$VAR'('COL')), trueSentence(implies(isa('$VAR'('INST'), '$VAR'('COL')), holds('$VAR'('PRED'), '$VAR'('INST')))), 'BaseKB', vStrMon).
assertedTinyKB(implies, quotedIsa('$VAR'('X'), '$VAR'('COL')), isa('Quote'('EscapeQuote'('$VAR'('X'))), '$VAR'('COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, quotedIsa('$VAR'('EXPR'), 'CycLClosedExpression'), equals('Quote'('$VAR'('EXPR')), 'Quote'('EscapeQuote'('$VAR'('EXPR')))), 'BaseKB', vStrMon).
assertedTinyKB(implies, quotedIsa('$VAR'('ASSERTION'), 'CycLRuleAssertion'), assertionDirection('$VAR'('ASSERTION'), 'Backward-AssertionDirection'), 'BaseKB', vStrDef).
assertedTinyKB(implies, quotedIsa('$VAR'('ASSERTION'), 'CycLGAFAssertion'), assertionDirection('$VAR'('ASSERTION'), 'Forward-AssertionDirection'), 'BaseKB', vStrDef).
assertedTinyKB(implies, quantitySubsumes('$VAR'('NUM2'), '$VAR'('SUBNUM2')), quantitySubsumes('Unity'('$VAR'('_NUM1'), '$VAR'('NUM2')), '$VAR'('SUBNUM2')), 'BaseKB', vStrDef).
assertedTinyKB(implies, quantitySubsumes('$VAR'('NUM1'), '$VAR'('SUBNUM1')), quantitySubsumes('Unity'('$VAR'('NUM1'), '$VAR'('_NUM2')), '$VAR'('SUBNUM1')), 'BaseKB', vStrDef).
assertedTinyKB(implies, pointQuantValue('$VAR'('SCALAR'), '$VAR'('VALUE')), minQuantValue('$VAR'('SCALAR'), '$VAR'('VALUE')), 'BaseKB', vStrMon).
assertedTinyKB(implies, pointQuantValue('$VAR'('SCALAR'), '$VAR'('VALUE')), maxQuantValue('$VAR'('SCALAR'), '$VAR'('VALUE')), 'BaseKB', vStrMon).
assertedTinyKB(implies, operatorFormulas('$VAR'('A'), '$VAR'('B')), natFunction('$VAR'('B'), '$VAR'('A')), 'BaseKB', vStrDef).
assertedTinyKB(implies, omitArgIsa('$VAR'('RELN'), '$VAR'('N')), abnormal('TheList'('$VAR'('Q_COL'), '$VAR'('COL'), '$VAR'('RELN'), '$VAR'('N')), 'TINYKB-ASSERTION'(':TRUE-DEF', [[['genls-SpecDenotesGenlInstances', '$VAR'('Q_COL'), '$VAR'('COL')], [argQuotedIsa, '$VAR'('RELN'), '$VAR'('N'), '$VAR'('Q_COL')]], [[argIsa, '$VAR'('RELN'), '$VAR'('N'), '$VAR'('COL')]]], 'UniversalVocabularyMt', ["?Q-COL", "?COL", "?RELN", "?N"], [implies, [and, ['genls-SpecDenotesGenlInstances', '$VAR'('Q_COL'), '$VAR'('COL')], [argQuotedIsa, '$VAR'('RELN'), '$VAR'('N'), '$VAR'('Q_COL')]], [argIsa, '$VAR'('RELN'), '$VAR'('N'), '$VAR'('COL')]])), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, notAssertible('$VAR'('SPEC_PRED')), abnormal('TheList'('$VAR'('SPEC_PRED')), 'TINYKB-ASSERTION'(':TRUE-DEF', [[[different, disjointWith, '$VAR'('SPEC_PRED')], [genlPreds, '$VAR'('SPEC_PRED'), disjointWith]], [[afterAdding, '$VAR'('SPEC_PRED'), ['SubLQuoteFn', 'PROPAGATE-TO-DISJOINTWITH']]]], 'BaseKB', ["?SPEC-PRED"], [implies, [and, [different, disjointWith, '$VAR'('SPEC_PRED')], [genlPreds, '$VAR'('SPEC_PRED'), disjointWith]], [afterAdding, '$VAR'('SPEC_PRED'), ['SubLQuoteFn', 'PROPAGATE-TO-DISJOINTWITH']]])), 'BaseKB', vStrDef).
assertedTinyKB(implies, notAssertible('$VAR'('PRED')), abnormal('TheList'('$VAR'('PRED')), 'TINYKB-ASSERTION'(':TRUE-MON', [[[genlPreds, '$VAR'('PRED'), termDependsOn]], [[afterRemoving, '$VAR'('PRED'), ['SubLQuoteFn', 'REMOVE-DEPENDENT-TERM']]]], 'BaseKB', ["?PRED"], [implies, [genlPreds, '$VAR'('PRED'), termDependsOn], [afterRemoving, '$VAR'('PRED'), ['SubLQuoteFn', 'REMOVE-DEPENDENT-TERM']]])), 'BaseKB', vStrDef).
assertedTinyKB(implies, nearestDifferentIsa('$VAR'('OBJ_1'), '$VAR'('OBJ_2'), '$VAR'('NEAR_DIFF')), isa('$VAR'('OBJ_1'), '$VAR'('NEAR_DIFF')), 'BaseKB', vStrMon).
assertedTinyKB(implies, nearestDifferentGenls('$VAR'('COL_1'), '$VAR'('COL_2'), '$VAR'('NEAR_DIFF')), genls('$VAR'('COL_1'), '$VAR'('NEAR_DIFF')), 'BaseKB', vStrMon).
assertedTinyKB(implies, nearestCommonSpecs('$VAR'('COL'), '$VAR'('COL'), '$VAR'('NEAREST_SPEC')), nearestGenls('$VAR'('NEAREST_SPEC'), '$VAR'('COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, nearestCommonIsa('$VAR'('OBJ'), '$VAR'('OBJ'), '$VAR'('NEAR_ISA')), nearestIsa('$VAR'('OBJ'), '$VAR'('NEAR_ISA')), 'BaseKB', vStrMon).
assertedTinyKB(implies, nearestCommonGenls('$VAR'('COL'), '$VAR'('COL'), '$VAR'('NEAR_GENL')), nearestGenls('$VAR'('COL'), '$VAR'('NEAR_GENL')), 'BaseKB', vStrMon).
assertedTinyKB(implies, nearestCommonGenlMt('$VAR'('MT'), '$VAR'('MT'), '$VAR'('NEAR_MT')), nearestGenlMt('$VAR'('MT'), '$VAR'('NEAR_MT')), 'BaseKB', vStrMon).
assertedTinyKB(implies, natArgument('$VAR'('NAT'), 0, '$VAR'('FUNCTION')), natFunction('$VAR'('NAT'), '$VAR'('FUNCTION')), 'BaseKB', vStrMon).
assertedTinyKB(implies, multiplicationUnits('$VAR'('UNIT1'), '$VAR'('UNIT2'), '$VAR'('PROD_UNIT')), multiplicationUnits('$VAR'('UNIT1'), '$VAR'('UNIT2'), '$VAR'('PROD_UNIT')), 'BaseKB', vStrMon).
assertedTinyKB(implies, knownAntecedentRule('$VAR'('ASSERTION')), highlyRelevantAssertion('$VAR'('ASSERTION')), 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(implies, ist(dot_holds(['MtSpace'|'$VAR'('OTHER_MT_DIMS')]), '$VAR'('SENTENCE')), ist(dot_holds(['MtSpace', '$VAR'('MT_DIM')|'$VAR'('OTHER_MT_DIMS')]), '$VAR'('SENTENCE')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, ist(dot_holds(['MtSpace', '$VAR'('MT_DIM')|'$VAR'('OTHER_MT_DIMS')]), '$VAR'('SENTENCE')), ist(dot_holds(['MtSpace'|'$VAR'('OTHER_MT_DIMS')]), '$VAR'('SENTENCE')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, ist('MtSpace'('$VAR'('MT')), '$VAR'('SENTENCE')), ist('$VAR'('MT'), '$VAR'('SENTENCE')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, ist('$VAR'('MT'), '$VAR'('SENTENCE')), ist('MtSpace'('$VAR'('MT')), '$VAR'('SENTENCE')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, isa('Quote'('EscapeQuote'('$VAR'('X'))), '$VAR'('COL')), quotedIsa('$VAR'('X'), '$VAR'('COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, isa('$VAR'('X'), 'PositiveInteger'), greaterThanOrEqualTo('$VAR'('X'), 1), 'BaseKB', vStrDef).
assertedTinyKB(implies, isa('$VAR'('WEEKDAY'), 'DayOfWeekType'), defnSufficient('$VAR'('WEEKDAY'), 'SubLQuoteFn'('CYC-DAY-OF-WEEK-DEFN')), 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(implies, isa('$VAR'('UNIT'), 'UnitOfMeasure'), unitMultiplicationFactor('$VAR'('UNIT'), '$VAR'('UNIT'), 1), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, isa('$VAR'('UNIT'), 'UnitOfMeasure'), equals(dot_holds(['$VAR'('UNIT')|'$VAR'('ARGS')]), holds('$VAR'('UNIT'), dot_holds(['Unity'|'$VAR'('ARGS')]))), 'BaseKB', vStrDef).
assertedTinyKB(implies, isa('$VAR'('UNIT'), 'UnitOfMeasure'), arityMin('$VAR'('UNIT'), 1), 'BaseKB', vStrMon).
assertedTinyKB(implies, isa('$VAR'('UNIT'), 'UnitOfMeasure'), arityMax('$VAR'('UNIT'), 2), 'BaseKB', vStrMon).
assertedTinyKB(implies, isa('$VAR'('TEMPLATE'), 'RuleTemplate'), ruleTemplateDirection('$VAR'('TEMPLATE'), 'Backward-AssertionDirection'), 'BaseKB', vStrDef).
assertedTinyKB(implies, isa('$VAR'('REL'), 'UnaryRelation'), arity('$VAR'('REL'), 1), 'CoreCycLMt', vStrMon).
assertedTinyKB(implies, isa('$VAR'('REL'), 'TernaryRelation'), arity('$VAR'('REL'), 3), 'CoreCycLMt', vStrMon).
assertedTinyKB(implies, isa('$VAR'('REL'), 'QuintaryRelation'), arity('$VAR'('REL'), 5), 'CoreCycLMt', vStrMon).
assertedTinyKB(implies, isa('$VAR'('REL'), 'QuaternaryRelation'), arity('$VAR'('REL'), 4), 'CoreCycLMt', vStrMon).
assertedTinyKB(implies, isa('$VAR'('REL'), 'BinaryRelation'), arity('$VAR'('REL'), 2), 'CoreCycLMt', vStrMon).
assertedTinyKB(implies, isa('$VAR'('QUANT'), 'ExistentialQuantifier-Bounded'), arg3QuotedIsa('$VAR'('QUANT'), 'CycLSentence-Assertible'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, isa('$VAR'('QUANT'), 'ExistentialQuantifier-Bounded'), arg2QuotedIsa('$VAR'('QUANT'), ftVar), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, isa('$VAR'('PRED'), 'TransitiveBinaryPredicate'), transitiveViaArgInverse('$VAR'('PRED'), '$VAR'('PRED'), 1), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, isa('$VAR'('PRED'), 'TransitiveBinaryPredicate'), transitiveViaArg('$VAR'('PRED'), '$VAR'('PRED'), 2), 'BaseKB', vStrMon).
assertedTinyKB(implies, isa('$VAR'('PRED'), 'SymmetricBinaryPredicate'), genlInverse('$VAR'('PRED'), '$VAR'('PRED')), 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(implies, isa('$VAR'('PRED'), 'ReflexiveBinaryPredicate'), holds('$VAR'('PRED'), '$VAR'('OBJ'), '$VAR'('OBJ')), 'BaseKB', vStrMon).
assertedTinyKB(implies, isa('$VAR'('PRED'), 'ReflexiveBinaryPredicate'), genlPreds(equals, '$VAR'('PRED')), 'BaseKB', vStrMon).
assertedTinyKB(implies, isa('$VAR'('PRED'), 'IrreflexiveBinaryPredicate'), genlPreds('$VAR'('PRED'), different), 'BaseKB', vStrMon).
assertedTinyKB(implies, isa('$VAR'('PRED'), 'InterArgIsaPredicate'), arg1Isa('$VAR'('PRED'), tRelation), 'BaseKB', vStrDef).
assertedTinyKB(implies, isa('$VAR'('PRED'), 'InterArgIsaPredicate'), afterRemoving('$VAR'('PRED'), 'SubLQuoteFn'('INTER-ARG-ISA-AFTER-REMOVING')), 'BaseKB', vStrDef).
assertedTinyKB(implies, isa('$VAR'('PRED'), 'InterArgIsaPredicate'), afterAdding('$VAR'('PRED'), 'SubLQuoteFn'('INTER-ARG-ISA-AFTER-ADDING')), 'BaseKB', vStrDef).
assertedTinyKB(implies, isa('$VAR'('PRED'), 'InterArgFormatPredicate'), arg1Isa('$VAR'('PRED'), tRelation), 'BaseKB', vStrDef).
assertedTinyKB(implies, isa('$VAR'('PRED'), 'InterArgFormatPredicate'), afterRemoving('$VAR'('PRED'), 'SubLQuoteFn'('INTER-ARG-FORMAT-AFTER-REMOVING')), 'BaseKB', vStrDef).
assertedTinyKB(implies, isa('$VAR'('PRED'), 'InterArgFormatPredicate'), afterAdding('$VAR'('PRED'), 'SubLQuoteFn'('INTER-ARG-FORMAT-AFTER-ADDING')), 'BaseKB', vStrDef).
assertedTinyKB(implies, isa('$VAR'('PRED'), 'InferenceRelatedBookkeepingPredicate'), definingMt('$VAR'('PRED'), 'BaseKB'), 'BaseKB', vStrMon).
assertedTinyKB(implies, isa('$VAR'('PRED'), 'BookkeepingPredicate'), minimizeExtent('$VAR'('PRED')), 'BaseKB', vStrDef).
assertedTinyKB(implies, isa('$VAR'('PRED'), 'AsymmetricBinaryPredicate'), negationInverse('$VAR'('PRED'), '$VAR'('PRED')), 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(implies, isa('$VAR'('PRED'), 'ArgIsaTernaryPredicate'), transitiveViaArg('$VAR'('PRED'), genls, 3), 'BaseKB', vStrMon).
assertedTinyKB(implies, isa('$VAR'('PRED'), 'ArgIsaBinaryPredicate'), transitiveViaArg('$VAR'('PRED'), genls, 2), 'BaseKB', vStrMon).
assertedTinyKB(implies, isa('$VAR'('PRED'), 'ArgGenlTernaryPredicate'), transitiveViaArg('$VAR'('PRED'), genls, 3), 'BaseKB', vStrMon).
assertedTinyKB(implies, isa('$VAR'('PRED'), 'ArgGenlQuantityTernaryPredicate'), transitiveViaArgInverse('$VAR'('PRED'), quantitySubsumes, 3), 'BaseKB', vStrMon).
assertedTinyKB(implies, isa('$VAR'('PRED'), 'ArgGenlQuantityBinaryPredicate'), transitiveViaArgInverse('$VAR'('PRED'), quantitySubsumes, 2), 'BaseKB', vStrMon).
assertedTinyKB(implies, isa('$VAR'('PRED'), 'ArgGenlBinaryPredicate'), transitiveViaArg('$VAR'('PRED'), genls, 2), 'BaseKB', vStrMon).
assertedTinyKB(implies, isa('$VAR'('OBJ_1'), '$VAR'('DIFF_NEAR')), or(elementOf('$VAR'('OBJ_2'), 'TheSetOf'('$VAR'('ITEM_1'), isa('$VAR'('ITEM_1'), '$VAR'('DIFF_NEAR')))), nearestDifferentIsa('$VAR'('OBJ_1'), '$VAR'('OBJ_2'), '$VAR'('DIFF_NEAR')), elementOf('$VAR'('DIFF_NEAR'), 'TheSetOf'('$VAR'('DIFF_FARTHER'), thereExists('$VAR'('DIFF_FAR'), and(isa('$VAR'('OBJ_1'), '$VAR'('DIFF_FAR')), genls('$VAR'('DIFF_FAR'), '$VAR'('DIFF_FARTHER')), different('$VAR'('DIFF_FAR'), '$VAR'('DIFF_FARTHER')), not(elementOf('$VAR'('OBJ_2'), 'TheSetOf'('$VAR'('ITEM_2'), isa('$VAR'('ITEM_2'), '$VAR'('DIFF_NEAR')))))))))), 'BaseKB', vStrMon).
assertedTinyKB(implies, isa('$VAR'('OBJ'), '$VAR'('NEAR_COL')), or(nearestIsa('$VAR'('OBJ'), '$VAR'('NEAR_COL')), elementOf('$VAR'('NEAR_COL'), 'TheSetOf'('$VAR'('FARTHER_COL'), thereExists('$VAR'('FAR_COL'), and(isa('$VAR'('OBJ'), '$VAR'('FAR_COL')), genls('$VAR'('FAR_COL'), '$VAR'('FARTHER_COL')), different('$VAR'('FAR_COL'), '$VAR'('FARTHER_COL'))))))), 'BaseKB', vStrDef).
assertedTinyKB(implies, isa('$VAR'('MT'), 'Microtheory'), ist('BaseKB', isa('$VAR'('MT'), 'Microtheory')), 'BaseKB', vStrMon).
assertedTinyKB(implies, isa('$VAR'('MIC'), 'Microtheory'), genlMt('$VAR'('MIC'), 'BaseKB'), 'BaseKB', vStrMon).
assertedTinyKB(implies, isa('$VAR'('MEASURE_FN'), 'UnitOfMeasure'), resultIsa('$VAR'('MEASURE_FN'), 'ScalarInterval'), 'BaseKB', vStrDef).
assertedTinyKB(implies, isa('$VAR'('INSTANCE'), 'ScalarInterval'), abnormal('TheList'('$VAR'('PRED'), '$VAR'('COLLECTION'), '$VAR'('INSTANCE')), 'TINYKB-ASSERTION'(':TRUE-MON', [[[relationAllInstance, '$VAR'('PRED'), '$VAR'('COLLECTION'), '$VAR'('INSTANCE')]], [[conceptuallyRelated, '$VAR'('COLLECTION'), '$VAR'('INSTANCE')]]], 'BaseKB', ["?PRED", "?COLLECTION", "?INSTANCE"], [implies, [relationAllInstance, '$VAR'('PRED'), '$VAR'('COLLECTION'), '$VAR'('INSTANCE')], [conceptuallyRelated, '$VAR'('COLLECTION'), '$VAR'('INSTANCE')]])), 'BaseKB', vStrMon).
assertedTinyKB(implies, isa('$VAR'('FUNC'), 'IndeterminateTermDenotingFunction'), resultQuotedIsa('$VAR'('FUNC'), 'IndeterminateTerm'), 'BaseKB', vStrDef).
assertedTinyKB(implies, isa('$VAR'('CONNECT'), 'ExceptionPredicate'), abnormal('TheList'('$VAR'('CONNECT'), '$VAR'('ARITY'), '$VAR'('ARG_N_QUOTED_ISA'), '$VAR'('N'), '$VAR'('ARG_N_ISA')), 'TINYKB-ASSERTION'(':TRUE-MON', [[[isa, '$VAR'('CONNECT'), 'FixedArityRelation'], [isa, '$VAR'('CONNECT'), 'LogicalConnective'], [arity, '$VAR'('CONNECT'), '$VAR'('ARITY')], [isa, '$VAR'('ARG_N_QUOTED_ISA'), 'ArgQuotedIsaBinaryPredicate'], [constrainsArg, '$VAR'('ARG_N_QUOTED_ISA'), '$VAR'('N')], [integerBetween, 1, '$VAR'('N'), '$VAR'('ARITY')]], [['$VAR'('ARG_N_QUOTED_ISA'), '$VAR'('CONNECT'), 'CycLSentence-Assertible']]], 'BaseKB', ["?CONNECT", "?ARITY", "?ARG-N-QUOTED-ISA", "?N"], [implies, [and, [isa, '$VAR'('CONNECT'), 'FixedArityRelation'], [isa, '$VAR'('CONNECT'), 'LogicalConnective'], [arity, '$VAR'('CONNECT'), '$VAR'('ARITY')], [isa, '$VAR'('ARG_N_QUOTED_ISA'), 'ArgQuotedIsaBinaryPredicate'], [constrainsArg, '$VAR'('ARG_N_QUOTED_ISA'), '$VAR'('N')], [integerBetween, 1, '$VAR'('N'), '$VAR'('ARITY')]], ['$VAR'('ARG_N_QUOTED_ISA'), '$VAR'('CONNECT'), 'CycLSentence-Assertible']])), 'BaseKB', vStrMon).
assertedTinyKB(implies, isa('$VAR'('COL1'), tCol), or(genls('$VAR'('COL1'), '$VAR'('COL2')), different('$VAR'('COL1'), '$VAR'('COL2'))), 'BaseKB', vStrMon).
assertedTinyKB(implies, isa('$VAR'('ANECT'), 'AtemporalNecessarilyEssentialCollectionType'), decontextualizedCollection('$VAR'('ANECT')), 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(implies, isa('$VAR'('ANECT'), 'AtemporalNecessarilyEssentialCollectionType'), collectionConventionMt('$VAR'('ANECT'), 'UniversalVocabularyMt'), 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(implies, irrelevantAssertion('$VAR'('ASSERTION')), 'assertionUtility-1'('$VAR'('ASSERTION'), -1), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, interArgResultIsa('$VAR'('FN'), '$VAR'('_NUM'), 'Thing', '$VAR'('COLL')), resultIsa('$VAR'('FN'), '$VAR'('COLL')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, interArgIsa('$VAR'('PRED'), 5, '$VAR'('IND_COL'), 4, '$VAR'('DEP_COL')), 'interArgIsa5-4'('$VAR'('PRED'), '$VAR'('IND_COL'), '$VAR'('DEP_COL')), 'BaseKB', vStrMon).
assertedTinyKB(implies, interArgIsa('$VAR'('PRED'), 5, '$VAR'('IND_COL'), 3, '$VAR'('DEP_COL')), 'interArgIsa5-3'('$VAR'('PRED'), '$VAR'('IND_COL'), '$VAR'('DEP_COL')), 'BaseKB', vStrMon).
assertedTinyKB(implies, interArgIsa('$VAR'('PRED'), 5, '$VAR'('IND_COL'), 2, '$VAR'('DEP_COL')), 'interArgIsa5-2'('$VAR'('PRED'), '$VAR'('IND_COL'), '$VAR'('DEP_COL')), 'BaseKB', vStrMon).
assertedTinyKB(implies, interArgIsa('$VAR'('PRED'), 5, '$VAR'('IND_COL'), 1, '$VAR'('DEP_COL')), 'interArgIsa5-1'('$VAR'('PRED'), '$VAR'('IND_COL'), '$VAR'('DEP_COL')), 'BaseKB', vStrMon).
assertedTinyKB(implies, interArgIsa('$VAR'('PRED'), 4, '$VAR'('IND_COL'), 5, '$VAR'('DEP_COL')), 'interArgIsa4-5'('$VAR'('PRED'), '$VAR'('IND_COL'), '$VAR'('DEP_COL')), 'BaseKB', vStrMon).
assertedTinyKB(implies, interArgIsa('$VAR'('PRED'), 4, '$VAR'('IND_COL'), 3, '$VAR'('DEP_COL')), 'interArgIsa4-3'('$VAR'('PRED'), '$VAR'('IND_COL'), '$VAR'('DEP_COL')), 'BaseKB', vStrMon).
assertedTinyKB(implies, interArgIsa('$VAR'('PRED'), 4, '$VAR'('IND_COL'), 2, '$VAR'('DEP_COL')), 'interArgIsa4-2'('$VAR'('PRED'), '$VAR'('IND_COL'), '$VAR'('DEP_COL')), 'BaseKB', vStrMon).
assertedTinyKB(implies, interArgIsa('$VAR'('PRED'), 4, '$VAR'('IND_COL'), 1, '$VAR'('DEP_COL')), 'interArgIsa4-1'('$VAR'('PRED'), '$VAR'('IND_COL'), '$VAR'('DEP_COL')), 'BaseKB', vStrMon).
assertedTinyKB(implies, interArgIsa('$VAR'('PRED'), 3, '$VAR'('IND_COL'), 5, '$VAR'('DEP_COL')), 'interArgIsa3-5'('$VAR'('PRED'), '$VAR'('IND_COL'), '$VAR'('DEP_COL')), 'BaseKB', vStrMon).
assertedTinyKB(implies, interArgIsa('$VAR'('PRED'), 3, '$VAR'('IND_COL'), 4, '$VAR'('DEP_COL')), 'interArgIsa3-4'('$VAR'('PRED'), '$VAR'('IND_COL'), '$VAR'('DEP_COL')), 'BaseKB', vStrMon).
assertedTinyKB(implies, interArgIsa('$VAR'('PRED'), 3, '$VAR'('IND_COL'), 2, '$VAR'('DEP_COL')), 'interArgIsa3-2'('$VAR'('PRED'), '$VAR'('IND_COL'), '$VAR'('DEP_COL')), 'BaseKB', vStrMon).
assertedTinyKB(implies, interArgIsa('$VAR'('PRED'), 3, '$VAR'('IND_COL'), 1, '$VAR'('DEP_COL')), 'interArgIsa3-1'('$VAR'('PRED'), '$VAR'('IND_COL'), '$VAR'('DEP_COL')), 'BaseKB', vStrMon).
assertedTinyKB(implies, interArgIsa('$VAR'('PRED'), 2, '$VAR'('IND_COL'), 5, '$VAR'('DEP_COL')), 'interArgIsa2-5'('$VAR'('PRED'), '$VAR'('IND_COL'), '$VAR'('DEP_COL')), 'BaseKB', vStrMon).
assertedTinyKB(implies, interArgIsa('$VAR'('PRED'), 2, '$VAR'('IND_COL'), 4, '$VAR'('DEP_COL')), 'interArgIsa2-4'('$VAR'('PRED'), '$VAR'('IND_COL'), '$VAR'('DEP_COL')), 'BaseKB', vStrMon).
assertedTinyKB(implies, interArgIsa('$VAR'('PRED'), 2, '$VAR'('IND_COL'), 3, '$VAR'('DEP_COL')), 'interArgIsa2-3'('$VAR'('PRED'), '$VAR'('IND_COL'), '$VAR'('DEP_COL')), 'BaseKB', vStrMon).
assertedTinyKB(implies, interArgIsa('$VAR'('PRED'), 2, '$VAR'('IND_COL'), 1, '$VAR'('DEP_COL')), 'interArgIsa2-1'('$VAR'('PRED'), '$VAR'('IND_COL'), '$VAR'('DEP_COL')), 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(implies, interArgIsa('$VAR'('PRED'), 1, '$VAR'('IND_COL'), 5, '$VAR'('DEP_COL')), 'interArgIsa1-5'('$VAR'('PRED'), '$VAR'('IND_COL'), '$VAR'('DEP_COL')), 'BaseKB', vStrMon).
assertedTinyKB(implies, interArgIsa('$VAR'('PRED'), 1, '$VAR'('IND_COL'), 4, '$VAR'('DEP_COL')), 'interArgIsa1-4'('$VAR'('PRED'), '$VAR'('IND_COL'), '$VAR'('DEP_COL')), 'BaseKB', vStrMon).
assertedTinyKB(implies, interArgIsa('$VAR'('PRED'), 1, '$VAR'('IND_COL'), 3, '$VAR'('DEP_COL')), 'interArgIsa1-3'('$VAR'('PRED'), '$VAR'('IND_COL'), '$VAR'('DEP_COL')), 'BaseKB', vStrMon).
assertedTinyKB(implies, interArgIsa('$VAR'('PRED'), 1, '$VAR'('IND_COL'), 2, '$VAR'('DEP_COL')), 'interArgIsa1-2'('$VAR'('PRED'), '$VAR'('IND_COL'), '$VAR'('DEP_COL')), 'BaseKB', vStrMon).
assertedTinyKB(implies, integerBetween('$VAR'('LOW'), '$VAR'('MED'), '$VAR'('HIGH')), greaterThanOrEqualTo('$VAR'('MED'), '$VAR'('LOW')), 'BaseKB', vStrDef).
assertedTinyKB(implies, integerBetween('$VAR'('LOW'), '$VAR'('MED'), '$VAR'('HIGH')), greaterThanOrEqualTo('$VAR'('HIGH'), '$VAR'('MED')), 'BaseKB', vStrDef).
assertedTinyKB(implies, instanceElementType('$VAR'('SET_TYPE'), '$VAR'('_COL')), defnSufficient('$VAR'('SET_TYPE'), 'SubLQuoteFn'('CYC-SET-OF-TYPE-SUFFICIENT')), 'UniversalVocabularyImplementationMt', vStrMon).
assertedTinyKB(implies, hypotheticalTerm('$VAR'('TERM')), quotedIsa('$VAR'('TERM'), 'IndeterminateTerm'), 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(implies, hypotheticalTerm('$VAR'('TERM')), highlyRelevantTerm('$VAR'('TERM')), 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(implies, hypotheticalTerm('$VAR'('TERM')), ephemeralTerm('$VAR'('TERM')), 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(implies, holdsIn('$VAR'('_T1'), holdsIn('$VAR'('T2'), '$VAR'('P'))), holdsIn('$VAR'('T2'), '$VAR'('P')), 'BaseKB', vStrDef).
assertedTinyKB(implies, highlyRelevantAssertion('$VAR'('ASSERTION')), assertionUtility('$VAR'('ASSERTION'), 1), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, highlyRelevantAssertion('$VAR'('ASSERTION')), 'assertionUtility-1'('$VAR'('ASSERTION'), 1), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, genls('$VAR'('SUB'), '$VAR'('SUPER')), genls('$VAR'('SUPER'), 'Thing'), 'BaseKB', vStrMon).
assertedTinyKB(implies, genls('$VAR'('SUB'), '$VAR'('SUPER')), genls('$VAR'('SUB'), 'Thing'), 'BaseKB', vStrMon).
assertedTinyKB(implies, genls('$VAR'('SPEC'), 'Quantifier'), decontextualizedCollection('$VAR'('SPEC')), 'BaseKB', vStrMon).
assertedTinyKB(implies, genls('$VAR'('SPEC'), 'LogicalConnective'), decontextualizedCollection('$VAR'('SPEC')), 'BaseKB', vStrMon).
assertedTinyKB(implies, genlPreds('$VAR'('SPEC_PRED'), genls), afterRemoving('$VAR'('SPEC_PRED'), 'SubLQuoteFn'('REMOVE-TVA-CACHE-VALUE')), 'BaseKB', vStrDef).
assertedTinyKB(implies, genlPreds('$VAR'('PRED'), termDependsOn), afterRemoving('$VAR'('PRED'), 'SubLQuoteFn'('REMOVE-DEPENDENT-TERM')), 'BaseKB', vStrMon).
assertedTinyKB(implies, genlPreds('$VAR'('EQUALITY_PRED'), equals), afterRemoving('$VAR'('EQUALITY_PRED'), 'SubLQuoteFn'('DECACHE-SOME-EQUALITY-ASSERTIONS-SOMEWHERE')), 'BaseKB', vStrDef).
assertedTinyKB(implies, genlPreds('$VAR'('EQUALITY_PRED'), equals), afterAdding('$VAR'('EQUALITY_PRED'), 'SubLQuoteFn'('DECACHE-SOME-EQUALITY-ASSERTIONS-SOMEWHERE')), 'BaseKB', vStrDef).
assertedTinyKB(implies, genlMt('$VAR'('SPEC'), '$VAR'('GENL')), genlMt(dot_holds(['MtUnionFn', '$VAR'('SPEC')|'$VAR'('OTHER_MTS')]), '$VAR'('GENL')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, genlInverse('$VAR'('SPEC_INVERSE'), isa), afterAdding('$VAR'('SPEC_INVERSE'), 'SubLQuoteFn'('PROPAGATE-INVERSE-TO-ISA')), 'BaseKB', vStrMon).
assertedTinyKB(implies, genlInverse('$VAR'('SPEC_INVERSE'), genls), afterRemoving('$VAR'('SPEC_INVERSE'), 'SubLQuoteFn'('REMOVE-TVA-CACHE-VALUE')), 'BaseKB', vStrDef).
assertedTinyKB(implies, genlInverse('$VAR'('SPEC_INVERSE'), genls), afterAdding('$VAR'('SPEC_INVERSE'), 'SubLQuoteFn'('PROPAGATE-INVERSE-TO-GENLS')), 'BaseKB', vStrMon).
assertedTinyKB(implies, genlInverse('$VAR'('SPEC_INVERSE'), genlPreds), afterAdding('$VAR'('SPEC_INVERSE'), 'SubLQuoteFn'('PROPAGATE-INVERSE-TO-GENLPREDS')), 'BaseKB', vStrMon).
assertedTinyKB(implies, genlInverse('$VAR'('SPEC_INVERSE'), genlMt), afterAdding('$VAR'('SPEC_INVERSE'), 'SubLQuoteFn'('PROPAGATE-INVERSE-TO-GENLMT')), 'BaseKB', vStrMon).
assertedTinyKB(implies, genlInverse('$VAR'('SPEC_INVERSE'), genlInverse), afterAdding('$VAR'('SPEC_INVERSE'), 'SubLQuoteFn'('PROPAGATE-INVERSE-TO-GENLINVERSE')), 'BaseKB', vStrMon).
assertedTinyKB(implies, forwardNonTriggerLiteral(isa('$VAR'('TERM'), '$VAR'('INDEP_COL'))), meetsPragmaticRequirement('TheList'('$VAR'('NAT'), '$VAR'('FUNC'), '$VAR'('TERM'), '$VAR'('INDEP_COL'), '$VAR'('ARG'), '$VAR'('DEP_COL')), 'TINYKB-ASSERTION'(':TRUE-DEF', [[[natFunction, '$VAR'('NAT'), '$VAR'('FUNC')], [isa, '$VAR'('TERM'), '$VAR'('INDEP_COL')], [natArgument, '$VAR'('NAT'), '$VAR'('ARG'), '$VAR'('TERM')], [interArgResultIsa, '$VAR'('FUNC'), '$VAR'('ARG'), '$VAR'('INDEP_COL'), '$VAR'('DEP_COL')]], [[isa, '$VAR'('NAT'), '$VAR'('DEP_COL')]]], 'BaseKB', ["?NAT", "?FUNC", "?TERM", "?INDEP-COL", "?ARG", "?DEP-COL"], [implies, [and, [natFunction, '$VAR'('NAT'), '$VAR'('FUNC')], [isa, '$VAR'('TERM'), '$VAR'('INDEP_COL')], [natArgument, '$VAR'('NAT'), '$VAR'('ARG'), '$VAR'('TERM')], [interArgResultIsa, '$VAR'('FUNC'), '$VAR'('ARG'), '$VAR'('INDEP_COL'), '$VAR'('DEP_COL')]], [isa, '$VAR'('NAT'), '$VAR'('DEP_COL')]])), 'BaseKB', vStrDef).
assertedTinyKB(implies, forwardNonTriggerLiteral(isa('$VAR'('ARG'), '$VAR'('COL'))), meetsPragmaticRequirement('TheList'('$VAR'('ARG'), '$VAR'('COL'), '$VAR'('NART'), '$VAR'('FUNC'), '$VAR'('INT')), 'TINYKB-ASSERTION'(':TRUE-MON', [[[assertedSentence, [isa, '$VAR'('ARG'), '$VAR'('COL')]], [natFunction, '$VAR'('NART'), '$VAR'('FUNC')], [resultIsaArgIsa, '$VAR'('FUNC'), '$VAR'('INT')], [natArgument, '$VAR'('NART'), '$VAR'('INT'), '$VAR'('ARG')]], [[isa, '$VAR'('NART'), '$VAR'('COL')]]], 'BaseKB', ["?ARG", "?COL", "?NART", "?FUNC", "?INT"], [implies, [and, [assertedSentence, [isa, '$VAR'('ARG'), '$VAR'('COL')]], [natFunction, '$VAR'('NART'), '$VAR'('FUNC')], [resultIsaArgIsa, '$VAR'('FUNC'), '$VAR'('INT')], [natArgument, '$VAR'('NART'), '$VAR'('INT'), '$VAR'('ARG')]], [isa, '$VAR'('NART'), '$VAR'('COL')]])), 'BaseKB', vStrMon).
assertedTinyKB(implies, forwardNonTriggerLiteral(arity('$VAR'('PRED'), 2)), meetsPragmaticRequirement('TheList'('$VAR'('PRED'), '$VAR'('COL1'), '$VAR'('COL2')), 'TINYKB-ASSERTION'(':TRUE-MON', [[[arity, '$VAR'('PRED'), 2], [requiredArg1Pred, '$VAR'('COL1'), '$VAR'('PRED')], ['interArgIsa1-2', '$VAR'('PRED'), '$VAR'('COL1'), '$VAR'('COL2')]], [[relationAllExists, '$VAR'('PRED'), '$VAR'('COL1'), '$VAR'('COL2')]]], 'BaseKB', ["?PRED", "?COL1", "?COL2"], [implies, [and, [arity, '$VAR'('PRED'), 2], [requiredArg1Pred, '$VAR'('COL1'), '$VAR'('PRED')], ['interArgIsa1-2', '$VAR'('PRED'), '$VAR'('COL1'), '$VAR'('COL2')]], [relationAllExists, '$VAR'('PRED'), '$VAR'('COL1'), '$VAR'('COL2')]])), 'BaseKB', vStrMon).
assertedTinyKB(implies, extentCardinality('TheSetOf'('$VAR'('OBJ'), and(isa('$VAR'('OBJ'), '$VAR'('COLL_1')), not(isa('$VAR'('OBJ'), '$VAR'('COLL_2'))))), 0), subsetOf('$VAR'('COLL_1'), '$VAR'('COLL_2')), 'BaseKB', vStrDef).
assertedTinyKB(implies, extConceptOverlapsColAndReln('$VAR'('COL'), '$VAR'('RELN'), '$VAR'('SOURCE'), '$VAR'('STRING')), overlappingExternalConcept('$VAR'('RELN'), '$VAR'('SOURCE'), '$VAR'('STRING')), 'BaseKB', vStrDef).
assertedTinyKB(implies, extConceptOverlapsColAndReln('$VAR'('COL'), '$VAR'('RELN'), '$VAR'('SOURCE'), '$VAR'('STRING')), overlappingExternalConcept('$VAR'('COL'), '$VAR'('SOURCE'), '$VAR'('STRING')), 'BaseKB', vStrDef).
assertedTinyKB(implies, except('$VAR'('ASSERTION')), exceptWhen(except('$VAR'('ASSERTION')), '$VAR'('ASSERTION')), 'BaseKB', vStrDef).
assertedTinyKB(implies, evaluateImmediately('$VAR'('FUNC')), evaluateAtEL('$VAR'('FUNC')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, evaluate('$VAR'('TIMESFN'), 'TimesFn'('$VAR'('X'), 0)), evaluate(0, '$VAR'('TIMESFN')), 'BaseKB', vStrMon).
assertedTinyKB(implies, evaluate('$VAR'('QUOTIENTFN'), 'QuotientFn'('$VAR'('NUM_1'), '$VAR'('NUM_2'))), ratioOfTo('$VAR'('NUM_1'), '$VAR'('NUM_2'), '$VAR'('QUOTIENTFN')), 'BaseKB', vStrDef).
assertedTinyKB(implies, evaluate('$VAR'('PLUSFN'), 'PlusFn'('$VAR'('X'), 0)), equals('$VAR'('PLUSFN'), '$VAR'('X')), 'BaseKB', vStrMon).
assertedTinyKB(implies, evaluate('$VAR'('PLUSFN'), 'PlusFn'('$VAR'('X'))), equals('$VAR'('PLUSFN'), '$VAR'('X')), 'BaseKB', vStrMon).
assertedTinyKB(implies, evaluate('$VAR'('FORMULAARGFN'), 'FormulaArgFn'(0, '$VAR'('FORMULA'))), operatorFormulas('$VAR'('FORMULAARGFN'), '$VAR'('FORMULA')), 'BaseKB', vStrDef).
assertedTinyKB(implies, evaluate('$VAR'('_RESULT'), 'EvaluateSubLFn'('$VAR'('SUBL'))), performSubL('$VAR'('SUBL')), 'BaseKB', vStrMon).
assertedTinyKB(implies, equals('True', '$VAR'('VALUE')), trueSentence('$VAR'('VALUE')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, equals('$VAR'('X'), '$VAR'('Y')), equals('$VAR'('X'), '$VAR'('Y')), 'LogicalTruthMt', vStrMon).
assertedTinyKB(implies, equals('$VAR'('A'), '$VAR'('B')), 'equalStrings-CaseInsensitive'('$VAR'('A'), '$VAR'('B')), 'BaseKB', vStrDef).
assertedTinyKB(implies, elInverse('$VAR'('SLOT'), '$VAR'('INVERSE')), expansion('$VAR'('INVERSE'), holds('$VAR'('SLOT'), '$VAR'((':ARG2')), '$VAR'((':ARG1')))), 'BaseKB', vStrDef).
assertedTinyKB(implies, elementOf('$VAR'('MT_DIM'), dot_holds(['TheSet'|'$VAR'('MT_DIMS')])), genlMt(dot_holds(['MtSpace'|'$VAR'('MT_DIMS')]), '$VAR'('MT_DIM')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, elementOf('$VAR'('A'), '$VAR'('B')), isa('$VAR'('A'), '$VAR'('B')), 'BaseKB', vStrDef).
assertedTinyKB(implies, dot_holds([commutativeInArgs, '$VAR'('_PRED')|'$VAR'('ARGS')]), dot_holds([different|'$VAR'('ARGS')]), 'BaseKB', vStrMon).
assertedTinyKB(implies, disjointWith('$VAR'('X'), '$VAR'('Y')), disjointWith('$VAR'('X'), '$VAR'('Y')), 'LogicalTruthMt', vStrMon).
assertedTinyKB(implies, different('CycLNonAtomicTerm', '$VAR'('COL')), meetsPragmaticRequirement('TheList'('$VAR'('NAT'), '$VAR'('FUNCTION'), '$VAR'('COL')), 'TINYKB-ASSERTION'(':TRUE-DEF', [[[natFunction, '$VAR'('NAT'), '$VAR'('FUNCTION')], [resultQuotedIsa, '$VAR'('FUNCTION'), '$VAR'('COL')]], [[quotedIsa, '$VAR'('NAT'), '$VAR'('COL')]]], 'CoreCycLMt', ["?NAT", "?FUNCTION", "?COL"], [implies, [and, [natFunction, '$VAR'('NAT'), '$VAR'('FUNCTION')], [resultQuotedIsa, '$VAR'('FUNCTION'), '$VAR'('COL')]], [quotedIsa, '$VAR'('NAT'), '$VAR'('COL')]])), 'CoreCycLMt', vStrDef).
assertedTinyKB(implies, different('$VAR'('UNIT_THREE'), '$VAR'('UNIT_TWO')), meetsPragmaticRequirement('TheList'('$VAR'('UNIT_TWO'), '$VAR'('UNIT_THREE'), '$VAR'('FACTOR1'), '$VAR'('PERFN_1'), '$VAR'('UNIT_ONE'), '$VAR'('PERFN')), 'TINYKB-ASSERTION'(':TRUE-MON', [[[unitMultiplicationFactor, '$VAR'('UNIT_TWO'), '$VAR'('UNIT_THREE'), '$VAR'('FACTOR1')], [termOfUnit, '$VAR'('PERFN_1'), ['PerFn', '$VAR'('UNIT_ONE'), '$VAR'('UNIT_THREE')]], [termOfUnit, '$VAR'('PERFN'), ['PerFn', '$VAR'('UNIT_ONE'), '$VAR'('UNIT_TWO')]]], [[unitMultiplicationFactor, '$VAR'('PERFN_1'), '$VAR'('PERFN'), '$VAR'('FACTOR1')]]], 'BaseKB', ["?UNIT-TWO", "?UNIT-THREE", "?FACTOR1", "?PERFN-1", "?UNIT-ONE", "?PERFN"], [implies, [and, [unitMultiplicationFactor, '$VAR'('UNIT_TWO'), '$VAR'('UNIT_THREE'), '$VAR'('FACTOR1')], [termOfUnit, '$VAR'('PERFN_1'), ['PerFn', '$VAR'('UNIT_ONE'), '$VAR'('UNIT_THREE')]], [termOfUnit, '$VAR'('PERFN'), ['PerFn', '$VAR'('UNIT_ONE'), '$VAR'('UNIT_TWO')]]], [unitMultiplicationFactor, '$VAR'('PERFN_1'), '$VAR'('PERFN'), '$VAR'('FACTOR1')]])), 'BaseKB', vStrMon).
assertedTinyKB(implies, different('$VAR'('UNIT_ONE'), '$VAR'('UNIT_TWO')), meetsPragmaticRequirement('TheList'('$VAR'('UNIT_ONE'), '$VAR'('UNIT_TWO'), '$VAR'('FACTOR1'), '$VAR'('PERFN_1'), '$VAR'('UNIT_THREE'), '$VAR'('PERFN')), 'TINYKB-ASSERTION'(':TRUE-DEF', [[[unitMultiplicationFactor, '$VAR'('UNIT_ONE'), '$VAR'('UNIT_TWO'), '$VAR'('FACTOR1')], [termOfUnit, '$VAR'('PERFN_1'), ['PerFn', '$VAR'('UNIT_ONE'), '$VAR'('UNIT_THREE')]], [termOfUnit, '$VAR'('PERFN'), ['PerFn', '$VAR'('UNIT_TWO'), '$VAR'('UNIT_THREE')]]], [[unitMultiplicationFactor, '$VAR'('PERFN_1'), '$VAR'('PERFN'), '$VAR'('FACTOR1')]]], 'BaseKB', ["?UNIT-ONE", "?UNIT-TWO", "?FACTOR1", "?PERFN-1", "?UNIT-THREE", "?PERFN"], [implies, [and, [unitMultiplicationFactor, '$VAR'('UNIT_ONE'), '$VAR'('UNIT_TWO'), '$VAR'('FACTOR1')], [termOfUnit, '$VAR'('PERFN_1'), ['PerFn', '$VAR'('UNIT_ONE'), '$VAR'('UNIT_THREE')]], [termOfUnit, '$VAR'('PERFN'), ['PerFn', '$VAR'('UNIT_TWO'), '$VAR'('UNIT_THREE')]]], [unitMultiplicationFactor, '$VAR'('PERFN_1'), '$VAR'('PERFN'), '$VAR'('FACTOR1')]])), 'BaseKB', vStrMon).
assertedTinyKB(implies, denotes('Quote'('EscapeQuote'('$VAR'('X'))), '$VAR'('_ANYTHING')), denotes('Quote'('EscapeQuote'('$VAR'('X'))), '$VAR'('X')), 'LogicalTruthMt', vStrMon).
assertedTinyKB(implies, completelyEnumerableCollection('$VAR'('COL')), completeExtentEnumerableForValueInArg(isa, '$VAR'('COL'), 2), 'CoreCycLMt', vStrDef).
assertedTinyKB(implies, completelyDecidableCollection('$VAR'('COL')), completeExtentDecidableForValueInArg(isa, '$VAR'('COL'), 2), 'CoreCycLMt', vStrDef).
assertedTinyKB(implies, completeExtentEnumerableForValueInArg(isa, '$VAR'('COL'), 2), completelyEnumerableCollection('$VAR'('COL')), 'CoreCycLMt', vStrDef).
assertedTinyKB(implies, completeExtentDecidableForValueInArg(isa, '$VAR'('COL'), 2), completelyDecidableCollection('$VAR'('COL')), 'CoreCycLMt', vStrDef).
assertedTinyKB(implies, completeExtentDecidable('$VAR'('PRED')), backchainForbidden('$VAR'('PRED')), 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(implies, collectionIsaBackchainRequired('$VAR'('PRED')), collectionIsaBackchainEncouraged('$VAR'('PRED')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, collectionGenlsBackchainRequired('$VAR'('PRED')), collectionGenlsBackchainEncouraged('$VAR'('PRED')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, collectionBackchainRequired('$VAR'('PRED')), collectionBackchainEncouraged('$VAR'('PRED')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, canonicalizerDirectiveForArgAndRest('$VAR'('RELN'), 1, '$VAR'('DIRECTIVE')), canonicalizerDirectiveForAllArgs('$VAR'('RELN'), '$VAR'('DIRECTIVE')), 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(implies, canonicalizerDirectiveForAllArgs('$VAR'('RELN'), '$VAR'('DIRECTIVE')), canonicalizerDirectiveForArgAndRest('$VAR'('RELN'), 1, '$VAR'('DIRECTIVE')), 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(implies, assertionUtility('$VAR'('ASSERTION'), 1), highlyRelevantAssertion('$VAR'('ASSERTION')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, assertedSentence(relationAllInstance(quotedIsa, '$VAR'('COLL'), '$VAR'('QUOTED_COLL'))), meetsPragmaticRequirement('TheList'('$VAR'('INS'), '$VAR'('COLL'), '$VAR'('QUOTED_COLL')), 'TINYKB-ASSERTION'(':TRUE-DEF', [[[isa, '$VAR'('INS'), '$VAR'('COLL')], [relationAllInstance, quotedIsa, '$VAR'('COLL'), '$VAR'('QUOTED_COLL')]], [[quotedIsa, '$VAR'('INS'), '$VAR'('QUOTED_COLL')]]], 'BookkeepingMt', ["?INS", "?COLL", "?QUOTED-COLL"], [implies, [and, [isa, '$VAR'('INS'), '$VAR'('COLL')], [relationAllInstance, quotedIsa, '$VAR'('COLL'), '$VAR'('QUOTED_COLL')]], [quotedIsa, '$VAR'('INS'), '$VAR'('QUOTED_COLL')]])), 'BookkeepingMt', vStrDef).
assertedTinyKB(implies, assertedSentence(interArgResultIsa('$VAR'('FUNC'), '$VAR'('ARG'), '$VAR'('INDEP_COL'), '$VAR'('DEP_COL'))), meetsPragmaticRequirement('TheList'('$VAR'('NAT'), '$VAR'('FUNC'), '$VAR'('TERM'), '$VAR'('INDEP_COL'), '$VAR'('ARG'), '$VAR'('DEP_COL')), 'TINYKB-ASSERTION'(':TRUE-DEF', [[[natFunction, '$VAR'('NAT'), '$VAR'('FUNC')], [isa, '$VAR'('TERM'), '$VAR'('INDEP_COL')], [natArgument, '$VAR'('NAT'), '$VAR'('ARG'), '$VAR'('TERM')], [interArgResultIsa, '$VAR'('FUNC'), '$VAR'('ARG'), '$VAR'('INDEP_COL'), '$VAR'('DEP_COL')]], [[isa, '$VAR'('NAT'), '$VAR'('DEP_COL')]]], 'BaseKB', ["?NAT", "?FUNC", "?TERM", "?INDEP-COL", "?ARG", "?DEP-COL"], [implies, [and, [natFunction, '$VAR'('NAT'), '$VAR'('FUNC')], [isa, '$VAR'('TERM'), '$VAR'('INDEP_COL')], [natArgument, '$VAR'('NAT'), '$VAR'('ARG'), '$VAR'('TERM')], [interArgResultIsa, '$VAR'('FUNC'), '$VAR'('ARG'), '$VAR'('INDEP_COL'), '$VAR'('DEP_COL')]], [isa, '$VAR'('NAT'), '$VAR'('DEP_COL')]])), 'BaseKB', vStrDef).
assertedTinyKB(implies, assertedSentence(genls('$VAR'('TERM'), '$VAR'('INDEP_COLL'))), meetsPragmaticRequirement('TheList'('$VAR'('NAT'), '$VAR'('FUNC'), '$VAR'('NUM'), '$VAR'('INDEP_COLL_NAT'), '$VAR'('TERM'), '$VAR'('INDEP_COLL')), 'TINYKB-ASSERTION'(':TRUE-DEF', [[[natFunction, '$VAR'('NAT'), '$VAR'('FUNC')], [preservesGenlsInArg, '$VAR'('FUNC'), '$VAR'('NUM')], [natFunction, '$VAR'('INDEP_COLL_NAT'), '$VAR'('FUNC')], [genls, '$VAR'('TERM'), '$VAR'('INDEP_COLL')], [natArgument, '$VAR'('NAT'), '$VAR'('NUM'), '$VAR'('TERM')], [natArgument, '$VAR'('INDEP_COLL_NAT'), '$VAR'('NUM'), '$VAR'('INDEP_COLL')]], [[genls, '$VAR'('NAT'), '$VAR'('INDEP_COLL_NAT')]]], 'UniversalVocabularyMt', ["?NAT", "?FUNC", "?NUM", "?INDEP-COLL-NAT", "?TERM", "?INDEP-COLL"], [implies, [and, [natFunction, '$VAR'('NAT'), '$VAR'('FUNC')], [preservesGenlsInArg, '$VAR'('FUNC'), '$VAR'('NUM')], [natFunction, '$VAR'('INDEP_COLL_NAT'), '$VAR'('FUNC')], [genls, '$VAR'('TERM'), '$VAR'('INDEP_COLL')], [natArgument, '$VAR'('NAT'), '$VAR'('NUM'), '$VAR'('TERM')], [natArgument, '$VAR'('INDEP_COLL_NAT'), '$VAR'('NUM'), '$VAR'('INDEP_COLL')]], [genls, '$VAR'('NAT'), '$VAR'('INDEP_COLL_NAT')]])), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, assertedSentence(genlPreds('$VAR'('SPEC'), '$VAR'('PRED'))), meetsPragmaticRequirement('TheList'('$VAR'('PRED'), '$VAR'('SPEC')), 'TINYKB-ASSERTION'(':TRUE-MON', [[[decontextualizedPredicate, '$VAR'('PRED')], [genlPreds, '$VAR'('SPEC'), '$VAR'('PRED')]], [[decontextualizedPredicate, '$VAR'('SPEC')]]], 'BaseKB', ["?PRED", "?SPEC"], [implies, [and, [decontextualizedPredicate, '$VAR'('PRED')], [genlPreds, '$VAR'('SPEC'), '$VAR'('PRED')]], [decontextualizedPredicate, '$VAR'('SPEC')]])), 'BaseKB', vStrMon).
assertedTinyKB(implies, assertedSentence(genlPreds('$VAR'('SPEC'), '$VAR'('PRED'))), meetsPragmaticRequirement('TheList'('$VAR'('PRED'), '$VAR'('MT'), '$VAR'('SPEC')), 'TINYKB-ASSERTION'(':TRUE-DEF', [[[decontextualizedPredicate, '$VAR'('PRED')], [predicateConventionMt, '$VAR'('PRED'), '$VAR'('MT')], [genlPreds, '$VAR'('SPEC'), '$VAR'('PRED')]], [[predicateConventionMt, '$VAR'('SPEC'), '$VAR'('MT')]]], 'BaseKB', ["?PRED", "?MT", "?SPEC"], [implies, [and, [decontextualizedPredicate, '$VAR'('PRED')], [predicateConventionMt, '$VAR'('PRED'), '$VAR'('MT')], [genlPreds, '$VAR'('SPEC'), '$VAR'('PRED')]], [predicateConventionMt, '$VAR'('SPEC'), '$VAR'('MT')]])), 'BaseKB', vStrDef).
assertedTinyKB(implies, assertedSentence(collectionIsaBackchainRequired('$VAR'('PRED'))), meetsPragmaticRequirement('TheList'('$VAR'('PRED')), 'TINYKB-ASSERTION'(':TRUE-DEF', [[[collectionIsaBackchainRequired, '$VAR'('PRED')]], [[collectionIsaBackchainEncouraged, '$VAR'('PRED')]]], 'UniversalVocabularyMt', ["?PRED"], [implies, [collectionIsaBackchainRequired, '$VAR'('PRED')], [collectionIsaBackchainEncouraged, '$VAR'('PRED')]])), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, assertedSentence(collectionGenlsBackchainRequired('$VAR'('PRED'))), meetsPragmaticRequirement('TheList'('$VAR'('PRED')), 'TINYKB-ASSERTION'(':TRUE-DEF', [[[collectionGenlsBackchainRequired, '$VAR'('PRED')]], [[collectionGenlsBackchainEncouraged, '$VAR'('PRED')]]], 'UniversalVocabularyMt', ["?PRED"], [implies, [collectionGenlsBackchainRequired, '$VAR'('PRED')], [collectionGenlsBackchainEncouraged, '$VAR'('PRED')]])), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, assertedSentence(collectionBackchainRequired('$VAR'('PRED'))), meetsPragmaticRequirement('TheList'('$VAR'('PRED')), 'TINYKB-ASSERTION'(':TRUE-DEF', [[[collectionBackchainRequired, '$VAR'('PRED')]], [[collectionBackchainEncouraged, '$VAR'('PRED')]]], 'UniversalVocabularyMt', ["?PRED"], [implies, [collectionBackchainRequired, '$VAR'('PRED')], [collectionBackchainEncouraged, '$VAR'('PRED')]])), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, assertedSentence(argSometimesIsa('$VAR'('RELN'), 6, '$VAR'('COL'))), meetsPragmaticRequirement('TheList'('$VAR'('RELN'), '$VAR'('COL')), 'TINYKB-ASSERTION'(':TRUE-DEF', [[[argSometimesIsa, '$VAR'('RELN'), 6, '$VAR'('COL')]], [[arg6SometimesIsa, '$VAR'('RELN'), '$VAR'('COL')]]], 'UniversalVocabularyMt', ["?RELN", "?COL"], [implies, [argSometimesIsa, '$VAR'('RELN'), 6, '$VAR'('COL')], [arg6SometimesIsa, '$VAR'('RELN'), '$VAR'('COL')]])), 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(implies, assertedSentence(argSometimesIsa('$VAR'('RELN'), 5, '$VAR'('COL'))), meetsPragmaticRequirement('TheList'('$VAR'('RELN'), '$VAR'('COL')), 'TINYKB-ASSERTION'(':TRUE-DEF', [[[argSometimesIsa, '$VAR'('RELN'), 5, '$VAR'('COL')]], [[arg5SometimesIsa, '$VAR'('RELN'), '$VAR'('COL')]]], 'UniversalVocabularyMt', ["?RELN", "?COL"], [implies, [argSometimesIsa, '$VAR'('RELN'), 5, '$VAR'('COL')], [arg5SometimesIsa, '$VAR'('RELN'), '$VAR'('COL')]])), 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(implies, assertedSentence(argSometimesIsa('$VAR'('RELN'), 4, '$VAR'('COL'))), meetsPragmaticRequirement('TheList'('$VAR'('RELN'), '$VAR'('COL')), 'TINYKB-ASSERTION'(':TRUE-DEF', [[[argSometimesIsa, '$VAR'('RELN'), 4, '$VAR'('COL')]], [[arg4SometimesIsa, '$VAR'('RELN'), '$VAR'('COL')]]], 'UniversalVocabularyMt', ["?RELN", "?COL"], [implies, [argSometimesIsa, '$VAR'('RELN'), 4, '$VAR'('COL')], [arg4SometimesIsa, '$VAR'('RELN'), '$VAR'('COL')]])), 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(implies, assertedSentence(argSometimesIsa('$VAR'('RELN'), 3, '$VAR'('COL'))), meetsPragmaticRequirement('TheList'('$VAR'('RELN'), '$VAR'('COL')), 'TINYKB-ASSERTION'(':TRUE-DEF', [[[argSometimesIsa, '$VAR'('RELN'), 3, '$VAR'('COL')]], [[arg3SometimesIsa, '$VAR'('RELN'), '$VAR'('COL')]]], 'UniversalVocabularyMt', ["?RELN", "?COL"], [implies, [argSometimesIsa, '$VAR'('RELN'), 3, '$VAR'('COL')], [arg3SometimesIsa, '$VAR'('RELN'), '$VAR'('COL')]])), 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(implies, assertedSentence(argSometimesIsa('$VAR'('RELN'), 2, '$VAR'('COL'))), meetsPragmaticRequirement('TheList'('$VAR'('RELN'), '$VAR'('COL')), 'TINYKB-ASSERTION'(':TRUE-DEF', [[[argSometimesIsa, '$VAR'('RELN'), 2, '$VAR'('COL')]], [[arg2SometimesIsa, '$VAR'('RELN'), '$VAR'('COL')]]], 'UniversalVocabularyMt', ["?RELN", "?COL"], [implies, [argSometimesIsa, '$VAR'('RELN'), 2, '$VAR'('COL')], [arg2SometimesIsa, '$VAR'('RELN'), '$VAR'('COL')]])), 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(implies, assertedSentence(argSometimesIsa('$VAR'('RELN'), 1, '$VAR'('COL'))), meetsPragmaticRequirement('TheList'('$VAR'('RELN'), '$VAR'('COL')), 'TINYKB-ASSERTION'(':TRUE-DEF', [[[argSometimesIsa, '$VAR'('RELN'), 1, '$VAR'('COL')]], [[arg1SometimesIsa, '$VAR'('RELN'), '$VAR'('COL')]]], 'UniversalVocabularyMt', ["?RELN", "?COL"], [implies, [argSometimesIsa, '$VAR'('RELN'), 1, '$VAR'('COL')], [arg1SometimesIsa, '$VAR'('RELN'), '$VAR'('COL')]])), 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(implies, assertedSentence('$VAR'('SENT')), quotedIsa('$VAR'('SENT'), 'CycLAssertion'), 'BaseKB', vStrDef).
assertedTinyKB(implies, arity('$VAR'('REL'), 4), isa('$VAR'('REL'), 'QuaternaryRelation'), 'BaseKB', vStrMon).
assertedTinyKB(implies, arity('$VAR'('REL'), 3), isa('$VAR'('REL'), 'TernaryRelation'), 'BaseKB', vStrDef).
assertedTinyKB(implies, arity('$VAR'('REL'), 2), isa('$VAR'('REL'), 'BinaryRelation'), 'BaseKB', vStrMon).
assertedTinyKB(implies, argSometimesIsa('$VAR'('RELN'), 6, '$VAR'('COL')), arg6SometimesIsa('$VAR'('RELN'), '$VAR'('COL')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, argSometimesIsa('$VAR'('RELN'), 5, '$VAR'('COL')), arg5SometimesIsa('$VAR'('RELN'), '$VAR'('COL')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, argSometimesIsa('$VAR'('RELN'), 4, '$VAR'('COL')), arg4SometimesIsa('$VAR'('RELN'), '$VAR'('COL')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, argSometimesIsa('$VAR'('RELN'), 3, '$VAR'('COL')), arg3SometimesIsa('$VAR'('RELN'), '$VAR'('COL')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, argSometimesIsa('$VAR'('RELN'), 2, '$VAR'('COL')), arg2SometimesIsa('$VAR'('RELN'), '$VAR'('COL')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, argSometimesIsa('$VAR'('RELN'), 1, '$VAR'('COL')), arg1SometimesIsa('$VAR'('RELN'), '$VAR'('COL')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, argQuotedIsa('$VAR'('RELN'), 6, '$VAR'('COL')), arg6QuotedIsa('$VAR'('RELN'), '$VAR'('COL')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, argQuotedIsa('$VAR'('RELN'), 5, '$VAR'('COL')), arg5QuotedIsa('$VAR'('RELN'), '$VAR'('COL')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, argQuotedIsa('$VAR'('RELN'), 4, '$VAR'('COL')), arg4QuotedIsa('$VAR'('RELN'), '$VAR'('COL')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, argQuotedIsa('$VAR'('RELN'), 3, '$VAR'('COL')), arg3QuotedIsa('$VAR'('RELN'), '$VAR'('COL')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, argQuotedIsa('$VAR'('RELN'), 2, '$VAR'('COL')), arg2QuotedIsa('$VAR'('RELN'), '$VAR'('COL')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, argQuotedIsa('$VAR'('RELN'), 1, '$VAR'('COL')), arg1QuotedIsa('$VAR'('RELN'), '$VAR'('COL')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, argQuotedIsa('$VAR'('PRED'), '$VAR'('N'), '$VAR'('_COL')), quotedArgument('$VAR'('PRED'), '$VAR'('N')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, argIsa('$VAR'('RELN'), 6, '$VAR'('COL')), arg6Isa('$VAR'('RELN'), '$VAR'('COL')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, argIsa('$VAR'('RELN'), 5, '$VAR'('COL')), arg5Isa('$VAR'('RELN'), '$VAR'('COL')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, argIsa('$VAR'('RELN'), 4, '$VAR'('COL')), arg4Isa('$VAR'('RELN'), '$VAR'('COL')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, argIsa('$VAR'('RELN'), 3, '$VAR'('COL')), arg3Isa('$VAR'('RELN'), '$VAR'('COL')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, argIsa('$VAR'('RELN'), 2, '$VAR'('COL')), arg2Isa('$VAR'('RELN'), '$VAR'('COL')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, argIsa('$VAR'('RELN'), 1, '$VAR'('COL')), arg1Isa('$VAR'('RELN'), '$VAR'('COL')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, arg6SometimesIsa('$VAR'('RELN'), '$VAR'('COL')), argSometimesIsa('$VAR'('RELN'), 6, '$VAR'('COL')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, arg6QuotedIsa('$VAR'('RELN'), '$VAR'('COL')), argQuotedIsa('$VAR'('RELN'), 6, '$VAR'('COL')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, arg6Isa('$VAR'('RELN'), '$VAR'('COL')), argIsa('$VAR'('RELN'), 6, '$VAR'('COL')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, arg6Isa('$VAR'('PRED'), '$VAR'('TYPE')), resultIsa('FunctionToArg'(6, '$VAR'('PRED')), '$VAR'('TYPE')), 'BaseKB', vStrDef).
assertedTinyKB(implies, arg5SometimesIsa('$VAR'('RELN'), '$VAR'('COL')), argSometimesIsa('$VAR'('RELN'), 5, '$VAR'('COL')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, arg5QuotedIsa('$VAR'('RELN'), '$VAR'('COL')), argQuotedIsa('$VAR'('RELN'), 5, '$VAR'('COL')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, arg5Isa('$VAR'('RELN'), '$VAR'('COL')), argIsa('$VAR'('RELN'), 5, '$VAR'('COL')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, arg5Isa('$VAR'('PRED'), '$VAR'('TYPE')), resultIsa('FunctionToArg'(5, '$VAR'('PRED')), '$VAR'('TYPE')), 'BaseKB', vStrDef).
assertedTinyKB(implies, arg4SometimesIsa('$VAR'('RELN'), '$VAR'('COL')), argSometimesIsa('$VAR'('RELN'), 4, '$VAR'('COL')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, arg4QuotedIsa('$VAR'('RELN'), '$VAR'('COL')), argQuotedIsa('$VAR'('RELN'), 4, '$VAR'('COL')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, arg4Isa('$VAR'('RELN'), '$VAR'('COL')), argIsa('$VAR'('RELN'), 4, '$VAR'('COL')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, arg4Isa('$VAR'('PRED'), '$VAR'('TYPE')), resultIsa('FunctionToArg'(4, '$VAR'('PRED')), '$VAR'('TYPE')), 'BaseKB', vStrDef).
assertedTinyKB(implies, arg3SometimesIsa('$VAR'('RELN'), '$VAR'('COL')), argSometimesIsa('$VAR'('RELN'), 3, '$VAR'('COL')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, arg3QuotedIsa('$VAR'('RELN'), '$VAR'('COL')), argQuotedIsa('$VAR'('RELN'), 3, '$VAR'('COL')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, arg3Isa('$VAR'('RELN'), '$VAR'('COL')), argIsa('$VAR'('RELN'), 3, '$VAR'('COL')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, arg3Isa('$VAR'('PRED'), '$VAR'('TYPE')), resultIsa('FunctionToArg'(3, '$VAR'('PRED')), '$VAR'('TYPE')), 'BaseKB', vStrDef).
assertedTinyKB(implies, arg2SometimesIsa('$VAR'('RELN'), '$VAR'('COL')), argSometimesIsa('$VAR'('RELN'), 2, '$VAR'('COL')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, arg2QuotedIsa('$VAR'('RELN'), '$VAR'('COL')), argQuotedIsa('$VAR'('RELN'), 2, '$VAR'('COL')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, arg2Isa('$VAR'('RELN'), '$VAR'('COL')), argIsa('$VAR'('RELN'), 2, '$VAR'('COL')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, arg2Isa('$VAR'('PRED'), '$VAR'('TYPE')), resultIsa('FunctionToArg'(2, '$VAR'('PRED')), '$VAR'('TYPE')), 'BaseKB', vStrDef).
assertedTinyKB(implies, arg1SometimesIsa('$VAR'('RELN'), '$VAR'('COL')), argSometimesIsa('$VAR'('RELN'), 1, '$VAR'('COL')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, arg1QuotedIsa('$VAR'('RELN'), '$VAR'('COL')), argQuotedIsa('$VAR'('RELN'), 1, '$VAR'('COL')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, arg1Isa('$VAR'('RELN'), '$VAR'('COL')), argIsa('$VAR'('RELN'), 1, '$VAR'('COL')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, arg1Isa('$VAR'('PRED'), '$VAR'('TYPE')), resultIsa('FunctionToArg'(1, '$VAR'('PRED')), '$VAR'('TYPE')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(unitMultiplicationFactor('$VAR'('UNIT_TWO'), '$VAR'('UNIT_THREE'), '$VAR'('FACTOR1')), termOfUnit('$VAR'('PERFN_1'), 'PerFn'('$VAR'('UNIT_ONE'), '$VAR'('UNIT_THREE'))), termOfUnit('$VAR'('PERFN'), 'PerFn'('$VAR'('UNIT_ONE'), '$VAR'('UNIT_TWO')))), unitMultiplicationFactor('$VAR'('PERFN_1'), '$VAR'('PERFN'), '$VAR'('FACTOR1')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(unitMultiplicationFactor('$VAR'('UNIT_ONE'), '$VAR'('UNIT_TWO'), '$VAR'('FACTOR1')), termOfUnit('$VAR'('PERFN_1'), 'PerFn'('$VAR'('UNIT_ONE'), '$VAR'('UNIT_THREE'))), termOfUnit('$VAR'('PERFN'), 'PerFn'('$VAR'('UNIT_TWO'), '$VAR'('UNIT_THREE')))), unitMultiplicationFactor('$VAR'('PERFN_1'), '$VAR'('PERFN'), '$VAR'('FACTOR1')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(unitMultiplicationFactor('$VAR'('SMALL'), '$VAR'('BIG'), '$VAR'('FACTOR')), evaluate('$VAR'('TIMESFN'), 'TimesFn'('$VAR'('FACTOR'), '$VAR'('N')))), equals(holds('$VAR'('BIG'), '$VAR'('N')), holds('$VAR'('SMALL'), '$VAR'('TIMESFN'))), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(trueSentence('$VAR'('FORMULA')), interArgDifferent('$VAR'('FORMULAARGFN_2'), '$VAR'('ARG_1'), '$VAR'('ARG_2')), evaluate('$VAR'('FORMULAARGFN_2'), 'FormulaArgFn'(0, '$VAR'('FORMULA'))), evaluate('$VAR'('FORMULAARGFN'), 'FormulaArgFn'('$VAR'('ARG_1'), '$VAR'('FORMULA'))), evaluate('$VAR'('FORMULAARGFN_1'), 'FormulaArgFn'('$VAR'('ARG_2'), '$VAR'('FORMULA')))), different('$VAR'('FORMULAARGFN'), '$VAR'('FORMULAARGFN_1')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(trueSentence('$VAR'('ANTE')), sentenceImplies('$VAR'('ANTE'), '$VAR'('CONSEQ'))), trueSentence('$VAR'('CONSEQ')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(termOfUnit('$VAR'('UNITPRODUCTFN'), 'UnitProductFn'('$VAR'('PERFN'), '$VAR'('UNIT2'))), termOfUnit('$VAR'('PERFN'), 'PerFn'('$VAR'('UNIT1'), '$VAR'('UNIT2')))), equals('$VAR'('UNIT1'), '$VAR'('UNITPRODUCTFN')), 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(implies, and(termOfUnit('$VAR'('PERFN_1'), 'PerFn'('$VAR'('UNIT2'), '$VAR'('UNIT3'))), termOfUnit('$VAR'('PERFN_2'), 'PerFn'('$VAR'('UNIT1'), '$VAR'('UNIT2'))), termOfUnit('$VAR'('PERFN'), 'PerFn'('$VAR'('UNIT1'), '$VAR'('UNIT3')))), multiplicationUnits('$VAR'('PERFN_1'), '$VAR'('PERFN_2'), '$VAR'('PERFN')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(termOfUnit('$VAR'('PERFN'), 'PerFn'('$VAR'('UNITPRODUCTFN'), '$VAR'('UNIT2'))), termOfUnit('$VAR'('UNITPRODUCTFN'), 'UnitProductFn'('$VAR'('UNIT1'), '$VAR'('UNIT2')))), equals('$VAR'('PERFN'), '$VAR'('UNIT1')), 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(implies, and(rewriteOf('$VAR'('TERM'), '$VAR'('NART1')), rewriteOf('$VAR'('TERM'), '$VAR'('NART2'))), equals('$VAR'('NART1'), '$VAR'('NART2')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(rewriteOf('$VAR'('REWRITE'), '$VAR'('TERM')), holds('$VAR'('PRED'), '$VAR'('ARG1'), '$VAR'('TERM'), '$VAR'('ARG3'))), holds('$VAR'('PRED'), '$VAR'('ARG1'), '$VAR'('REWRITE'), '$VAR'('ARG3')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, and(rewriteOf('$VAR'('REWRITE'), '$VAR'('TERM')), holds('$VAR'('PRED'), '$VAR'('ARG1'), '$VAR'('TERM'))), holds('$VAR'('PRED'), '$VAR'('ARG1'), '$VAR'('REWRITE')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, and(resultIsaArg('$VAR'('FUNC'), 6), arg6Genl('$VAR'('FUNC'), '$VAR'('COL'))), resultIsa('$VAR'('FUNC'), '$VAR'('COL')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(resultIsaArg('$VAR'('FUNC'), 5), arg5Genl('$VAR'('FUNC'), '$VAR'('COL'))), resultIsa('$VAR'('FUNC'), '$VAR'('COL')), 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(implies, and(resultIsaArg('$VAR'('FUNC'), 4), arg4Genl('$VAR'('FUNC'), '$VAR'('COL'))), resultIsa('$VAR'('FUNC'), '$VAR'('COL')), 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(implies, and(resultIsaArg('$VAR'('FUNC'), 3), arg3Genl('$VAR'('FUNC'), '$VAR'('COL'))), resultIsa('$VAR'('FUNC'), '$VAR'('COL')), 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(implies, and(resultIsaArg('$VAR'('FUNC'), 2), arg2Genl('$VAR'('FUNC'), '$VAR'('COL'))), resultIsa('$VAR'('FUNC'), '$VAR'('COL')), 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(implies, and(resultIsaArg('$VAR'('FUNC'), 1), arg1Genl('$VAR'('FUNC'), '$VAR'('COL'))), resultIsa('$VAR'('FUNC'), '$VAR'('COL')), 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(implies, and(resultIsa('$VAR'('FUNCTION'), '$VAR'('COLTYPE')), genls('$VAR'('COLTYPE'), tCol)), isa('$VAR'('FUNCTION'), 'CollectionDenotingFunction'), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(resultIsa('$VAR'('FUNC'), '$VAR'('COL')), equals('$VAR'('VALUE'), dot_holds(['$VAR'('FUNC')|'$VAR'('ARGS')]))), isa('$VAR'('VALUE'), '$VAR'('COL')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(resultIsa('$VAR'('F'), '$VAR'('COL')), termOfUnit('$VAR'('U'), '$VAR'('F'))), isa('$VAR'('U'), '$VAR'('COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(resultGenl('$VAR'('FUNC'), '$VAR'('COL')), equals('$VAR'('VALUE'), dot_holds(['$VAR'('FUNC')|'$VAR'('ARGS')]))), genls('$VAR'('VALUE'), '$VAR'('COL')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(requiredArg2Pred('$VAR'('COL_2'), '$VAR'('PRED')), 'interArgIsa2-1'('$VAR'('PRED'), '$VAR'('COL_2'), '$VAR'('COL_1'))), relationExistsAll('$VAR'('PRED'), '$VAR'('COL_1'), '$VAR'('COL_2')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(relationAllExistsMax('$VAR'('REL'), '$VAR'('A'), '$VAR'('B'), '$VAR'('N')), relationAllExistsMin('$VAR'('REL'), '$VAR'('A'), '$VAR'('B'), '$VAR'('N'))), relationAllExistsCount('$VAR'('REL'), '$VAR'('A'), '$VAR'('B'), '$VAR'('N')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(relationAllExistsCount('$VAR'('REL'), '$VAR'('COL1'), '$VAR'('COL2'), '$VAR'('M')), relationAllExistsCount('$VAR'('REL'), '$VAR'('COL1'), '$VAR'('COL2'), '$VAR'('N'))), numericallyEquals('$VAR'('M'), '$VAR'('N')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(relationAllExistsCount('$VAR'('PRED'), '$VAR'('ARG1'), '$VAR'('ARG2'), '$VAR'('N')), relationAllExistsMin('$VAR'('PRED'), '$VAR'('ARG1'), '$VAR'('ARG2'), '$VAR'('M'))), greaterThanOrEqualTo('$VAR'('N'), '$VAR'('M')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(relationAll('$VAR'('PRED'), '$VAR'('COL')), isa('$VAR'('OBJ'), '$VAR'('COL'))), holds('$VAR'('PRED'), '$VAR'('OBJ')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(quotedIsa('$VAR'('SUBL_NUM'), 'SubLPositiveInteger'), denotes('$VAR'('SUBL_NUM'), '$VAR'('NUM'))), isa('$VAR'('NUM'), 'PositiveInteger'), 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(implies, and(quotedIsa('$VAR'('SUBL_NUM'), 'SubLNonNegativeInteger'), denotes('$VAR'('SUBL_NUM'), '$VAR'('NUM'))), isa('$VAR'('NUM'), 'NonNegativeInteger'), 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(implies, and(quantitySubsumes('$VAR'('SUPER'), '$VAR'('SUB')), followingValue('$VAR'('SUPER'), '$VAR'('LATER'))), followingValue('$VAR'('SUB'), '$VAR'('LATER')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(quantitySubsumes('$VAR'('INTERVAL1'), '$VAR'('INTERVAL2')), quantitySubsumes('$VAR'('INTERVAL2'), '$VAR'('INTERVAL1'))), numericallyEquals('$VAR'('INTERVAL1'), '$VAR'('INTERVAL2')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(numericallyEquals('$VAR'('M'), '$VAR'('N')), relationAllExistsCount('$VAR'('REL'), '$VAR'('COL1'), '$VAR'('COL2'), '$VAR'('N'))), relationAllExistsCount('$VAR'('REL'), '$VAR'('COL1'), '$VAR'('COL2'), '$VAR'('M')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(negationPreds('$VAR'('GENL_PRED'), '$VAR'('NEG_PRED')), genlPreds('$VAR'('SPEC_PRED'), '$VAR'('GENL_PRED'))), negationPreds('$VAR'('NEG_PRED'), '$VAR'('SPEC_PRED')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(negationPreds('$VAR'('GENL_PRED'), '$VAR'('NEG_PRED')), genlInverse('$VAR'('SPEC_PRED'), '$VAR'('GENL_PRED'))), negationInverse('$VAR'('NEG_PRED'), '$VAR'('SPEC_PRED')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(negationInverse('$VAR'('GENL_PRED'), '$VAR'('NEG_PRED')), genlPreds('$VAR'('SPEC_PRED'), '$VAR'('GENL_PRED'))), negationInverse('$VAR'('NEG_PRED'), '$VAR'('SPEC_PRED')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(negationInverse('$VAR'('GENL_PRED'), '$VAR'('NEG_PRED')), genlInverse('$VAR'('SPEC_PRED'), '$VAR'('GENL_PRED'))), negationPreds('$VAR'('NEG_PRED'), '$VAR'('SPEC_PRED')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(natFunction('$VAR'('NAT'), '$VAR'('FUNCTION')), resultQuotedIsa('$VAR'('FUNCTION'), '$VAR'('COL'))), quotedIsa('$VAR'('NAT'), '$VAR'('COL')), 'CoreCycLMt', vStrDef).
assertedTinyKB(implies, and(natFunction('$VAR'('NAT'), '$VAR'('FUNCTION')), resultIsa('$VAR'('FUNCTION'), '$VAR'('COL'))), isa('$VAR'('NAT'), '$VAR'('COL')), 'CoreCycLMt', vStrMon).
assertedTinyKB(implies, and(natFunction('$VAR'('NAT'), '$VAR'('FUNCTION')), resultGenl('$VAR'('FUNCTION'), '$VAR'('COL'))), genls('$VAR'('NAT'), '$VAR'('COL')), 'CoreCycLMt', vStrMon).
assertedTinyKB(implies, and(natFunction('$VAR'('NAT'), '$VAR'('FUNC')), resultIsaArg('$VAR'('FUNC'), '$VAR'('N')), natArgument('$VAR'('NAT'), '$VAR'('N'), '$VAR'('COL'))), isa('$VAR'('NAT'), '$VAR'('COL')), 'CoreCycLMt', vStrMon).
assertedTinyKB(implies, and(natFunction('$VAR'('NAT'), '$VAR'('FUNC')), resultGenlArg('$VAR'('FUNC'), '$VAR'('N')), natArgument('$VAR'('NAT'), '$VAR'('N'), '$VAR'('COL'))), genls('$VAR'('NAT'), '$VAR'('COL')), 'CoreCycLMt', vStrMon).
assertedTinyKB(implies, and(natFunction('$VAR'('NAT'), '$VAR'('FUNC')), preservesGenlsInArg('$VAR'('FUNC'), '$VAR'('NUM')), natFunction('$VAR'('INDEP_COLL_NAT'), '$VAR'('FUNC')), genls('$VAR'('TERM'), '$VAR'('INDEP_COLL')), natArgument('$VAR'('NAT'), '$VAR'('NUM'), '$VAR'('TERM')), natArgument('$VAR'('INDEP_COLL_NAT'), '$VAR'('NUM'), '$VAR'('INDEP_COLL'))), genls('$VAR'('NAT'), '$VAR'('INDEP_COLL_NAT')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, and(natFunction('$VAR'('NAT'), '$VAR'('FUNC')), isa('$VAR'('TERM'), '$VAR'('INDEP_COL')), natArgument('$VAR'('NAT'), '$VAR'('N'), '$VAR'('TERM')), interArgResultIsa('$VAR'('FUNC'), '$VAR'('N'), '$VAR'('INDEP_COL'), '$VAR'('DEP_COL'))), isa('$VAR'('NAT'), '$VAR'('DEP_COL')), 'CoreCycLMt', vStrDef).
assertedTinyKB(implies, and(natFunction('$VAR'('NAT'), '$VAR'('FUNC')), isa('$VAR'('TERM'), '$VAR'('INDEP_COL')), natArgument('$VAR'('NAT'), '$VAR'('ARG'), '$VAR'('TERM')), interArgResultIsa('$VAR'('FUNC'), '$VAR'('ARG'), '$VAR'('INDEP_COL'), '$VAR'('DEP_COL'))), isa('$VAR'('NAT'), '$VAR'('DEP_COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(natFunction('$VAR'('NAT'), '$VAR'('FUNC')), genls('$VAR'('COL'), '$VAR'('INDEP_COL')), natArgument('$VAR'('NAT'), '$VAR'('ARG'), '$VAR'('COL')), interArgResultGenl('$VAR'('FUNC'), '$VAR'('ARG'), '$VAR'('INDEP_COL'), '$VAR'('DEP_COL'))), genls('$VAR'('NAT'), '$VAR'('DEP_COL')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(minQuantValue('$VAR'('VALUE1'), '$VAR'('VALUE1MIN')), maxQuantValue('$VAR'('VALUE2'), '$VAR'('VALUE2MAX')), greaterThan('$VAR'('VALUE1MIN'), '$VAR'('VALUE2MAX'))), greaterThan('$VAR'('VALUE1'), '$VAR'('VALUE2')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(minQuantValue('$VAR'('MORE'), '$VAR'('MOREMIN')), greaterThan('$VAR'('MORE'), '$VAR'('LESS')), maxQuantValue('$VAR'('LESS'), '$VAR'('LESSMAX'))), greaterThan('$VAR'('MOREMIN'), '$VAR'('LESSMAX')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(minQuantValue('$VAR'('INTERVAL1'), '$VAR'('VALUE')), maxQuantValue('$VAR'('INTERVAL2'), '$VAR'('VALUE'))), quantityIntersects('$VAR'('INTERVAL1'), '$VAR'('INTERVAL2')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(minQuantValue('$VAR'('INTERVAL1'), '$VAR'('MIN')), minQuantValue('$VAR'('INTERVAL2'), '$VAR'('MIN'))), quantityIntersects('$VAR'('INTERVAL1'), '$VAR'('INTERVAL2')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(maxQuantValue('$VAR'('INTERVAL1'), '$VAR'('MAX1')), minQuantValue('$VAR'('INTERVAL1'), '$VAR'('MIN1')), minQuantValue('$VAR'('INTERVAL2'), '$VAR'('MIN2')), maxQuantValue('$VAR'('INTERVAL2'), '$VAR'('MAX2')), greaterThanOrEqualTo('$VAR'('MAX1'), '$VAR'('MAX2')), greaterThanOrEqualTo('$VAR'('MIN2'), '$VAR'('MIN1'))), quantitySubsumes('$VAR'('INTERVAL1'), '$VAR'('INTERVAL2')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(maxQuantValue('$VAR'('INTERVAL1'), '$VAR'('MAX1')), minQuantValue('$VAR'('INTERVAL1'), '$VAR'('MIN1')), minQuantValue('$VAR'('INTERVAL2'), '$VAR'('MIN2')), greaterThanOrEqualTo('$VAR'('MIN2'), '$VAR'('MIN1')), greaterThanOrEqualTo('$VAR'('MAX1'), '$VAR'('MIN2'))), quantityIntersects('$VAR'('INTERVAL1'), '$VAR'('INTERVAL2')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(maxQuantValue('$VAR'('INTERVAL1'), '$VAR'('MAX1')), minQuantValue('$VAR'('INTERVAL1'), '$VAR'('MIN1')), maxQuantValue('$VAR'('INTERVAL2'), '$VAR'('MAX2')), greaterThanOrEqualTo('$VAR'('MAX2'), '$VAR'('MIN1')), greaterThanOrEqualTo('$VAR'('MAX1'), '$VAR'('MAX2'))), quantityIntersects('$VAR'('INTERVAL1'), '$VAR'('INTERVAL2')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(maxQuantValue('$VAR'('INTERVAL1'), '$VAR'('MAX')), maxQuantValue('$VAR'('INTERVAL2'), '$VAR'('MAX'))), quantityIntersects('$VAR'('INTERVAL1'), '$VAR'('INTERVAL2')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(maxQuantValue('$VAR'('ATT'), holds('$VAR'('UNIT'), '$VAR'('VAL'))), minQuantValue('$VAR'('ATT'), holds('$VAR'('UNIT'), '$VAR'('VAL')))), equals('$VAR'('ATT'), holds('$VAR'('UNIT'), '$VAR'('VAL'))), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(ist('$VAR'('MT'), not(numericallyEquals('$VAR'('M'), '$VAR'('N')))), ist('$VAR'('MT'), relationAllExistsCount('$VAR'('REL'), '$VAR'('COL1'), '$VAR'('COL2'), '$VAR'('N')))), ist('$VAR'('MT'), not(relationAllExistsCount('$VAR'('REL'), '$VAR'('COL1'), '$VAR'('COL2'), '$VAR'('M')))), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('X'), '$VAR'('COL1')), trueSentence(forAll('$VAR'('Y'), or(isa('$VAR'('Y'), '$VAR'('COL2')), not(isa('$VAR'('Y'), '$VAR'('COL1'))))))), isa('$VAR'('X'), '$VAR'('COL2')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(isa('$VAR'('UNITPRODUCTFN'), 'UnitOfMeasure'), isa('$VAR'('PERFN'), 'UnitOfMeasure'), termOfUnit('$VAR'('PERFN'), 'PerFn'('$VAR'('UNIT1'), '$VAR'('UNIT2'))), termOfUnit('$VAR'('UNITPRODUCTFN'), 'UnitProductFn'('$VAR'('PERFN'), '$VAR'('UNIT2')))), equals('$VAR'('UNIT1'), '$VAR'('UNITPRODUCTFN')), 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(implies, and(isa('$VAR'('UNIT1'), 'UnitOfMeasure'), isa('$VAR'('UNIT2'), 'UnitOfMeasure'), evaluate('$VAR'('TIMESFN'), 'TimesFn'(holds('$VAR'('UNIT1'), '$VAR'('NUM2')), holds('$VAR'('UNIT2'), '$VAR'('NUM1')))), evaluate('$VAR'('TIMESFN_1'), 'TimesFn'(holds('$VAR'('UNIT1'), '$VAR'('NUM1')), holds('$VAR'('UNIT2'), '$VAR'('NUM2'))))), equals('$VAR'('TIMESFN'), '$VAR'('TIMESFN_1')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(isa('$VAR'('UNIT'), 'UnitOfMeasure'), quantityIntersects(holds('$VAR'('UNIT'), '$VAR'('NUM1A'), '$VAR'('NUM1B')), holds('$VAR'('UNIT'), '$VAR'('NUM2A'), '$VAR'('NUM2B')))), quantityIntersects('Unity'('$VAR'('NUM1A'), '$VAR'('NUM1B')), 'Unity'('$VAR'('NUM2A'), '$VAR'('NUM2B'))), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('UNIT'), 'UnitOfMeasure'), quantityIntersects(holds('$VAR'('UNIT'), '$VAR'('NUM1')), holds('$VAR'('UNIT'), '$VAR'('NUM2')))), quantityIntersects('$VAR'('NUM1'), '$VAR'('NUM2')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('UNIT'), 'UnitOfMeasure'), isa(holds('$VAR'('UNIT'), '$VAR'('M')), 'ScalarIntegralValue'), isa(holds('$VAR'('UNIT'), '$VAR'('N')), 'ScalarIntegralValue'), evaluate('$VAR'('TIMESFN'), 'TimesFn'(holds('$VAR'('UNIT'), '$VAR'('M')), holds('$VAR'('UNIT'), '$VAR'('N'))))), isa('$VAR'('TIMESFN'), 'ScalarIntegralValue'), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(isa('$VAR'('UNIT'), 'UnitOfMeasure'), isa(holds('$VAR'('UNIT'), '$VAR'('M')), 'ScalarIntegralValue'), isa(holds('$VAR'('UNIT'), '$VAR'('N')), 'ScalarIntegralValue'), evaluate('$VAR'('PLUSFN'), 'PlusFn'(holds('$VAR'('UNIT'), '$VAR'('M')), holds('$VAR'('UNIT'), '$VAR'('N'))))), isa('$VAR'('PLUSFN'), 'ScalarIntegralValue'), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(isa('$VAR'('UNIT'), 'UnitOfMeasure'), isa(holds('$VAR'('UNIT'), '$VAR'('M')), 'ScalarIntegralValue'), isa(holds('$VAR'('UNIT'), '$VAR'('N')), 'ScalarIntegralValue'), evaluate('$VAR'('DIFFERENCEFN'), 'DifferenceFn'(holds('$VAR'('UNIT'), '$VAR'('M')), holds('$VAR'('UNIT'), '$VAR'('N'))))), isa('$VAR'('DIFFERENCEFN'), 'ScalarIntegralValue'), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('UNIT'), 'UnitOfMeasure'), greaterThan(holds('$VAR'('UNIT'), '$VAR'('NUM1A'), '$VAR'('NUM1B')), holds('$VAR'('UNIT'), '$VAR'('NUM2A'), '$VAR'('NUM2B')))), greaterThan('Unity'('$VAR'('NUM1A'), '$VAR'('NUM1B')), 'Unity'('$VAR'('NUM2A'), '$VAR'('NUM2B'))), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('UNIT'), 'UnitOfMeasure'), greaterThan(holds('$VAR'('UNIT'), '$VAR'('NUM1')), holds('$VAR'('UNIT'), '$VAR'('NUM2')))), greaterThan('$VAR'('NUM1'), '$VAR'('NUM2')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('UNIT'), 'UnitOfMeasure'), equals('$VAR'('QUANT'), holds('$VAR'('UNIT'), '$VAR'('NUM')))), equals('$VAR'('QUANT'), holds('$VAR'('UNIT'), '$VAR'('NUM'), '$VAR'('NUM'))), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('THING'), '$VAR'('UNIVCOL')), relationAllExists('$VAR'('PRED'), '$VAR'('UNIVCOL'), '$VAR'('EXISTCOL'))), trueSentence(thereExists('$VAR'('OTHER'), and(isa('$VAR'('OTHER'), '$VAR'('EXISTCOL')), holds('$VAR'('PRED'), '$VAR'('THING'), '$VAR'('OTHER'))))), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('THING'), '$VAR'('COL1')), coExtensional('$VAR'('COL1'), '$VAR'('COL2'))), isa('$VAR'('THING'), '$VAR'('COL2')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(isa('$VAR'('TERM'), '$VAR'('INDEP_COL')), relationExistsAll('$VAR'('PRED'), '$VAR'('DEP_COL'), '$VAR'('INDEP_COL'))), isa('RelationExistsAllFn'('$VAR'('TERM'), '$VAR'('PRED'), '$VAR'('DEP_COL'), '$VAR'('INDEP_COL')), '$VAR'('DEP_COL')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(isa('$VAR'('TERM'), '$VAR'('INDEP_COL')), relationExistsAll('$VAR'('PRED'), '$VAR'('DEP_COL'), '$VAR'('INDEP_COL'))), holds('$VAR'('PRED'), 'RelationExistsAllFn'('$VAR'('TERM'), '$VAR'('PRED'), '$VAR'('DEP_COL'), '$VAR'('INDEP_COL')), '$VAR'('TERM')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(isa('$VAR'('TERM'), '$VAR'('INDEP_COL')), relationAllExists('$VAR'('PRED'), '$VAR'('INDEP_COL'), '$VAR'('DEP_COL'))), isa('RelationAllExistsFn'('$VAR'('TERM'), '$VAR'('PRED'), '$VAR'('INDEP_COL'), '$VAR'('DEP_COL')), '$VAR'('DEP_COL')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(isa('$VAR'('TERM'), '$VAR'('INDEP_COL')), relationAllExists('$VAR'('PRED'), '$VAR'('INDEP_COL'), '$VAR'('DEP_COL'))), holds('$VAR'('PRED'), '$VAR'('TERM'), 'RelationAllExistsFn'('$VAR'('TERM'), '$VAR'('PRED'), '$VAR'('INDEP_COL'), '$VAR'('DEP_COL'))), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(isa('$VAR'('SPEC_PRED'), 'ReflexiveBinaryPredicate'), genlInverse('$VAR'('SPEC_PRED'), '$VAR'('GENL_PRED')), different('$VAR'('GENL_PRED'), '$VAR'('SPEC_PRED')), arg1Isa('$VAR'('SPEC_PRED'), '$VAR'('ARG1ISA')), arg2Isa('$VAR'('GENL_PRED'), '$VAR'('ARG1ISA')), arg2Isa('$VAR'('SPEC_PRED'), '$VAR'('ARG2ISA')), arg1Isa('$VAR'('GENL_PRED'), '$VAR'('ARG2ISA'))), isa('$VAR'('GENL_PRED'), 'ReflexiveBinaryPredicate'), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(isa('$VAR'('SMALLER_UNIT'), 'UnitOfMeasure'), isa('$VAR'('LARGER_UNIT'), 'UnitOfMeasure'), unitMultiplicationFactor('$VAR'('SMALLER_UNIT'), '$VAR'('LARGER_UNIT'), '$VAR'('N')), evaluate('$VAR'('TIMESFN'), 'TimesFn'('$VAR'('M'), holds('$VAR'('SMALLER_UNIT'), '$VAR'('N'))))), equals('$VAR'('TIMESFN'), holds('$VAR'('LARGER_UNIT'), '$VAR'('M'))), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('SMALLER_UNIT'), 'UnitOfMeasure'), isa('$VAR'('LARGER_UNIT'), 'UnitOfMeasure'), unitMultiplicationFactor('$VAR'('SMALLER_UNIT'), '$VAR'('LARGER_UNIT'), '$VAR'('N'))), equals(holds('$VAR'('LARGER_UNIT'), 1), holds('$VAR'('SMALLER_UNIT'), '$VAR'('N'))), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('SLOT'), 'IrreflexiveBinaryPredicate'), isa('$VAR'('SLOT'), 'TransitiveBinaryPredicate')), isa('$VAR'('SLOT'), 'AsymmetricBinaryPredicate'), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('SLOT'), 'AntiSymmetricBinaryPredicate'), isa('$VAR'('SLOT'), 'IrreflexiveBinaryPredicate')), isa('$VAR'('SLOT'), 'AsymmetricBinaryPredicate'), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('SIBDIS_COL'), 'SiblingDisjointCollectionType'), isa('$VAR'('COL1'), '$VAR'('SIBDIS_COL')), isa('$VAR'('COL2'), '$VAR'('SIBDIS_COL'))), or(genls('$VAR'('COL1'), '$VAR'('COL2')), disjointWith('$VAR'('COL1'), '$VAR'('COL2')), siblingDisjointExceptions('$VAR'('COL1'), '$VAR'('COL2')), genls('$VAR'('COL2'), '$VAR'('COL1'))), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('RELN'), 'MicrotheoryDesignatingRelation'), sentenceDesignationArgnum('$VAR'('RELN'), '$VAR'('NUM'))), argIsa('$VAR'('RELN'), '$VAR'('NUM'), 'CycLSentence-Assertible'), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('RELN'), 'MicrotheoryDesignatingRelation'), microtheoryDesignationArgnum('$VAR'('RELN'), '$VAR'('NUM'))), argIsa('$VAR'('RELN'), '$VAR'('NUM'), 'Microtheory'), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('RELN'), 'MicrotheoryDesignatingRelation'), isa('$VAR'('RELN'), 'VariableArityRelation'), arityMin('$VAR'('RELN'), '$VAR'('ARITY_MIN'))), greaterThanOrEqualTo('$VAR'('ARITY_MIN'), 2), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('RELN'), 'FixedArityRelation'), isa('$VAR'('RELN'), 'MicrotheoryDesignatingRelation'), arity('$VAR'('RELN'), '$VAR'('ARITY'))), greaterThanOrEqualTo('$VAR'('ARITY'), 2), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('RELN'), 'CommutativeRelation'), arity('$VAR'('RELN'), '$VAR'('ARITY')), integerBetween(0, '$VAR'('M'), '$VAR'('ARITY')), different('$VAR'('M'), '$VAR'('N')), integerBetween(0, '$VAR'('N'), '$VAR'('ARITY'))), commutativeInArgs('$VAR'('RELN'), '$VAR'('M'), '$VAR'('N')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(isa('$VAR'('REL'), 'TransitiveBinaryPredicate'), relationExistsMaxAll('$VAR'('REL'), '$VAR'('TYPE2'), '$VAR'('TYPE3'), 1), relationAllExistsCount('$VAR'('REL'), '$VAR'('TYPE1'), '$VAR'('TYPE2'), '$VAR'('X')), relationAllExistsCount('$VAR'('REL'), '$VAR'('TYPE2'), '$VAR'('TYPE3'), '$VAR'('Y')), evaluate('$VAR'('TIMESFN'), 'TimesFn'('$VAR'('X'), '$VAR'('Y')))), relationAllExistsMin('$VAR'('REL'), '$VAR'('TYPE1'), '$VAR'('TYPE3'), '$VAR'('TIMESFN')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('REL'), 'PartiallyCommutativeRelation'), arity('$VAR'('REL'), '$VAR'('N'))), greaterThanOrEqualTo('$VAR'('N'), 3), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('PRED'), 'TransitiveBinaryPredicate'), relationExistsAll('$VAR'('PRED'), '$VAR'('COL1'), '$VAR'('COL2')), relationExistsAll('$VAR'('PRED'), '$VAR'('COL2'), '$VAR'('COL3'))), relationExistsAll('$VAR'('PRED'), '$VAR'('COL1'), '$VAR'('COL3')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(isa('$VAR'('PRED'), 'TransitiveBinaryPredicate'), relationAllExists('$VAR'('PRED'), '$VAR'('COL1'), '$VAR'('COL2')), relationAllExists('$VAR'('PRED'), '$VAR'('COL2'), '$VAR'('COL3'))), relationAllExists('$VAR'('PRED'), '$VAR'('COL1'), '$VAR'('COL3')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('PRED'), 'TransitiveBinaryPredicate'), holdsIn('$VAR'('TIME'), holds('$VAR'('PRED'), '$VAR'('ARG1'), '$VAR'('ARG2'))), holdsIn('$VAR'('TIME'), holds('$VAR'('PRED'), '$VAR'('ARG2'), '$VAR'('ARG3')))), holdsIn('$VAR'('TIME'), holds('$VAR'('PRED'), '$VAR'('ARG1'), '$VAR'('ARG3'))), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('PRED'), 'TransitiveBinaryPredicate'), holds('$VAR'('PRED'), '$VAR'('X'), '$VAR'('Y')), holds('$VAR'('PRED'), '$VAR'('Y'), '$VAR'('Z'))), holds('$VAR'('PRED'), '$VAR'('X'), '$VAR'('Z')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('PRED'), 'TernaryPredicate'), commutativeInArgs('$VAR'('PRED'), 2, 3), holds('$VAR'('PRED'), '$VAR'('ARG1'), '$VAR'('ARG2'), '$VAR'('ARG3'))), holds('$VAR'('PRED'), '$VAR'('ARG1'), '$VAR'('ARG3'), '$VAR'('ARG2')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('PRED'), 'TernaryPredicate'), commutativeInArgs('$VAR'('PRED'), 1, 3), holds('$VAR'('PRED'), '$VAR'('ARG1'), '$VAR'('ARG2'), '$VAR'('ARG3'))), holds('$VAR'('PRED'), '$VAR'('ARG3'), '$VAR'('ARG2'), '$VAR'('ARG1')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('PRED'), 'TernaryPredicate'), commutativeInArgs('$VAR'('PRED'), 1, 2), holds('$VAR'('PRED'), '$VAR'('ARG1'), '$VAR'('ARG2'), '$VAR'('ARG3'))), holds('$VAR'('PRED'), '$VAR'('ARG2'), '$VAR'('ARG1'), '$VAR'('ARG3')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('PRED'), 'SymmetricBinaryPredicate'), holds('$VAR'('PRED'), '$VAR'('ARG1'), '$VAR'('ARG2'))), holds('$VAR'('PRED'), '$VAR'('ARG2'), '$VAR'('ARG1')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('PRED'), 'SymmetricBinaryPredicate'), genlPreds('$VAR'('PRED'), '$VAR'('GENL_PRED')), holds('$VAR'('PRED'), '$VAR'('ARG_1'), '$VAR'('ARG_2'))), holds('$VAR'('GENL_PRED'), '$VAR'('ARG_2'), '$VAR'('ARG_1')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('PRED'), 'SymmetricBinaryPredicate'), 'interArgIsa2-1'('$VAR'('PRED'), '$VAR'('COL'), '$VAR'('COL'))), 'interArgIsa1-2'('$VAR'('PRED'), '$VAR'('COL'), '$VAR'('COL')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('PRED'), 'SymmetricBinaryPredicate'), 'interArgIsa1-2'('$VAR'('PRED'), '$VAR'('COL'), '$VAR'('COL'))), 'interArgIsa2-1'('$VAR'('PRED'), '$VAR'('COL'), '$VAR'('COL')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('PRED'), 'ReflexiveBinaryPredicate'), arg1Isa('$VAR'('PRED'), '$VAR'('CONSTRAINT1')), isa('$VAR'('OBJ1'), '$VAR'('CONSTRAINT1')), equals('$VAR'('OBJ1'), '$VAR'('OBJ2'))), holds('$VAR'('PRED'), '$VAR'('OBJ1'), '$VAR'('OBJ2')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(isa('$VAR'('PRED'), 'ReflexiveBinaryPredicate'), admittedArgument('$VAR'('THING'), 1, '$VAR'('PRED')), admittedArgument('$VAR'('THING'), 2, '$VAR'('PRED')), equals('$VAR'('SAMETHING'), '$VAR'('THING'))), holds('$VAR'('PRED'), '$VAR'('THING'), '$VAR'('SAMETHING')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(isa('$VAR'('PRED'), 'ReflexiveBinaryPredicate'), admittedArgument('$VAR'('OBJ'), 1, '$VAR'('PRED')), admittedArgument('$VAR'('OBJ'), 2, '$VAR'('PRED'))), holds('$VAR'('PRED'), '$VAR'('OBJ'), '$VAR'('OBJ')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(isa('$VAR'('PRED'), 'QuaternaryPredicate'), commutativeInArgs('$VAR'('PRED'), 3, 4), holds('$VAR'('PRED'), '$VAR'('ARG1'), '$VAR'('ARG2'), '$VAR'('ARG3'), '$VAR'('ARG4'))), holds('$VAR'('PRED'), '$VAR'('ARG1'), '$VAR'('ARG2'), '$VAR'('ARG4'), '$VAR'('ARG3')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('PRED'), 'QuaternaryPredicate'), commutativeInArgs('$VAR'('PRED'), 2, 4), holds('$VAR'('PRED'), '$VAR'('ARG1'), '$VAR'('ARG2'), '$VAR'('ARG3'), '$VAR'('ARG4'))), holds('$VAR'('PRED'), '$VAR'('ARG1'), '$VAR'('ARG4'), '$VAR'('ARG3'), '$VAR'('ARG2')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('PRED'), 'QuaternaryPredicate'), commutativeInArgs('$VAR'('PRED'), 2, 3), holds('$VAR'('PRED'), '$VAR'('ARG1'), '$VAR'('ARG2'), '$VAR'('ARG3'), '$VAR'('ARG4'))), holds('$VAR'('PRED'), '$VAR'('ARG1'), '$VAR'('ARG3'), '$VAR'('ARG2'), '$VAR'('ARG4')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('PRED'), 'QuaternaryPredicate'), commutativeInArgs('$VAR'('PRED'), 1, 4), holds('$VAR'('PRED'), '$VAR'('ARG1'), '$VAR'('ARG2'), '$VAR'('ARG3'), '$VAR'('ARG4'))), holds('$VAR'('PRED'), '$VAR'('ARG4'), '$VAR'('ARG2'), '$VAR'('ARG3'), '$VAR'('ARG1')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('PRED'), 'QuaternaryPredicate'), commutativeInArgs('$VAR'('PRED'), 1, 3), holds('$VAR'('PRED'), '$VAR'('ARG1'), '$VAR'('ARG2'), '$VAR'('ARG3'), '$VAR'('ARG4'))), holds('$VAR'('PRED'), '$VAR'('ARG3'), '$VAR'('ARG2'), '$VAR'('ARG1'), '$VAR'('ARG4')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('PRED'), 'QuaternaryPredicate'), commutativeInArgs('$VAR'('PRED'), 1, 2), holds('$VAR'('PRED'), '$VAR'('ARG1'), '$VAR'('ARG2'), '$VAR'('ARG3'), '$VAR'('ARG4'))), holds('$VAR'('PRED'), '$VAR'('ARG2'), '$VAR'('ARG1'), '$VAR'('ARG3'), '$VAR'('ARG4')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('PRED'), 'IrreflexiveBinaryPredicate'), holds('$VAR'('PRED'), '$VAR'('OBJ1'), '$VAR'('OBJ2'))), different('$VAR'('OBJ1'), '$VAR'('OBJ2')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('PRED'), 'FixedArityRelation'), arity('$VAR'('PRED'), '$VAR'('ARITY')), genlPreds('$VAR'('SPECPRED'), '$VAR'('PRED'))), arity('$VAR'('SPECPRED'), '$VAR'('ARITY')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('PRED'), 'BinaryPredicate'), isa('$VAR'('PRED'), 'CommutativeRelation')), isa('$VAR'('PRED'), 'SymmetricBinaryPredicate'), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(isa('$VAR'('PRED'), 'BinaryPredicate'), arg2Isa('$VAR'('PRED'), '$VAR'('COL2')), requiredArg1Pred('$VAR'('COL1'), '$VAR'('PRED'))), relationAllExists('$VAR'('PRED'), '$VAR'('COL1'), '$VAR'('COL2')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(isa('$VAR'('POINT1'), 'ScalarPointValue'), minQuantValue('$VAR'('POINT1'), '$VAR'('POINT2'))), equals('$VAR'('POINT1'), '$VAR'('POINT2')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(isa('$VAR'('POINT1'), 'ScalarPointValue'), maxQuantValue('$VAR'('POINT1'), '$VAR'('POINT2'))), equals('$VAR'('POINT1'), '$VAR'('POINT2')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(isa('$VAR'('OBJECT2'), '$VAR'('TYPE')), holds('$VAR'('RELATION'), '$VAR'('OBJECT1'), '$VAR'('OBJECT2'))), relationInstanceExists('$VAR'('RELATION'), '$VAR'('OBJECT1'), '$VAR'('TYPE')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('OBJECT1'), '$VAR'('TYPE')), holds('$VAR'('RELATION'), '$VAR'('OBJECT1'), '$VAR'('OBJECT2'))), relationExistsInstance('$VAR'('RELATION'), '$VAR'('TYPE'), '$VAR'('OBJECT2')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('OBJ_1'), '$VAR'('COMMON_NEAR')), isa('$VAR'('OBJ_2'), '$VAR'('COMMON_NEAR'))), or(nearestCommonIsa('$VAR'('OBJ_1'), '$VAR'('OBJ_2'), '$VAR'('COMMON_NEAR')), elementOf('$VAR'('COMMON_NEAR'), 'TheSetOf'('$VAR'('COMMON_FARTHER'), thereExists('$VAR'('COMMON_FAR'), and(isa('$VAR'('OBJ_1'), '$VAR'('COMMON_FAR')), isa('$VAR'('OBJ_2'), '$VAR'('COMMON_FAR')), genls('$VAR'('COMMON_FAR'), '$VAR'('COMMON_FARTHER')), different('$VAR'('COMMON_FAR'), '$VAR'('COMMON_FARTHER'))))))), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('OBJ'), '$VAR'('SUBSET')), genls('$VAR'('SUBSET'), '$VAR'('SUPERSET'))), isa('$VAR'('OBJ'), '$VAR'('SUPERSET')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(isa('$VAR'('OBJ'), '$VAR'('COL_2')), relationExistsAll('$VAR'('PRED'), '$VAR'('COL_1'), '$VAR'('COL_2'))), relationExistsInstance('$VAR'('PRED'), '$VAR'('COL_1'), '$VAR'('OBJ')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(isa('$VAR'('OBJ'), '$VAR'('COL_1')), relationAllExists('$VAR'('PRED'), '$VAR'('COL_1'), '$VAR'('COL_2'))), relationInstanceExists('$VAR'('PRED'), '$VAR'('OBJ'), '$VAR'('COL_2')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(isa('$VAR'('OBJ'), '$VAR'('COL')), conceptuallyRelated('$VAR'('COL'), '$VAR'('REL_OBJ'))), conceptuallyRelated('$VAR'('OBJ'), '$VAR'('REL_OBJ')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('NUM'), 'Integer'), isa(holds('$VAR'('UNIT1'), '$VAR'('M')), 'ScalarIntegralValue'), isa(holds('$VAR'('UNIT2'), '$VAR'('N')), 'ScalarIntegralValue'), unitMultiplicationFactor('$VAR'('UNIT1'), '$VAR'('UNIT2'), '$VAR'('NUM')), evaluate('$VAR'('TIMESFN'), 'TimesFn'(holds('$VAR'('UNIT1'), '$VAR'('M')), holds('$VAR'('UNIT2'), '$VAR'('N'))))), isa('$VAR'('TIMESFN'), 'ScalarIntegralValue'), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(isa('$VAR'('NUM'), 'Integer'), isa(holds('$VAR'('UNIT1'), '$VAR'('M')), 'ScalarIntegralValue'), isa(holds('$VAR'('UNIT2'), '$VAR'('N')), 'ScalarIntegralValue'), unitMultiplicationFactor('$VAR'('UNIT1'), '$VAR'('UNIT2'), '$VAR'('NUM')), evaluate('$VAR'('PLUSFN'), 'PlusFn'(holds('$VAR'('UNIT1'), '$VAR'('M')), holds('$VAR'('UNIT2'), '$VAR'('N'))))), isa('$VAR'('PLUSFN'), 'ScalarIntegralValue'), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(isa('$VAR'('NUM'), 'Integer'), isa(holds('$VAR'('UNIT1'), '$VAR'('M')), 'ScalarIntegralValue'), isa(holds('$VAR'('UNIT2'), '$VAR'('N')), 'ScalarIntegralValue'), unitMultiplicationFactor('$VAR'('UNIT1'), '$VAR'('UNIT2'), '$VAR'('NUM')), evaluate('$VAR'('DIFFERENCEFN'), 'DifferenceFn'(holds('$VAR'('UNIT1'), '$VAR'('M')), holds('$VAR'('UNIT2'), '$VAR'('N'))))), isa('$VAR'('DIFFERENCEFN'), 'ScalarIntegralValue'), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(isa('$VAR'('N'), 'PositiveInteger'), greaterThanOrEqualTo('$VAR'('N'), '$VAR'('ARGNUM')), greaterThanOrEqualTo('$VAR'('ARITY'), '$VAR'('N')), arity('$VAR'('RELN'), '$VAR'('ARITY')), canonicalizerDirectiveForArgAndRest('$VAR'('RELN'), '$VAR'('ARGNUM'), '$VAR'('DIRECTIVE'))), canonicalizerDirectiveForArg('$VAR'('RELN'), '$VAR'('N'), '$VAR'('DIRECTIVE')), 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(implies, and(isa('$VAR'('N'), 'PositiveInteger'), greaterThanOrEqualTo('$VAR'('ARITY'), '$VAR'('N')), arity('$VAR'('RELN'), '$VAR'('ARITY')), canonicalizerDirectiveForAllArgs('$VAR'('RELN'), '$VAR'('DIRECTIVE'))), canonicalizerDirectiveForArg('$VAR'('RELN'), '$VAR'('N'), '$VAR'('DIRECTIVE')), 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(implies, and(isa('$VAR'('M'), 'PositiveInteger'), isa('$VAR'('N'), 'PositiveInteger'), different('$VAR'('M'), '$VAR'('N'), 1)), interArgDifferent(commutativeInArgs, '$VAR'('M'), '$VAR'('N')), 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(implies, and(isa('$VAR'('LOW'), 'ScalarPointValue'), isa('$VAR'('UNIT'), 'UnitOfMeasure')), minQuantValue(holds('$VAR'('UNIT'), '$VAR'('LOW'), '$VAR'('HIGH')), holds('$VAR'('UNIT'), '$VAR'('LOW'))), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('INTERVAL1'), 'ScalarPointValue'), isa('$VAR'('INTERVAL2'), 'ScalarPointValue'), quantityIntersects('$VAR'('INTERVAL1'), '$VAR'('INTERVAL2'))), numericallyEquals('$VAR'('INTERVAL1'), '$VAR'('INTERVAL2')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('INTERVAL1'), 'ScalarInterval'), isa('$VAR'('INTERVAL2'), 'ScalarInterval'), equals('$VAR'('INTERVAL1'), '$VAR'('INTERVAL2'))), numericallyEquals('$VAR'('INTERVAL1'), '$VAR'('INTERVAL2')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('INT'), 'Integer'), isa('$VAR'('UNIT'), 'UnitOfMeasure')), isa(holds('$VAR'('UNIT'), '$VAR'('INT')), 'ScalarIntegralValue'), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(isa('$VAR'('INST_UNIV'), '$VAR'('UNIV_COL')), relationAllExistsCount('$VAR'('REL'), '$VAR'('UNIV_COL'), '$VAR'('EXIST_COL'), '$VAR'('NUM'))), trueSentence(thereExistExactly('$VAR'('NUM'), '$VAR'('INST_EXIST'), and(isa('$VAR'('INST_EXIST'), '$VAR'('EXIST_COL')), holds('$VAR'('REL'), '$VAR'('INST_UNIV'), '$VAR'('INST_EXIST'))))), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('INST'), '$VAR'('COL2')), relationAllInstance('$VAR'('PRED'), '$VAR'('COL1'), '$VAR'('INST'))), relationAllExists('$VAR'('PRED'), '$VAR'('COL1'), '$VAR'('COL2')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(isa('$VAR'('INST'), '$VAR'('COL')), relationInstanceAll('$VAR'('PRED'), '$VAR'('THING'), '$VAR'('COL'))), holds('$VAR'('PRED'), '$VAR'('THING'), '$VAR'('INST')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('INST'), '$VAR'('COL')), relationAllInstance('$VAR'('PRED'), '$VAR'('COL'), '$VAR'('THING'))), trueSentence(holds('$VAR'('PRED'), '$VAR'('INST'), '$VAR'('THING'))), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('INST'), '$VAR'('COL')), relationAllInstance('$VAR'('PRED'), '$VAR'('COL'), '$VAR'('THING'))), holds('$VAR'('PRED'), '$VAR'('INST'), '$VAR'('THING')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('INST'), '$VAR'('COL')), admittedAllArgument('$VAR'('COL'), '$VAR'('NUM'), '$VAR'('RELN'))), admittedArgument('$VAR'('INST'), '$VAR'('NUM'), '$VAR'('RELN')), 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(implies, and(isa('$VAR'('INS1'), tPred), isa('$VAR'('INS2'), 'SymmetricBinaryPredicate'), isa('$VAR'('INS3'), 'PositiveInteger'), transitiveViaArgInverse('$VAR'('INS1'), '$VAR'('INS2'), '$VAR'('INS3'))), transitiveViaArg('$VAR'('INS1'), '$VAR'('INS2'), '$VAR'('INS3')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('INS1'), tPred), isa('$VAR'('INS2'), 'SymmetricBinaryPredicate'), isa('$VAR'('INS3'), 'PositiveInteger'), transitiveViaArg('$VAR'('INS1'), '$VAR'('INS2'), '$VAR'('INS3'))), transitiveViaArgInverse('$VAR'('INS1'), '$VAR'('INS2'), '$VAR'('INS3')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('INS'), '$VAR'('SPEC')), genls('$VAR'('SPEC'), '$VAR'('GENL'))), isa('$VAR'('INS'), '$VAR'('GENL')), 'LogicalTruthMt', vStrMon).
assertedTinyKB(implies, and(isa('$VAR'('INS'), '$VAR'('COLL')), relationAllInstance(quotedIsa, '$VAR'('COLL'), '$VAR'('QUOTED_COLL'))), quotedIsa('$VAR'('INS'), '$VAR'('QUOTED_COLL')), 'BookkeepingMt', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('INS'), '$VAR'('COL')), trueSentence(holds('$VAR'('PRED'), '$VAR'('INS'), '$VAR'('VALUE')))), relationExistsInstance('$VAR'('PRED'), '$VAR'('COL'), '$VAR'('VALUE')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('INDEP_INS'), '$VAR'('INDEP_COL')), holds('$VAR'('PRED'), '$VAR'('DEP_INS'), '$VAR'('INDEP_INS')), 'interArgIsa2-1'('$VAR'('PRED'), '$VAR'('INDEP_COL'), '$VAR'('DEP_COL'))), isa('$VAR'('DEP_INS'), '$VAR'('DEP_COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('INDEP_INS'), '$VAR'('INDEP_COL')), 'interArgIsa5-4'('$VAR'('PRED'), '$VAR'('INDEP_COL'), '$VAR'('DEP_COL')), holds('$VAR'('PRED'), '$VAR'('ANY_ARG_1'), '$VAR'('ANY_ARG_2'), '$VAR'('ANY_ARG_3'), '$VAR'('DEP_INS'), '$VAR'('INDEP_INS'))), isa('$VAR'('DEP_INS'), '$VAR'('DEP_COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('INDEP_INS'), '$VAR'('INDEP_COL')), 'interArgIsa5-3'('$VAR'('PRED'), '$VAR'('INDEP_COL'), '$VAR'('DEP_COL')), holds('$VAR'('PRED'), '$VAR'('ANY_ARG_1'), '$VAR'('ANY_ARG_2'), '$VAR'('DEP_INS'), '$VAR'('ANY_ARG_4'), '$VAR'('INDEP_INS'))), isa('$VAR'('DEP_INS'), '$VAR'('DEP_COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('INDEP_INS'), '$VAR'('INDEP_COL')), 'interArgIsa5-2'('$VAR'('PRED'), '$VAR'('INDEP_COL'), '$VAR'('DEP_COL')), holds('$VAR'('PRED'), '$VAR'('ANY_ARG_1'), '$VAR'('DEP_INS'), '$VAR'('ANY_ARG_3'), '$VAR'('ANY_ARG_4'), '$VAR'('INDEP_INS'))), isa('$VAR'('DEP_INS'), '$VAR'('DEP_COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('INDEP_INS'), '$VAR'('INDEP_COL')), 'interArgIsa5-1'('$VAR'('PRED'), '$VAR'('INDEP_COL'), '$VAR'('DEP_COL')), holds('$VAR'('PRED'), '$VAR'('DEP_INS'), '$VAR'('ANY_ARG_2'), '$VAR'('ANY_ARG_3'), '$VAR'('ANY_ARG_4'), '$VAR'('INDEP_INS'))), isa('$VAR'('DEP_INS'), '$VAR'('DEP_COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('INDEP_INS'), '$VAR'('INDEP_COL')), 'interArgIsa4-5'('$VAR'('PRED'), '$VAR'('INDEP_COL'), '$VAR'('DEP_COL')), holds('$VAR'('PRED'), '$VAR'('ANY_ARG_1'), '$VAR'('ANY_ARG_2'), '$VAR'('ANY_ARG_3'), '$VAR'('INDEP_INS'), '$VAR'('DEP_INS'))), isa('$VAR'('DEP_INS'), '$VAR'('DEP_COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('INDEP_INS'), '$VAR'('INDEP_COL')), 'interArgIsa4-3'('$VAR'('PRED'), '$VAR'('INDEP_COL'), '$VAR'('DEP_COL')), holds('$VAR'('PRED'), '$VAR'('ANY_ARG_1'), '$VAR'('ANY_ARG_2'), '$VAR'('DEP_INS'), '$VAR'('INDEP_INS'))), isa('$VAR'('DEP_INS'), '$VAR'('DEP_COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('INDEP_INS'), '$VAR'('INDEP_COL')), 'interArgIsa4-2'('$VAR'('PRED'), '$VAR'('INDEP_COL'), '$VAR'('DEP_COL')), holds('$VAR'('PRED'), '$VAR'('ANY_ARG_1'), '$VAR'('DEP_INS'), '$VAR'('ANY_ARG_3'), '$VAR'('INDEP_INS'))), isa('$VAR'('DEP_INS'), '$VAR'('DEP_COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('INDEP_INS'), '$VAR'('INDEP_COL')), 'interArgIsa4-1'('$VAR'('PRED'), '$VAR'('INDEP_COL'), '$VAR'('DEP_COL')), holds('$VAR'('PRED'), '$VAR'('DEP_INS'), '$VAR'('ANY_ARG_2'), '$VAR'('ANY_ARG_3'), '$VAR'('INDEP_INS'))), isa('$VAR'('DEP_INS'), '$VAR'('DEP_COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('INDEP_INS'), '$VAR'('INDEP_COL')), 'interArgIsa3-5'('$VAR'('PRED'), '$VAR'('INDEP_COL'), '$VAR'('DEP_COL')), holds('$VAR'('PRED'), '$VAR'('ANY_ARG_1'), '$VAR'('ANY_ARG_2'), '$VAR'('INDEP_INS'), '$VAR'('ANY_ARG_4'), '$VAR'('DEP_INS'))), isa('$VAR'('DEP_INS'), '$VAR'('DEP_COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('INDEP_INS'), '$VAR'('INDEP_COL')), 'interArgIsa3-4'('$VAR'('PRED'), '$VAR'('INDEP_COL'), '$VAR'('DEP_COL')), holds('$VAR'('PRED'), '$VAR'('ANY_ARG_1'), '$VAR'('ANY_ARG_2'), '$VAR'('INDEP_INS'), '$VAR'('DEP_INS'))), isa('$VAR'('DEP_INS'), '$VAR'('DEP_COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('INDEP_INS'), '$VAR'('INDEP_COL')), 'interArgIsa3-2'('$VAR'('PRED'), '$VAR'('INDEP_COL'), '$VAR'('DEP_COL')), holds('$VAR'('PRED'), '$VAR'('ANY_ARG_1'), '$VAR'('DEP_INS'), '$VAR'('INDEP_INS'))), isa('$VAR'('DEP_INS'), '$VAR'('DEP_COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('INDEP_INS'), '$VAR'('INDEP_COL')), 'interArgIsa3-1'('$VAR'('PRED'), '$VAR'('INDEP_COL'), '$VAR'('DEP_COL')), holds('$VAR'('PRED'), '$VAR'('DEP_INS'), '$VAR'('ANY_ARG_2'), '$VAR'('INDEP_INS'))), isa('$VAR'('DEP_INS'), '$VAR'('DEP_COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('INDEP_INS'), '$VAR'('INDEP_COL')), 'interArgIsa2-5'('$VAR'('PRED'), '$VAR'('INDEP_COL'), '$VAR'('DEP_COL')), holds('$VAR'('PRED'), '$VAR'('ANY_ARG_1'), '$VAR'('INDEP_INS'), '$VAR'('ANY_ARG_3'), '$VAR'('ANY_ARG_4'), '$VAR'('DEP_INS'))), isa('$VAR'('DEP_INS'), '$VAR'('DEP_COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('INDEP_INS'), '$VAR'('INDEP_COL')), 'interArgIsa2-4'('$VAR'('PRED'), '$VAR'('INDEP_COL'), '$VAR'('DEP_COL')), holds('$VAR'('PRED'), '$VAR'('ANY_ARG_1'), '$VAR'('INDEP_INS'), '$VAR'('ANY_ARG_3'), '$VAR'('DEP_INS'))), isa('$VAR'('DEP_INS'), '$VAR'('DEP_COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('INDEP_INS'), '$VAR'('INDEP_COL')), 'interArgIsa2-3'('$VAR'('PRED'), '$VAR'('INDEP_COL'), '$VAR'('DEP_COL')), holds('$VAR'('PRED'), '$VAR'('ANY_ARG_1'), '$VAR'('INDEP_INS'), '$VAR'('DEP_INS'))), isa('$VAR'('DEP_INS'), '$VAR'('DEP_COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('INDEP_INS'), '$VAR'('INDEP_COL')), 'interArgIsa1-5'('$VAR'('PRED'), '$VAR'('INDEP_COL'), '$VAR'('DEP_COL')), holds('$VAR'('PRED'), '$VAR'('INDEP_INS'), '$VAR'('ANY_ARG_2'), '$VAR'('ANY_ARG_3'), '$VAR'('ANY_ARG_4'), '$VAR'('DEP_INS'))), isa('$VAR'('DEP_INS'), '$VAR'('DEP_COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('INDEP_INS'), '$VAR'('INDEP_COL')), 'interArgIsa1-4'('$VAR'('PRED'), '$VAR'('INDEP_COL'), '$VAR'('DEP_COL')), holds('$VAR'('PRED'), '$VAR'('INDEP_INS'), '$VAR'('ANY_ARG_2'), '$VAR'('ANY_ARG_3'), '$VAR'('DEP_INS'))), isa('$VAR'('DEP_INS'), '$VAR'('DEP_COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('INDEP_INS'), '$VAR'('INDEP_COL')), 'interArgIsa1-3'('$VAR'('PRED'), '$VAR'('INDEP_COL'), '$VAR'('DEP_COL')), dot_holds(['$VAR'('PRED'), '$VAR'('INDEP_INS'), '$VAR'('_ANY_ARG_2'), '$VAR'('DEP_INS')|'$VAR'('_ARGS')])), isa('$VAR'('DEP_INS'), '$VAR'('DEP_COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('INDEP_INS'), '$VAR'('INDEP_COL')), 'interArgIsa1-2'('$VAR'('PRED'), '$VAR'('INDEP_COL'), '$VAR'('DEP_COL')), dot_holds(['$VAR'('PRED'), '$VAR'('INDEP_INS'), '$VAR'('DEP_INS')|'$VAR'('_ARGS')])), isa('$VAR'('DEP_INS'), '$VAR'('DEP_COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('HIGH'), 'ScalarPointValue'), isa('$VAR'('LOW'), 'ScalarPointValue'), isa('$VAR'('UNIT'), 'UnitOfMeasure')), maxQuantValue(holds('$VAR'('UNIT'), '$VAR'('LOW'), '$VAR'('HIGH')), holds('$VAR'('UNIT'), '$VAR'('HIGH'))), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('FUNCTION'), tFunction), quotedIsa('$VAR'('FUNCTION'), 'CycLConstant')), or(isa('$VAR'('FUNCTION'), 'ReifiableFunction'), isa('$VAR'('FUNCTION'), 'UnreifiableFunction')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('FUNC'), tFunction), arity('$VAR'('FUNC'), 5)), isa('$VAR'('FUNC'), 'QuintaryFunction'), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('FUNC'), 'AssociativeRelation'), isa('$VAR'('FUNC'), tFunction), resultIsa('$VAR'('FUNC'), '$VAR'('RESULTCOL')), argIsa('$VAR'('FUNC'), '$VAR'('_N'), '$VAR'('ARGCOL'))), genls('$VAR'('RESULTCOL'), '$VAR'('ARGCOL')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(isa('$VAR'('FUNC'), 'AssociativeRelation'), isa('$VAR'('FUNC'), tFunction), argIsa('$VAR'('FUNC'), '$VAR'('_N'), '$VAR'('ARGCOL'))), argIsa('$VAR'('FUNC'), '$VAR'('_M'), '$VAR'('ARGCOL')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(isa('$VAR'('FUNC'), 'AssociativeRelation'), isa('$VAR'('FUNC'), 'BinaryFunction')), equals(holds('$VAR'('FUNC'), '$VAR'('THING1'), holds('$VAR'('FUNC'), '$VAR'('THING2'), '$VAR'('THING3'))), holds('$VAR'('FUNC'), '$VAR'('THING3'), holds('$VAR'('FUNC'), '$VAR'('THING1'), '$VAR'('THING2')))), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(isa('$VAR'('FUN'), tFunction), arity('$VAR'('FUN'), 2)), isa('$VAR'('FUN'), 'BinaryFunction'), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('DIS_COL_TYPE'), 'DisjointCollectionType'), isa('$VAR'('COL1'), '$VAR'('DIS_COL_TYPE')), isa('$VAR'('COL2'), '$VAR'('DIS_COL_TYPE')), different('$VAR'('COL1'), '$VAR'('COL2'))), disjointWith('$VAR'('COL1'), '$VAR'('COL2')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('CONNECT'), 'LogicalConnective'), isa('$VAR'('CONNECT'), 'VariableArityRelation')), argsQuotedIsa('$VAR'('CONNECT'), 'CycLSentence-Assertible'), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(isa('$VAR'('CONNECT'), 'FixedArityRelation'), isa('$VAR'('CONNECT'), 'LogicalConnective'), arity('$VAR'('CONNECT'), '$VAR'('ARITY')), isa('$VAR'('ARG_N_QUOTED_ISA'), 'ArgQuotedIsaBinaryPredicate'), constrainsArg('$VAR'('ARG_N_QUOTED_ISA'), '$VAR'('N')), integerBetween(1, '$VAR'('N'), '$VAR'('ARITY'))), holds('$VAR'('ARG_N_QUOTED_ISA'), '$VAR'('CONNECT'), 'CycLSentence-Assertible'), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(isa('$VAR'('COL'), tCol), isa('$VAR'('RELN'), 'BinaryPredicate'), overlappingExternalConcept('$VAR'('RELN'), '$VAR'('SOURCE'), '$VAR'('STRING')), overlappingExternalConcept('$VAR'('COL'), '$VAR'('SOURCE'), '$VAR'('STRING'))), extConceptOverlapsColAndReln('$VAR'('COL'), '$VAR'('RELN'), '$VAR'('SOURCE'), '$VAR'('STRING')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('BPRED'), 'SymmetricBinaryPredicate'), transitiveViaArgInverse('$VAR'('PRED'), '$VAR'('BPRED'), '$VAR'('N'))), transitiveViaArg('$VAR'('PRED'), '$VAR'('BPRED'), '$VAR'('N')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('BPRED'), 'SymmetricBinaryPredicate'), transitiveViaArg('$VAR'('PRED'), '$VAR'('BPRED'), '$VAR'('N'))), transitiveViaArgInverse('$VAR'('PRED'), '$VAR'('BPRED'), '$VAR'('N')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('BINPRED'), 'BinaryPredicate'), arg1Isa('$VAR'('BINPRED'), '$VAR'('COL2')), requiredArg2Pred('$VAR'('COL1'), '$VAR'('BINPRED'))), relationExistsAll('$VAR'('BINPRED'), '$VAR'('COL2'), '$VAR'('COL1')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(isa('$VAR'('ARG_ISA_PRED'), 'ArgIsaBinaryPredicate'), constrainsArg('$VAR'('ARG_ISA_PRED'), '$VAR'('N')), preservesGenlsInArg('$VAR'('FUNC'), '$VAR'('N'))), holds('$VAR'('ARG_ISA_PRED'), '$VAR'('FUNC'), tCol), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('ARG_ISA'), 'ArgIsaBinaryPredicate'), constrainsArg('$VAR'('ARG_ISA'), '$VAR'('NUM'))), trueRule('NART'(['CollectionRuleTemplateFn', 'ArgIsaPredicate']), and(implies(holds('$VAR'('ARG_ISA'), '$VAR'('RELN'), '$VAR'('COL')), argIsa('$VAR'('RELN'), '$VAR'('NUM'), '$VAR'('COL'))), implies(argIsa('$VAR'('RELN'), '$VAR'('NUM'), '$VAR'('COL')), holds('$VAR'('ARG_ISA'), '$VAR'('RELN'), '$VAR'('COL'))))), 'CoreCycLMt', vStrMon).
assertedTinyKB(implies, and(isa('$VAR'('ARG2'), '$VAR'('UNIV_COL')), relationExistsMinAll('$VAR'('SLOT'), '$VAR'('EXIST_COL'), '$VAR'('UNIV_COL'), '$VAR'('NUM'))), trueSentence(thereExistAtLeast('$VAR'('NUM'), '$VAR'('ARG'), and(isa('$VAR'('ARG'), '$VAR'('EXIST_COL')), holds('$VAR'('SLOT'), '$VAR'('ARG'), '$VAR'('ARG2'))))), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('ARG2'), '$VAR'('UNIV_COL')), relationExistsMaxAll('$VAR'('SLOT'), '$VAR'('EXIST_COL'), '$VAR'('UNIV_COL'), '$VAR'('NUM'))), trueSentence(thereExistAtMost('$VAR'('NUM'), '$VAR'('ARG'), and(isa('$VAR'('ARG'), '$VAR'('EXIST_COL')), holds('$VAR'('SLOT'), '$VAR'('ARG'), '$VAR'('ARG2'))))), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('ARG2'), '$VAR'('UNIV_COL')), relationExistsCountAll('$VAR'('SLOT'), '$VAR'('EXIST_COL'), '$VAR'('UNIV_COL'), '$VAR'('NUM'))), trueSentence(thereExistExactly('$VAR'('NUM'), '$VAR'('ARG1'), and(isa('$VAR'('ARG1'), '$VAR'('EXIST_COL')), holds('$VAR'('SLOT'), '$VAR'('ARG1'), '$VAR'('ARG2'))))), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('ARG1'), '$VAR'('UNIV_COL')), relationAllExistsMin('$VAR'('SLOT'), '$VAR'('UNIV_COL'), '$VAR'('EXIST_COL'), '$VAR'('NUM'))), trueSentence(thereExistAtLeast('$VAR'('NUM'), '$VAR'('ARG'), and(isa('$VAR'('ARG'), '$VAR'('EXIST_COL')), holds('$VAR'('SLOT'), '$VAR'('ARG1'), '$VAR'('ARG'))))), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('ARG1'), '$VAR'('UNIV_COL')), relationAllExistsMax('$VAR'('SLOT'), '$VAR'('UNIV_COL'), '$VAR'('EXIST_COL'), '$VAR'('NUM'))), trueSentence(thereExistAtMost('$VAR'('NUM'), '$VAR'('ARG'), and(isa('$VAR'('ARG'), '$VAR'('EXIST_COL')), holds('$VAR'('SLOT'), '$VAR'('ARG1'), '$VAR'('ARG'))))), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(isa('$VAR'('ALL_INST'), '$VAR'('ALL_COL')), relationAllExists('$VAR'('PRED'), '$VAR'('ALL_COL'), '$VAR'('EX_COL'))), trueSentence(thereExists('$VAR'('EX_INST'), and(isa('$VAR'('EX_INST'), '$VAR'('EX_COL')), holds('$VAR'('PRED'), '$VAR'('ALL_INST'), '$VAR'('EX_INST'))))), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(isa('$VAR'('_ANY'), '$VAR'('COL')), relationAllInstance('$VAR'('PRED'), '$VAR'('COL'), '$VAR'('INST'))), relationExistsInstance('$VAR'('PRED'), '$VAR'('COL'), '$VAR'('INST')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(holds('$VAR'('PRED'), '$VAR'('ARG1')), genlPreds('$VAR'('PRED'), '$VAR'('GENL_PRED'))), holds('$VAR'('GENL_PRED'), '$VAR'('ARG1')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(greaterThanOrEqualTo(5, '$VAR'('N')), arg6Isa('$VAR'('PRED'), '$VAR'('TYPE'))), arg5Isa('FunctionToArg'('$VAR'('N'), '$VAR'('PRED')), '$VAR'('TYPE')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(greaterThanOrEqualTo(4, '$VAR'('N')), arg5Isa('$VAR'('PRED'), '$VAR'('TYPE'))), arg4Isa('FunctionToArg'('$VAR'('N'), '$VAR'('PRED')), '$VAR'('TYPE')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(greaterThanOrEqualTo(3, '$VAR'('N')), arg4Isa('$VAR'('PRED'), '$VAR'('TYPE'))), arg3Isa('FunctionToArg'('$VAR'('N'), '$VAR'('PRED')), '$VAR'('TYPE')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(greaterThanOrEqualTo(2, '$VAR'('N')), arg3Isa('$VAR'('PRED'), '$VAR'('TYPE'))), arg2Isa('FunctionToArg'('$VAR'('N'), '$VAR'('PRED')), '$VAR'('TYPE')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(greaterThanOrEqualTo(1, '$VAR'('N')), arg2Isa('$VAR'('PRED'), '$VAR'('TYPE'))), arg1Isa('FunctionToArg'('$VAR'('N'), '$VAR'('PRED')), '$VAR'('TYPE')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(greaterThanOrEqualTo('$VAR'('N'), '$VAR'('ARGNUM')), argAndRestIsa('$VAR'('PRED'), '$VAR'('ARGNUM'), '$VAR'('COL'))), argIsa('$VAR'('PRED'), '$VAR'('N'), '$VAR'('COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(greaterThanOrEqualTo('$VAR'('MAX'), '$VAR'('MIN')), maxQuantValue('$VAR'('ATT'), holds('$VAR'('UNIT'), '$VAR'('MAX'))), minQuantValue('$VAR'('ATT'), holds('$VAR'('UNIT'), '$VAR'('MIN')))), equals('$VAR'('ATT'), holds('$VAR'('UNIT'), '$VAR'('MIN'), '$VAR'('MAX'))), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(greaterThan('$VAR'('NUM'), 0), relationExistsMinAll('$VAR'('SLOT'), '$VAR'('EXIST_COL'), '$VAR'('UNIV_COL'), '$VAR'('NUM'))), relationExistsAll('$VAR'('SLOT'), '$VAR'('EXIST_COL'), '$VAR'('UNIV_COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(greaterThan('$VAR'('NUM'), 0), relationExistsCountAll('$VAR'('SLOT'), '$VAR'('EXIST_COL'), '$VAR'('UNIV_COL'), '$VAR'('NUM'))), relationExistsAll('$VAR'('SLOT'), '$VAR'('EXIST_COL'), '$VAR'('UNIV_COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(greaterThan('$VAR'('NUM'), 0), relationAllExistsMin('$VAR'('SLOT'), '$VAR'('UNIV_COL'), '$VAR'('EXIST_COL'), '$VAR'('NUM'))), relationAllExists('$VAR'('SLOT'), '$VAR'('UNIV_COL'), '$VAR'('EXIST_COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(greaterThan('$VAR'('NUM'), 0), relationAllExistsCount('$VAR'('SLOT'), '$VAR'('UNIV_COL'), '$VAR'('EXIST_COL'), '$VAR'('NUM'))), relationAllExists('$VAR'('SLOT'), '$VAR'('UNIV_COL'), '$VAR'('EXIST_COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(greaterThan('$VAR'('NUM'), 0), greaterThanOrEqualTo('$VAR'('ARITY'), '$VAR'('NUM')), arity('$VAR'('FN'), '$VAR'('ARITY')), resultIsa('$VAR'('FN'), '$VAR'('COLL'))), interArgResultIsa('$VAR'('FN'), '$VAR'('NUM'), 'Thing', '$VAR'('COLL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(greaterThan('$VAR'('N'), 5), arg5Isa('$VAR'('PRED'), '$VAR'('TYPE'))), arg5Isa('FunctionToArg'('$VAR'('N'), '$VAR'('PRED')), '$VAR'('TYPE')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(greaterThan('$VAR'('N'), 4), arg4Isa('$VAR'('PRED'), '$VAR'('TYPE'))), arg4Isa('FunctionToArg'('$VAR'('N'), '$VAR'('PRED')), '$VAR'('TYPE')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(greaterThan('$VAR'('N'), 3), arg3Isa('$VAR'('PRED'), '$VAR'('TYPE'))), arg3Isa('FunctionToArg'('$VAR'('N'), '$VAR'('PRED')), '$VAR'('TYPE')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(greaterThan('$VAR'('N'), 2), arg2Isa('$VAR'('PRED'), '$VAR'('TYPE'))), arg2Isa('FunctionToArg'('$VAR'('N'), '$VAR'('PRED')), '$VAR'('TYPE')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(greaterThan('$VAR'('N'), 1), arg1Isa('$VAR'('PRED'), '$VAR'('TYPE'))), arg1Isa('FunctionToArg'('$VAR'('N'), '$VAR'('PRED')), '$VAR'('TYPE')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(greaterThan('$VAR'('BIGGER'), '$VAR'('SMALLER')), relationAllInstance(greaterThanOrEqualTo, '$VAR'('COL'), '$VAR'('BIGGER'))), relationAllInstance(greaterThan, '$VAR'('COL'), '$VAR'('SMALLER')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, and(genls('$VAR'('X'), 'larkc-Plugin'), 'larkc-hasOutputType'('$VAR'('X'), '$VAR'('TYPE')), genls('$VAR'('TYPE'), '$VAR'('TYPE1')), 'larkc-hasInputType'('$VAR'('Y'), '$VAR'('TYPE1')), genls('$VAR'('Y'), 'larkc-Plugin')), 'larkc-pluginByDataConnectsTo'('$VAR'('X'), '$VAR'('Y')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(genls('$VAR'('X'), '$VAR'('Y')), genls('$VAR'('Y'), '$VAR'('Z'))), genls('$VAR'('X'), '$VAR'('Z')), 'LogicalTruthMt', vStrMon).
assertedTinyKB(implies, and(genls('$VAR'('SPEC'), '$VAR'('COL2')), different('$VAR'('COL2'), '$VAR'('SPEC')), relationAllExists('$VAR'('PRED'), '$VAR'('COL1'), '$VAR'('SPEC'))), abnormal('TheList'('$VAR'('PRED'), '$VAR'('COL1'), '$VAR'('COL2')), 'TINYKB-ASSERTION'(':TRUE-MON', [[[arity, '$VAR'('PRED'), 2], [requiredArg1Pred, '$VAR'('COL1'), '$VAR'('PRED')], ['interArgIsa1-2', '$VAR'('PRED'), '$VAR'('COL1'), '$VAR'('COL2')]], [[relationAllExists, '$VAR'('PRED'), '$VAR'('COL1'), '$VAR'('COL2')]]], 'BaseKB', ["?PRED", "?COL1", "?COL2"], [implies, [and, [arity, '$VAR'('PRED'), 2], [requiredArg1Pred, '$VAR'('COL1'), '$VAR'('PRED')], ['interArgIsa1-2', '$VAR'('PRED'), '$VAR'('COL1'), '$VAR'('COL2')]], [relationAllExists, '$VAR'('PRED'), '$VAR'('COL1'), '$VAR'('COL2')]])), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(genls('$VAR'('SPEC'), '$VAR'('COL')), defnNecessary('$VAR'('COL'), '$VAR'('DEFN'))), defnNecessary('$VAR'('SPEC'), '$VAR'('DEFN')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(genls('$VAR'('SPEC'), '$VAR'('COL')), conceptuallyRelated('$VAR'('COL'), '$VAR'('REL_OBJ'))), conceptuallyRelated('$VAR'('SPEC'), '$VAR'('REL_OBJ')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(genls('$VAR'('INDEP_SPEC'), '$VAR'('INDEP_COL')), holds('$VAR'('PRED'), '$VAR'('INDEP_SPEC'), '$VAR'('DEP_SPEC')), 'interArgGenl1-2'('$VAR'('PRED'), '$VAR'('INDEP_COL'), '$VAR'('DEP_COL'))), genls('$VAR'('DEP_SPEC'), '$VAR'('DEP_COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(genls('$VAR'('COL_1'), '$VAR'('DIFF_NEAR')), different('$VAR'('COL_1'), '$VAR'('DIFF_NEAR'))), or(elementOf('$VAR'('COL_2'), 'TheSetOf'('$VAR'('ITEM_1'), genls('$VAR'('ITEM_1'), '$VAR'('DIFF_NEAR')))), nearestDifferentGenls('$VAR'('COL_1'), '$VAR'('COL_2'), '$VAR'('DIFF_NEAR')), elementOf('$VAR'('DIFF_NEAR'), 'TheSetOf'('$VAR'('DIFF_FARTHER'), thereExists('$VAR'('DIFF_FAR'), and(genls('$VAR'('COL_1'), '$VAR'('DIFF_FAR')), genls('$VAR'('DIFF_FAR'), '$VAR'('DIFF_FARTHER')), different('$VAR'('COL_1'), '$VAR'('DIFF_FAR')), different('$VAR'('DIFF_FAR'), '$VAR'('DIFF_FARTHER')), not(elementOf('$VAR'('COL_2'), 'TheSetOf'('$VAR'('ITEM_2'), genls('$VAR'('ITEM_2'), '$VAR'('DIFF_FAR'))))), not(elementOf('$VAR'('COL_2'), 'TheSetOf'('$VAR'('ITEM_3'), genls('$VAR'('ITEM_3'), '$VAR'('DIFF_FARTHER')))))))))), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(genls('$VAR'('COL_1'), '$VAR'('COMMON_NEAR')), different('$VAR'('COL_1'), '$VAR'('COMMON_NEAR')), genls('$VAR'('COL_2'), '$VAR'('COMMON_NEAR')), different('$VAR'('COL_2'), '$VAR'('COMMON_NEAR'))), or(nearestCommonGenls('$VAR'('COL_1'), '$VAR'('COL_2'), '$VAR'('COMMON_NEAR')), elementOf('$VAR'('COMMON_NEAR'), 'TheSetOf'('$VAR'('COMMON_FARTHER'), thereExists('$VAR'('COMMON_FAR'), and(genls('$VAR'('COL_1'), '$VAR'('COMMON_FAR')), genls('$VAR'('COL_2'), '$VAR'('COMMON_FAR')), genls('$VAR'('COMMON_FAR'), '$VAR'('COMMON_FARTHER')), different('$VAR'('COL_1'), '$VAR'('COMMON_FAR')), different('$VAR'('COL_2'), '$VAR'('COMMON_FAR')), different('$VAR'('COMMON_FAR'), '$VAR'('COMMON_FARTHER'))))))), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(genls('$VAR'('COL2'), '$VAR'('COL3')), arg2Isa('$VAR'('PRED'), '$VAR'('COL3'))), meetsPragmaticRequirement('TheList'('$VAR'('PRED'), '$VAR'('COL1'), '$VAR'('COL2')), 'TINYKB-ASSERTION'(':TRUE-MON', [[[arity, '$VAR'('PRED'), 2], [requiredArg1Pred, '$VAR'('COL1'), '$VAR'('PRED')], ['interArgIsa1-2', '$VAR'('PRED'), '$VAR'('COL1'), '$VAR'('COL2')]], [[relationAllExists, '$VAR'('PRED'), '$VAR'('COL1'), '$VAR'('COL2')]]], 'BaseKB', ["?PRED", "?COL1", "?COL2"], [implies, [and, [arity, '$VAR'('PRED'), 2], [requiredArg1Pred, '$VAR'('COL1'), '$VAR'('PRED')], ['interArgIsa1-2', '$VAR'('PRED'), '$VAR'('COL1'), '$VAR'('COL2')]], [relationAllExists, '$VAR'('PRED'), '$VAR'('COL1'), '$VAR'('COL2')]])), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(genls('$VAR'('COL1'), '$VAR'('GENL')), different('$VAR'('COL1'), '$VAR'('GENL')), relationAllExists('$VAR'('PRED'), '$VAR'('GENL'), '$VAR'('COL2'))), abnormal('TheList'('$VAR'('PRED'), '$VAR'('COL1'), '$VAR'('COL2')), 'TINYKB-ASSERTION'(':TRUE-MON', [[[arity, '$VAR'('PRED'), 2], [requiredArg1Pred, '$VAR'('COL1'), '$VAR'('PRED')], ['interArgIsa1-2', '$VAR'('PRED'), '$VAR'('COL1'), '$VAR'('COL2')]], [[relationAllExists, '$VAR'('PRED'), '$VAR'('COL1'), '$VAR'('COL2')]]], 'BaseKB', ["?PRED", "?COL1", "?COL2"], [implies, [and, [arity, '$VAR'('PRED'), 2], [requiredArg1Pred, '$VAR'('COL1'), '$VAR'('PRED')], ['interArgIsa1-2', '$VAR'('PRED'), '$VAR'('COL1'), '$VAR'('COL2')]], [relationAllExists, '$VAR'('PRED'), '$VAR'('COL1'), '$VAR'('COL2')]])), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(genls('$VAR'('COL1'), '$VAR'('COL2')), genls('$VAR'('COL2'), '$VAR'('COL1'))), coExtensional('$VAR'('COL1'), '$VAR'('COL2')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(genls('$VAR'('COL'), '$VAR'('NEAR_COL')), different('$VAR'('COL'), '$VAR'('NEAR_COL')), unknownSentence(thereExists('$VAR'('BETWEEN'), and(genls('$VAR'('BETWEEN'), '$VAR'('NEAR_COL')), genls('$VAR'('COL'), '$VAR'('BETWEEN')), different('$VAR'('BETWEEN'), '$VAR'('COL'), '$VAR'('NEAR_COL')))))), nearestGenls('$VAR'('COL'), '$VAR'('NEAR_COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(genls('$VAR'('COL'), '$VAR'('GENL')), defnSufficient('$VAR'('COL'), '$VAR'('DEFN'))), defnSufficient('$VAR'('GENL'), '$VAR'('DEFN')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(genls('$VAR'('ARGS_5'), '$VAR'('ARGS_6')), genls('$VAR'('ARGS_6'), '$VAR'('ARGS_5'))), coExtensional('$VAR'('ARGS_5'), '$VAR'('ARGS_6')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, and(genlPreds('$VAR'('SPEC_PRED'), '$VAR'('PRED')), genls('$VAR'('EXISTS_SPEC'), '$VAR'('EXISTS_COL')), genls('$VAR'('ALL_SPEC'), '$VAR'('ALL_COL')), greaterThanOrEqualTo('$VAR'('MORE'), '$VAR'('MAX')), relationExistsMaxAll('$VAR'('PRED'), '$VAR'('EXISTS_COL'), '$VAR'('ALL_COL'), '$VAR'('MAX'))), relationExistsMaxAll('$VAR'('SPEC_PRED'), '$VAR'('EXISTS_SPEC'), '$VAR'('ALL_SPEC'), '$VAR'('MORE')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(genlPreds('$VAR'('SPEC_PRED'), '$VAR'('PRED')), genlInverse('$VAR'('PRED'), '$VAR'('GENL_PRED'))), genlInverse('$VAR'('SPEC_PRED'), '$VAR'('GENL_PRED')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(genlPreds('$VAR'('SPEC_PRED'), '$VAR'('PRED')), different('$VAR'('PRED'), '$VAR'('SPEC_PRED')), relationAllExists('$VAR'('SPEC_PRED'), '$VAR'('COL1'), '$VAR'('COL2'))), abnormal('TheList'('$VAR'('PRED'), '$VAR'('COL1'), '$VAR'('COL2')), 'TINYKB-ASSERTION'(':TRUE-MON', [[[arity, '$VAR'('PRED'), 2], [requiredArg1Pred, '$VAR'('COL1'), '$VAR'('PRED')], ['interArgIsa1-2', '$VAR'('PRED'), '$VAR'('COL1'), '$VAR'('COL2')]], [[relationAllExists, '$VAR'('PRED'), '$VAR'('COL1'), '$VAR'('COL2')]]], 'BaseKB', ["?PRED", "?COL1", "?COL2"], [implies, [and, [arity, '$VAR'('PRED'), 2], [requiredArg1Pred, '$VAR'('COL1'), '$VAR'('PRED')], ['interArgIsa1-2', '$VAR'('PRED'), '$VAR'('COL1'), '$VAR'('COL2')]], [relationAllExists, '$VAR'('PRED'), '$VAR'('COL1'), '$VAR'('COL2')]])), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(genlPreds('$VAR'('SPEC_PRED'), '$VAR'('GENL_PRED')), unknownSentence(thereExists('$VAR'('DIR'), reformulationDirectionInMode('$VAR'('DIR'), '$VAR'('MODE'), '$VAR'('RULE')))), defaultReformulationDirectionInModeForPred('$VAR'('DEFAULT_DIR'), '$VAR'('MODE'), '$VAR'('GENL_PRED')), evaluate('$VAR'('SPEC_PRED'), 'FormulaArgFn'(0, '$VAR'('RULE')))), reformulationDirectionInMode('$VAR'('DEFAULT_DIR'), '$VAR'('MODE'), '$VAR'('RULE')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(genlPreds('$VAR'('SPEC_PRED'), '$VAR'('GENL_PRED')), relationAllExists('$VAR'('SPEC_PRED'), '$VAR'('COL_1'), '$VAR'('COL_2'))), relationAllExists('$VAR'('GENL_PRED'), '$VAR'('COL_1'), '$VAR'('COL_2')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(genlPreds('$VAR'('SPEC_PRED'), '$VAR'('GENL_PRED')), relationAll('$VAR'('SPEC_PRED'), '$VAR'('COL'))), relationAll('$VAR'('GENL_PRED'), '$VAR'('COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(genlPreds('$VAR'('SPEC_PRED'), '$VAR'('GENL_PRED')), different('$VAR'('GENL_PRED'), '$VAR'('SPEC_PRED')), relationInstanceAll('$VAR'('SPEC_PRED'), '$VAR'('ARG1'), '$VAR'('ARG2'))), relationInstanceAll('$VAR'('GENL_PRED'), '$VAR'('ARG1'), '$VAR'('ARG2')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(genlPreds('$VAR'('SPEC_PRED'), '$VAR'('GENL_PRED')), different('$VAR'('GENL_PRED'), '$VAR'('SPEC_PRED')), relationAllInstance('$VAR'('SPEC_PRED'), '$VAR'('ARG1'), '$VAR'('ARG2'))), relationAllInstance('$VAR'('GENL_PRED'), '$VAR'('ARG1'), '$VAR'('ARG2')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(genlPreds('$VAR'('SPEC'), '$VAR'('GENL')), fanOutArg('$VAR'('GENL'), '$VAR'('ARG_NUM'))), fanOutArg('$VAR'('SPEC'), '$VAR'('ARG_NUM')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(genlPreds('$VAR'('PRED'), '$VAR'('NEAR_PRED')), different('$VAR'('NEAR_PRED'), '$VAR'('PRED')), unknownSentence(thereExists('$VAR'('BETWEEN'), and(genlPreds('$VAR'('BETWEEN'), '$VAR'('NEAR_PRED')), genlPreds('$VAR'('PRED'), '$VAR'('BETWEEN')), different('$VAR'('BETWEEN'), '$VAR'('NEAR_PRED'), '$VAR'('PRED')))))), nearestGenlPreds('$VAR'('PRED'), '$VAR'('NEAR_PRED')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(genlPreds('$VAR'('PRED'), '$VAR'('GENL_PRED')), holds('$VAR'('PRED'), '$VAR'('ARG1'), '$VAR'('ARG2'), '$VAR'('ARG3'), '$VAR'('ARG4'), '$VAR'('ARG5'))), holds('$VAR'('GENL_PRED'), '$VAR'('ARG1'), '$VAR'('ARG2'), '$VAR'('ARG3'), '$VAR'('ARG4'), '$VAR'('ARG5')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(genlPreds('$VAR'('PRED'), '$VAR'('GENL_PRED')), holds('$VAR'('PRED'), '$VAR'('ARG1'), '$VAR'('ARG2'), '$VAR'('ARG3'), '$VAR'('ARG4'))), holds('$VAR'('GENL_PRED'), '$VAR'('ARG1'), '$VAR'('ARG2'), '$VAR'('ARG3'), '$VAR'('ARG4')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(genlPreds('$VAR'('PRED'), '$VAR'('GENL_PRED')), holds('$VAR'('PRED'), '$VAR'('ARG1'), '$VAR'('ARG2'), '$VAR'('ARG3'))), holds('$VAR'('GENL_PRED'), '$VAR'('ARG1'), '$VAR'('ARG2'), '$VAR'('ARG3')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(genlPreds('$VAR'('PRED'), '$VAR'('GENL_PRED')), holds('$VAR'('PRED'), '$VAR'('ARG1'), '$VAR'('ARG2'))), holds('$VAR'('GENL_PRED'), '$VAR'('ARG1'), '$VAR'('ARG2')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(genlMt('$VAR'('X'), '$VAR'('Y')), genlMt('$VAR'('Y'), '$VAR'('Z'))), genlMt('$VAR'('X'), '$VAR'('Z')), 'LogicalTruthMt', vStrMon).
assertedTinyKB(implies, and(genlMt('$VAR'('MT_1'), '$VAR'('COMMON_NEAR')), different('$VAR'('COMMON_NEAR'), '$VAR'('MT_1')), different('$VAR'('COMMON_NEAR'), '$VAR'('MT_2')), genlMt('$VAR'('MT_2'), '$VAR'('COMMON_NEAR'))), or(nearestCommonGenlMt('$VAR'('MT_1'), '$VAR'('MT_2'), '$VAR'('COMMON_NEAR')), elementOf('$VAR'('COMMON_NEAR'), 'TheSetOf'('$VAR'('COMMON_FARTHER'), thereExists('$VAR'('COMMON_FAR'), and(genlMt('$VAR'('COMMON_FAR'), '$VAR'('COMMON_FARTHER')), genlMt('$VAR'('MT_1'), '$VAR'('COMMON_FAR')), genlMt('$VAR'('MT_2'), '$VAR'('COMMON_FAR')), different('$VAR'('COMMON_FAR'), '$VAR'('COMMON_FARTHER')), different('$VAR'('COMMON_FAR'), '$VAR'('MT_1')), different('$VAR'('COMMON_FAR'), '$VAR'('MT_2'))))))), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(genlInverse('$VAR'('SPEC_PRED'), '$VAR'('PRED')), genlPreds('$VAR'('PRED'), '$VAR'('GENL_PRED'))), genlInverse('$VAR'('SPEC_PRED'), '$VAR'('GENL_PRED')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(genlInverse('$VAR'('SPEC_PRED'), '$VAR'('PRED')), genlInverse('$VAR'('PRED'), '$VAR'('GENL_PRED'))), genlPreds('$VAR'('SPEC_PRED'), '$VAR'('GENL_PRED')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(genlInverse('$VAR'('PRED'), '$VAR'('INVERSE')), relationExistsAll('$VAR'('PRED'), '$VAR'('TYPE1'), '$VAR'('TYPE2'))), relationAllExists('$VAR'('INVERSE'), '$VAR'('TYPE2'), '$VAR'('TYPE1')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(genlInverse('$VAR'('PRED'), '$VAR'('GENL_INV_PRED')), holds('$VAR'('PRED'), '$VAR'('ARG1'), '$VAR'('ARG2'))), holds('$VAR'('GENL_INV_PRED'), '$VAR'('ARG2'), '$VAR'('ARG1')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(evaluationResultQuotedIsa('$VAR'('FUNCTION'), '$VAR'('Q_COL')), 'genls-SpecDenotesGenlInstances'('$VAR'('Q_COL'), '$VAR'('COL'))), resultIsa('$VAR'('FUNCTION'), '$VAR'('COL')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, and(evaluate('$VAR'('TIMESFN'), 'TimesFn'(holds('$VAR'('UNIT2'), 1), holds('$VAR'('UNIT1'), '$VAR'('N')))), termOfUnit('$VAR'('UNITPRODUCTFN'), 'UnitProductFn'('$VAR'('UNIT1'), '$VAR'('UNIT2')))), equals('$VAR'('TIMESFN'), holds('$VAR'('UNITPRODUCTFN'), '$VAR'('N'))), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(evaluate('$VAR'('TERM'), 'FormulaArgFn'('$VAR'('ARG'), '$VAR'('NAT'))), termOfUnit('$VAR'('NAT'), '$VAR'('FORMULA'))), natArgument('$VAR'('NAT'), '$VAR'('ARG'), '$VAR'('TERM')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(evaluate('$VAR'('QUOTIENTFN'), 'QuotientFn'(holds('$VAR'('UNIT1'), '$VAR'('N')), holds('$VAR'('UNIT2'), 1))), termOfUnit('$VAR'('PERFN'), 'PerFn'('$VAR'('UNIT1'), '$VAR'('UNIT2')))), equals('$VAR'('QUOTIENTFN'), holds('$VAR'('PERFN'), '$VAR'('N'))), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(evaluate('$VAR'('QUOTIENTFN'), 'QuotientFn'(holds('$VAR'('UNIT1'), '$VAR'('M'), '$VAR'('N')), holds('$VAR'('UNIT2'), 1))), termOfUnit('$VAR'('PERFN'), 'PerFn'('$VAR'('UNIT1'), '$VAR'('UNIT2')))), equals('$VAR'('QUOTIENTFN'), holds('$VAR'('PERFN'), '$VAR'('M'), '$VAR'('N'))), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(evaluate('$VAR'('QUOTIENTFN'), 'QuotientFn'(dot_holds(['$VAR'('UNIT1')|'$VAR'('ARGS')]), holds('$VAR'('UNIT2'), 1))), termOfUnit('$VAR'('PERFN'), 'PerFn'('$VAR'('UNIT1'), '$VAR'('UNIT2')))), equals('$VAR'('QUOTIENTFN'), dot_holds(['$VAR'('PERFN')|'$VAR'('ARGS')])), 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(implies, and(evaluate('$VAR'('FUNCTION'), 'FormulaArgFn'(0, '$VAR'('NAT'))), termOfUnit('$VAR'('NAT'), '$VAR'('FORMULA'))), natFunction('$VAR'('NAT'), '$VAR'('FUNCTION')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(evaluate('$VAR'('ARGS_LIST'), 'FormulaArgListFn'('$VAR'('NAT1'))), evaluate('$VAR'('ARGS_LIST'), 'FormulaArgListFn'('$VAR'('NAT2'))), termOfUnit('$VAR'('NAT1'), '$VAR'('FORMULA1')), termOfUnit('$VAR'('NAT2'), '$VAR'('FORMULA2'))), natArgumentsEqual('$VAR'('NAT1'), '$VAR'('NAT2')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(evaluate('$VAR'('ARG'), 'FormulaArgFn'('$VAR'('N'), '$VAR'('NAT'))), termOfUnit('$VAR'('NAT'), '$VAR'('FORMULA'))), termDependsOn('$VAR'('NAT'), '$VAR'('ARG')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(equals('$VAR'('X'), '$VAR'('Y')), isa('$VAR'('X'), '$VAR'('COL'))), isa('$VAR'('Y'), '$VAR'('COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(equals('$VAR'('X'), '$VAR'('Y')), equals('$VAR'('Y'), '$VAR'('Z'))), equals('$VAR'('X'), '$VAR'('Z')), 'LogicalTruthMt', vStrMon).
assertedTinyKB(implies, and(elInverse('$VAR'('PRED'), '$VAR'('INVERSE')), arg2Isa('$VAR'('PRED'), '$VAR'('COL'))), arg1Isa('$VAR'('INVERSE'), '$VAR'('COL')), 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(implies, and(elInverse('$VAR'('PRED'), '$VAR'('INVERSE')), arg2Genl('$VAR'('PRED'), '$VAR'('COL'))), arg1Genl('$VAR'('INVERSE'), '$VAR'('COL')), 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(implies, and(elInverse('$VAR'('PRED'), '$VAR'('INVERSE')), arg1Isa('$VAR'('PRED'), '$VAR'('COL'))), arg2Isa('$VAR'('INVERSE'), '$VAR'('COL')), 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(implies, and(elInverse('$VAR'('PRED'), '$VAR'('INVERSE')), arg1Genl('$VAR'('PRED'), '$VAR'('COL'))), arg2Genl('$VAR'('INVERSE'), '$VAR'('COL')), 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(implies, and(dot_holds(['$VAR'('SPEC')|'$VAR'('ARGS')]), genlPreds('$VAR'('SPEC'), '$VAR'('GENL'))), dot_holds(['$VAR'('GENL')|'$VAR'('ARGS')]), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(disjointWith('$VAR'('COL'), '$VAR'('SUPERSET')), genls('$VAR'('SUBSET'), '$VAR'('SUPERSET'))), disjointWith('$VAR'('COL'), '$VAR'('SUBSET')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(different(negationPreds, '$VAR'('SPEC_PRED')), genlPreds('$VAR'('SPEC_PRED'), negationPreds)), afterAdding('$VAR'('SPEC_PRED'), 'SubLQuoteFn'('PROPAGATE-TO-NEGATIONPREDS')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(different(negationInverse, '$VAR'('SPEC_PRED')), genlPreds('$VAR'('SPEC_PRED'), negationInverse)), afterAdding('$VAR'('SPEC_PRED'), 'SubLQuoteFn'('PROPAGATE-TO-NEGATIONINVERSE')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(different(isa, '$VAR'('SPEC_PRED')), genlPreds('$VAR'('SPEC_PRED'), isa)), afterAdding('$VAR'('SPEC_PRED'), 'SubLQuoteFn'('PROPAGATE-TO-ISA')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(different(genls, '$VAR'('SPEC_PRED')), genlPreds('$VAR'('SPEC_PRED'), genls)), afterAdding('$VAR'('SPEC_PRED'), 'SubLQuoteFn'('PROPAGATE-TO-GENLS')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(different(genlPreds, '$VAR'('SPEC_PRED')), genlPreds('$VAR'('SPEC_PRED'), genlPreds)), afterAdding('$VAR'('SPEC_PRED'), 'SubLQuoteFn'('PROPAGATE-TO-GENLPREDS')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(different(genlMt, '$VAR'('SPEC_PRED')), genlPreds('$VAR'('SPEC_PRED'), genlMt)), afterAdding('$VAR'('SPEC_PRED'), 'SubLQuoteFn'('PROPAGATE-TO-GENLMT')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(different(genlInverse, '$VAR'('SPEC_PRED')), genlPreds('$VAR'('SPEC_PRED'), genlInverse)), afterAdding('$VAR'('SPEC_PRED'), 'SubLQuoteFn'('PROPAGATE-TO-GENLINVERSE')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(different(disjointWith, '$VAR'('SPEC_PRED')), genlPreds('$VAR'('SPEC_PRED'), disjointWith)), afterAdding('$VAR'('SPEC_PRED'), 'SubLQuoteFn'('PROPAGATE-TO-DISJOINTWITH')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(different('False', '$VAR'('EVALUATESUBLFN')), evaluate('$VAR'('EVALUATESUBLFN'), 'EvaluateSubLFn'('ExpandSubLFn'('$VAR'('RESULT'), 'FIF'('QUOTE'('$VAR'('RESULT')), 'True', 'False')))), evaluate('$VAR'('RESULT'), 'EvaluateSubLFn'('$VAR'('SUBL')))), trueSubL('$VAR'('SUBL')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(different('$VAR'('X'), '$VAR'('Y')), different('$VAR'('Y'), '$VAR'('Z'))), meetsPragmaticRequirement('TheList'('$VAR'('PRED'), '$VAR'('X'), '$VAR'('Y'), '$VAR'('Z')), 'TINYKB-ASSERTION'(':TRUE-DEF', [[[isa, '$VAR'('PRED'), 'TransitiveBinaryPredicate'], ['$VAR'('PRED'), '$VAR'('X'), '$VAR'('Y')], ['$VAR'('PRED'), '$VAR'('Y'), '$VAR'('Z')]], [['$VAR'('PRED'), '$VAR'('X'), '$VAR'('Z')]]], 'BaseKB', ["?PRED", "?X", "?Y", "?Z"], [implies, [and, [isa, '$VAR'('PRED'), 'TransitiveBinaryPredicate'], ['$VAR'('PRED'), '$VAR'('X'), '$VAR'('Y')], ['$VAR'('PRED'), '$VAR'('Y'), '$VAR'('Z')]], ['$VAR'('PRED'), '$VAR'('X'), '$VAR'('Z')]])), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(different('$VAR'('MT'), '$VAR'('NEAR_MT')), genlMt('$VAR'('MT'), '$VAR'('NEAR_MT')), unknownSentence(thereExists('$VAR'('BETWEEN'), and(genlMt('$VAR'('BETWEEN'), '$VAR'('NEAR_MT')), genlMt('$VAR'('MT'), '$VAR'('BETWEEN')), different('$VAR'('BETWEEN'), '$VAR'('MT'), '$VAR'('NEAR_MT')))))), nearestGenlMt('$VAR'('MT'), '$VAR'('NEAR_MT')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(different('$VAR'('GENL_COL'), '$VAR'('SPEC_COL')), genls('$VAR'('SPEC_COL'), '$VAR'('GENL_COL')), relationInstanceAll('$VAR'('PRED'), '$VAR'('ARG'), '$VAR'('GENL_COL'))), relationInstanceAll('$VAR'('PRED'), '$VAR'('ARG'), '$VAR'('SPEC_COL')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(different('$VAR'('GENL_COL'), '$VAR'('SPEC_COL')), genls('$VAR'('SPEC_COL'), '$VAR'('GENL_COL')), relationAllInstance('$VAR'('PRED'), '$VAR'('GENL_COL'), '$VAR'('ARG'))), relationAllInstance('$VAR'('PRED'), '$VAR'('SPEC_COL'), '$VAR'('ARG')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(different('$VAR'('COL_1'), '$VAR'('COMMON_NEAR')), genls('$VAR'('COMMON_NEAR'), '$VAR'('COL_1')), genls('$VAR'('COMMON_NEAR'), '$VAR'('COL_2')), different('$VAR'('COL_2'), '$VAR'('COMMON_NEAR'))), or(nearestCommonSpecs('$VAR'('COL_1'), '$VAR'('COL_2'), '$VAR'('COMMON_NEAR')), elementOf('$VAR'('COMMON_NEAR'), 'TheSetOf'('$VAR'('COMMON_FARTHER'), thereExists('$VAR'('COMMON_FAR'), and(genls('$VAR'('COMMON_FAR'), '$VAR'('COL_1')), genls('$VAR'('COMMON_FAR'), '$VAR'('COL_2')), genls('$VAR'('COMMON_FARTHER'), '$VAR'('COMMON_FAR')), different('$VAR'('COL_1'), '$VAR'('COMMON_FAR')), different('$VAR'('COL_2'), '$VAR'('COMMON_FAR')), different('$VAR'('COMMON_FAR'), '$VAR'('COMMON_FARTHER'))))))), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(decontextualizedPredicate('$VAR'('SPEC_PRED')), genlPreds('$VAR'('SPEC_PRED'), genlMt)), predicateConventionMt('$VAR'('SPEC_PRED'), 'UniversalVocabularyMt'), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(decontextualizedPredicate('$VAR'('PRED')), predicateConventionMt('$VAR'('PRED'), '$VAR'('MT')), genlPreds('$VAR'('SPEC'), '$VAR'('PRED'))), predicateConventionMt('$VAR'('SPEC'), '$VAR'('MT')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(decontextualizedPredicate('$VAR'('PRED')), predicateConventionMt('$VAR'('PRED'), '$VAR'('MT'))), genlMt('BaseKB', '$VAR'('MT')), 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(implies, and(decontextualizedPredicate('$VAR'('PRED')), genlPreds('$VAR'('SPEC'), '$VAR'('PRED'))), decontextualizedPredicate('$VAR'('SPEC')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(decontextualizedPredicate('$VAR'('PRED')), different('$VAR'('PRED'), '$VAR'('SPEC')), genlInverse('$VAR'('SPEC'), '$VAR'('PRED')), predicateConventionMt('$VAR'('PRED'), '$VAR'('MT'))), predicateConventionMt('$VAR'('SPEC'), '$VAR'('MT')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(decontextualizedPredicate('$VAR'('PRED')), different('$VAR'('PRED'), '$VAR'('SPEC')), genlInverse('$VAR'('SPEC'), '$VAR'('PRED'))), decontextualizedPredicate('$VAR'('SPEC')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(decontextualizedCollection('$VAR'('COL')), collectionConventionMt('$VAR'('COL'), '$VAR'('MT'))), genlMt('BaseKB', '$VAR'('MT')), 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(implies, and(completelyEnumerableCollection('$VAR'('COL')), isa('$VAR'('INST'), '$VAR'('COL'))), knownSentence(isa('$VAR'('INST'), '$VAR'('COL'))), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(completelyDecidableCollection('$VAR'('COLL_2')), completelyDecidableCollection('$VAR'('COLL_1'))), meetsPragmaticRequirement('TheList'('$VAR'('COLL_2'), '$VAR'('COLL_1')), 'TINYKB-ASSERTION'(':TRUE-DEF', [[[extentCardinality, ['TheSetOf', '?OBJ', [and, [isa, '?OBJ', '$VAR'('COLL_1')], [not, [isa, '?OBJ', '$VAR'('COLL_2')]]]], 0]], [[subsetOf, '$VAR'('COLL_1'), '$VAR'('COLL_2')]]], 'BaseKB', ["?COLL-2", "?COLL-1"], [implies, [extentCardinality, ['TheSetOf', '?OBJ', [and, [isa, '?OBJ', '$VAR'('COLL_1')], [not, [isa, '?OBJ', '$VAR'('COLL_2')]]]], 0], [subsetOf, '$VAR'('COLL_1'), '$VAR'('COLL_2')]])), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(assertedSentence(isa('$VAR'('ARG'), '$VAR'('COL'))), natFunction('$VAR'('NART'), '$VAR'('FUNC')), resultIsaArgIsa('$VAR'('FUNC'), '$VAR'('INT')), natArgument('$VAR'('NART'), '$VAR'('INT'), '$VAR'('ARG'))), isa('$VAR'('NART'), '$VAR'('COL')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(assertedSentence(genls('$VAR'('SPEC'), '$VAR'('GENL'))), genls('$VAR'('GENL'), '$VAR'('SPEC')), different('$VAR'('GENL'), '$VAR'('SPEC'))), coExtensional('$VAR'('GENL'), '$VAR'('SPEC')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(assertedSentence('$VAR'('FORMULA')), evaluate('$VAR'('FORMULAARGFN'), 'FormulaArgFn'(0, '$VAR'('FORMULA'))), evaluate('$VAR'('FORMULAARGFN_1'), 'FormulaArgFn'('$VAR'('ARG'), '$VAR'('FORMULA')))), assertedPredicateArg('$VAR'('FORMULAARGFN_1'), '$VAR'('ARG'), '$VAR'('FORMULAARGFN')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(arityMax('$VAR'('RELN'), '$VAR'('MAX')), arityMin('$VAR'('RELN'), '$VAR'('MIN'))), greaterThanOrEqualTo('$VAR'('MAX'), '$VAR'('MIN')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(arity('$VAR'('RELN'), 5), isa('$VAR'('RELN'), 'CommutativeRelation')), commutativeInArgs('$VAR'('RELN'), 1, 2, 3, 4, 5), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(arity('$VAR'('RELN'), 4), isa('$VAR'('RELN'), 'CommutativeRelation')), commutativeInArgs('$VAR'('RELN'), 1, 2, 3, 4), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(arity('$VAR'('RELN'), 3), isa('$VAR'('RELN'), 'CommutativeRelation')), commutativeInArgs('$VAR'('RELN'), 1, 2, 3), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(arity('$VAR'('RELN'), 2), isa('$VAR'('RELN'), 'CommutativeRelation')), commutativeInArgs('$VAR'('RELN'), 1, 2), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(arity('$VAR'('PRED1'), '$VAR'('ARITY')), arity('$VAR'('PRED2'), '$VAR'('ARITY')), disjointWith('$VAR'('TYPE1'), '$VAR'('TYPE2')), argIsa('$VAR'('PRED1'), '$VAR'('ARG'), '$VAR'('TYPE1')), argIsa('$VAR'('PRED2'), '$VAR'('ARG'), '$VAR'('TYPE2'))), negationPreds('$VAR'('PRED1'), '$VAR'('PRED2')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, and(arity('$VAR'('PRED'), 2), requiredArg1Pred('$VAR'('COL1'), '$VAR'('PRED')), 'interArgIsa1-2'('$VAR'('PRED'), '$VAR'('COL1'), '$VAR'('COL2'))), relationAllExists('$VAR'('PRED'), '$VAR'('COL1'), '$VAR'('COL2')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(arity('$VAR'('PRED'), '$VAR'('M')), evaluate('$VAR'('M_1'), 'DifferenceFn'('$VAR'('M'), 1))), arity('FunctionToArg'('$VAR'('N'), '$VAR'('PRED')), '$VAR'('M_1')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(arg5Isa('$VAR'('REL'), '$VAR'('COLL')), admittedArgument('$VAR'('TERM'), 5, '$VAR'('REL'))), isa('$VAR'('TERM'), '$VAR'('COLL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(arg5Genl('$VAR'('REL'), '$VAR'('COLL')), admittedArgument('$VAR'('TERM'), 5, '$VAR'('REL'))), genls('$VAR'('TERM'), '$VAR'('COLL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(arg4Isa('$VAR'('REL'), '$VAR'('COLL')), admittedArgument('$VAR'('TERM'), 4, '$VAR'('REL'))), isa('$VAR'('TERM'), '$VAR'('COLL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(arg4Genl('$VAR'('REL'), '$VAR'('COLL')), admittedArgument('$VAR'('TERM'), 4, '$VAR'('REL'))), genls('$VAR'('TERM'), '$VAR'('COLL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(arg4Format('$VAR'('GENLPRED'), 'SingleEntry'), different('$VAR'('GENLPRED'), '$VAR'('SPECPRED')), genlPreds('$VAR'('SPECPRED'), '$VAR'('GENLPRED'))), arg4Format('$VAR'('SPECPRED'), 'SingleEntry'), 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(implies, and(arg3Isa('$VAR'('REL'), '$VAR'('COLL')), admittedArgument('$VAR'('TERM'), 3, '$VAR'('REL'))), isa('$VAR'('TERM'), '$VAR'('COLL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(arg3Genl('$VAR'('REL'), '$VAR'('COLL')), admittedArgument('$VAR'('TERM'), 3, '$VAR'('REL'))), genls('$VAR'('TERM'), '$VAR'('COLL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(arg3Format('$VAR'('GENLPRED'), 'SingleEntry'), different('$VAR'('GENLPRED'), '$VAR'('SPECPRED')), genlPreds('$VAR'('SPECPRED'), '$VAR'('GENLPRED'))), arg3Format('$VAR'('SPECPRED'), 'SingleEntry'), 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(implies, and(arg2Isa('$VAR'('ROLE'), '$VAR'('TYPE')), requiredArg1Pred('$VAR'('SITTYPE'), '$VAR'('ROLE')), isa('$VAR'('SIT'), '$VAR'('SITTYPE'))), relationInstanceExists('$VAR'('ROLE'), '$VAR'('SIT'), '$VAR'('TYPE')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(arg2Isa('$VAR'('REL'), '$VAR'('COLL')), admittedArgument('$VAR'('TERM'), 2, '$VAR'('REL'))), isa('$VAR'('TERM'), '$VAR'('COLL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(arg2Isa('$VAR'('PRED'), '$VAR'('TYPE')), relationAllInstance('$VAR'('PRED'), '$VAR'('COL'), '$VAR'('ARG2'))), isa('$VAR'('ARG2'), '$VAR'('TYPE')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(arg2Isa('$VAR'('PRED'), '$VAR'('COL')), relationExistsInstance('$VAR'('PRED'), '$VAR'('_DUMMY'), '$VAR'('THING'))), isa('$VAR'('THING'), '$VAR'('COL')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(arg2Genl('$VAR'('REL'), '$VAR'('COLL')), admittedArgument('$VAR'('TERM'), 2, '$VAR'('REL'))), genls('$VAR'('TERM'), '$VAR'('COLL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(arg2Format('$VAR'('GENLPRED'), 'SingleEntry'), different('$VAR'('GENLPRED'), '$VAR'('SPECPRED')), genlPreds('$VAR'('SPECPRED'), '$VAR'('GENLPRED'))), arg2Format('$VAR'('SPECPRED'), 'SingleEntry'), 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(implies, and(arg1Isa('$VAR'('REL'), '$VAR'('COLL')), admittedArgument('$VAR'('TERM'), 1, '$VAR'('REL'))), isa('$VAR'('TERM'), '$VAR'('COLL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(arg1Isa('$VAR'('PRED'), '$VAR'('TYPE')), relationInstanceAll('$VAR'('PRED'), '$VAR'('ARG1'), '$VAR'('COL'))), isa('$VAR'('ARG1'), '$VAR'('TYPE')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(arg1Isa('$VAR'('PRED'), '$VAR'('COL')), relationInstanceExists('$VAR'('PRED'), '$VAR'('THING'), '$VAR'('_DUMMY'))), isa('$VAR'('THING'), '$VAR'('COL')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(arg1Isa('$VAR'('PRED'), '$VAR'('COL')), holds('$VAR'('PRED'), '$VAR'('THING'), '$VAR'('_DUMMY'))), isa('$VAR'('THING'), '$VAR'('COL')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(arg1Genl('$VAR'('REL'), '$VAR'('COLL')), admittedArgument('$VAR'('TERM'), 1, '$VAR'('REL'))), genls('$VAR'('TERM'), '$VAR'('COLL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(arg1Genl('$VAR'('PRED'), '$VAR'('COL2')), relationAllInstance('$VAR'('PRED'), '$VAR'('_ARG1'), '$VAR'('ARG2'))), isa('$VAR'('ARG2'), '$VAR'('COL2')), 'BaseKB', vStrMon).
assertedTinyKB(implies, and(arg1Format('$VAR'('GENLPRED'), 'SingleEntry'), different('$VAR'('GENLPRED'), '$VAR'('SPECPRED')), genlPreds('$VAR'('SPECPRED'), '$VAR'('GENLPRED'))), arg1Format('$VAR'('SPECPRED'), 'SingleEntry'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, and(admittedSentence('$VAR'('FORMULA')), integerBetween(1, '$VAR'('ARG'), '$VAR'('ARITY')), evaluate('$VAR'('RELATION'), 'FormulaArgFn'(0, '$VAR'('FORMULA'))), evaluate('$VAR'('ARITY'), 'FormulaArityFn'('$VAR'('FORMULA'))), evaluate('$VAR'('TERM'), 'FormulaArgFn'('$VAR'('ARG'), '$VAR'('FORMULA')))), admittedArgument('$VAR'('TERM'), '$VAR'('ARG'), '$VAR'('RELATION')), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(admittedArgument('$VAR'('B'), 1, natFunction), admittedArgument('$VAR'('A'), 2, natFunction)), meetsPragmaticRequirement('TheList'('$VAR'('A'), '$VAR'('B')), 'TINYKB-ASSERTION'(':TRUE-DEF', [[[operatorFormulas, '$VAR'('A'), '$VAR'('B')]], [[natFunction, '$VAR'('B'), '$VAR'('A')]]], 'BaseKB', ["?A", "?B"], [implies, [operatorFormulas, '$VAR'('A'), '$VAR'('B')], [natFunction, '$VAR'('B'), '$VAR'('A')]])), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(admittedArgument('$VAR'('A'), 1, isa), admittedArgument('$VAR'('B'), 2, isa)), meetsPragmaticRequirement('TheList'('$VAR'('A'), '$VAR'('B')), 'TINYKB-ASSERTION'(':TRUE-DEF', [[[elementOf, '$VAR'('A'), '$VAR'('B')]], [[isa, '$VAR'('A'), '$VAR'('B')]]], 'BaseKB', ["?A", "?B"], [implies, [elementOf, '$VAR'('A'), '$VAR'('B')], [isa, '$VAR'('A'), '$VAR'('B')]])), 'BaseKB', vStrDef).
assertedTinyKB(implies, and(admittedArgument('$VAR'('A'), 1, genls), admittedArgument('$VAR'('B'), 2, genls)), meetsPragmaticRequirement('TheList'('$VAR'('A'), '$VAR'('B')), 'TINYKB-ASSERTION'(':TRUE-DEF', [[[subsetOf, '$VAR'('A'), '$VAR'('B')]], [[genls, '$VAR'('A'), '$VAR'('B')]]], 'BaseKB', ["?A", "?B"], [implies, [subsetOf, '$VAR'('A'), '$VAR'('B')], [genls, '$VAR'('A'), '$VAR'('B')]])), 'BaseKB', vStrDef).
assertedTinyKB(implies, and('genls-SpecDenotesGenlInstances'('$VAR'('Q_COL'), '$VAR'('COL')), argQuotedIsa('$VAR'('RELN'), '$VAR'('N'), '$VAR'('Q_COL'))), argIsa('$VAR'('RELN'), '$VAR'('N'), '$VAR'('COL')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, afterRemoving('$VAR'('PRED'), 'SubLQuoteFn'('REMOVE-TVA-CACHE-VALUE')), afterAdding('$VAR'('PRED'), 'SubLQuoteFn'('ADD-TVA-CACHE-VALUE')), 'BaseKB', vStrDef).
assertedTinyKB(implies, afterRemoving('$VAR'('PRED'), 'SubLQuoteFn'('REMOVE-TVA-CACHE-KEY')), afterAdding('$VAR'('PRED'), 'SubLQuoteFn'('ADD-TVA-CACHE-KEY')), 'BaseKB', vStrDef).
assertedTinyKB(implies, afterAdding('$VAR'('PRED'), 'SubLQuoteFn'('ADD-TVA-CACHE-VALUE')), afterRemoving('$VAR'('PRED'), 'SubLQuoteFn'('REMOVE-TVA-CACHE-VALUE')), 'BaseKB', vStrDef).
assertedTinyKB(implies, afterAdding('$VAR'('PRED'), 'SubLQuoteFn'('ADD-TVA-CACHE-KEY')), afterRemoving('$VAR'('PRED'), 'SubLQuoteFn'('REMOVE-TVA-CACHE-KEY')), 'BaseKB', vStrDef).
assertedTinyKB(implies, admittedSentence(isa('$VAR'('A'), '$VAR'('B'))), meetsPragmaticRequirement('TheList'('$VAR'('A'), '$VAR'('B')), 'TINYKB-ASSERTION'(':TRUE-DEF', [[[elementOf, '$VAR'('A'), '$VAR'('B')]], [[isa, '$VAR'('A'), '$VAR'('B')]]], 'BaseKB', ["?A", "?B"], [implies, [elementOf, '$VAR'('A'), '$VAR'('B')], [isa, '$VAR'('A'), '$VAR'('B')]])), 'BaseKB', vStrDef).
assertedTinyKB(implies, admittedSentence(genls('$VAR'('A'), '$VAR'('B'))), meetsPragmaticRequirement('TheList'('$VAR'('A'), '$VAR'('B')), 'TINYKB-ASSERTION'(':TRUE-DEF', [[[subsetOf, '$VAR'('A'), '$VAR'('B')]], [[genls, '$VAR'('A'), '$VAR'('B')]]], 'BaseKB', ["?A", "?B"], [implies, [subsetOf, '$VAR'('A'), '$VAR'('B')], [genls, '$VAR'('A'), '$VAR'('B')]])), 'BaseKB', vStrDef).
assertedTinyKB(implies, admittedSentence('equalStrings-CaseInsensitive'('$VAR'('A'), '$VAR'('B'))), meetsPragmaticRequirement('TheList'('$VAR'('A'), '$VAR'('B')), 'TINYKB-ASSERTION'(':TRUE-DEF', [[[equals, '$VAR'('A'), '$VAR'('B')]], [['equalStrings-CaseInsensitive', '$VAR'('A'), '$VAR'('B')]]], 'BaseKB', ["?A", "?B"], [implies, [equals, '$VAR'('A'), '$VAR'('B')], ['equalStrings-CaseInsensitive', '$VAR'('A'), '$VAR'('B')]])), 'BaseKB', vStrDef).
assertedTinyKB(implies, admittedAllArgument('$VAR'('COL'), '$VAR'('NUM'), '$VAR'('RELN')), relationAllInstance('Kappa'('?X'('$VAR'('Y')), admittedArgument('$VAR'('X'), '$VAR'('NUM'), '$VAR'('Y'))), '$VAR'('COL'), '$VAR'('RELN')), 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(implies, 'ist-Asserted'('$VAR'('MT'), '$VAR'('FORMULA')), ist('$VAR'('MT'), assertedSentence('$VAR'('FORMULA'))), 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(implies, 'interArgIsa5-4'('$VAR'('CONSTRAINED_PRED'), '$VAR'('IND_COL'), '$VAR'('DEP_COL')), interArgIsa('$VAR'('CONSTRAINED_PRED'), 5, '$VAR'('IND_COL'), 4, '$VAR'('DEP_COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, 'interArgIsa5-3'('$VAR'('CONSTRAINED_PRED'), '$VAR'('IND_COL'), '$VAR'('DEP_COL')), interArgIsa('$VAR'('CONSTRAINED_PRED'), 5, '$VAR'('IND_COL'), 3, '$VAR'('DEP_COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, 'interArgIsa5-2'('$VAR'('CONSTRAINED_PRED'), '$VAR'('IND_COL'), '$VAR'('DEP_COL')), interArgIsa('$VAR'('CONSTRAINED_PRED'), 5, '$VAR'('IND_COL'), 2, '$VAR'('DEP_COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, 'interArgIsa5-1'('$VAR'('CONSTRAINED_PRED'), '$VAR'('IND_COL'), '$VAR'('DEP_COL')), interArgIsa('$VAR'('CONSTRAINED_PRED'), 5, '$VAR'('IND_COL'), 1, '$VAR'('DEP_COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, 'interArgIsa4-5'('$VAR'('CONSTRAINED_PRED'), '$VAR'('IND_COL'), '$VAR'('DEP_COL')), interArgIsa('$VAR'('CONSTRAINED_PRED'), 4, '$VAR'('IND_COL'), 5, '$VAR'('DEP_COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, 'interArgIsa4-3'('$VAR'('CONSTRAINED_PRED'), '$VAR'('IND_COL'), '$VAR'('DEP_COL')), interArgIsa('$VAR'('CONSTRAINED_PRED'), 4, '$VAR'('IND_COL'), 3, '$VAR'('DEP_COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, 'interArgIsa4-2'('$VAR'('CONSTRAINED_PRED'), '$VAR'('IND_COL'), '$VAR'('DEP_COL')), interArgIsa('$VAR'('CONSTRAINED_PRED'), 4, '$VAR'('IND_COL'), 2, '$VAR'('DEP_COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, 'interArgIsa4-1'('$VAR'('CONSTRAINED_PRED'), '$VAR'('IND_COL'), '$VAR'('DEP_COL')), interArgIsa('$VAR'('CONSTRAINED_PRED'), 4, '$VAR'('IND_COL'), 1, '$VAR'('DEP_COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, 'interArgIsa3-5'('$VAR'('CONSTRAINED_PRED'), '$VAR'('IND_COL'), '$VAR'('DEP_COL')), interArgIsa('$VAR'('CONSTRAINED_PRED'), 3, '$VAR'('IND_COL'), 5, '$VAR'('DEP_COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, 'interArgIsa3-4'('$VAR'('CONSTRAINED_PRED'), '$VAR'('IND_COL'), '$VAR'('DEP_COL')), interArgIsa('$VAR'('CONSTRAINED_PRED'), 3, '$VAR'('IND_COL'), 4, '$VAR'('DEP_COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, 'interArgIsa3-2'('$VAR'('CONSTRAINED_PRED'), '$VAR'('IND_COL'), '$VAR'('DEP_COL')), interArgIsa('$VAR'('CONSTRAINED_PRED'), 3, '$VAR'('IND_COL'), 2, '$VAR'('DEP_COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, 'interArgIsa3-1'('$VAR'('CONSTRAINED_PRED'), '$VAR'('IND_COL'), '$VAR'('DEP_COL')), interArgIsa('$VAR'('CONSTRAINED_PRED'), 3, '$VAR'('IND_COL'), 1, '$VAR'('DEP_COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, 'interArgIsa2-5'('$VAR'('CONSTRAINED_PRED'), '$VAR'('IND_COL'), '$VAR'('DEP_COL')), interArgIsa('$VAR'('CONSTRAINED_PRED'), 2, '$VAR'('IND_COL'), 5, '$VAR'('DEP_COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, 'interArgIsa2-4'('$VAR'('CONSTRAINED_PRED'), '$VAR'('IND_COL'), '$VAR'('DEP_COL')), interArgIsa('$VAR'('CONSTRAINED_PRED'), 2, '$VAR'('IND_COL'), 4, '$VAR'('DEP_COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, 'interArgIsa2-3'('$VAR'('CONSTRAINED_PRED'), '$VAR'('IND_COL'), '$VAR'('DEP_COL')), interArgIsa('$VAR'('CONSTRAINED_PRED'), 2, '$VAR'('IND_COL'), 3, '$VAR'('DEP_COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, 'interArgIsa2-1'('$VAR'('CONSTRAINED_PRED'), '$VAR'('IND_COL'), '$VAR'('DEP_COL')), interArgIsa('$VAR'('CONSTRAINED_PRED'), 2, '$VAR'('IND_COL'), 1, '$VAR'('DEP_COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, 'interArgIsa1-5'('$VAR'('CONSTRAINED_PRED'), '$VAR'('IND_COL'), '$VAR'('DEP_COL')), interArgIsa('$VAR'('CONSTRAINED_PRED'), 1, '$VAR'('IND_COL'), 5, '$VAR'('DEP_COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, 'interArgIsa1-4'('$VAR'('CONSTRAINED_PRED'), '$VAR'('IND_COL'), '$VAR'('DEP_COL')), interArgIsa('$VAR'('CONSTRAINED_PRED'), 1, '$VAR'('IND_COL'), 4, '$VAR'('DEP_COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, 'interArgIsa1-3'('$VAR'('CONSTRAINED_PRED'), '$VAR'('IND_COL'), '$VAR'('DEP_COL')), interArgIsa('$VAR'('CONSTRAINED_PRED'), 1, '$VAR'('IND_COL'), 3, '$VAR'('DEP_COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, 'interArgIsa1-2'('$VAR'('CONSTRAINED_PRED'), '$VAR'('IND_COL'), '$VAR'('DEP_COL')), interArgIsa('$VAR'('CONSTRAINED_PRED'), 1, '$VAR'('IND_COL'), 2, '$VAR'('DEP_COL')), 'BaseKB', vStrDef).
assertedTinyKB(implies, 'assertionUtility-1'('$VAR'('ASSERTION'), 1), highlyRelevantAssertion('$VAR'('ASSERTION')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(implies, 'assertionUtility-1'('$VAR'('ASSERTION'), -1), irrelevantAssertion('$VAR'('ASSERTION')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(hlPrototypicalInstance, 'ThePrototypicalTransitiveBinaryPredicate', 'TransitiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(hlPrototypicalInstance, 'ThePrototypicalCollection', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(hlPrototypicalInstance, 'ThePrototypicalBinaryPredicate', 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'WFFSupportedPredicate', 'WFFSupportedTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'WFFDirectivePredicate', 'WFFSupportedPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'WFFConstraintSatisfactionPredicate', 'WFFSupportedPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'WFFConstraintPredicate', 'WFFSupportedPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'Wednesday', 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'VariableAritySkolemFunction', 'VariableArityRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'VariableAritySkolemFunction', 'VariableArityRelation', 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(genls, 'VariableAritySkolemFunction', 'SkolemFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'VariableAritySkolemFunction', 'SkolemFunction', 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(genls, 'VariableAritySkolemFuncN', 'VariableAritySkolemFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'VariableAritySkolemFuncN', 'VariableAritySkolemFunction', 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(genls, 'VariableAritySkolemFuncN', 'VariableArityRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'VariableAritySkolemFuncN', 'SkolemFuncN', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'VariableAritySkolemFuncN', 'SkolemFuncN', 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(genls, 'VariableArityRelation', tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'VariableArityRelation', tRelation, 'LogicalTruthMt', vStrDef).
assertedTinyKB(genls, 'UnreifiableFunction', tFunction, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'UnreifiableFunction', tFunction, 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(genls, 'UnitOfMeasure', 'VariableArityRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'UnitOfMeasure', 'UnreifiableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'UnaryRelation', 'FixedArityRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'UnaryRelation', 'FixedArityRelation', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'UnaryPredicate', 'UnaryRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'UnaryPredicate', 'UnaryRelation', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'UnaryPredicate', tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'UnaryPredicate', tPred, 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'UnaryFunction', 'UnaryRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'UnaryFunction', 'UnaryRelation', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'UnaryFunction', tFunction, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'UnaryFunction', tFunction, 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'Tuesday', 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'TruthValue', 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'TruthFunction', tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'TruthFunction', tRelation, 'LogicalTruthMt', vStrDef).
assertedTinyKB(genls, 'TransitiveBinaryPredicate', 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'TransitiveBinaryPredicate', 'BinaryPredicate', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'TransformationModuleSupportedPredicate', 'InferenceSupportedPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'TransformationModuleSupportedPredicate', 'CycLTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'TransformationModuleSupportedCollection', 'InferenceSupportedCollection', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'Thursday', 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'TheTerm', 'IndeterminateTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'TernaryRelation', 'FixedArityRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'TernaryRelation', 'FixedArityRelation', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'TernaryPredicate', 'TernaryRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'TernaryPredicate', 'TernaryRelation', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'TernaryPredicate', tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'TernaryPredicate', tPred, 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'TernaryFunction', 'TernaryRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'TernaryFunction', 'TernaryRelation', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'TernaryFunction', tFunction, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'TernaryFunction', tFunction, 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'SymmetricBinaryPredicate', 'CommutativeRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'SymmetricBinaryPredicate', 'CommutativeRelation', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'SymmetricBinaryPredicate', 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'SymmetricBinaryPredicate', 'BinaryPredicate', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'Sunday', 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'SubLSymbol', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'SubLSymbol', 'SubLAtom', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'SubLSymbol', 'SubLAtom', 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(genls, 'SubLSymbol', 'CycLExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'SubLSymbol', 'CycLExpression', 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(genls, 'SubLString', 'SubLAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'SubLString', 'SubLAtomicTerm', 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(genls, 'SubLString', 'SubLAtom', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'SubLString', 'SubLAtom', 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(genls, 'SubLSExpression', 'CharacterString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'SubLRealNumber', 'SubLAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'SubLRealNumber', 'SubLAtomicTerm', 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(genls, 'SubLRealNumber', 'SubLAtom', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'SubLPositiveInteger', 'SubLNonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'SubLPositiveInteger', 'SubLNonNegativeInteger', 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(genls, 'SubLPositiveInteger', 'SubLInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'SubLPositiveInteger', 'SubLInteger', 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(genls, 'SubLNonVariableSymbol', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'SubLNonVariableSymbol', 'SubLSymbol', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'SubLNonVariableSymbol', 'SubLSymbol', 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(genls, 'SubLNonVariableSymbol', 'SubLAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'SubLNonVariableSymbol', 'SubLAtomicTerm', 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(genls, 'SubLNonVariableNonKeywordSymbol', 'SubLNonVariableSymbol', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'SubLNonNegativeInteger', 'SubLInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'SubLNonNegativeInteger', 'SubLInteger', 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(genls, 'SubLNonNegativeInteger', 'CycLExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'SubLNonNegativeInteger', 'CycLExpression', 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(genls, 'SubLList', 'CycLTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'SubLKeyword', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'SubLKeyword', 'SubLSymbol', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'SubLKeyword', 'SubLNonVariableSymbol', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'SubLInteger', 'SubLRealNumber', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'SubLInteger', 'SubLRealNumber', 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(genls, 'SubLExpressionType', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'SubLCharacter', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'SubLCharacter', 'SubLAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'SubLCharacter', 'SubLAtomicTerm', 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(genls, 'SubLAtomicTerm', 'CycLClosedAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'SubLAtomicTerm', 'CycLClosedAtomicTerm', 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(genls, 'SubLAtom', 'CycLTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'SkolemFunction', 'ReifiableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'SkolemFunction', 'ReifiableFunction', 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(genls, 'SkolemFunction', 'IndeterminateTermDenotingFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'SkolemFuncN', 'SkolemFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'SkolemFuncN', 'SkolemFunction', 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(genls, 'SiblingDisjointCollectionType', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'SiblingDisjointAttributeType', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'SetOrCollection', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'SetOrCollection', 'Thing', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'Set-Mathematical', 'SetOrCollection', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'Set-Mathematical', 'SetOrCollection', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'September', 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'SententialRelation', 'TruthFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'SententialRelation', 'TruthFunction', 'LogicalTruthMt', vStrDef).
assertedTinyKB(genls, 'ScopingRelation', tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'ScopingRelation', tRelation, 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'ScalarPointValue', 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'ScalarPointValue', 'ScalarInterval', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'ScalarInterval', 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'ScalarIntegralValue', 'ScalarPointValue', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'Saturday', 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'RuleTemplate', 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'RemovalModuleSupportedPredicate-Specific', 'InferenceSupportedPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'RemovalModuleSupportedPredicate-Specific', 'CycLTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'RemovalModuleSupportedPredicate-Generic', 'InferenceSupportedPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'RemovalModuleSupportedPredicate-Generic', 'CycLTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'RemovalModuleSupportedCollection-Generic', 'InferenceSupportedCollection', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, tRelation, 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'ReifiableFunction', tFunction, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'ReifiableFunction', tFunction, 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(genls, 'ReformulatorIrrelevantFORT', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'ReformulatorHighlyRelevantFORT', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'ReformulatorDirectivePredicate', tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'ReflexiveBinaryPredicate', 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'ReflexiveBinaryPredicate', 'BinaryPredicate', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'RealNumber', 'ScalarPointValue', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'RealNumber', 'ScalarPointValue', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'QuintaryRelation', 'FixedArityRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'QuintaryRelation', 'FixedArityRelation', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'QuintaryPredicate', 'QuintaryRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'QuintaryPredicate', 'QuintaryRelation', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'QuintaryPredicate', tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'QuintaryPredicate', tPred, 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'QuintaryFunction', 'QuintaryRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'QuintaryFunction', 'QuintaryRelation', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'QuintaryFunction', tFunction, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'QuintaryFunction', tFunction, 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'QuaternaryRelation', 'FixedArityRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'QuaternaryRelation', 'FixedArityRelation', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'QuaternaryPredicate', 'QuaternaryRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'QuaternaryPredicate', 'QuaternaryRelation', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'QuaternaryPredicate', tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'QuaternaryPredicate', tPred, 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'QuaternaryFunction', 'QuaternaryRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'QuaternaryFunction', 'QuaternaryRelation', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'QuaternaryFunction', tFunction, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'QuaternaryFunction', tFunction, 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'Quantifier', 'SententialRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'Quantifier', 'SententialRelation', 'LogicalTruthMt', vStrDef).
assertedTinyKB(genls, 'Quantifier', 'ScopingRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'Quantifier', 'ScopingRelation', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'ProblemSolvingCntxt', 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'ProblemSolvingCntxt', 'Microtheory', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'PredicateTypeByArity', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, tPred, 'TruthFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, tPred, 'TruthFunction', 'LogicalTruthMt', vStrDef).
assertedTinyKB(genls, 'PositiveInteger', 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'PositiveInteger', 'NonNegativeInteger', 'LogicalTruthMt', vStrDef).
assertedTinyKB(genls, 'PositiveInteger', 'Integer', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'PartiallyCommutativeRelation', tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'PartiallyCommutativeRelation', tRelation, 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'Open-InferenceProblemLinkStatus', 'CycInferenceProblemLinkStatus', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'October', 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'November', 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'NonNegativeScalarInterval', 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'NonNegativeScalarInterval', 'ScalarInterval', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'NonNegativeInteger', 'NonNegativeScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'NonNegativeInteger', 'Integer', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'NonNegativeInteger', 'Integer', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'NoGood-ProblemProvabilityStatus', 'CycProvabilityStatus', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'Neutral-ProblemProvabilityStatus', 'CycProvabilityStatus', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'Multigraph', 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'MonthOfYearType', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'Monday', 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'MicrotheoryDesignatingRelation', tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'MicrotheoryDesignatingRelation', tRelation, 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'Microtheory', 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'May', 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'March', 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'LogicalConnective', 'SententialRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'LogicalConnective', 'SententialRelation', 'LogicalTruthMt', vStrDef).
assertedTinyKB(genls, 'List', 'List', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(genls, 'List', 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'larkc-VariableBinding', 'larkc-InformationSet', 'BaseKB', vStrDef).
assertedTinyKB(genls, 'larkc-TriplePatternQuery', 'larkc-Query', 'BaseKB', vStrDef).
assertedTinyKB(genls, 'larkc-SPARQLQuery', 'larkc-Query', 'BaseKB', vStrDef).
assertedTinyKB(genls, 'larkc-SetOfStatements', 'larkc-InformationSet', 'BaseKB', vStrDef).
assertedTinyKB(genls, 'larkc-Selecter', 'larkc-Plugin', 'BaseKB', vStrDef).
assertedTinyKB(genls, 'larkc-Scalability', 'wsl-NonFunctionalParameter', 'BaseKB', vStrDef).
assertedTinyKB(genls, 'larkc-Reasoner', 'larkc-Plugin', 'BaseKB', vStrDef).
assertedTinyKB(genls, 'larkc-RdfGraph', 'larkc-SetOfStatements', 'BaseKB', vStrDef).
assertedTinyKB(genls, 'larkc-QueryTransformer', 'larkc-Plugin', 'BaseKB', vStrDef).
assertedTinyKB(genls, 'larkc-Query', 'larkc-Resource', 'BaseKB', vStrDef).
assertedTinyKB(genls, 'larkc-NaturalLanguageDocument', 'larkc-InformationSet', 'BaseKB', vStrDef).
assertedTinyKB(genls, 'larkc-LabelledGroupOfStatements', 'larkc-SetOfStatements', 'BaseKB', vStrDef).
assertedTinyKB(genls, 'larkc-KeywordQuery', 'larkc-Query', 'BaseKB', vStrDef).
assertedTinyKB(genls, 'larkc-InformationSetTransformer', 'larkc-Plugin', 'BaseKB', vStrDef).
assertedTinyKB(genls, 'larkc-InformationSet', 'larkc-Resource', 'BaseKB', vStrDef).
assertedTinyKB(genls, 'larkc-Identifier', 'larkc-Plugin', 'BaseKB', vStrDef).
assertedTinyKB(genls, 'larkc-GateTransformer', 'larkc-InformationSetTransformer', 'BaseKB', vStrDef).
assertedTinyKB(genls, 'larkc-Decider', 'larkc-Plugin', 'BaseKB', vStrDef).
assertedTinyKB(genls, 'larkc-DataSet', 'larkc-SetOfStatements', 'BaseKB', vStrDef).
assertedTinyKB(genls, 'larkc-CycSelecter', 'larkc-Selecter', 'BaseKB', vStrDef).
assertedTinyKB(genls, 'larkc-CycReasoner', 'larkc-Reasoner', 'BaseKB', vStrDef).
assertedTinyKB(genls, 'larkc-CycGateDecider', 'larkc-Decider', 'BaseKB', vStrDef).
assertedTinyKB(genls, 'larkc-Cost', 'wsl-NonFunctionalParameter', 'BaseKB', vStrDef).
assertedTinyKB(genls, 'larkc-BooleanInformationSet', 'larkc-InformationSet', 'BaseKB', vStrDef).
assertedTinyKB(genls, 'larkc-ArticleIdentifier', 'larkc-Identifier', 'BaseKB', vStrDef).
assertedTinyKB(genls, 'KnowledgeBase', 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'June', 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'July', 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'January', 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'IrreflexiveBinaryPredicate', 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'IrreflexiveBinaryPredicate', 'BinaryPredicate', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'InterArgIsaPredicate', 'ArgIsaPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'InterArgFormatPredicate', 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'InterArgFormatPredicate', 'TernaryPredicate', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'InterArgFormatPredicate', 'ArgConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'Integer', 'ScalarIntegralValue', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'Integer', 'RealNumber', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'InferenceSupportedTerm', 'CycLTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'InferenceSupportedPredicate', 'InferenceSupportedTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'InferenceSupportedFunction', 'CycLTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'InferenceSupportedCollection', 'InferenceSupportedTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'InferenceRelatedBookkeepingPredicate', 'BookkeepingPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'Individual', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'Individual', 'Thing', 'LogicalTruthMt', vStrDef).
assertedTinyKB(genls, 'IndeterminateTermDenotingFunction', tFunction, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'IndeterminateTerm', 'CycLClosedDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'HypotheticalContext', 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'HypotheticalContext', 'Microtheory', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'HumanCyclist', 'Cyclist', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'HumanCyclist', 'Cyclist', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'HLPrototypicalTerm', 'IndeterminateTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'HLExternalIDString', 'SubLAtom', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'HLAssertedArgumentKeywordDatastructure', 'CycArgumentDatastructure', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'Good-ProblemProvabilityStatus', 'CycProvabilityStatus', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, tFunction, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, tFunction, tRelation, 'LogicalTruthMt', vStrDef).
assertedTinyKB(genls, 'Friday', 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'Forward-AssertionDirection', 'CycLAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'Format', 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'FixedAritySkolemFunction', 'SkolemFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'FixedAritySkolemFunction', 'SkolemFunction', 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(genls, 'FixedAritySkolemFunction', 'FixedArityRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'FixedAritySkolemFunction', 'FixedArityRelation', 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(genls, 'FixedAritySkolemFuncN', 'SkolemFuncN', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'FixedAritySkolemFuncN', 'SkolemFuncN', 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(genls, 'FixedAritySkolemFuncN', 'FixedAritySkolemFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'FixedAritySkolemFuncN', 'FixedAritySkolemFunction', 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(genls, 'FixedArityRelation', tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'FixedArityRelation', tRelation, 'LogicalTruthMt', vStrDef).
assertedTinyKB(genls, 'February', 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'ExistentialQuantifier-Bounded', 'TernaryRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'ExistentialQuantifier-Bounded', 'ExistentialQuantifier', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'ExistentialQuantifier', 'Quantifier', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'ExistentialQuantifier', 'Quantifier', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'ExceptionPredicate', tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'EvaluatableRelation', tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'EvaluatableRelation', tRelation, 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'EvaluatablePredicate', tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'EvaluatablePredicate', 'EvaluatableRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'EvaluatableFunction', 'UnreifiableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'EvaluatableFunction', tFunction, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'EvaluatableFunction', tFunction, 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'EvaluatableFunction', 'EvaluatableRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'EvaluatableFunction', 'EvaluatableRelation', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'ELRelation-Reversible', 'ELRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'ELRelation-OneWay', 'ELRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'ELRelation', tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'DocumentationPredicate', tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'DocumentationConstant', 'CycLConstant', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'DocumentationConstant', 'CycLConstant', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'DistributingMetaKnowledgePredicate', tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'DisjointCollectionType', 'SiblingDisjointCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'DirectedMultigraph', 'Multigraph', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'DirectedMultigraph', 'Multigraph', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'DefaultMonotonicPredicate', tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'December', 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'DayOfWeekType', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycTransformationProof', 'CycProof', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycTactic', 'CycInferenceDataStructure', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycSupportDatastructure', 'CycInferenceDataStructure', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycProvabilityStatus', 'CycInferenceDataStructure', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycProof', 'CycInferenceDataStructure', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycProblemStore', 'CycInferenceDataStructure', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycProblemLink-Union', 'CycProblemLink-Disjunctive', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycProblemLink-Transformation', 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycProblemLink-Structural', 'CycProblemLink', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycProblemLink-Split', 'CycProblemLink-Conjunctive', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycProblemLink-Restriction', 'CycProblemLink-Structural', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycProblemLink-Removal', 'CycProblemLink-Content', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycProblemLink-Logical', 'CycProblemLink-Structural', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycProblemLink-JoinOrdered', 'CycProblemLink-Conjunctive', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycProblemLink-Join', 'CycProblemLink-Conjunctive', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycProblemLink-Disjunctive', 'CycProblemLink-Logical', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycProblemLink-Content', 'CycProblemLink', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycProblemLink-Conjunctive', 'CycProblemLink-Logical', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycProblemLink-AnswerLink', 'CycProblemLink-Structural', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycProblemLink', 'CycInferenceDataStructure', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycProblem', 'CycInferenceDataStructure', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, ftVar, 'CycLRepresentedAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, ftVar, 'CycLRepresentedAtomicTerm', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, ftVar, 'CycLOpenDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, ftVar, 'CycLOpenDenotationalTerm', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, ftVar, 'CycLAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, ftVar, 'CycLAtomicTerm', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLTruthValueSentence', 'CycLConstant', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLTruthValueSentence', 'CycLClosedSentence', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLTruthValueSentence', 'CycLClosedSentence', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLTerm', 'CycLExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLTerm', 'CycLExpression', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLSentence-ClosedPredicate', 'CycLSentence', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLSentence-ClosedPredicate', 'CycLSentence', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLSentence-Assertible', 'CycLSentence-Askable', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLSentence-Assertible', 'CycLSentence-Askable', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLSentence-Assertible', 'CycLExpression-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLSentence-Assertible', 'CycLExpression-Assertible', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLSentence-Askable', 'CycLSentence', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLSentence-Askable', 'CycLSentence', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLSentence-Askable', 'CycLExpression-Askable', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLSentence-Askable', 'CycLExpression-Askable', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLSentence', 'CycLTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLSentence', 'CycLTerm', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLSentence', 'CycLExpression', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLRuleAssertion', 'CycLAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLRuleAssertion', 'CycLAssertion', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLRepresentedTerm', 'CycLDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLRepresentedTerm', 'CycLDenotationalTerm', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLRepresentedAtomicTerm', 'CycLRepresentedTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLRepresentedAtomicTerm', 'CycLRepresentedTerm', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLRepresentedAtomicTerm', 'CycLAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLRepresentedAtomicTerm', 'CycLAtomicTerm', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLReifiedDenotationalTerm', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLReifiedDenotationalTerm', 'CycLReifiableDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLReifiedDenotationalTerm', 'CycLReifiableDenotationalTerm', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLReifiableNonAtomicTerm', 'CycLReifiableDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLReifiableNonAtomicTerm', 'CycLNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLReifiableNonAtomicTerm', 'CycLIndexedTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLReifiableNonAtomicTerm', 'CycLIndexedTerm', 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(genls, 'CycLReifiableNonAtomicTerm', 'CycLExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLReifiableNonAtomicTerm', 'CycLExpression', 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(genls, 'CycLReifiableNonAtomicTerm', 'CycLClosedNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLReifiableDenotationalTerm', 'CycLIndexedTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLReifiableDenotationalTerm', 'CycLClosedDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLReifiableDenotationalTerm', 'CycLClosedDenotationalTerm', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLReformulationRulePredicate', tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLPropositionalSentence', 'CycLSentence-Askable', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLPropositionalSentence', 'CycLSentence-Askable', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLPropositionalSentence', 'CycLClosedSentence', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLPropositionalSentence', 'CycLClosedSentence', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLOpenSentence', 'CycLSentence', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLOpenSentence', 'CycLSentence', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLOpenSentence', 'CycLOpenFormula', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLOpenSentence', 'CycLOpenFormula', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLOpenSentence', 'CycLOpenExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLOpenSentence', 'CycLFormulaicSentence', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLOpenSentence', 'CycLFormulaicSentence', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLOpenNonAtomicTerm', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLOpenNonAtomicTerm', 'CycLOpenFormula', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLOpenNonAtomicTerm', 'CycLOpenFormula', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLOpenNonAtomicTerm', 'CycLOpenDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLOpenNonAtomicTerm', 'CycLOpenDenotationalTerm', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLOpenNonAtomicTerm', 'CycLNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLOpenNonAtomicTerm', 'CycLNonAtomicTerm', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLOpenFormula', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLOpenFormula', 'CycLOpenExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLOpenFormula', 'CycLOpenExpression', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLOpenFormula', 'CycLFormula', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLOpenFormula', 'CycLFormula', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLOpenExpression', 'CycLTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLOpenExpression', 'CycLTerm', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLOpenExpression', 'CycLExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLOpenExpression', 'CycLExpression', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLOpenDenotationalTerm', 'CycLOpenExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLOpenDenotationalTerm', 'CycLOpenExpression', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLOpenDenotationalTerm', 'CycLDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLOpenDenotationalTerm', 'CycLDenotationalTerm', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLNonAtomicTerm-ClosedFunctor', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLNonAtomicTerm-ClosedFunctor', 'CycLNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLNonAtomicTerm-ClosedFunctor', 'CycLNonAtomicTerm', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLNonAtomicTerm-Assertible', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLNonAtomicTerm-Assertible', 'CycLNonAtomicTerm-Askable', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLNonAtomicTerm-Assertible', 'CycLNonAtomicTerm-Askable', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLNonAtomicTerm-Assertible', 'CycLExpression-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLNonAtomicTerm-Assertible', 'CycLExpression-Assertible', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLNonAtomicTerm-Assertible', 'CycLDenotationalTerm-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLNonAtomicTerm-Askable', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLNonAtomicTerm-Askable', 'CycLNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLNonAtomicTerm-Askable', 'CycLNonAtomicTerm', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLNonAtomicTerm-Askable', 'CycLExpression-Askable', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLNonAtomicTerm-Askable', 'CycLExpression-Askable', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLNonAtomicTerm', 'CycLRepresentedTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLNonAtomicTerm', 'CycLRepresentedTerm', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLNonAtomicTerm', 'CycLFormula', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLNonAtomicTerm', 'CycLFormula', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLNonAtomicTerm', 'CycLDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLNonAtomicTerm', 'CycLDenotationalTerm', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLNonAtomicReifiedTerm', 'CycLReifiedDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLNonAtomicReifiedTerm', 'CycLReifiedDenotationalTerm', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLNonAtomicReifiedTerm', 'CycLReifiableNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLNonAtomicReifiedTerm', 'CycLClosedNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLNonAtomicReifiedTerm', 'CycLClosedNonAtomicTerm', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLNonAtomicReifiedTerm', 'CycKBDatastructure', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'Cyclist', 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLIndexedTerm', 'CycLClosedExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLGenericRelationFormula', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLGenericRelationFormula', 'CycLFormula', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLGenericRelationFormula', 'CycLFormula', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLGAFAssertion', 'CycLClosedAtomicSentence', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLGAFAssertion', 'CycLClosedAtomicSentence', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLGAFAssertion', 'CycLAtomicAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLGAFAssertion', 'CycLAtomicAssertion', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLGAFAssertion', 'CycLAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLFormulaicSentence', 'CycLSentence', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLFormulaicSentence', 'CycLSentence', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLFormulaicSentence', 'CycLFormula', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLFormulaicSentence', 'CycLFormula', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLFormula', 'CycLTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLFormula', 'CycLTerm', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLFormula', 'CycLExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLFormula', 'CycLExpression', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, ttFormatType, 'SubLExpressionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLExpression-Assertible', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLExpression-Assertible', 'CycLExpression-Askable', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLExpression-Assertible', 'CycLExpression-Askable', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLExpression-Askable', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLExpression-Askable', 'CycLExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLExpression-Askable', 'CycLExpression', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLExpression', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLExpression', 'Thing', 'LogicalTruthMt', vStrDef).
assertedTinyKB(genls, 'CycLExpression', 'SubLSExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLExpression', 'SubLSExpression', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLExpression', 'CycLTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLExpression', 'CycLTerm', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLDenotationalTerm-Assertible', 'CycLExpression-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLDenotationalTerm-Assertible', 'CycLDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLDenotationalTerm', 'CycLTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLDenotationalTerm', 'CycLTerm', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLDenotationalTerm', 'CycLExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLDenotationalTerm', 'CycLExpression', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLDeducedAssertion', 'CycLAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLDeducedAssertion', 'CycLAssertion', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLConstant', 'CycLRepresentedAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLConstant', 'CycLRepresentedAtomicTerm', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLConstant', 'CycLReifiedDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLConstant', 'CycLReifiedDenotationalTerm', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLConstant', 'CycLReifiableDenotationalTerm', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLConstant', 'CycLClosedAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLConstant', 'CycLClosedAtomicTerm', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLClosedSentence', 'CycLSentence-ClosedPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLClosedSentence', 'CycLSentence-ClosedPredicate', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLClosedSentence', 'CycLClosedExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLClosedNonAtomicTerm', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLClosedNonAtomicTerm', 'CycLNonAtomicTerm-ClosedFunctor', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLClosedNonAtomicTerm', 'CycLNonAtomicTerm-ClosedFunctor', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLClosedNonAtomicTerm', 'CycLNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLClosedNonAtomicTerm', 'CycLNonAtomicTerm', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLClosedNonAtomicTerm', 'CycLClosedFormula', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLClosedNonAtomicTerm', 'CycLClosedDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLClosedNonAtomicTerm', 'CycLClosedDenotationalTerm', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLClosedFormula', 'CycLFormula', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLClosedFormula', 'CycLFormula', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLClosedFormula', 'CycLClosedExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLClosedFormula', 'CycLClosedExpression', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLClosedExpression', 'CycLTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLClosedExpression', 'CycLTerm', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLClosedExpression', 'CycLExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLClosedExpression', 'CycLExpression', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLClosedDenotationalTerm', 'CycLDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLClosedDenotationalTerm', 'CycLDenotationalTerm', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLClosedDenotationalTerm', 'CycLClosedExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLClosedDenotationalTerm', 'CycLClosedExpression', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLClosedAtomicTerm', 'CycLClosedDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLClosedAtomicTerm', 'CycLClosedDenotationalTerm', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLClosedAtomicTerm', 'CycLAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLClosedAtomicTerm', 'CycLAtomicTerm', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLClosedAtomicSentence', 'CycLClosedSentence', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLClosedAtomicSentence', 'CycLClosedFormula', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLClosedAtomicSentence', 'CycLAtomicSentence', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLClosedAtomicSentence', 'CycLAtomicSentence', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLAtomicTerm', 'CycLExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLAtomicTerm', 'CycLExpression', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLAtomicTerm', 'CycLDenotationalTerm-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLAtomicTerm', 'CycLDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLAtomicTerm', 'CycLDenotationalTerm', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLAtomicSentence', 'CycLSentence', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLAtomicSentence', 'CycLSentence', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLAtomicSentence', 'CycLFormulaicSentence', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLAtomicSentence', 'CycLFormulaicSentence', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLAtomicAssertion', 'CycLAtomicSentence', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLAtomicAssertion', 'CycLAtomicSentence', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLAtomicAssertion', 'CycLAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLAtomicAssertion', 'CycLAssertion', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLAssertionDirection', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLAssertion', 'CycSupportDatastructure', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLAssertion', 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLAssertion', 'CycLSentence-Assertible', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycLAssertion', 'CycLIndexedTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLAssertedAssertion', 'CycLAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycLAssertedAssertion', 'CycLAssertion', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CycKBDatastructure', 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycInferenceProblemLinkStatus', 'CycInferenceDataStructure', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycInferenceDataStructure', 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycInferenceBindingsDataStructure', 'CycInferenceDataStructure', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycInferenceAnswerJustification', 'CycInferenceDataStructure', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycInferenceAnswer', 'CycInferenceDataStructure', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycInference', 'CycInferenceDataStructure', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycHLTruthValue', 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycHLSupportDatastructure', 'CycSupportDatastructure', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycHLSupportDatastructure', 'CycKBDatastructure', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycDeductionDatastructure', 'CycArgumentDatastructure', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CycArgumentDatastructure', 'CycKBDatastructure', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CommutativeRelation', tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CommutativeRelation', tRelation, 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'CollectionDenotingFunction', tFunction, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CollectionDenotingFunction', tFunction, 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, tCol, 'Thing', 'LogicalTruthMt', vStrDef).
assertedTinyKB(genls, tCol, 'SetOrCollection', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, tCol, 'SetOrCollection', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'Code-AssertionDirection', 'CycLAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'Closed-InferenceProblemLinkStatus', 'CycInferenceProblemLinkStatus', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CharacterString', 'List', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'CanonicalizerDirective', 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'BroadMicrotheory', 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'BookkeepingPredicate', tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'BookkeepingPredicate', tPred, 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'BinaryRelation', 'FixedArityRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'BinaryRelation', 'FixedArityRelation', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'BinaryPredicate', tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'BinaryPredicate', tPred, 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'BinaryPredicate', 'FixedArityRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'BinaryPredicate', 'FixedArityRelation', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'BinaryPredicate', 'BinaryRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'BinaryPredicate', 'BinaryRelation', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'BinaryFunction', tFunction, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'BinaryFunction', tFunction, 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'BinaryFunction', 'BinaryRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'BinaryFunction', 'BinaryRelation', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'Backward-AssertionDirection', 'CycLAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'August', 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'AtemporalNecessarilyEssentialCollectionType', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'AsymmetricBinaryPredicate', 'IrreflexiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'AsymmetricBinaryPredicate', 'IrreflexiveBinaryPredicate', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'AsymmetricBinaryPredicate', 'AntiSymmetricBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'AsymmetricBinaryPredicate', 'AntiSymmetricBinaryPredicate', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'AssociativeRelation', tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'AssociativeRelation', tRelation, 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'ArgTypeTernaryPredicate', 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'ArgTypeTernaryPredicate', 'TernaryPredicate', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'ArgTypeTernaryPredicate', 'ArgTypePredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'ArgTypeTernaryPredicate', 'ArgTypePredicate', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'ArgTypePredicate', 'CycLTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'ArgTypePredicate', 'ArgConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'ArgTypePredicate', 'ArgConstraintPredicate', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'ArgTypeBinaryPredicate', 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'ArgTypeBinaryPredicate', 'BinaryPredicate', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'ArgTypeBinaryPredicate', 'ArgTypePredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'ArgTypeBinaryPredicate', 'ArgTypePredicate', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'ArgSometimesIsaPredicate', tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'ArgQuotedIsaTernaryPredicate', 'ArgTypeTernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'ArgQuotedIsaTernaryPredicate', 'ArgTypeTernaryPredicate', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'ArgQuotedIsaTernaryPredicate', 'ArgQuotedIsaPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'ArgQuotedIsaPredicate', 'ArgTypePredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'ArgQuotedIsaBinaryPredicate', 'ArgTypeBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'ArgQuotedIsaBinaryPredicate', 'ArgTypeBinaryPredicate', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'ArgQuotedIsaBinaryPredicate', 'ArgQuotedIsaPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'ArgIsaTernaryPredicate', 'ArgTypeTernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'ArgIsaTernaryPredicate', 'ArgTypeTernaryPredicate', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'ArgIsaTernaryPredicate', 'ArgIsaPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'ArgIsaPredicate', 'ArgTypePredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'ArgIsaBinaryPredicate', 'ArgTypeBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'ArgIsaBinaryPredicate', 'ArgTypeBinaryPredicate', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'ArgIsaBinaryPredicate', 'ArgIsaPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'ArgGenlTernaryPredicate', 'ArgTypeTernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'ArgGenlTernaryPredicate', 'ArgTypeTernaryPredicate', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'ArgGenlQuantityTernaryPredicate', 'ArgTypeTernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'ArgGenlQuantityTernaryPredicate', 'ArgTypeTernaryPredicate', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'ArgGenlQuantityBinaryPredicate', 'ArgTypeBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'ArgGenlQuantityBinaryPredicate', 'ArgTypeBinaryPredicate', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'ArgGenlBinaryPredicate', 'ArgTypeBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'ArgGenlBinaryPredicate', 'ArgTypeBinaryPredicate', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'ArgConstraintPredicate', tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'April', 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'AntiTransitiveBinaryPredicate', 'IrreflexiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'AntiTransitiveBinaryPredicate', 'IrreflexiveBinaryPredicate', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, 'AntiSymmetricBinaryPredicate', 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genls, 'AntiSymmetricBinaryPredicate', 'BinaryPredicate', 'CoreCycLMt', vStrDef).
assertedTinyKB(genls, '$VAR'('X'), '$VAR'('X'), 'LogicalTruthMt', vStrMon).
assertedTinyKB(genlPreds, trueSentence, consistent, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, synonymousExternalConcept, overlappingExternalConcept, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, siblingDisjointExceptions, different, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, sentenceEquiv, sentenceImplies, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, rewriteOf, equals, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, relationAllExistsCount, relationAllExistsMin, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, relationAllExistsCount, relationAllExistsMax, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, reformulatorEquiv, reformulatorRule, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, reformulatorEquals, reformulatorRule, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, quotedArgument, opaqueArgument, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, quantitySubsumes, quantityIntersects, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, pointQuantValue, numericallyEquals, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, pointQuantValue, minQuantValue, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, pointQuantValue, maxQuantValue, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, numericallyEquals, quantitySubsumes, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, numericallyEquals, greaterThanOrEqualTo, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, nearestIsa, isa, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, nearestGenls, genls, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, nearestGenlPreds, genlPreds, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, nearestGenlMt, genlMt, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, natFunction, termDependsOn, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, minQuantValue, quantitySubsumes, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, maxQuantValue, quantitySubsumes, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, knownSentence, trueSentence, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, knownAntecedentRule, highlyRelevantAssertion, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, isa, elementOf, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, indexicalReferent, equals, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, greaterThan, greaterThanOrEqualTo, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, greaterThan, different, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, genls, subsetOf, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, followingValue, different, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, expresses, means, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, exactlyAssertedSentence, assertedSentence, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, equalSymbols, equals, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, elInverse, genlInverse, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, different, differentSymbols, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, denotes, means, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, defnIff, defnSufficient, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, defnIff, defnNecessary, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, definingMt, termDependsOn, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, consistent, admittedSentence, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, completelyEnumerableCollection, completelyDecidableCollection, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, completelyEnumerableCollection, completelyDecidableCollection, 'CoreCycLMt', vStrDef).
assertedTinyKB(genlPreds, completeExtentEnumerableViaBackchain, minimizeExtent, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, completeExtentEnumerableViaBackchain, minimizeExtent, 'CoreCycLMt', vStrDef).
assertedTinyKB(genlPreds, completeExtentEnumerableForValueInArg, nonAbducibleWithValueInArg, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, completeExtentEnumerableForValueInArg, nonAbducibleWithValueInArg, 'CoreCycLMt', vStrDef).
assertedTinyKB(genlPreds, completeExtentEnumerableForValueInArg, completeExtentDecidableForValueInArg, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, completeExtentEnumerableForValueInArg, completeExtentDecidableForValueInArg, 'CoreCycLMt', vStrDef).
assertedTinyKB(genlPreds, completeExtentEnumerable, minimizeExtent, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, completeExtentEnumerable, minimizeExtent, 'CoreCycLMt', vStrDef).
assertedTinyKB(genlPreds, completeExtentEnumerable, completeExtentDecidable, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, completeExtentEnumerable, completeExtentDecidable, 'CoreCycLMt', vStrDef).
assertedTinyKB(genlPreds, completeExtentDecidable, backchainForbidden, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, completeExtentAssertedForValueInArg, completeExtentEnumerableForValueInArg, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, completeExtentAssertedForValueInArg, completeExtentEnumerableForValueInArg, 'CoreCycLMt', vStrDef).
assertedTinyKB(genlPreds, completeExtentAsserted, completeExtentEnumerable, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, completeExtentAsserted, completeExtentEnumerable, 'CoreCycLMt', vStrDef).
assertedTinyKB(genlPreds, commutativeInArgsAndRest, commutativeInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, collectionIsaBackchainRequired, collectionIsaBackchainEncouraged, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, collectionGenlsBackchainRequired, collectionGenlsBackchainEncouraged, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, collectionBackchainRequired, collectionIsaBackchainRequired, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, collectionBackchainRequired, collectionGenlsBackchainRequired, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, collectionBackchainRequired, collectionBackchainEncouraged, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, collectionBackchainEncouraged, collectionIsaBackchainEncouraged, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, collectionBackchainEncouraged, collectionGenlsBackchainEncouraged, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, coExtensional, genls, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, canonicalizerDirectiveForArgAndRest, canonicalizerDirectiveForArg, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, canonicalizerDirectiveForArgAndRest, canonicalizerDirectiveForArg, 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(genlPreds, assertedSentence, knownSentence, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, assertedPredicateArg, admittedArgument, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, argsIsa, arg1Isa, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, argIsa, argSometimesIsa, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, argAndRestQuotedIsa, argQuotedIsa, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, argAndRestIsa, argIsa, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, 'ist-Asserted', ist, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, 'equalStrings-CaseInsensitive', equals, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlPreds, 'equalStrings-CaseInsensitive', 'substring-CaseInsensitive', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlMt, dot_holds(['MtSpace'|'$VAR'('_MT_DIMS')]), 'UniversalVocabularyMt', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(genlMt, 'UniversalVocabularyMt', 'UniversalVocabularyImplementationMt', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlMt, 'UniversalVocabularyMt', 'CoreCycLImplementationMt', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlMt, 'UniversalVocabularyMt', 'BaseKB', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlMt, 'UniversalVocabularyImplementationMt', 'UniversalVocabularyMt', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlMt, 'UniversalVocabularyImplementationMt', 'CoreCycLImplementationMt', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlMt, 'UniversalVocabularyImplementationMt', 'BaseKB', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlMt, 'TemporaryEnglishParaphraseMt', 'EnglishParaphraseMt', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlMt, 'TemporaryEnglishParaphraseMt', 'BaseKB', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlMt, 'QueryMt', 'BaseKB', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlMt, 'LogicalTruthMt', 'LogicalTruthImplementationMt', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlMt, 'LogicalTruthMt', 'BaseKB', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlMt, 'LogicalTruthImplementationMt', 'LogicalTruthMt', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlMt, 'LogicalTruthImplementationMt', 'BaseKB', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlMt, 'InferencePSC', 'BaseKB', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlMt, 'EverythingPSC', 'BaseKB', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlMt, 'EnglishParaphraseMt', 'CurrentWorldDataCollectorMt-NonHomocentric', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlMt, 'EnglishParaphraseMt', 'BaseKB', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlMt, 'CyclistDefinitionalMt', 'BaseKB', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlMt, 'CurrentWorldDataCollectorMt-NonHomocentric', 'CyclistDefinitionalMt', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlMt, 'CurrentWorldDataCollectorMt-NonHomocentric', 'BaseKB', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlMt, 'CoreCycLMt', 'LogicalTruthMt', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlMt, 'CoreCycLMt', 'CoreCycLImplementationMt', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlMt, 'CoreCycLMt', 'BaseKB', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlMt, 'CoreCycLImplementationMt', 'LogicalTruthImplementationMt', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlMt, 'CoreCycLImplementationMt', 'CoreCycLMt', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlMt, 'CoreCycLImplementationMt', 'BaseKB', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlMt, 'BookkeepingMt', 'EnglishParaphraseMt', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlMt, 'BookkeepingMt', 'BaseKB', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlMt, 'BaseKB', 'UniversalVocabularyMt', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlMt, 'BaseKB', 'UniversalVocabularyImplementationMt', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlMt, 'BaseKB', 'CoreCycLImplementationMt', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlMt, 'BaseKB', 'BaseKB', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlMt, '$VAR'('X'), '$VAR'('X'), 'LogicalTruthMt', vStrDef).
assertedTinyKB(genlInverse, siblingDisjointExceptions, siblingDisjointExceptions, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlInverse, sentenceEquiv, sentenceImplies, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlInverse, sentenceEquiv, sentenceEquiv, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlInverse, reformulatorRuleProperties, isa, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlInverse, quantitySubsumes, quantityIntersects, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlInverse, quantityIntersects, quantityIntersects, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlInverse, numericallyEquals, numericallyEquals, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlInverse, negationPreds, negationPreds, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlInverse, negationMt, negationMt, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlInverse, negationInverse, negationInverse, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlInverse, natFunction, operatorFormulas, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlInverse, minQuantValue, quantityIntersects, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlInverse, maxQuantValue, quantityIntersects, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlInverse, greaterThan, different, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlInverse, followingValue, greaterThan, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlInverse, equalSymbols, equalSymbols, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlInverse, equals, equals, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlInverse, elInverse, genlInverse, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlInverse, disjointWith, disjointWith, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlInverse, coExtensional, genls, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlInverse, coExtensional, coExtensional, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlInverse, 'equalStrings-CaseInsensitive', 'substring-CaseInsensitive', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(genlCanonicalizerDirectives, 'LeaveSomeTermsAtELAndAllowKeywordVariables', 'LeaveSomeTermsAtEL', 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(genlCanonicalizerDirectives, 'LeaveSomeTermsAtELAndAllowKeywordVariables', 'AllowKeywordVariables', 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(genlCanonicalizerDirectives, 'LeaveSomeTermsAtEL', 'LeaveVariablesAtEL', 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(genlCanonicalizerDirectives, 'AllowKeywordVariables', 'AllowGenericArgVariables', 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(genKeyword, thereExists, '$VAR'((':THERE_EXISTS')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, thereExistExactly, '$VAR'((':THERE_EXIST_EXACTLY')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, thereExistAtMost, '$VAR'((':THERE_EXIST_AT_MOST')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, thereExistAtLeast, '$VAR'((':THERE_EXIST_AT_LEAST')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, termOfUnit, '$VAR'((':TERM_OF_UNIT')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, relationExpansion, '$VAR'((':RELATION_EXPANSION')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, prettyString, '$VAR'((':PRETTY_NAME')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, or, '$VAR'((':OR')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, nthSmallestElement, '$VAR'((':NTH_SMALLEST_ELEMENT')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, nthLargestElement, '$VAR'((':NTH_LARGEST_ELEMENT')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, not, '$VAR'((':NOT')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, myCreator, '$VAR'((':MY_CREATOR')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, myCreationTime, '$VAR'((':MY_CREATION_TIME')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, isa, '$VAR'((':ISA')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, implies, '$VAR'((':IMPLIES')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, genMassNoun, '$VAR'((':GEN_MASS_NOUN')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, genls, '$VAR'((':GENLS')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, genFormat, '$VAR'((':GEN_FORMAT')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, forAll, '$VAR'((':FOR_ALL')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, exceptWhen, '$VAR'((':EXCEPT_WHEN')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, exceptFor, '$VAR'((':EXCEPT_FOR')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, equals, '$VAR'((':EQUALS')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, different, '$VAR'((':DIFFERENT')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, and, '$VAR'((':AND')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, 'VariableArityRelation', '$VAR'((':VARIABLE_ARITY_RELATION')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, 'UnitOfMeasure', '$VAR'((':UNIT_OF_MEASURE')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, 'Thing', '$VAR'((':THING')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, 'TheTerm', '$VAR'((':THE_TERM')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, 'TemporaryEnglishParaphraseMt', '$VAR'((':TEMPORARY_ENGLISH_PARAPHRASE_MT')), 'TemporaryEnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, 'SetOrCollection', '$VAR'((':SET_OR_COLLECTION')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, 'Set-Mathematical', '$VAR'((':SET_MATHEMATICAL')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, 'September', '$VAR'((':SEPTEMBER')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, tRelation, '$VAR'((':RELATIONSHIP')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, 'Quantifier', '$VAR'((':QUANTIFIER')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, 'PerFn', '$VAR'((':PER_FN')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, 'October', '$VAR'((':OCTOBER')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, 'November', '$VAR'((':NOVEMBER')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, 'NonNegativeInteger', '$VAR'((':NON_NEGATIVE_INTEGER')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, 'MeaningInSystemFn', '$VAR'((':MEANING_IN_SYSTEM_FN')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, 'May', '$VAR'((':MAY')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, 'March', '$VAR'((':MARCH')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, 'LogicalConnective', '$VAR'((':LOGICAL_CONNECTIVE')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, 'Kappa', '$VAR'((':KAPPA')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, 'June', '$VAR'((':JUNE')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, 'July', '$VAR'((':JULY')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, 'January', '$VAR'((':JANUARY')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, 'Individual', '$VAR'((':INDIVIDUAL')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, 'FunctionToArg', '$VAR'((':FUNCTION_TO_ARG')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, tFunction, '$VAR'((':NON_PREDICATE_FUNCTION')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, 'FixedAritySkolemFunction', '$VAR'((':SKOLEM_FUNCTION')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, 'February', '$VAR'((':FEBRUARY')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, 'EnglishParaphraseMt', '$VAR'((':ENGLISH_PARAPHRASE_MT')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, 'December', '$VAR'((':DECEMBER')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, tCol, '$VAR'((':COLLECTION')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, 'BaseKB', '$VAR'((':BASE_K_B')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, 'August', '$VAR'((':AUGUST')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genKeyword, 'April', '$VAR'((':APRIL')), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genFormat, xor, "either ~a or ~a (but not both)", 'TheEmptyList', 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genFormat, trueRule, "~a is true, and ~a is an instantiation of the rule template ~a", 'TheList'(2, 2, 1), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genFormat, thereExistAtMost, "there ~a at most ~a ~a such that ~a", 'TheList'('TheList'("is", "are"), 1, 2, 3), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genFormat, thereExistAtLeast, "there ~a at least ~a ~a such that ~a", 'TheList'('TheList'("is", "are"), 1, 2, 3), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genFormat, synonymousExternalConcept, "~s is synonymous with ~s in ~a", 'TheList'('TheList'(1, '$VAR'((':SINGULAR'))), 3, 2), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genFormat, substring, "~s is a substring of ~s", 'TheList'(1, 2), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genFormat, sentenceEquiv, "the formula ~a is logically equivalent to the formula ~a", 'TheList'('TheList'(1, '$VAR'((':QUOTE'))), 'TheList'(2, '$VAR'((':QUOTE')))), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genFormat, requiredArg2Pred, "every ~a is arg 2 of ~a relation", 'TheList'(1, 'TheList'(2, '$VAR'((':QUOTE')), '$VAR'((':A_THE_WORD')))), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genFormat, relationExpansion, "one CycL expansion for assertions which have ~a in the operator position is ~a", 'TheList'('TheList'(1, '$VAR'((':EQUALS'))), 'TheList'(2, '$VAR'((':EQUALS')))), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genFormat, notAssertibleMt, "Sentences cannot be asserted in ~a", 'TheList'('TheList'(1, '$VAR'((':EQUALS')))), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genFormat, nearestCommonIsa, "both ~a and ~a are ~a", 'TheList'(1, 2, 'TheList'(3, 'TheList'('$VAR'((':PN_MASS_NUMBER')), '$VAR'((':PN_SINGULAR')), '$VAR'((':MASS_NUMBER'))), '$VAR'((':GERUND')), '$VAR'((':AGENTIVE_SG')), '$VAR'((':SINGULAR')), '$VAR'((':A_THE_WORD')))), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genFormat, indexicalReferent, "the indexical term ~a refers to ~a", 'TheList'('TheList'(1, '$VAR'((':QUOTE'))), 2), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genFormat, implies, "if ~a, then ~a", 'TheEmptyList', 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genFormat, genFormat, "to generate English for assertions formed with ~a, the format string ~a is used with the extra information in this list: ~a", 'TheList'('TheList'(1, '$VAR'((':EQUALS'))), 2, 3), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genFormat, forAll, "for every ~a, ~a", 'TheEmptyList', 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genFormat, equiv, "~a if and only if ~a", 'TheEmptyList', 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genFormat, differentSymbols, "~a are different symbols", 'TheList'('TheList'(1, '$VAR'((':AND')))), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genFormat, cycTacticID, "the inference tactic ~a contained within the inference problem ~a, has ~a as its ID", 'TheList'('TheList'(1, '$VAR'((':SINGULAR'))), 'TheList'(2, '$VAR'((':SINGULAR')))), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genFormat, cycProofID, "the inference proof ~a contained within inference problem store ~a, has ~a as its ID", 'TheList'('TheList'(1, '$VAR'((':SINGULAR'))), 'TheList'(2, '$VAR'((':SINGULAR')))), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genFormat, cycProblemStoreProofCount, "the inference problem store ~a has ~a proof~a", 'TheList'(1, 2, 'TheList'("", "s")), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genFormat, cycProblemStoreProblemCount, "the inference problem store ~a has ~a inference problem~a", 'TheList'(1, 2, 'TheList'("", "s")), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genFormat, cycProblemStoreLinkCount, "the inference problem store ~a has ~a inference link~a", 'TheList'(1, 2, 'TheList'("", "s")), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genFormat, cycProblemStoreInferenceCount, "the inference problem store ~a has ~a inference~a", 'TheList'(1, 2, 'TheList'("", "s")), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genFormat, cycProblemLinkID, "the inference problem link ~a contained within inference problem store ~a, has ~a as its ID", 'TheList'('TheList'(1, '$VAR'((':SINGULAR'))), 'TheList'(2, '$VAR'((':SINGULAR')))), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genFormat, cycProblemID, "the inference problem ~a contained within inference problem store ~a, has ~a as its ID", 'TheList'('TheList'(1, '$VAR'((':SINGULAR'))), 'TheList'(2, '$VAR'((':SINGULAR')))), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genFormat, completeExtentEnumerable, "the complete extent of the predicate ~a is known", 'TheList'('TheList'(1, '$VAR'((':EQUALS')))), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genFormat, 'UnitProductFn', "~a-~a", 'TheList'('TheList'(1, '$VAR'((':PLURAL'))), 'TheList'(2, '$VAR'((':SINGULAR')))), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genFormat, 'TheSet', "the set containing ~a", 'TheList'('TheList'(1, '$VAR'((':AND')))), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genFormat, 'substring-CaseInsensitive', "~s is a case-insensitive substring of ~s", 'TheEmptyList', 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genFormat, 'RoundUpFn', "~a, truncated", 'TheEmptyList', 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genFormat, 'RoundUpFn', "~a, rounded up", 'TheEmptyList', 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genFormat, 'RoundDownFn', "~a, rounded down", 'TheEmptyList', 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genFormat, 'PlusFn', "the sum of ~a", 'TheList'('TheList'(1, '$VAR'((':AND')))), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genFormat, 'PlusAll', "the sum of ~a over ~a", 'TheList'(2, 'TheList'(1, '$VAR'((':PLURAL')))), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genFormat, 'MinRangeFn', "the minimum range subsumed by ~a and ~a", 'TheEmptyList', 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genFormat, 'Minimum', "the minimum ~a over ~a", 'TheList'(2, 'TheList'(1, '$VAR'((':PLURAL')))), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genFormat, 'MaxRangeFn', "the maximum range subsuming ~a and ~a", 'TheEmptyList', 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genFormat, 'Maximum', "the maximum ~a over ~a", 'TheList'(2, 'TheList'(1, '$VAR'((':PLURAL')))), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(genFormat, 'FunctionToArg', "'~a'", 'TheList'(2, '$VAR'((':SINGULAR')), '$VAR'((':MASS_NUMBER'))), 'EnglishParaphraseMt', vStrDef).
assertedTinyKB(fanOutArg, substring, 2, 'BaseKB', vStrMon).
assertedTinyKB(fanOutArg, genls, 1, 'BaseKB', vStrMon).
assertedTinyKB(fanOutArg, genlPreds, 1, 'BaseKB', vStrMon).
assertedTinyKB(fanOutArg, genlMt, 1, 'BaseKB', vStrMon).
assertedTinyKB(expansionDefn, 'TLVariableFn', 'SubLQuoteFn'('TL-VAR-TO-EL'), 'BaseKB', vStrDef).
assertedTinyKB(expansionDefn, 'TLReifiedNatFn', 'SubLQuoteFn'('TL-FUNCTION-TERM-TO-EL'), 'BaseKB', vStrDef).
assertedTinyKB(expansionDefn, 'TLAssertionFn', 'SubLQuoteFn'('TL-ASSERTION-TERM-TO-EL'), 'BaseKB', vStrDef).
assertedTinyKB(expansion, xor, or(and('$VAR'((':ARG1')), not('$VAR'((':ARG2')))), and('$VAR'((':ARG2')), not('$VAR'((':ARG1'))))), 'BaseKB', vStrDef).
assertedTinyKB(expansion, resultIsa, implies(equals('$VAR'('VALUE'), dot_holds(['$VAR'((':ARG1')), '?ARGS'])), isa('$VAR'('VALUE'), '$VAR'((':ARG2')))), 'BaseKB', vStrMon).
assertedTinyKB(expansion, resultGenl, implies(equals('$VAR'('VALUE'), dot_holds(['$VAR'((':ARG1')), '?ARGS'])), genls('$VAR'('VALUE'), '$VAR'((':ARG2')))), 'BaseKB', vStrMon).
assertedTinyKB(expansion, requiredArg2Pred, implies(and(isa('$VAR'((':ARG2')), 'BinaryPredicate'), isa('$VAR'('INS_1'), '$VAR'((':ARG1')))), thereExists('$VAR'('INS'), ':ARG2'('$VAR'('INS'), '$VAR'('INS_1')))), 'BaseKB', vStrDef).
assertedTinyKB(expansion, requiredArg1Pred, implies(and(isa('$VAR'((':ARG2')), 'BinaryPredicate'), isa('$VAR'('INS_1'), '$VAR'((':ARG1')))), thereExists('$VAR'('INS'), ':ARG2'('$VAR'('INS_1'), '$VAR'('INS')))), 'BaseKB', vStrDef).
assertedTinyKB(expansion, relationInstanceExists, thereExists('$VAR'('ARG'), and(isa('$VAR'('ARG'), '$VAR'((':ARG3'))), ':ARG1'('$VAR'((':ARG2')), '$VAR'('ARG')))), 'BaseKB', vStrDef).
assertedTinyKB(expansion, relationInstanceAll, implies(isa('$VAR'('INS'), '$VAR'((':ARG3'))), ':ARG1'('$VAR'((':ARG2')), '$VAR'('INS'))), 'BaseKB', vStrMon).
assertedTinyKB(expansion, relationExistsMinAll, implies(isa('$VAR'('ARG2'), '$VAR'((':ARG3'))), thereExistAtLeast('$VAR'((':ARG4')), '$VAR'('ARG'), and(isa('$VAR'('ARG'), '$VAR'((':ARG2'))), ':ARG1'('$VAR'('ARG'), '$VAR'('ARG2'))))), 'BaseKB', vStrDef).
assertedTinyKB(expansion, relationExistsMaxAll, implies(isa('$VAR'('ARG2'), '$VAR'((':ARG3'))), thereExistAtMost('$VAR'((':ARG4')), '$VAR'('ARG'), and(isa('$VAR'('ARG'), '$VAR'((':ARG2'))), ':ARG1'('$VAR'('ARG'), '$VAR'('ARG2'))))), 'BaseKB', vStrDef).
assertedTinyKB(expansion, relationExistsInstance, thereExists('$VAR'('OBJ'), and(isa('$VAR'('OBJ'), '$VAR'((':ARG2'))), ':ARG1'('$VAR'('OBJ'), '$VAR'((':ARG3'))))), 'BaseKB', vStrDef).
assertedTinyKB(expansion, relationExistsCountAll, implies(isa('$VAR'('ARG2'), '$VAR'((':ARG3'))), thereExistExactly('$VAR'((':ARG4')), '$VAR'('ARG1'), and(isa('$VAR'('ARG1'), '$VAR'((':ARG2'))), ':ARG1'('$VAR'('ARG1'), '$VAR'('ARG2'))))), 'BaseKB', vStrDef).
assertedTinyKB(expansion, relationExistsAll, implies(isa('$VAR'('TERM'), '$VAR'((':ARG3'))), ':ARG1'('RelationExistsAllFn'('$VAR'('TERM'), '$VAR'((':ARG1')), '$VAR'((':ARG2')), '$VAR'((':ARG3'))), '$VAR'('TERM'))), 'BaseKB', vStrMon).
assertedTinyKB(expansion, relationAllInstance, implies(isa('$VAR'('INS'), '$VAR'((':ARG2'))), ':ARG1'('$VAR'('INS'), '$VAR'((':ARG3')))), 'BaseKB', vStrMon).
assertedTinyKB(expansion, relationAllExistsMin, implies(isa('$VAR'('ARG1'), '$VAR'((':ARG2'))), thereExistAtLeast('$VAR'((':ARG4')), '$VAR'('ARG'), and(isa('$VAR'('ARG'), '$VAR'((':ARG3'))), ':ARG1'('$VAR'('ARG1'), '$VAR'('ARG'))))), 'BaseKB', vStrDef).
assertedTinyKB(expansion, relationAllExistsMax, implies(isa('$VAR'('ARG1'), '$VAR'((':ARG2'))), thereExistAtMost('$VAR'((':ARG4')), '$VAR'('ARG'), and(isa('$VAR'('ARG'), '$VAR'((':ARG3'))), ':ARG1'('$VAR'('ARG1'), '$VAR'('ARG'))))), 'BaseKB', vStrDef).
assertedTinyKB(expansion, relationAllExistsCount, implies(isa('$VAR'('TERM'), '$VAR'((':ARG2'))), thereExistExactly('$VAR'((':ARG4')), '$VAR'('OTHER'), and(isa('$VAR'('OTHER'), '$VAR'((':ARG3'))), ':ARG1'('$VAR'('TERM'), '$VAR'('OTHER'))))), 'BaseKB', vStrDef).
assertedTinyKB(expansion, relationAllExists, implies(isa('$VAR'('TERM'), '$VAR'((':ARG2'))), ':ARG1'('$VAR'('TERM'), 'RelationAllExistsFn'('$VAR'('TERM'), '$VAR'((':ARG1')), '$VAR'((':ARG2')), '$VAR'((':ARG3'))))), 'BaseKB', vStrMon).
assertedTinyKB(expansion, relationAll, implies(isa('$VAR'('OBJ'), '$VAR'((':ARG2'))), ':ARG1'('$VAR'('OBJ'))), 'BaseKB', vStrDef).
assertedTinyKB(expansion, quotedIsa, isa('QuasiQuote'('$VAR'((':ARG1'))), '$VAR'((':ARG2'))), 'BaseKB', vStrDef).
assertedTinyKB(expansion, negationPreds, not(and(dot_holds(['$VAR'((':ARG1')), '?ARGS']), dot_holds(['$VAR'((':ARG2')), '?ARGS']))), 'BaseKB', vStrDef).
assertedTinyKB(expansion, negationInverse, not(and(':ARG1'('$VAR'('ARG1'), '$VAR'('ARG2')), ':ARG2'('$VAR'('ARG2'), '$VAR'('ARG1')))), 'BaseKB', vStrDef).
assertedTinyKB(expansion, mtVisible, trueSubL('ExpandSubLFn'('$VAR'((':ARG1')), 'RELEVANT-MT?'('QUOTE'('$VAR'((':ARG1')))))), 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(expansion, implies, or('$VAR'((':ARG2')), not('$VAR'((':ARG1')))), 'BaseKB', vStrDef).
assertedTinyKB(expansion, genls, implies(isa('$VAR'('OBJ'), '$VAR'((':ARG1'))), isa('$VAR'('OBJ'), '$VAR'((':ARG2')))), 'BaseKB', vStrDef).
assertedTinyKB(expansion, genlPreds, implies(dot_holds(['$VAR'((':ARG1')), '?ARGS']), dot_holds(['$VAR'((':ARG2')), '?ARGS'])), 'BaseKB', vStrDef).
assertedTinyKB(expansion, genlMt, implies(ist('$VAR'((':ARG2')), '$VAR'('ASSERTION')), ist('$VAR'((':ARG1')), '$VAR'('ASSERTION'))), 'BaseKB', vStrMon).
assertedTinyKB(expansion, genlInverse, implies(':ARG1'('$VAR'('ARG1'), '$VAR'('ARG2')), ':ARG2'('$VAR'('ARG2'), '$VAR'('ARG1'))), 'BaseKB', vStrDef).
assertedTinyKB(expansion, equiv, and(implies('$VAR'((':ARG1')), '$VAR'((':ARG2'))), implies('$VAR'((':ARG2')), '$VAR'((':ARG1')))), 'BaseKB', vStrDef).
assertedTinyKB(expansion, disjointWith, not(and(isa('$VAR'('OBJ'), '$VAR'((':ARG1'))), isa('$VAR'('OBJ'), '$VAR'((':ARG2'))))), 'BaseKB', vStrDef).
assertedTinyKB(expansion, 'Percent', 'QuotientFn'('$VAR'((':ARG1')), 100), 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(expansion, 'interArgGenl1-2', implies(and(genls('$VAR'('INDEP_SPEC'), '$VAR'((':ARG2'))), ':ARG1'('$VAR'('INDEP_SPEC'), '$VAR'('DEP_SPEC'))), genls('$VAR'('DEP_SPEC'), '$VAR'((':ARG3')))), 'BaseKB', vStrDef).
assertedTinyKB(expansion, 'genls-SpecDenotesGenlInstances', implies(quotedIsa('$VAR'('OBJ'), '$VAR'((':ARG1'))), isa('$VAR'('OBJ'), '$VAR'((':ARG2')))), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(expansion, 'genls-GenlDenotesSpecInstances', implies(isa('$VAR'('OBJ'), '$VAR'((':ARG1'))), quotedIsa('$VAR'('OBJ'), '$VAR'((':ARG2')))), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(evaluationResultQuotedIsa, 'FormulaArgFn', 'CycLTerm', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(evaluationResultQuotedIsa, 'DateEncodeStringFn', 'SubLString', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(evaluationDefn, trueSubL, 'SubLQuoteFn'('CYC-TRUE-SUBL'), 'BaseKB', vStrMon).
assertedTinyKB(evaluationDefn, substring, 'SubLQuoteFn'('CYC-SUBSTRING-PREDICATE'), 'BaseKB', vStrMon).
assertedTinyKB(evaluationDefn, quantitySubsumes, 'SubLQuoteFn'('CYC-QUANTITY-SUBSUMES'), 'BaseKB', vStrMon).
assertedTinyKB(evaluationDefn, quantityIntersects, 'SubLQuoteFn'('CYC-QUANTITY-INTERSECTS'), 'BaseKB', vStrMon).
assertedTinyKB(evaluationDefn, numericallyEquals, 'SubLQuoteFn'('CYC-NUMERICALLY-EQUAL'), 'BaseKB', vStrMon).
assertedTinyKB(evaluationDefn, greaterThanOrEqualTo, 'SubLQuoteFn'('CYC-GREATER-THAN-OR-EQUAL-TO'), 'BaseKB', vStrMon).
assertedTinyKB(evaluationDefn, greaterThan, 'SubLQuoteFn'('CYC-GREATER-THAN'), 'BaseKB', vStrMon).
assertedTinyKB(evaluationDefn, differentSymbols, 'SubLQuoteFn'('CYC-DIFFERENT-SYMBOLS'), 'BaseKB', vStrMon).
assertedTinyKB(evaluationDefn, different, 'SubLQuoteFn'('CYC-DIFFERENT'), 'BaseKB', vStrMon).
assertedTinyKB(evaluationDefn, 'TimesFn', 'SubLQuoteFn'('CYC-TIMES'), 'BaseKB', vStrMon).
assertedTinyKB(evaluationDefn, 'substring-CaseInsensitive', 'SubLQuoteFn'('CYC-SUBSTRING-CASE-INSENSITIVE-PREDICATE'), 'BaseKB', vStrMon).
assertedTinyKB(evaluationDefn, 'RoundUpFn', 'SubLQuoteFn'('CYC-ROUND-UP'), 'BaseKB', vStrMon).
assertedTinyKB(evaluationDefn, 'RoundDownFn', 'SubLQuoteFn'('CYC-ROUND-DOWN'), 'BaseKB', vStrMon).
assertedTinyKB(evaluationDefn, 'RoundClosestFn', 'SubLQuoteFn'('CYC-ROUND-CLOSEST'), 'BaseKB', vStrMon).
assertedTinyKB(evaluationDefn, 'QuotientFn', 'SubLQuoteFn'('CYC-QUOTIENT'), 'BaseKB', vStrMon).
assertedTinyKB(evaluationDefn, 'QuantityConversionFn', 'SubLQuoteFn'('CYC-QUANTITY-CONVERSION'), 'BaseKB', vStrMon).
assertedTinyKB(evaluationDefn, 'PlusFn', 'SubLQuoteFn'('CYC-PLUS'), 'BaseKB', vStrMon).
assertedTinyKB(evaluationDefn, 'PlusAll', 'SubLQuoteFn'('CYC-PLUS-ALL'), 'BaseKB', vStrMon).
assertedTinyKB(evaluationDefn, 'Percent', 'SubLQuoteFn'('CYC-PERCENT'), 'BaseKB', vStrMon).
assertedTinyKB(evaluationDefn, 'ModuloFn', 'SubLQuoteFn'('CYC-MODULO'), 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(evaluationDefn, 'MinRangeFn', 'SubLQuoteFn'('CYC-MIN-RANGE'), 'BaseKB', vStrMon).
assertedTinyKB(evaluationDefn, 'Minimum', 'SubLQuoteFn'('CYC-MINIMUM'), 'BaseKB', vStrMon).
assertedTinyKB(evaluationDefn, 'MaxRangeFn', 'SubLQuoteFn'('CYC-MAX-RANGE'), 'BaseKB', vStrMon).
assertedTinyKB(evaluationDefn, 'Maximum', 'SubLQuoteFn'('CYC-MAXIMUM'), 'BaseKB', vStrMon).
assertedTinyKB(evaluationDefn, 'FunctionToArg'('$VAR'('N'), '$VAR'('PREDICATE')), 'SubLQuoteFn'('CYC-FUNCTION-TO-ARG'), 'BaseKB', vStrMon).
assertedTinyKB(evaluationDefn, 'FormulaArityFn', 'SubLQuoteFn'('CYC-RELATION-EXPRESSION-ARITY'), 'BaseKB', vStrMon).
assertedTinyKB(evaluationDefn, 'FormulaArgSetFn', 'SubLQuoteFn'('CYC-RELATION-ARG-SET'), 'BaseKB', vStrMon).
assertedTinyKB(evaluationDefn, 'FormulaArgListFn', 'SubLQuoteFn'('CYC-RELATION-ARGS-LIST'), 'BaseKB', vStrMon).
assertedTinyKB(evaluationDefn, 'FormulaArgFn', 'SubLQuoteFn'('CYC-RELATION-ARG'), 'BaseKB', vStrMon).
assertedTinyKB(evaluationDefn, 'EvaluateSubLFn', 'SubLQuoteFn'('CYC-EVALUATE-SUBL'), 'BaseKB', vStrMon).
assertedTinyKB(evaluationDefn, 'DifferenceFn', 'SubLQuoteFn'('CYC-DIFFERENCE'), 'BaseKB', vStrMon).
assertedTinyKB(evaluationDefn, 'DateEncodeStringFn', 'SubLQuoteFn'('CYC-DATE-ENCODE-STRING'), 'BaseKB', vStrMon).
assertedTinyKB(evaluationDefn, 'DateDecodeStringFn', 'SubLQuoteFn'('CYC-DATE-DECODE-STRING'), 'BaseKB', vStrMon).
assertedTinyKB(evaluationDefn, 'Average', 'SubLQuoteFn'('CYC-AVERAGE'), 'BaseKB', vStrMon).
assertedTinyKB(evaluationDefn, 'AbsoluteValueFn', 'SubLQuoteFn'('CYC-ABSOLUTE-VALUE'), 'BaseKB', vStrMon).
assertedTinyKB(equals, 'TheEmptyList', 'TheList', 'BaseKB', vStrMon).
assertedTinyKB(equals, '$VAR'('X'), '$VAR'('X'), 'LogicalTruthMt', vStrDef).
assertedTinyKB(equals, '$VAR'('X'), '$VAR'('X'), 'BaseKB', vStrMon).
assertedTinyKB(equals, '$VAR'('NUM'), 'Unity'('$VAR'('NUM')), 'BaseKB', vStrDef).
assertedTinyKB(distributesOutOfArg, and, holdsIn, 2, 'BaseKB', vStrDef).
assertedTinyKB(disjointWith, 'VariableArityRelation', 'FixedArityRelation', 'LogicalTruthMt', vStrMon).
assertedTinyKB(disjointWith, 'TruthValue', 'List', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(disjointWith, 'SubLString', 'TruthValue', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(disjointWith, 'SubLNonVariableNonKeywordSymbol', 'SubLKeyword', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(disjointWith, 'SubLNonNegativeInteger', 'SubLSymbol', 'LogicalTruthImplementationMt', vStrMon).
assertedTinyKB(disjointWith, 'SententialRelation', tPred, 'LogicalTruthMt', vStrMon).
assertedTinyKB(disjointWith, tRelation, 'TruthValue', 'LogicalTruthMt', vStrMon).
assertedTinyKB(disjointWith, tRelation, 'NonNegativeInteger', 'LogicalTruthMt', vStrMon).
assertedTinyKB(disjointWith, tRelation, 'Microtheory', 'LogicalTruthMt', vStrMon).
assertedTinyKB(disjointWith, 'ReifiableFunction', 'UnreifiableFunction', 'LogicalTruthImplementationMt', vStrMon).
assertedTinyKB(disjointWith, 'ReflexiveBinaryPredicate', 'IrreflexiveBinaryPredicate', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(disjointWith, 'PartiallyCommutativeRelation', 'UnaryRelation', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(disjointWith, 'Microtheory', 'TruthValue', 'LogicalTruthMt', vStrMon).
assertedTinyKB(disjointWith, 'LogicalConnective', 'Quantifier', 'LogicalTruthMt', vStrMon).
assertedTinyKB(disjointWith, 'Individual', 'SetOrCollection', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(disjointWith, tFunction, 'TruthFunction', 'LogicalTruthMt', vStrMon).
assertedTinyKB(disjointWith, 'FixedAritySkolemFunction', 'VariableAritySkolemFunction', 'LogicalTruthImplementationMt', vStrMon).
assertedTinyKB(disjointWith, 'ELRelation-Reversible', 'ELRelation-OneWay', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(disjointWith, 'CycLTruthValueSentence', 'CycLFormulaicSentence', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(disjointWith, 'CycLSentence-ClosedPredicate', 'CycLNonAtomicTerm-ClosedFunctor', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(disjointWith, 'CycLSentence', 'CycLNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(disjointWith, 'CycLSentence', 'CycLGenericRelationFormula', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(disjointWith, 'CycLRuleAssertion', 'CycLGAFAssertion', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(disjointWith, 'CycLRepresentedAtomicTerm', 'SubLAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(disjointWith, 'CycLOpenSentence', 'CycLOpenDenotationalTerm', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(disjointWith, 'CycLOpenExpression', 'CycLClosedExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(disjointWith, 'CycLGenericRelationFormula', 'CycLNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(disjointWith, 'CycLClosedSentence', 'CycLNonAtomicTerm', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(disjointWith, 'CycLAtomicTerm', 'CycLFormula', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(disjointWith, 'CommutativeRelation', 'UnaryRelation', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(disjointWith, 'CommutativeRelation', 'PartiallyCommutativeRelation', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(disjointWith, tCol, 'Set-Mathematical', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(disjointWith, tCol, 'Individual', 'LogicalTruthMt', vStrMon).
assertedTinyKB(disjointWith, 'BinaryRelation', 'PartiallyCommutativeRelation', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(denotes, 'Quote'('Quote'('EscapeQuote'('$VAR'('X')))), 'Quote'('EscapeQuote'('$VAR'('X'))), 'BaseKB', vStrMon).
assertedTinyKB(defnSufficient, 'Wednesday', 'SubLQuoteFn'('CYC-DAY-OF-WEEK-DEFN'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(defnSufficient, 'Tuesday', 'SubLQuoteFn'('CYC-DAY-OF-WEEK-DEFN'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(defnSufficient, 'Thursday', 'SubLQuoteFn'('CYC-DAY-OF-WEEK-DEFN'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(defnSufficient, 'Sunday', 'SubLQuoteFn'('CYC-DAY-OF-WEEK-DEFN'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(defnSufficient, 'ScalarPointValue', 'SubLQuoteFn'('SCALAR-POINT-VALUE?'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(defnSufficient, 'ScalarInterval', 'SubLQuoteFn'('IBQE?'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(defnSufficient, 'Saturday', 'SubLQuoteFn'('CYC-DAY-OF-WEEK-DEFN'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(defnSufficient, 'Monday', 'SubLQuoteFn'('CYC-DAY-OF-WEEK-DEFN'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(defnSufficient, 'List', 'SubLQuoteFn'('CYC-LIST-OF-TYPE-SUFFICIENT'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(defnSufficient, 'Integer', 'SubLQuoteFn'('INTEGERP'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(defnSufficient, 'Friday', 'SubLQuoteFn'('CYC-DAY-OF-WEEK-DEFN'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(defnSufficient, 'CharacterString', 'SubLQuoteFn'('STRINGP'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(defnSufficient, 'CharacterString', 'SubLQuoteFn'('CYC-LIST-OF-TYPE-SUFFICIENT'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(defnNecessary, 'Set-Mathematical', 'SubLQuoteFn'('CYC-SET-OF-TYPE-NECESSARY'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(defnNecessary, 'List', 'SubLQuoteFn'('CYC-LIST-OF-TYPE-NECESSARY'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(defnNecessary, 'Individual', 'SubLQuoteFn'('CYC-INDIVIDUAL-NECESSARY'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(defnNecessary, 'CharacterString', 'SubLQuoteFn'('CYC-LIST-OF-TYPE-NECESSARY'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(defnIff, 'Thing', 'SubLQuoteFn'('TRUE'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(defnIff, 'Thing', 'SubLQuoteFn'('TRUE'), 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(defnIff, 'RealNumber', 'SubLQuoteFn'('CYC-REAL-NUMBER'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(defnIff, 'PositiveInteger', 'SubLQuoteFn'('CYC-POSITIVE-INTEGER'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(defnIff, 'PositiveInteger', 'SubLQuoteFn'('CYC-POSITIVE-INTEGER'), 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(defnIff, 'NonNegativeScalarInterval', 'SubLQuoteFn'('NON-NEGATIVE-SCALAR-INTERVAL?'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(defnIff, 'NonNegativeInteger', 'SubLQuoteFn'('CYC-NON-NEGATIVE-INTEGER'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(defnIff, 'NonNegativeInteger', 'SubLQuoteFn'('CYC-NON-NEGATIVE-INTEGER'), 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(defnIff, 'Integer', 'SubLQuoteFn'('CYC-INTEGER'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(defnIff, 'HLExternalIDString', 'SubLQuoteFn'('HL-EXTERNAL-ID-STRING-P'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(definingMt, termOfUnit, 'BaseKB', 'BaseKB', vStrDef).
assertedTinyKB(definingMt, termDependsOn, 'BaseKB', 'BaseKB', vStrDef).
assertedTinyKB(definingMt, subsetOf, 'CoreCycLMt', 'BaseKB', vStrMon).
assertedTinyKB(definingMt, skolem, 'BaseKB', 'BaseKB', vStrMon).
assertedTinyKB(definingMt, ruleAfterRemoving, 'BaseKB', 'BaseKB', vStrMon).
assertedTinyKB(definingMt, ruleAfterAdding, 'BaseKB', 'BaseKB', vStrMon).
assertedTinyKB(definingMt, oldConstantName, 'BookkeepingMt', 'BaseKB', vStrMon).
assertedTinyKB(definingMt, myCreator, 'BookkeepingMt', 'BaseKB', vStrMon).
assertedTinyKB(definingMt, myCreationTime, 'BookkeepingMt', 'BaseKB', vStrMon).
assertedTinyKB(definingMt, myCreationPurpose, 'BookkeepingMt', 'BaseKB', vStrDef).
assertedTinyKB(definingMt, evaluationDefn, 'BaseKB', 'BaseKB', vStrDef).
assertedTinyKB(definingMt, equals, 'LogicalTruthMt', 'BaseKB', vStrMon).
assertedTinyKB(definingMt, elementOf, 'CoreCycLMt', 'BaseKB', vStrMon).
assertedTinyKB(definingMt, defnSufficient, 'BaseKB', 'BaseKB', vStrDef).
assertedTinyKB(definingMt, defnNecessary, 'BaseKB', 'BaseKB', vStrDef).
assertedTinyKB(definingMt, defnIff, 'BaseKB', 'BaseKB', vStrDef).
assertedTinyKB(definingMt, afterRemoving, 'BaseKB', 'BaseKB', vStrDef).
assertedTinyKB(definingMt, afterAdding, 'BaseKB', 'BaseKB', vStrDef).
assertedTinyKB(definingMt, 'HumanCyclist', 'BaseKB', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedPredicate, termOfUnit, 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedPredicate, quotedArgument, 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedPredicate, predicateConventionMt, 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedPredicate, notAssertibleMt, 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedPredicate, nearestGenlMt, 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedPredicate, ist, 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedPredicate, genlMt, 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedPredicate, evaluateImmediately, 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedPredicate, ephemeralTerm, 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedPredicate, definingMt, 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedPredicate, decontextualizedPredicate, 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedPredicate, decontextualizedCollection, 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedPredicate, collectionConventionMt, 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedPredicate, canonicalizerDirectiveForArgAndRest, 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedPredicate, canonicalizerDirectiveForArg, 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedPredicate, canonicalizerDirectiveForAllArgs, 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedPredicate, assertionDirection, 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedPredicate, arityMin, 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedPredicate, arityMax, 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedPredicate, arity, 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedPredicate, 'ist-Asserted', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'VariableAritySkolemFunction', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'VariableArityRelation', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'UnreifiableFunction', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'UnitOfMeasure', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'UnaryRelation', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'UnaryPredicate', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'UnaryFunction', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'TruthFunction', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'TransitiveBinaryPredicate', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'Thing', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'TheTerm', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'TernaryRelation', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'TernaryPredicate', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'TernaryFunction', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'SymmetricBinaryPredicate', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'SubLSymbol', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'SubLString', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'SubLSExpression', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'SubLRealNumber', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'SubLPositiveInteger', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'SubLNonVariableSymbol', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'SubLNonVariableNonKeywordSymbol', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'SubLNonNegativeInteger', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'SubLList', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'SubLKeyword', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'SubLInteger', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'SubLExpressionType', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'SubLCharacter', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'SubLAtomicTerm', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'SubLAtom', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'SkolemFunction', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'SiblingDisjointCollectionType', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'SiblingDisjointAttributeType', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'SetOrCollection', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'Set-Mathematical', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'SententialRelation', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'ScopingRelation', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'ScalarPointValue', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'ScalarInterval', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'ScalarIntegralValue', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, tRelation, 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'ReifiableFunction', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'ReformulatorDirectivePredicate', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'ReflexiveBinaryPredicate', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'RealNumber', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'QuintaryRelation', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'QuintaryPredicate', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'QuintaryFunction', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'QuaternaryRelation', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'QuaternaryPredicate', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'QuaternaryFunction', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'Quantifier', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'ProblemSolvingCntxt', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, tPred, 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'PositiveInteger', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'PartiallyCommutativeRelation', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'NonNegativeScalarInterval', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'NonNegativeInteger', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'Multigraph', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'MonthOfYearType', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'MicrotheoryDesignatingRelation', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'Microtheory', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'LogicalConnective', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'List', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'IrreflexiveBinaryPredicate', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'InterArgIsaPredicate', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'InterArgFormatPredicate', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'Integer', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'InferenceRelatedBookkeepingPredicate', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'Individual', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'HypotheticalContext', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'HLExternalIDString', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, tFunction, 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'Format', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'FixedAritySkolemFunction', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'FixedAritySkolemFuncN', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'FixedArityRelation', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'ExistentialQuantifier-Bounded', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'ExistentialQuantifier', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'ExceptionPredicate', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'EvaluatableRelation', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'EvaluatableFunction', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'ELRelation-Reversible', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'ELRelation-OneWay', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'ELRelation', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'DistributingMetaKnowledgePredicate', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'DisjointCollectionType', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'DirectedMultigraph', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'DefaultMonotonicPredicate', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, ftVar, 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'CycLTruthValueSentence', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'CycLTerm', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'CycLSentence-Assertible', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'CycLSentence-Askable', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'CycLSentence', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'CycLRuleAssertion', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'CycLRepresentedTerm', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'CycLRepresentedAtomicTerm', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'CycLReifiedDenotationalTerm', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'CycLReifiableNonAtomicTerm', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'CycLReifiableDenotationalTerm', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'CycLPropositionalSentence', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'CycLOpenSentence', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'CycLOpenNonAtomicTerm', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'CycLOpenFormula', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'CycLOpenExpression', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'CycLOpenDenotationalTerm', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'CycLNonAtomicTerm-Assertible', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'CycLNonAtomicTerm-Askable', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'CycLNonAtomicTerm', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'CycLNonAtomicReifiedTerm', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'CycLIndexedTerm', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'CycLGenericRelationFormula', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'CycLGAFAssertion', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'CycLFormulaicSentence', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'CycLFormula', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, ttFormatType, 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'CycLExpression-Assertible', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'CycLExpression-Askable', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'CycLExpression', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'CycLDenotationalTerm-Assertible', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'CycLDenotationalTerm', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'CycLDeducedAssertion', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'CycLConstant', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'CycLClosedSentence', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'CycLClosedNonAtomicTerm', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'CycLClosedFormula', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'CycLClosedExpression', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'CycLClosedDenotationalTerm', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'CycLClosedAtomicTerm', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'CycLClosedAtomicSentence', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'CycLAtomicTerm', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'CycLAtomicSentence', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'CycLAtomicAssertion', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'CycLAssertionDirection', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'CycLAssertion', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'CycLAssertedAssertion', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'CommutativeRelation', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'CollectionDenotingFunction', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, tCol, 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'CanonicalizerDirective', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'BroadMicrotheory', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'BookkeepingPredicate', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'BinaryRelation', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'BinaryPredicate', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'BinaryFunction', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'AtemporalNecessarilyEssentialCollectionType', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'AsymmetricBinaryPredicate', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'AssociativeRelation', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'ArgTypeTernaryPredicate', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'ArgTypePredicate', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'ArgTypeBinaryPredicate', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'ArgQuotedIsaTernaryPredicate', 'BaseKB', vStrMon).
assertedTinyKB(decontextualizedCollection, 'ArgIsaTernaryPredicate', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'ArgIsaBinaryPredicate', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'ArgGenlTernaryPredicate', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'ArgGenlQuantityTernaryPredicate', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'ArgGenlQuantityBinaryPredicate', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'ArgGenlBinaryPredicate', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'ArgConstraintPredicate', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'AntiTransitiveBinaryPredicate', 'BaseKB', vStrDef).
assertedTinyKB(decontextualizedCollection, 'AntiSymmetricBinaryPredicate', 'BaseKB', vStrDef).
assertedTinyKB(constrainsArg, argsIsa, 0, 'CoreCycLMt', vStrDef).
assertedTinyKB(constrainsArg, argsGenl, 0, 'CoreCycLMt', vStrDef).
assertedTinyKB(constrainsArg, arg6SometimesIsa, 6, 'CoreCycLMt', vStrMon).
assertedTinyKB(constrainsArg, arg6QuotedIsa, 6, 'CoreCycLMt', vStrMon).
assertedTinyKB(constrainsArg, arg6Isa, 6, 'CoreCycLMt', vStrDef).
assertedTinyKB(constrainsArg, arg6Genl, 6, 'CoreCycLMt', vStrDef).
assertedTinyKB(constrainsArg, arg5SometimesIsa, 5, 'CoreCycLMt', vStrMon).
assertedTinyKB(constrainsArg, arg5QuotedIsa, 5, 'CoreCycLMt', vStrMon).
assertedTinyKB(constrainsArg, arg5Isa, 5, 'CoreCycLMt', vStrDef).
assertedTinyKB(constrainsArg, arg5Genl, 5, 'CoreCycLMt', vStrDef).
assertedTinyKB(constrainsArg, arg5Format, 5, 'CoreCycLMt', vStrDef).
assertedTinyKB(constrainsArg, arg4SometimesIsa, 4, 'CoreCycLMt', vStrMon).
assertedTinyKB(constrainsArg, arg4QuotedIsa, 4, 'CoreCycLMt', vStrMon).
assertedTinyKB(constrainsArg, arg4Isa, 4, 'CoreCycLMt', vStrDef).
assertedTinyKB(constrainsArg, arg4Genl, 4, 'CoreCycLMt', vStrDef).
assertedTinyKB(constrainsArg, arg4Format, 4, 'CoreCycLMt', vStrDef).
assertedTinyKB(constrainsArg, arg3SometimesIsa, 3, 'CoreCycLMt', vStrMon).
assertedTinyKB(constrainsArg, arg3QuotedIsa, 3, 'CoreCycLMt', vStrMon).
assertedTinyKB(constrainsArg, arg3Isa, 3, 'CoreCycLMt', vStrDef).
assertedTinyKB(constrainsArg, arg3Genl, 3, 'CoreCycLMt', vStrDef).
assertedTinyKB(constrainsArg, arg3Format, 3, 'CoreCycLMt', vStrDef).
assertedTinyKB(constrainsArg, arg2SometimesIsa, 2, 'CoreCycLMt', vStrMon).
assertedTinyKB(constrainsArg, arg2QuotedIsa, 2, 'CoreCycLMt', vStrMon).
assertedTinyKB(constrainsArg, arg2Isa, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(constrainsArg, arg2Isa, 2, 'CoreCycLMt', vStrDef).
assertedTinyKB(constrainsArg, arg2Genl, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(constrainsArg, arg2Genl, 2, 'CoreCycLMt', vStrDef).
assertedTinyKB(constrainsArg, arg2Format, 2, 'CoreCycLMt', vStrDef).
assertedTinyKB(constrainsArg, arg1SometimesIsa, 1, 'CoreCycLMt', vStrMon).
assertedTinyKB(constrainsArg, arg1QuotedIsa, 1, 'CoreCycLMt', vStrMon).
assertedTinyKB(constrainsArg, arg1Isa, 1, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(constrainsArg, arg1Isa, 1, 'CoreCycLMt', vStrDef).
assertedTinyKB(constrainsArg, arg1Genl, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(constrainsArg, arg1Genl, 1, 'CoreCycLMt', vStrDef).
assertedTinyKB(constrainsArg, arg1Format, 1, 'CoreCycLMt', vStrDef).
assertedTinyKB(constrainsArg, 'interArgIsa5-4', 4, 'CoreCycLMt', vStrDef).
assertedTinyKB(constrainsArg, 'interArgIsa5-3', 3, 'CoreCycLMt', vStrDef).
assertedTinyKB(constrainsArg, 'interArgIsa5-2', 2, 'CoreCycLMt', vStrDef).
assertedTinyKB(constrainsArg, 'interArgIsa5-1', 1, 'CoreCycLMt', vStrDef).
assertedTinyKB(constrainsArg, 'interArgIsa4-5', 5, 'CoreCycLMt', vStrDef).
assertedTinyKB(constrainsArg, 'interArgIsa4-3', 3, 'CoreCycLMt', vStrDef).
assertedTinyKB(constrainsArg, 'interArgIsa4-2', 2, 'CoreCycLMt', vStrDef).
assertedTinyKB(constrainsArg, 'interArgIsa4-1', 1, 'CoreCycLMt', vStrDef).
assertedTinyKB(constrainsArg, 'interArgIsa3-5', 5, 'CoreCycLMt', vStrDef).
assertedTinyKB(constrainsArg, 'interArgIsa3-4', 4, 'CoreCycLMt', vStrDef).
assertedTinyKB(constrainsArg, 'interArgIsa3-2', 2, 'CoreCycLMt', vStrDef).
assertedTinyKB(constrainsArg, 'interArgIsa3-1', 1, 'CoreCycLMt', vStrDef).
assertedTinyKB(constrainsArg, 'interArgIsa2-5', 5, 'CoreCycLMt', vStrDef).
assertedTinyKB(constrainsArg, 'interArgIsa2-4', 4, 'CoreCycLMt', vStrDef).
assertedTinyKB(constrainsArg, 'interArgIsa2-3', 3, 'CoreCycLMt', vStrDef).
assertedTinyKB(constrainsArg, 'interArgIsa2-1', 1, 'CoreCycLMt', vStrDef).
assertedTinyKB(constrainsArg, 'interArgIsa1-5', 5, 'CoreCycLMt', vStrDef).
assertedTinyKB(constrainsArg, 'interArgIsa1-4', 4, 'CoreCycLMt', vStrDef).
assertedTinyKB(constrainsArg, 'interArgIsa1-3', 3, 'CoreCycLMt', vStrDef).
assertedTinyKB(constrainsArg, 'interArgIsa1-2', 2, 'CoreCycLMt', vStrDef).
assertedTinyKB(constrainsArg, 'interArgGenl1-2', 2, 'CoreCycLMt', vStrDef).
assertedTinyKB(constrainsArg, 'interArgFormat1-2', 2, 'CoreCycLMt', vStrDef).
assertedTinyKB(conceptuallyRelated, querySentence, pragmaticRequirement, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(conceptuallyRelated, querySentence, meetsPragmaticRequirement, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(conceptuallyRelated, pragmaticRequirement, pragmaticallyNormal, 'BaseKB', vStrMon).
assertedTinyKB(conceptuallyRelated, pragmaticRequirement, meetsPragmaticRequirement, 'BaseKB', vStrMon).
assertedTinyKB(conceptuallyRelated, knownAntecedentRule, knownSentence, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(conceptuallyRelated, knownAntecedentRule, backchainRequired, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(conceptuallyRelated, exceptWhen, abnormal, 'BaseKB', vStrMon).
assertedTinyKB(conceptuallyRelated, exceptFor, abnormal, 'BaseKB', vStrMon).
assertedTinyKB(conceptuallyRelated, exactlyAssertedSentence, assertedSentence, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(conceptuallyRelated, commutativeInArgs, 'CommutativeRelation', 'BaseKB', vStrMon).
assertedTinyKB(conceptuallyRelated, collectionIsaBackchainEncouraged, isa, 'BaseKB', vStrMon).
assertedTinyKB(conceptuallyRelated, collectionIsaBackchainEncouraged, tCol, 'BaseKB', vStrMon).
assertedTinyKB(conceptuallyRelated, collectionGenlsBackchainEncouraged, isa, 'BaseKB', vStrMon).
assertedTinyKB(conceptuallyRelated, collectionGenlsBackchainEncouraged, tCol, 'BaseKB', vStrMon).
assertedTinyKB(conceptuallyRelated, collectionBackchainRequired, isa, 'BaseKB', vStrMon).
assertedTinyKB(conceptuallyRelated, collectionBackchainRequired, tCol, 'BaseKB', vStrMon).
assertedTinyKB(conceptuallyRelated, collectionBackchainEncouraged, isa, 'BaseKB', vStrMon).
assertedTinyKB(conceptuallyRelated, collectionBackchainEncouraged, tCol, 'BaseKB', vStrMon).
assertedTinyKB(conceptuallyRelated, abnormal, pragmaticallyNormal, 'BaseKB', vStrMon).
assertedTinyKB(conceptuallyRelated, abnormal, meetsPragmaticRequirement, 'BaseKB', vStrMon).
assertedTinyKB(conceptuallyRelated, 'SubLQuoteFn', trueSubL, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(conceptuallyRelated, 'SubLQuoteFn', performSubL, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(conceptuallyRelated, 'SubLQuoteFn', 'ExpandSubLFn', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(conceptuallyRelated, 'SubLQuoteFn', 'EvaluateSubLFn', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(conceptuallyRelated, 'MonotonicallyFalse', 'False', 'BaseKB', vStrMon).
assertedTinyKB(conceptuallyRelated, 'IrreflexiveBinaryPredicate', interArgDifferent, 'BaseKB', vStrMon).
assertedTinyKB(conceptuallyRelated, 'DefaultFalse', 'False', 'BaseKB', vStrMon).
assertedTinyKB(conceptuallyRelated, 'CycHLTruthValue', 'TruthValue', 'BaseKB', vStrDef).
assertedTinyKB(completelyEnumerableCollection, 'TruthValue', 'BaseKB', vStrMon).
assertedTinyKB(completelyEnumerableCollection, 'TheTerm', 'BaseKB', vStrDef).
assertedTinyKB(completelyEnumerableCollection, 'SkolemFunction', 'BaseKB', vStrMon).
assertedTinyKB(completelyEnumerableCollection, 'SententialRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(completelyEnumerableCollection, 'Quantifier', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(completelyEnumerableCollection, 'ProblemSolvingCntxt', 'BaseKB', vStrMon).
assertedTinyKB(completelyEnumerableCollection, 'LogicalConnective', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(completelyEnumerableCollection, 'InferenceRelatedBookkeepingPredicate', 'BaseKB', vStrMon).
assertedTinyKB(completelyEnumerableCollection, 'HumanCyclist', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(completelyEnumerableCollection, 'ExistentialQuantifier-Bounded', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(completelyEnumerableCollection, 'ExceptionPredicate', 'BaseKB', vStrMon).
assertedTinyKB(completelyEnumerableCollection, 'DayOfWeekType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(completelyEnumerableCollection, 'CycProvabilityStatus', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(completelyEnumerableCollection, 'CycLRuleAssertion', 'BaseKB', vStrMon).
assertedTinyKB(completelyEnumerableCollection, 'CycLGAFAssertion', 'BaseKB', vStrMon).
assertedTinyKB(completelyEnumerableCollection, 'CycLDeducedAssertion', 'BaseKB', vStrMon).
assertedTinyKB(completelyEnumerableCollection, 'CycLAssertionDirection', 'BaseKB', vStrMon).
assertedTinyKB(completelyEnumerableCollection, 'CycLAssertedAssertion', 'BaseKB', vStrMon).
assertedTinyKB(completelyEnumerableCollection, 'CycInferenceProblemLinkStatus', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(completelyEnumerableCollection, 'CanonicalizerDirective', 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(completelyEnumerableCollection, 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(completelyEnumerableCollection, 'ArgIsaBinaryPredicate', 'BaseKB', vStrMon).
assertedTinyKB(completelyEnumerableCollection, 'ArgGenlQuantityTernaryPredicate', 'BaseKB', vStrDef).
assertedTinyKB(completelyEnumerableCollection, 'ArgGenlQuantityBinaryPredicate', 'BaseKB', vStrDef).
assertedTinyKB(completelyEnumerableCollection, 'ArgGenlBinaryPredicate', 'BaseKB', vStrMon).
assertedTinyKB(completelyDecidableCollection, 'Microtheory', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completelyDecidableCollection, 'IndeterminateTerm', 'BaseKB', vStrMon).
assertedTinyKB(completelyDecidableCollection, 'HLPrototypicalTerm', 'BaseKB', vStrMon).
assertedTinyKB(completeExtentEnumerableForValueInArg, indexicalReferent, 'TheUser', 1, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentEnumerableForValueInArg, indexicalReferent, 'QueryMt', 1, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentEnumerableForArg, termOfUnit, 2, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentEnumerableForArg, termOfUnit, 1, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentEnumerableForArg, conceptuallyRelated, 1, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentEnumerable, termDependsOn, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(completeExtentEnumerable, termChosen, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentEnumerable, quotedArgument, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentEnumerable, pragmaticRequirement, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentEnumerable, performSubL, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentEnumerable, operatorFormulas, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentEnumerable, natFunction, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentEnumerable, natArgumentsEqual, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentEnumerable, natArgument, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentEnumerable, myCreator, 'BookkeepingMt', vStrMon).
assertedTinyKB(completeExtentEnumerable, myCreationTime, 'BookkeepingMt', vStrMon).
assertedTinyKB(completeExtentEnumerable, myCreationSecond, 'BookkeepingMt', vStrMon).
assertedTinyKB(completeExtentEnumerable, myCreationPurpose, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentEnumerable, formulaArity, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentEnumerable, exactlyAssertedSentence, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentEnumerable, evaluate, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentEnumerable, equalSymbols, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentEnumerable, definingMt, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentEnumerable, cycTransformationProofRule, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentEnumerable, cycTransformationProofBindings, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentEnumerable, cycProblemStoreTerms, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentEnumerable, cycProblemStoreProofCount, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentEnumerable, cycProblemStoreProblems, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentEnumerable, cycProblemStoreProblemCount, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentEnumerable, cycProblemStoreLinkCount, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentEnumerable, cycProblemStoreInferenceCount, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentEnumerable, cycProblemQueryTerms, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentEnumerable, cycProblemQuerySentence, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentEnumerable, cycProblemProvabilityStatus, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentEnumerable, constantName, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentEnumerable, constantID, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentEnumerable, constantGUID, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentEnumerable, comment, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentEnumerable, collectionIsaBackchainRequired, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentEnumerable, collectionIsaBackchainEncouraged, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentEnumerable, collectionGenlsBackchainRequired, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentEnumerable, collectionGenlsBackchainEncouraged, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentEnumerable, collectionBackchainEncouraged, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentEnumerable, backchainRequired, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentEnumerable, backchainForbiddenWhenUnboundInArg, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentEnumerable, backchainForbidden, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentEnumerable, assertionDirection, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentEnumerable, assertedTermSentences, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentEnumerable, assertedSentence, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentEnumerable, assertedPredicateArg, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentEnumerable, admittedSentence, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentEnumerable, admittedArgument, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentEnumerable, 'ist-Asserted', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentDecidable, unknownSentence, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentDecidable, termOfUnit, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentDecidable, sentenceImplies, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentDecidable, sentenceEquiv, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentDecidable, mtVisible, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentDecidable, knownSentence, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentDecidable, integerBetween, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentDecidable, indexicalReferent, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentDecidable, differentSymbols, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentDecidable, consistent, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentDecidable, conceptuallyRelated, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentDecidable, 'equalStrings-CaseInsensitive', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentAsserted, salientAssertions, 'BaseKB', vStrDef).
assertedTinyKB(completeExtentAsserted, resultIsaArgIsa, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentAsserted, omitArgIsa, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(completeExtentAsserted, instanceElementType, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentAsserted, hypotheticalTerm, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(completeExtentAsserted, elInverse, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(commutativeInArgsAndRest, commutativeInArgsAndRest, 2, 'BaseKB', vStrDef).
assertedTinyKB(commutativeInArgsAndRest, commutativeInArgs, 2, 'BaseKB', vStrDef).
assertedTinyKB(commutativeInArgs, multiplicationUnits, 1, 2, 'BaseKB', vStrMon).
assertedTinyKB(commutativeInArgs, interArgDifferent, 2, 3, 'BaseKB', vStrMon).
assertedTinyKB(comment, xor, "The LogicalConnective that represents exclusive-or in CycL. Unlike or, which is a VariableArityRelation, xor takes two arguments, which must be instances of ELSentence-Assertible. (xor P Q) means  one but not both of P and Q is true. (An EL formula that mentions \n  xor is translated during canonicalization into an equivalent, less compact, formula that mentions or, and, and not).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, unknownSentence, "A unary KBDependentRelation (q.v.) that takes instances of CycLSentence as arguments.  <code>(unknownSentence SENTENCE)</code> means that <code>SENTENCE</code> is not currently  \"known\" by the Cyc system to be true.  More precisely, the inference engine cannot prove <code>SENTENCE</code> <i>using only removal</i> (see CycRemovalModule) from the current state of the knowledge base.  <code>SENTENCE</code> might actually be known to be false (see the specialization contradictorySentence), or its truth-value might be simply unknown in the present sense.  \n<p>\nNote that, as a KB dependent relation, unknownSentence is notAssertible (q.v.).", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, unitMultiplicationFactor, "A ternary MetaFunction predicate that relates two interconvertible UnitOfMeasures (q.v.) to the real number by which the larger unit is a multiple of the smaller.  <code>(unitMultiplicationFactor SMALLUNIT BIGUNIT N)</code> means that there are <code>N SMALLUNIT</code>s in one <code>BIGUNIT</code>.  In other words, to convert from a measure <code>BIGUNIT</code>s to a measure in <code>SMALLUNIT</code>s, multiply by <code>N</code>.\n<p>\nFor example, (unitMultiplicationFactor Inch Foot-UnitOfMeasure 12) entails that, when converting from feet to inches, one multiplies the number of feet by twelve.\n<p>\nNote that <code>SMALLUNIT</code> and <code>BIGUNIT</code> must be instances of the same InterconvertibleUnitType (q.v.), and that <code>N</code> must be greater than or equal to 1.\n<p>\nSee also QuantityConversionFn.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, trueSubL, "<code>(trueSubL SUBL)</code> states that the SubL expression <code>SUBL</code> evaluates to a value other than NIL.  This predicate allows for a procedural test for programmatic 'truth' in the implementation language to be reflected as a CycL test for logical truth in the logical language.  For example, <code>(trueSubL (ExpandSubLFn () (integerp 42)))</code> states that the SubL expression <code>(integerp 42)</code> evaluates to something other than NIL.  See ExpandSubLFn for a way to denote SubL within CycL.  See also evaluate and EvaluateSubLFn, and performSubL.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, trueSentence, "A KBDependentRelation (q.v.) and specialization of consistent (q.v.) that is used to state that a given CycL sentence is true.  <code>(trueSentence SENT)</code> means that <code>SENT</code> is true.\n<p>\ntrueSentence is a non-assertible predicate (see  notAssertible).  But this puts no real limitation on the expressive power of the Cyc system since one can assert that <code>SENT</code> is true by simply asserting <code>SENT</code> itself.  \n<p>\nMost occurrences of the expression 'trueSentence' in CycL assertions have been added by the canonicalizer, so that certain nested sentences (or variables occurring in argument-positions intended for sentences) can receive special handling during canonicalization or inference. See the accompanying cyclistNotes for details.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, trueRule, "(trueRule TEMPLATE FORMULA) states that FORMULA is both true and an instantiation of the rule template TEMPLATE.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, transitiveViaArgInverse, "A MetaPredicate used for stating that a given predicate behaves transitively, in a specified argument-place, with respect to the inverse of a given binary predicate.  <code>(transitiveViaArgInverse PRED BINPRED N)</code> means that the <code>N</code>th argument position of <code>PRED</code> is \"transitive\" with respect to the inverse of <code>BINPRED</code>.  That is, if <code>(PRED</code> ... <code>ARGN</code> ...) and <code>(BINPRED ARGN-PRIME ARGN)</code> hold, then so does <code>(PRED</code> ... <code>ARGN-PRIME</code> ...).  For example,(transitiveViaArgInverse relationAllExists genls 2) holds; thus from (relationAllExists anatomicalParts Mammal Head-AnimalBodyPart) and (genls Horse Mammal) it follows that (relationAllExists anatomicalParts Horse Head-AnimalBodyPart).  See also transitiveViaArg.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, transitiveViaArg, "A MetaPredicate used for stating that a given predicate behaves transitively, in a specified argument-place, with respect to a given binary predicate. <code>(transitiveViaArg PRED BINPRED N)</code> means that the <code>N</code>th argument position of <code>PRED</code> is \"transitive\" with respect to <code>BINPRED</code>.  That is, if <code>(PRED ... ARG-N ...)</code> and <code>(BINPRED ARG-N ARG-N-PRIME)</code> hold, then so does <code>(PRED ... ARG-N-PRIME ...)</code>.  For example, (transitiveViaArg relationAllExists genlPreds 1) holds; thus from (relationAllExists anatomicalParts Mammal Head-AnimalBodyPart) and (genlPreds anatomicalParts physicalParts) it follows that (relationAllExists physicalParts Mammal Head-AnimalBodyPart). See also transitiveViaArgInverse.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, thereExists, "An ExistentialQuantifier (q.v.) that corresponds to the standard existential quantifier of predicate calculus.  thereExists takes as its arguments an ELVariable and an ELSentence-Assertible (such that, typically, the former occurs free in the latter).  (thereExists VAR SENT) means that there is at least one thing THING such that SENT is true of it.  That is, if some given CycL term that denotes THING were substituted for each free occurrence of VAR in SENT, the result would be a true sentence.  For example, `(thereExists ?X (mother ?X GeorgeWBush))' means that George W. Bush has a (i.e. at least one) mother; and\n<p>\n(forAll ?PER\n(implies\n(isa ?PER Person)\n(thereExists ?MOM\n(mother ?MOM ?PER))))\n<p>\nmeans that every person has a mother.  Note that some existential statements can be represented more tersely in CycL using other instances of ExistentialQuantifier, such as thereExistAtMost or thereExistExactly.  Also see the cyclistNotes for thereExists.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, thereExistExactly, "An ExistentialQuantifier (q.v.) and a specialization of both thereExistAtLeast and  thereExistAtMost (qq.v.).  Compared to the standard existential quantifier thereExists, thereExistExactly has an extra argument-place for specifying exactly how many things satisfy a given condition (specified by an CycLSentence-Assertible, in which the also-specified CycLVariable will typically occur free).  A closed sentence of the form <code>(thereExistExactly NUM VAR SENT)</code> means that there are exactly<code> NUM</code> distinct things that satisfy <code>SENT</code>, i.e. that render <code>SENT</code> true when taken as the value of <code>VAR</code>.  For example, the sentence\n<p>\n<pre>\n  (thereExistExactly 7 ?X (isa ?X Sea))\n</pre>\n<p>\nmeans that there are exactly seven seas.\n<p>\nIn the degenerate case where <code>VAR</code> does not appear free in <code>SENT</code>, then <code>(thereExistExactly NUM VAR SENT)</code> is equivalent to <code>SENT</code>.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, thereExistAtMost, "An ExistentialQuantifier (q.v.) and a specialized (albeit higher arity) version of thereExists (q.v.).  Compared to the latter, standard existential quantifier, thereExistAtLeast has an extra argument-place for specifying how many things (at the most) satisfy a given condition (specified by an ELSentence-Assertible, in which the also-specified ELVariable will typically occur free).  A closed sentence of the form (thereExistAtMost NUM VAR SENT) means that there are at most NUM distinct things that satisfy SENT, i.e. that render SENT true when taken as the value of VAR.  For example, the sentence\n<p>\n<pre>\n  (thereExistAtMost 7 ?X (isa ?X Sea))\n</pre>\n<p>\nmeans that there are at most seven seas.\n<p>\nIn the degenerate case where VAR does not appear free in SENT, then (thereExistAtMost NUM VAR SENT) is equivalent to SENT.\n<p>\nSee also thereExistAtLeast, thereExistExactly.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, thereExistAtLeast, "An ExistentialQuantifier (q.v.) and a specialized (albeit higher arity) version of thereExists (q.v.).  Compared to the latter, standard existential quantifier, thereExistAtLeast has an extra argument-place for specifying how many things (at the least) satisfy a given condition (specified by an ELSentence-Assertible, in which the also-specified ELVariable will typically occur free).  A closed sentence of the form (thereExistAtLeast NUM VAR SENT) means that there are at least NUM distinct things that satisfy SENT, i.e. that render SENT true when taken as the value of VAR.  For example, the sentence\n<p>\n<pre>\n  (thereExistAtLeast 7 ?X (isa ?X Sea))\n</pre>\n<p>\nmeans that there are at least seven seas.\n<p>\nIn the degenerate case where VAR does not appear free in SENT, then (thereExistAtLeast NUM VAR SENT) is equivalent to SENT.\n<p>\nSee also thereExistAtMost, thereExistExactly.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, termOfUnit, "An InferenceRelatedBookkeepingPredicate (q.v.) that appears in system-generated assertions.  termOfUnit relates unreified reifiable non-atomic terms (\"NATs\") to indexed data structures reified by the system.  termOfUnit GAF (see CycLClosedAtomicSentence) assertions\nare added by the system when an unreified reifiable NAT first appears in a CycL sentence that is added to the knowledge base.  When such a NAT is first used in a sentence, the Cyc system automatically creates an indexed data structure to reify the NAT.  A name is automatically assigned to the new data structure by the Cyc system.  (Typically, this name is character-for-character identical to the unreified reifiable NAT itself; but one should not be misled by this into thinking that termOfUnit is a specialization of equals.)  The predicate termOfUnit relates the system-generated data structure to the original NAT.  <code>(termOfUnit DATA-STRUCTURE NAT)</code> means that the data structure <code>DATA-STRUCTURE</code> was created to reify the value of the non-atomic term <code>NAT</code>, and that <code>NAT</code> refers to <code>DATA-STRUCTURE</code>, which in turn denotes something in the range of the function in the 0th (or \"arg 0\") position of <code>NAT</code>.\n<p>\nFor example, if an assertion such as (isa (RepairingFn Automobile) ProductType) introduced the unreified reifiable NAT (RepairingFn Automobile) in the Cyc knowledge base, the system would create a data structure to reify the value of (RepairingFn Automobile).  The system would assign the name `(RepairingFn Automobile)' to the newly-created data structure.  The system would also associate the newly-reified data structure with the unreified refiable NAT by means of the termOfUnit assertion (termOfUnit (RepairingFn Automobile) (RepairingFn Automobile)).\n<p>\nNote that termOfUnit assertions are made in the BaseKB because the relation between a NAT and the data structure reified for it is meant to hold in all contexts.  \n<p>\nOne should view termOfUnit assertions as bits of bookkeeping knowledge that are very rarely, if ever, entered into the Cyc knowledge base by hand. See retainTerm -- the predicate to use to create a NART that one wishes to remain in the Cyc KB even if no substantive additional assertions are made about it. NARTs that have only termOfUnit assertions made about them are removed from the KB at build time.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, termExternalIDString, "A predicate which relates any CycLExpression to an external\nidentification string which is guaranteed to uniquely identify the\nexpression in both time and space. (termExternalIDString EXPRESSION\nID-STRING) states that the HLExternalIDString ID-STRING is the string\nrepresentation of the unique external id for the CycLExpression\nEXPRESSION. For obvious reasons, this predicate is notAssertible.\nAlso, note that this predicate is *not* a generalization of\nconstantGUID, since the latter relates a CycLConstant to an\nentirely different string.  That is to say, the termExternalIDString\nof a CycLConstant is not the same string as its constantGUID.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, termDependsOn, "(termDependsOn DEP-TERM INDEP-TERM) states that the reason for the existence of the term DEP-TERM in the Cyc knowledge base is completely dependent on the continued existence of the term INDEP-TERM.  Thus, if INDEP-TERM should ever be removed from the knowledge base, then DEP-TERM should also be immediately removed.  This relationship is automatically maintained between reified non-atomic terms (NATs) and the terms from which they are constructed.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, termChosen, "(termChosen TERM) is true for any closed Cyc TERM, and indicates that TERM has been chosen from the set of terms in the universe of discourse.  This predicate is primarily used on a variable so that the moment of choice of a particular term as the binding for that variable can be identified.  There should never be methods for generating bindings for non-closed termChosen literals.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, synonymousExternalConcept, "<code>(synonymousExternalConcept THING SOURCE STRING)</code> means that as it occurs in the external data source <code>SOURCE</code>, the string <code>STRING</code> denotes <code>THING</code>.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, substring, "A binary predicate that relates an instance of CharacterString to another intance of CharacterString. <code>(substring SUBSTRING STRING)</code> means that <code>SUBSTRING</code> is a substring of <code>STRING</code>.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, subsetOf, "This predicate relates a set or collection <code>SUB</code> to a set or collection <code>SUPER</code> whenever the extent (see extent) of <code>SUB</code> is a  subset of the extent of <code>SUPER</code>.  That is, <code>(subsetOf SUB SUPER)</code> means that  every element of (see elementOf) <code>SUB</code> is an element of <code>SUPER</code>.  subsetOf is thus a generalization both of the subset relation in set theory and of genls (q.v.); and (unlike either of those other relations) subsetOf can hold between a set and a collection, or between a collection and a set.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, skolemizeForward, "(skolemizeForward FUNC) tells the inference engine that terms should be generated for fully-bound uses of FUNC during forward inference.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, skolem, "An InferenceRelatedBookkeepingPredicate (q.v.) that appears in system-generated assertions.  skolem holds of all instances of SkolemFunction, and exists solely for internal bookkeeping purposes.  The set of supports for a skolem assertion of the form (skolem FUNCTOR) is the set of defining assertions of FUNCTOR.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, singleEntryFormatInArgs, "An instance of SpecificEntryFormatPredicate (q.v.).  <code>(singleEntryFormatInArgs PRED N)</code> means that, for any particular way of fixing the other arguments to <code>PRED</code> besides the <code>N</code>th, there is at most one thing such that, if taken as the <code>N</code>th argument, <code>PRED</code> holds of those arguments.  That is, if the sequences <code><... ARGN ...></code> and <code><... ARGN-PRIME ...></code> differ at most in their <code>N</code>th items and both <code>(PRED ... ARGN ...)</code> and <code>(PRED ... ARGN-PRIME ...)</code> hold, then <code>ARGN = ARGN-PRIME</code> (see equals).  For example, singleEntryFormatInArgs holds of biologicalMother with respect to its second argument-place, since an animal can only have one biological mother.  A predicate with a single-entry format argument-place is thus a StrictlyFunctionalPredicate (q.v.) that is \"functional\" with respect to that argument-place (see strictlyFunctionalInArgs).  Contrast with openEntryFormatInArgs.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, siblingDisjointExceptions, "A predicate that is  used to make exceptions to constraints normally imposed by some instance of SiblingDisjointCollectionType or SiblingDisjointSetOrCollectionType (qq.v.).  <code>(siblingDisjointExceptions SETORCOL1 SETORCOL2)</code> means that the pair consisting of <code>SETORCOL1</code> and <code>SETORCOL2</code> is exempt from the disjointness constraint that would otherwise be imposed because those set-or-collections are both elements of some instance of SiblingDisjointCollectionType or SiblingDisjointSetOrCollectionType.  (See these collections' comments for a full explanation of the constraints.)   \n<p>\nFor example, SensoryNerve and CranialNerve are both instances of OrganismPartType, which in turn is an instance of SiblingDisjointCollectionType.  Consequently, since SensoryNerve is not a specialization of CranialNerve (or vice versa), the two collections have a default disjointness constraint placed between them.  However, such a disjointness constraint should be blocked, since any instance of OpticNerve is an instance of both SensoryNerve and CranialNerve.  By asserting <code>(siblingDisjointExceptions SensoryNerve CranialNerve)</code>, we block the disjointness constraint between those two collections, without disturbing the constraints between each of those collections and all their other (sibling) instances of the parent collection OrganismPartType.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, sharedNotes, "A predicate-denoting constant that is an instance of DocumentationPredicate.  It is sometimes useful to include the same piece of text in the documentation of two or more constants or other CycLIndexedTerms. Rather than actually duplicating text in the Knowledge Base, one can create a SharedNote (q.v.): a piece of text that is to serve as this shared documentation, and which is itself the comment (see comment) on the SharedNote's constant.  (Thus the constants for shared-notes actually denote their own comments.)  (sharedNotes TERM NOTE) means that NOTE is a string of text (see TextString) serving as shared documentation partly about TERM.  Since SharedNotes are typically _shared_, there are likely to be one or more other indexed terms having NOTE as their shared-note as well.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, sentenceTruth, "A KBDependentRelation (q.v.) that is used to state the truth of a given CycL sentence. (sentenceTruth SENT TRUTH) means that the CycL sentence SENT has the truth value TRUTH, which is either True or False.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, sentenceImplies, "A binary predicate that represents logical entailment in CycL.  <code>(sentenceImplies ANTECEDENT CONSEQUENT)</code> means that <code>CONSEQUENT</code> can be derived from <code>ANTECEDENT</code> using purely logical transformations.  For example, this holds by double negation:\n<pre>\n  (sentenceImplies\n    (isa Muffet Poodle)\n    (not (not (isa Muffet Poodle))) .\n</pre>\nNote that there are cases in which <code>(implies ANTECEDENT CONSEQUENT)</code> is analytically true, or necessarily true in some sense of necessity weaker than logical necessity, such that <code>(sentenceImplies ANTECEDENT CONSEQUENT)</code> is false.  For example, whereas:\n<pre>\n  (implies (isa Muffet Poodle) (isa Muffet Dog))\n</pre>\nis analytically true or in some sense necessarily true,\n<pre>\n  (sentenceImplies (isa Muffet Poodle) (isa Muffet Dog))\n</pre>\nis not true, since the material conditional is not logically valid.\n<p>\nsentenceImplies also differs from implies in that whereas implies is a LogicalConnective (q.v.), sentenceImplies is merely a predicate that holds between sentences.  sentenceImplies is primarily intended to be used for rules that quantify over CycL sentences.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, sentenceEquiv, "(sentenceEquiv FORMULA-1 FORMULA-2) means that  the ELSentence-Assertible FORMULA-1 is logically equivalent to the ELSentence-Assertible FORMULA-2.  This predicate is very similar to equiv, but equiv is an instance of LogicalConnective, while sentenceEquiv is an instance of Predicate.  sentenceEquiv is primarily intended to be used for rules that quantify over CycL formulas.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, sentenceDesignationArgnum, "Used to specify which argument of a given MicrotheoryDesignatingRelation\ndesignates the CycL sentence to be interpreted in a specific microtheory.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, scopingArg, "A binary MetaRelation that relates a ScopingRelation (q.v.) to an integer indicating the argument-place of the former that takes a variable or list of variables.  (scopingArg RELN N) means that RELN's Nth argument is a variable or variable-list (see CycLVariable and CycLVariableList) such that it (they) and any other occurrences of the same variable(s) that occur free in the CycL formula serving as the \"scoped\" argument (see scopedFormulaArg) to RELN is (are) bound with respect to the entire RELN-based formula.  For example, (scopingArg thereExists 1) entails that in the sentence\n<p>\n<pre>\n  (thereExists ?KIT\n    (and\n      (isa ?KIT Cat)\n      (isa ?KIT BlackColor)))\n</pre>\n<p>\neach occurrence of the variable '?KIT' is bound by the quantifier thereExists.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, salientAssertions, "(salientAssertions TERM ASSERTION) means that ASSERTION has been deemed one of the assertions most useful to examine when one is trying to figure out the intended meaning of TERM.  Thus, ASSERTION will normally contain TERM, and should be something that has been asserted on its own in the KB as well.  Statements using salientAssertions are primarily intended for human consumption, and are not normally used by the Cyc inference engine.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, ruleTemplateDirection, "A MetaKnowledgePredicate. (ruleTemplateDirection TEMPLATE DIRECTION) states that all assertions which are instantiations of TEMPLATE should  have a direction of DIRECTION.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, ruleAfterRemoving, "Whenever a new rule is unasserted, ruleAfterRemovings are called on each literal of the rule.  The particular ruleAfterRemovings called depend on the predicate of the literal.  (ruleAfterRemoving PRED HOOK) means that HOOK will be called on each of the rule's literals whose predicate is PRED.  If the rule has multiple literals containing predicate with ruleAfterRemoving the order of execution is not guaranteed.  Also, ruleAfterRemovings are retriggered on the removal of the each argument to a rule.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, ruleAfterAdding, "Whenever a new rule is asserted, ruleAfterAddings are called on each literal of the rule.  The particular ruleAfterAddings called depend on the predicate of the literal.  (ruleAfterAdding PRED HOOK) means that HOOK will be called on each of the rule's literals whose predicate is PRED.  If the rule has multiple literals containing predicate with ruleAfterAdding, the order of execution is not guaranteed.  Also, ruleAfterAddings are retriggered on the addition of new arguments to an existing rule.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, rewriteOf, "A specialization of equals and a CycLReformulatorConstant that relates pairs of CycLClosedDenotationalTerms.   rewriteOf is, in a sense, a \"directional\" version of equals.  <code>(rewriteOf FAVORED-TERM DISFAVORED-TERM)</code> means that (1) <code>FAVORED-TERM</code> and <code>DISFAVORED-TERM</code> denote the same thing, and (2) <code>FAVORED-TERM</code> is deemed worthy of being privileged over <code>DISFAVORED-TERM</code> in the following senses: assertions made on <code>DISFAVORED-TERM</code> will be propagated to <code>FAVORED-TERM</code>, and whenever possible attempts to reason about  <code>DISFAVORED-TERM</code> will be transformed into attempts to reason about <code>FAVORED-TERM</code>.  The propagated assertions will differ from the original assertions only in that the propagated assertions will be the result of substituting <code>FAVORED-TERM</code> for <code>DISFAVORED-TERM</code> wherever <code>DISFAVORED-TERM</code> occurs in the original assertions.  Note that substitution does not happen in the opposite direction.  That is, assertions containing <code>FAVORED-TERM</code> will not propagate to <code>DISFAVORED-TERM</code>.\n<p>\nOne common use of rewriteOf is that in which <code>FAVORED-TERM</code> is a syntactically simpler term than <code>DISFAVORED-TERM</code>.  For example, <code>FAVORED-TERM</code> may contain fewer nested terms that denote Function-Denotationals than does <code>DISFAVORED-TERM</code>.  (rewriteOf UnitedStatesNavy (NavyFn UnitedStatesOfAmerica)) is a good example of this common sort of use.\n<p>\nNote that rewriteOf expresses a strictly conventional notion of \"directional\" equality. Pragmatic considerations, not ontology, will dictate which term is chosen to occur as the privileged (left-hand side) term in a rewriteOf assertion.  Thus, in the example the fact that simpler terms are generally easier to use (remember, manipulate, etc.) dictates that UnitedStatesNavy should be a rewrite of (NavyFn UnitedStatesOfAmerica), and not vice versa.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, resultQuotedIsa, "A binary MetaRelation predicate that holds between functions and expression-types. resultQuotedIsa indicates that any value returned by a given Function-Denotational is a \"quoted instance\" of a given expression-type.   More correctly, <code>(resultQuotedIsa FUNC TYPE)</code> means that, for any term-sequence <code>ARGS</code>, if the expression <code>(FUNC . ARGS)</code> is an admittedNAT (q.v.), then it is an instance of the SubLExpressionType <code>TYPE</code>.  That is, the following holds:\n<pre>\n  (quotedIsa (FUNC . ARGS) TYPE)\n</pre>\nAnd, equivalently, so does:\n<pre>\n  (isa (Quote (FUNC . ARGS)) TYPE)\n</pre>\n\nTo contrast this predicate with resultIsa: <code>(resultIsa FUNC COL)</code> holds just in case each defined term of the form <code>(FUNC . ARGS)</code> <i>denotes</i> an instance of <code>COL</code>, whereas <code>(resultQuotedIsa FUNC COL)</code> holds just in case each admitted (i.e. syntactically and semantically well-formed) term of the form <code>(FUNC . ARGS)</code> <i>is itself</i> an instance of <code>COL</code>.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, resultIsaArgIsa, "(resultIsaArgIsa FUNC INT) means that the NAT resulting from a use of FUNC is a member of the same collections that the term\nin arg position INT is a member of.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, resultIsaArg, "A MetaRelation predicate.  <code>(resultIsaArg FUNC N)</code>  means that the value returned by <code>FUNC</code> for any given sequence of arguments  is an instance of the <code>N</code>th argument in that sequence.  That is, if  <code>(FUNC ARG1 ... ARGN ...) = VALUE</code>, then <code>(isa VALUE ARGN)</code> holds.  Obviously, <code>ARGN</code> must be a collection; so <code>FUNC</code>'s <code>N</code>th argument-place is likely to be constrained (via argIsa) to be an instance of Collection or some specialization thereof.\n<p>\nFor example, (resultIsaArg The 1) entails that (The Dog) is an instance of Dog.\n<p>\nSee also resultGenlArg and resultIsa.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, resultIsa, "A binary MetaFunction that is used to indicate that any value returned by a given function (see Function-Denotational) is an instance of a given collection.  <code>(resultIsa FUNC COL)</code> means that <code>FUNC</code> returns an instance of <code>COL</code> for any sequence of arguments for which <code>FUNC</code> is defined.  That is, <code>(isa (FUNC . ARGS) COL)</code> holds for any sequence <code>ARGS</code> for which <code>FUNC</code> has a value (see valueOfFunctionForArgs and relationDomain).  \n<p>\nFor example, <code>(resultIsa PlusFn ScalarInterval)</code> holds, and it entails (e.g.) <code>(isa (PlusFn 2 2) ScalarInterval)</code>.  \n<p>\nSee also resultGenl.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, resultGenlArg, "A MetaFunction predicate that holds of certain CollectionRelatingFunctions with respect to certain argument-places.  (resultGenlArg FUNC N) means that FUNC always returns a subcollection of its own corresponding Nth-place argument, and that FUNC is \"genls preserving\" in that argument-place.  More precisely: (i) the value of FUNC for any sequence of arguments for which it is defined is a subcollection of the Nth item in that sequence (i.e. (genls (FUNC ARG1..ARGN..) ARGN)) and (ii) (preservesGenlsInArg FUNC N) holds.  For example, (resultGenlArg JuvenileFn 1) entails (genls (JuvenileFn Dog) Dog) and -- given that (genls Dog Mammal) --   (genls (JuvenileFn Dog) (JuvenileFn Mammal)).  See also resultIsaArg and resultGenl.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, resultGenl, "A MetaFunction that is used to specify that a \ngiven collection is a supercollection of any value returned by a given CollectionDenotingFunction (q.v.).  <code>(resultGenl COLFUNC COL)</code> means that when <code>COLFUNC</code> is applied to any sequence of arguments <code>ARGS</code> for which it is defined, the resulting value will be a subcollection of <code>COL</code>.  That is, <code>(genls (COLFUNC . ARGS) COL)</code> holds.  \n<p>\nFor example, <code>(resultGenl UsingAFn Action)</code> implies that the collection of acts done using any given type of object is a type of action, <code>(resultGenl AttemptingFn PurposefulAction)</code> implies that the attempts at a given type of action constitute a type of purposeful act, and <code>(resultGenl JointTypeBetweenFn Joint-Physical)</code> means that the collection of joints between two given types of things is a type of physical joint.  \n<p>\nSee also resultIsa.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, requiredArg3Pred, "A MetaPredicate for stating that every instance of a given collection is related (as the \"arg3\") to some things by a given predicate.  <code>(requiredArg3Pred COL PRED)</code>  means that for every instance <code>INST</code> of <code>COL</code>, there exists some sequence  <<code>X1</code>, <code>X2</code>,..., <code>Xn</code>> such that <code>(PRED X1 X2 INST</code> ... <code>Xn)</code> holds.  For  example, (requiredArg3Pred ConflictEvent opponentsInConflict) means that every conflict involves (at least) two opponents.  See also requiredArg1Pred and requiredArg2Pred.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, requiredArg2Pred, "A MetaPredicate for stating that every  instance of a given collection is related (as the \"arg2\") to some  thing or things by a given predicate.  (requiredArg2Pred COL PRED)  means that for every instance INST of COL, there exists some sequence  <X1, X3, ..., Xn> of such that (PRED X1 INST X3 ... Xn) holds.  For  example, (requiredArg2Pred Side objectSides) means that every  side is the side of at least one object.  See also requiredArg1Pred.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, requiredArg1Pred, "A MetaPredicate for stating that every instance of a given collection is related to some thing or things by a given predicate.  <code>(requiredArg1Pred COL PRED)</code> means that for every  instance <code>INST</code> of <code>COL</code>, there exists some sequence <code>ARGS</code> such that <code>(PRED INST . ARGS)</code> holds.  For example, (requiredArg1Pred Organization hasMembers) means that every organization has at least one member.  \n<p>\nSee also requiredArg2Pred and requiredArg3Pred.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, relationMemberInstance, "(relationMemberInstance PRED GROUP INST) states that for every MEMBER of GROUP the following is true: (PRED MEMBER INST).  This predicate enables one to make claims about the members of a group by referencing only the group itself.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, relationInstanceMember, "(relationInstanceMember PRED INST GROUP) states that for every MEMBER of GROUP the following is true: (PRED INST MEMBER).  This predicate enables one to make claims about the members of a group by referencing only the group itself.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, relationInstanceExists, "A ternary RuleMacroPredicate (q.v.) that can be used to state that a given binary predicate holds between a specified thing and some instance of a given collection.  <code>(relationInstanceExists PRED THING COL)</code> means that there exists an instance <code>INST</code> of <code>COL</code> such that <code>(PRED THING INST)</code> holds.  It is equivalent to (and can thus be used in effect as shorthand for) the more complex form:\n<p>\n<pre>\n     (thereExists ?INST\n          (and\n               (isa ?INST COL)\n               (PRED THING ?INST))) .\n</pre>\n<p>\nFor example, '(relationInstanceExists geographicalSubRegions Iran OilField)' means that there exists an oilfield in Iran.  Cf. relationExistsInstance, and see the shared NoteAboutUseOfRuleMacroPredicates.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, relationInstanceAll, "A ternary RuleMacroPredicate that is used to state that a given binary predicate holds between a given thing and all instances of a given collection. (relationInstanceAll BINPRED THING COL) means that THING bears the relation PRED to every instance INST of COL such that (BINPRED THING INST) holds.  It is equivalent to (and can thus be used in effect as shorthand for) the more complex form:\n<p>\n(implies\n(isa ?INST COL)\n(BINPRED THING ?INST)) .\n<p>\nFor example, `(relationInstanceAll geopoliticalSubdivision UnitedStatesOfAmerica State-UnitedStates)' means that each State in the Union is a subdivision of the United States.  Cf. relationAllInstance, and see NoteAboutUseOfRuleMacroPredicates.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, relationExpansion, "ARG2 is a CycL expression which indicates the meaning of expressions in which the relation ARG1 is the operator (i.e., in which ARG1 is in the 0th argument position).  In ARG2, the variables ?arg1, ?arg2, ?arg3, ?arg4, and ?arg5 correspond to the objects in the argument positions 1, 2, 3, 4, and 5, respectively, in expressions which have ARG1 as the operator.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, relationExistsMinAll, "A quaternary RuleMacroPredicate (q.v.) that can be used to state that a given binary predicate stands in a certain numerical relation with respect to two collections.  (relationExistsMinAll BINPRED COL1 COL2 N) means that for any instance INST of COL2, there are at least N instances of (INST(1), ..., INST(N)) of COL1 such that (BINPRED INST(i) INST) holds (for 1 <= i <= N).  This is equivalent to (and can thus be used in effect as shorthand for) the more complex form:\n<p>\n(implies\n(isa INST COL2)\n(thereExistAtLeast N ?INST-I\n(and\n(isa ?INST-I COL1)\n(BINPRED ?INST-I INST)))) .\n<p>\nFor example, `(relationExistsMinAll physicalParts Hand Finger 1)' means that every finger is part of at least one hand.  Cf. relationAllExistsMin, and see the shared NoteAboutUseOfRuleMacroPredicates.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, relationExistsMaxAll, "A quaternary RuleMacroPredicate (q.v.) that can be used to state that a given binary predicate stands in a certain numerical relation with respect to two collections.  <code>(relationExistsMaxAll BINPRED COL1 COL2 N)</code> means that for any instance <code>INST</code> of <code>COL2</code>, there are at most <code>N</code> instances of <code>(INST(1), ..., INST(N))</code> of <code>COL1</code> such that <code>(BINPRED INST(i) INST)</code> holds (for 1 <= <code>i</code> <= <code>N</code>).  This is equivalent to (and can thus be used in effect as shorthand for) the more complex form:\n<pre>\n  (implies\n    (isa INST COL2)\n    (thereExistAtMost N ?INST-I\n      (and\n        (isa ?INST-I COL1)\n        (BINPRED ?INST-I INST)))).\n</pre>\nFor example, <code>(relationExistsMaxAll physicalParts Hand Finger 1)</code> means that every finger is part of at most one hand.  Cf. relationAllExistsMax, and see the shared NoteAboutUseOfRuleMacroPredicates.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, relationExistsInstance, "A ternary RuleMacroPredicate (q.v.) that can be used to state that a given binary predicate holds between some instance of a given collection and a given thing.  <code>(relationExistsInstance BINPRED COL THING)</code> means that there exists an instance <code>INST</code> of <code>COL</code> such that <code>(BINPRED INST THING)</code> holds.  This is equivalent to (and can thus be used in effect as shorthand for) the more complex form:\n<p>\n<pre>\n(thereExists ?INST\n  (and\n     (isa ?INST COL)\n     (PRED ?INST THING))) .\n</pre>\n<p>\nFor example, (relationExistsInstance eventOccursAt IllegalDrugActivity Sweden) means that there exists illegal drug activity in Sweden.  See also the shared  NoteAboutUseOfRuleMacroPredicates.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, relationExistsCountAll, "A quaternary RuleMacroPredicate (q.v.) that is used to state that a given binary predicate stands in a certain numerical relationship with respect to two collections.  (relationExistsCountAll BINPRED COL1 COL2 N) means that for every instance INST of COL2 there are exactly N instances of COL1 (INST(1), ..., INST(N)) such that (BINPRED INST(i) INST) holds (for 1 <= i <= N).  It is equivalent to (and so can be used in effect as shorthand for) the more complex form:\n<p>\n<pre>\n  (implies\n    (isa ?INST COL2)\n    (thereExistExactly N ?INST-I\n      (and\n             (isa ?INST COL1)\n             (BINPRED ?INST-I ?INST)))) .\n</pre>\n<p>\nFor example, (relationExistsCountAll anatomicalParts Animal Head-AnimalBodyPart 1) means that every animal head is a part of exactly one animal.  See also relationAllExistsCount and NoteAboutUseOfRuleMacroPredicates.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, relationExistsAll, "A ternary RuleMacroPredicate (q.v.) that can be used to state that a given binary predicate stands in a certain relation to two collections.  <code>(relationExistsAll BINPRED COL1 COL2)</code> means that for any instance <code>INST2</code> of <code>COL2</code>, there exists some instance <code>INST1</code> of <code>COL1</code> such that <code>(BINPRED INST1 INST2)</code> holds.  It is equivalent to (and can thus be used in effect as shorthand for) the more complex form\n<pre>\n  (implies\n    (isa ?INST2 COL2)\n    (thereExists ?INST1\n      (and\n        (isa ?INST1 COL1)\n        (BINPRED ?INST1 ?INST2)))).\n</pre>\nFor example, <code>(relationExistsAll adjacentTo Harbor PortCity)</code> means that for every port city there exists a harbor to which the city is adjacent.  See also relationAllExists and NoteAboutUseOfRuleMacroPredicates.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, relationAllInstance, "A ternary RuleMacroPredicate that is used to state that a given binary predicate holds between all instances of a given collection and a given thing. <code>(relationAllInstance PRED COL THING)</code> means that every instance <code>INST</code> of <code>COL</code> bears the relation <code>PRED</code> to <code>THING</code> such that <code>(PRED INST THING)</code> holds.  It is equivalent to (and can thus be used in effect as shorthand for) the more complex form:\n<p>\n<pre>\n     (implies\n          (isa ?INST COL)\n          (PRED ?INST THING)) .\n</pre>\n<p>\nFor example, '(relationAllInstance maxSpeed GolfCart (MilesPerHour 15))' means that the maximum speed of every golf cart is 15 miles per hour. Cf. relationInstanceAll, and see NoteAboutUseOfRuleMacroPredicates.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, relationAllExistsMin, "A quaternary RuleMacroPredicate that can be used to state that a given binary predicate stands in a certain numerical relationship with respect to two collections.  (relationAllExistsMin BINPRED COL1 COL2 N) means that for any instance INST of COL1 there are at least N instances (INST(1), ..., INST(N)) of COL2 such that (BINPRED INST INST(i)) holds (for 1 <= i <= N).  This is equivalent to (and can thus be used in effect as shorthand for) the more complex form:\n<p>\n(implies\n(isa ?INST COL1)\n(thereExistAtLeast N ?INST-I\n(and\n(isa ?INST-I COL2)\n(BINPRED ?INST ?INST-I)))) .\n<p>\nFor example, `(relationAllExistsMin subEvents EatingEvent Swallowing 1)' means that every act of eating includes at least one swallowing. Cf. relationExistsMinAll, and see NoteAboutUseOfRuleMacroPredicates.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, relationAllExistsMax, "A quaternary RuleMacroPredicate that can be used to state that a given binary predicate stands in a certain numerical relationship with respect to two collections.  (relationAllExistsMax BINPRED COL1 COL2 N) means that for any instance INST of COL1 there are at most N instances (INST(1), ..., INST(N)) of COL2 such that (BINPRED INST INST(i)) holds (for 1 <= i <= N).  This is equivalent to (and can thus be used in effect as shorthand for) the more complex form:\n<p>\n(implies\n(isa ?INST COL1)\n(thereExistAtMost N ?INST-I\n(and\n(isa ?INST-I COL2)\n(BINPRED ?INST INST-I)))) .\n<p>\nFor example, `(relationAllExistsMax anatomicalParts Dog Leg 4)' means that all dogs have at most four legs.\n<p>\nCf. relationExistsMaxAll; also see NoteAboutUseOfRuleMacroPredicates.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, relationAllExistsCount, "A quaternary RuleMacroPredicate that is a specialization of both relationAllExistsMin and relationAllExistsMax (qq.v.).  <code>(relationAllExistsCount BINPRED COL1 COL2 N)</code> means that for any instance <code>INST</code> of <code>COL1</code> there are exactly <code>N</code> instances <code>INST1</code>, ..., <code>INSTn</code> of <code>COL2</code> such that <code>(BINPRED INST INSTi)</code> holds (for 1 <code><= i <= N)</code>. It is equivalent to (and can thus be used in effect as shorthand for) the more complex form:\n<pre>\n  (implies\n    (isa ?INST COL1)\n    (thereExistExactly N ?INST-I\n      (and\n        (isa ?INST-I COL2)\n        (BINPRED ?INST ?INST-I))))\n</pre>\n<p>\n(wherein the variable <code>?INST</code> is interpreted as if it were bound by an initial universal quantifier).\n<p>\nFor example, <code>(relationAllExistsCount anatomicalParts Dog Leg 4)</code> means that all dogs have four legs.\n<p>\nCf. relationExistsCountAll, and see the NoteAboutUseOfRuleMacroPredicates.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, relationAllExists, "A ternary RuleMacroPredicate (q.v.) that can be used to state that a given binary predicate stands in a certain relation to two collections. <code>(relationAllExists BINPRED COL1 COL2)</code> means that for any instance <code>INST1</code> of <code>COL1</code>, there exists some instance <code>INST2</code> of <code>COL2</code> such that <code>(BINPRED INST1 INST2)</code> holds.  It is equivalent to (and can thus be used in effect as shorthand for) the more complex form:\n<p>\n<pre>\n  (implies\n    (isa ?INST1 COL1)\n    (thereExists ?INST2\n      (and\n        (isa ?INST2 COL2)\n        (BINPRED ?INST1 ?INST2)))).\n</pre>\n<p>\nFor example, <code>(relationAllExists temporalBoundsContain CalendarWeek Wednesday)</code> means that every calendar week contains a Wednesday.  See also relationExistsAll and NoteAboutUseOfRuleMacroPredicates.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, relationAll, "A binary RuleMacroPredicate that relates a given unary predicate to a collection of things that the predicate holds of.  <code>(relationAll PRED COL)</code> means that, for every instance <code>INST</code> of <code>COL</code>, <code>(PRED INST)</code> holds.  Thus <code>(relationAll PRED COL)</code> is equivalent to -- and so can be used in effect as shorthand for -- (the unversal closure of) the more complex form:\n<pre>\n  (implies \n    (isa <b>?INST</b> COL) \n    (PRED <b>?INST</b>)) .\n</pre>\nFor example, <code>(relationAll assertedSentence CycLAssertion)</code> means that all CycLAssertions are asserted sentences.  \n<p>\nSee also relationOnly and the shared NoteAboutUseOfRuleMacroPredicates.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, reformulatorRuleProperties, "(reformulatorRuleProperties PROP RULE) means that RULE has\nthe property PROP.  Most reformulator directives express an assertion\nof the form 'The reformulator should do X', for some X.  In contrast,\nreformulatorRuleProperties assertions are stronger, in that they\nexpress intrinsic properties of reformulator rules, and it is a\nconsequence that the reformulator should do X in order to be\ncorrect.  For example, a reformulator directive could say 'For this\nreformulator rule, if in tersification mode, the reformulator should reformulate\nthe second argument into the first argument.', whereas a reformulator\nrule property could say 'This reformulator rule's first argument is\nmore terse than its second argument.'  The latter implies the former.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, reformulatorRule, "(reformulatorRule EXPR-1 EXPR-2), asserted in the\nmicrotheory MT, means that EXPR-1 may be reformulated into EXPR-2 (or\nvice versa, based on meta-properties of this rule and what mode the\nreformulator is in) in MT\nor a specMt thereof.  Free variables in EXPR-1 and EXPR-2 are shared,\nand may bind with CycL expressions which match the template. Truth\nand semantics are not necessarily preserved (see TruthPreservingReformulation).\nUse the more specific predicates reformulatorEquiv and reformulatorEquals\nwhen applicable.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, reformulatorEquiv, "A CycLReformulationRulePredicate that relates two CycL sentences.  When asserted in a Microtheory MT, (reformulatorEquiv SENTENCE-1 SENTENCE-2) means that the CycLSentence SENTENCE-1 may be reformulated into the CycLSentence SENTENCE-2, or vice versa (based on meta-properties of this rule and what mode the reformulator is in), in any Microtheory SPEC-MT such that (genlMt SPEC-MT MT) holds.  Free variables in SENTENCE-1 and SENTENCE-2 are shared, and may bind with CycL sentences which match the template.  Note that (reformulatorEquiv SENTENCE-1 SENTENCE-2) does _not_ necessarily imply (equiv SENTENCE-1 SENTENCE-2), although this implication would hold if the reformulation is a TruthPreservingReformulation (q.v.).", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, reformulatorEquals, "A CycLReformulationRulePredicate that relates two CycL denotational terms.  When asserted in a Microtheory MT, (reformulatorEquals TERM-1 TERM-2) means that the CycLDenotationalTerm TERM-1 may be reformulated into the CycLDenotationalTerm TERM-2, or vice-versa (based on meta-properties of this rule and what mode the reformulator is in), in any Microtheory SPEC-MT such that (genlMt SPEC-MT MT) holds.  Free variables in TERM-1 and TERM-2 are shared, and may bind with CycL terms which match the template.  Note that (reformulatorEquals TERM-1 TERM-2) does _not_ necessarily imply (equals TERM-1 TERM-2), although this implication would hold if the reformualtion is a TruthPreservingReformulation (q.v.).", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, reformulationPrecondition, "(reformulationPrecondition DIRECTION PRECONDITION RULE), asserted in\nthe microtheory MT, means that the CycLReformulator may only use\nRULE in MT in the DIRECTION direction (reformulating the 'from' arg\ninto the 'to' arg) if PRECONDITION holds.  PRECONDITION must be a closed CycL query, which will be asked during reformulation, and either proven true or fail to be proven.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, reformulationDirectionInMode, "(reformulationDirectionInMode DIRECTION MODE RULE), when\nasserted in the microtheory MT, tells the CycLReformulator whether to use RULE\nin the forward (ReformulationForwardDirection) or backward\n(ReformulationBackwardDirection) direction when reformulating\nCycLExpressions in MT or a specMt thereof, and when operating in the mode MODE.\nIt will reformulate the 'from' arg into the 'to' arg,\nbased on DIRECTION.  ReformulationNeitherDirection\nindicates the rule is not to be used at all in this mt.\nThis concept of direction has nothing to do with the forward vs. backward rule\ndistinction in inference.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, ratioOfTo, "The predicate corresponding to QuotientFn.  (ratioOfTo NUM-1 NUM-2 NUM-3) holds just in case the ratio of NUM-1 to NUM-2 is NUM-3; that is, just in case  (QuotientFn NUM-1 NUM-2) = NUM-3.  For example, (ratioOfTo 1 2 0.5) is true because 1 divided by 2 is 0.5.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, quotedIsa, "A binary MetaLanguagePredicate (q.v.) that relates CycL expressions to the SubLExpressionTypes (q.v.) of which they are instances.  quotedIsa is thus like a restricted version of isa (q.v.), but with one important difference: the first argument-place of quotedIsa is \"implicitly quoted\" (see quotedArgument).  So a ground atomic sentence of the form <code>(quotedIsa THING EXPR-TYPE)</code> does <i>not</i> mean that <code>THING</code> itself is an instance of <code>EXPR-TYPE</code>.  Rather, such a sentence is partly self-referential, and means that the particular <i>CycL expression</i> appearing in the sentence's own first argument-position is an instance of <code>EXPR-TYPE</code>.  Thus, quotedIsa provides a convenient shorthand for stating certain things that would otherwise require explicit quotation (or some other device for naming expressions).\n<p>\nThis is better illustrated with a specific example.  Suppose we wish to state that the CycL constant <code>IndianOcean</code> is an instance of the CycL expression type PublicConstant.  We cannot express this with the straightforward isa sentence <code>(isa IndianOcean PublicConstant)</code>, as that states the falsehood that the IndianOcean itself -- which is <i>not</i> a constant but a body of water -- is a public constant.  But we can express precisely what we want like this:\n<pre>\n  (quotedIsa IndianOcean PublicConstant) .\n</pre>  \nNow quotedIsa is a MacroRelation (q.v.), and by its expansion any given quotedIsa sentence is equivalent to some isa sentence with an <i>explicitly</i> quoted first argument.  The sentence displayed above turns out to be equivalent to: \n<pre>\n  (isa (Quote IndianOcean) PublicConstant).\n</pre> \nBut the quotedIsa version has two related practical advantages over the isa version.  First, the former is syntactically simpler than the latter.  Second, the simpler syntax of the former makes it easier to browse in the Knowedge Base: while the quotedIsa version is conveniently indexed under the KB Browser page for the constant <code>IndianOcean</code>, the isa version would apparently be indexed under a separate, brand new page for the term <code>(Quote IndianOcean)</code>. Generalizing the point, quotedIsa lets us avoid having potentially to double the number of pages currently in the browser.\n<p>\nFor the semantically more complicated (but rarely encountered) case in which quotedIsa's first argument-place is filled with an <i>open</i> expression, see the accompanying cyclistNotes.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, quotedDefnSufficient, "A CycInferenceDescriptorPredicate. (quotedDefnSufficient COL TEST) means that TEST is the name of a piece of code in the SubL implementation of Cyc that specifies, and tests for, a sufficient condition for a CycL term's denoting a quoted instance of (see quotedIsa) the collection COL. If TEST returns `T' (for `True') when applied to a particular term, then that term's denotatum is considered to be a quoted instance of COL. Note that TEST isn't necessarily a necessary test for quoted membership in COL; that is, not all quoted instances of COL must pass the test, unless TEST is also a defnNecessary for COL, or the term is asserted to be a quoted instance of COL using quotedIsa. See the related predicates quotedDefnNecessary and quotedDefnIff.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, quotedDefnNecessary, "A CycInferenceDescriptorPredicate. (quotedDefnNecessary COL TEST) means that TEST is the name of a piece of code in the SubL implementation of Cyc that specifies, and tests for, a necessary condition for a CycL term's denoting a quoted instance of (see quotedIsa) the collection COL. Only if TEST returns `T' (for `True') when applied to a particular term can that term's denotatum be considered a quoted instance of COL; all terms that denote quoted instances of COL must fulfill TEST's requirements, although there may be additional requirements for denoting an instance of COL as well. However, terms asserted to be quoted instances of the collection COL using quotedIsa are exempt from fulfilling TEST's requirements. See also quotedDefnSufficient and quotedDefnIff.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, quotedDefnIff, "A CycInferenceDescriptorPredicate. (quotedDefnIff COL TEST) means that TEST is the name of a piece of code in the SubL implementation of Cyc that specifies, and tests for, a necessary and sufficient condition for a CycL term's denoting a quoted instance of (see quotedIsa) the collection COL. If and only if TEST returns `T' (for `True') when applied to a particular term can that term's denotatum be considered a quoted instance of COL; all and only terms that denote quoted instances of COL must fulfill TEST's requirements.  However, terms asserted to be quoted instances of the collection COL using quotedIsa are exempt from fulfilling TEST's requirements. See also quotedDefnNecessary and quotedDefnSufficient.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, quotedArgument, "The main (longer) comment on this predicate was written to explain the role of quotedArgument in an earlier approach for referring to CycL expressions in the CycL language that is currently (April 2002) being phased out in favor of a new approach.  Whereas the earlier approach enabled self-reference only by means of a sort of \"implicit quotation\", the new approach involves a mechanism for explicitly quoting CycL expressions (by putting them inside something analogous to quotation marks).  quotedArgument, unlike quotedCollection (q.v.), still has a role to play with respect to the new approach, and its main comment will soon revised to better explain that role.  For an explanation of the new approach to quoting, see the shared NoteAboutQuotingInCycL and the constants that share that note.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, quotedArgument, "A specialization of opaqueArgument (q.v.).  quotedArgument is a binary MetaLanguagePredicate used to state that a given argument-place of a given CycL relation-denoting expression is an <i>implicitly quoted</i> context, in the sense that a symbol appearing in that context denotes <i>itself</i> (as opposed to whatever that symbol might denote, if anything, in ordinary non-quoted contexts).  \n<p>\n<code>(quotedArgument REL N)</code> means that in a closed compound expression built from <code>REL</code> -- i.e. a ground atomic sentence (or <i>gaf</i>) if <code>REL</code> is a predicate or a closed non-atomic term (or <i>nat</i>) if <code>REL</code> is a function -- the term (i.e. the CycL expression) <code>EXPR</code> appearing in <code>REL</code>'s <code>N</code>th argument-place is taken to denote <i>itself</i> (i.e. that very expression <code>EXPR</code>).  \n<p>\nquotedArgument thus makes possible a kind of a self-reference in CycL. Relations with quoted argument-places can be used to make statements about particular CycL expressions, without quoting those expressions explicitly (cf. Quote).\n<p>\nFor example, the first argument-place of the predicate myCreator is quoted and its second argument-place is not.  Thus in the sentence <code>(myCreator PlanetEarth Maeda)</code>, the CycL constant <code>PlanetEarth</code> denotes that constant itself (and not the actual planet Earth), while the constant <code>Maeda</code> simply denotes the person Maeda (and not a CycL expression).  Hence the above sentence correctly states that Maeda created (i.e. reified) the CycL constant <code>PlanetEarth</code>; it does <i>not</i> state the absurdity that he created the planet Earth.  In ordinary non-quoted contexts, of course, <code>PlanetEarth</code> denotes the planet and not the constant.\n<p>\nSee also quotedCollection and NoteAboutUseVersusMention.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, querySentence, "querySentence is an HL level predicate that allows for special handling of a sentence (especially nested sentences) as a top level query during the process of canonicalization.  querySentence is not-assertible.  It should not be used in any assertions.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, quantitySubsumes, "A specialization of both quantityIntersects and intangibleParts, this predicate relates a given numerically measurable ScalarInterval to those scalar intervals that it subsumes or that \"fall completely inside\" it.    <code>(quantitySubsumes SUPER SUB)</code> means that both (i) the maximum (see maxQuantValue) of <code>SUPER</code> is greaterThanOrEqualTo the maximum of <code>SUB</code> and (ii) the minimum (see minQuantValue) of <code>SUPER</code> is lessThanOrEqualTo the minimum of <code>SUB</code>.\n<p>\nFor example, (Meter 2 5) -- the Distance of between 2 and 5 meters inclusive -- subsumes both (Meter 3 4) and (Meter 3 5), but not (Meter 3 6).", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, quantityIntersects, "A binary predicate that relates numerically measurable ScalarIntervals (q.v.) that intersect or overlap.  <code>(quantityIntersects SCALAR1 SCALAR2)</code> means that  <code>SCALAR1</code> and <code>SCALAR2</code> intersect. More precisely: there is  some scalar interval (which might even be as small as an  instance of ScalarPointValue) that is subsumed by (see quantitySubsumes) both <code>SCALAR1</code> and <code>SCALAR2</code>.\n<p>\nFor example, (Meter 2 5) -- the Distance of between 2 and 5 meters inclusive -- intersects both (Meter 3 4) and (Meter 3 7), but does not intersect (Meter 6 7).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, prettyString, "(prettyString TERM STRING) means that STRING is the English word or expression (sequence of words) commonly used to refer to TERM.  The predicate prettyString is used by the code which generates CycL to English paraphrases, but its applicability is not restricted to this use.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, preservesGenlsInArg, "<code>(preservesGenlsInArg FUNCTION N)</code> means that the CollectionDenotingFunction <code>FUNCTION</code> has the following properties: \n<p>\n(1) argument place <code>N</code> of <code>FUNCTION</code> is constrained to instances of Collection, and <br>\n(2) if <code>COLLECTION1</code> and <code>COLLECTION2</code> can both serve as the <code>N</code>th argument of <code>FUNCTION</code>, and <code>COLLECTION2</code> is a specialization of <code>COLLECTION1</code> (so that <code>(genls COLLECTION2 COLLECTION1)</code> holds), then <code>(genls (FUNCTION ARG_1 ARG_2 ... ARG_N-1 COLLECTION2   ... ARG-M) (FUNCTION ARG_1 ARG_2 .. ARG_N-1 COLLECTION1 ... ARG-M))</code> also holds, where <code>ARG_1</code>, <code>ARG_2</code>, ..., <code>ARG_M</code> (where <code>M</code> is the arity of <code>FUNCTION</code>) are admitted arguments for <code>FUNCTION</code> (see admittedArgument).  \n<p>\nFor example, (preservesGenlsInArg GroupFn 1) holds because <code>(genls COL-2 COL-1)</code> implies <code>(genls (GroupFn COL-2) (GroupFn COL-1))</code>, for all collections <code>COL-1</code> and <code>COL-2</code> that satisfy the argument constraints for GroupFn.  \n<p>\nSimilarly, (preservesGenlsInArg SubcollectionOfByTypeFn 2) holds because <code>(genls COL-2 COL-1)</code> implies <code>(genls (SubcollectionOfByTypeFn FIXED-ARG COL-2) (SubcollectionOfByTypeFn FIXED-ARG COL-1))</code> for all collections <code>COL-1</code> and <code>COL-2</code>, and all arguments <code>FIXED-ARG</code>, that satisfy the appropriate argument constraints for SubcollectionOfByTypeFn.  See also the collection GenlsPreservingFunction.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, predicateConventionMt, "(predicateConventionMt PRED MT) means that the predicate extent of the predicate PRED, by convention, is asserted in MT.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, pragmaticRequirement, "A MetaKnowledgePredicate that is used to place a certain kind of pragmatic precondition on the use of a given asserted rule (see CycLRuleAssertion). (pragmaticRequirement SENTENCE RULE) means that SENTENCE expresses a necessary condition on RULE's being used in any proof carried out by the Cyc inference engine. The effect of asserting this is virtually the same as that of asserting (exceptWhen (unknownSentence SENTENCE) RULE): it blocks the use of RULE when SENTENCE is not currently \"known\" by the Cyc system to be true. SENTENCE should not contain disjuncts (or canonicalize into disjuncts). Upon assertion to the knowledge base, a pragmaticRequirement sentence is transformed by the canonicalizer into a rule involving pragmaticallyNormal (q.v.).", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, pragmaticallyNormal, "A MetaKnowledgePredicate that is used to express that certain pragmatic preconditions on a given rule are satisfied.  The predicate takes as arguments a list of CycL variables and an asserted rule (see CycLRuleAssertion) in which those variables occur \"free\".  At the EL (\"epistemological level\"), pragmaticallyNormal sentences are not asserted as GAFs, but appear instead as the antecedents of system-generated implies rules.  For a given sequence of values for the respective variables VAR1, ..., VARn,    (pragmaticallyNormal (TheList VAR1 ... VARn) RULE) means that any pragmatic preconditions placed on RULE's being used by the Cyc inference engine (see pragmaticRequirement) are satisfied with respect to those values.\n<p>\nLet's make this more precise and explicit.  A pragmatic precondition for a rule is written like so:\n<p>\n(pragmaticRequirement CONDITION RULE)\n<p>\nand gets canonicalized into a rule involving pragmaticallyNormal like so:\n<p>\n(implies\n(pragmaticallyNormal (TheList VAR1 ... VARn) RULE)\nCONDITION),\n<p>\nwhere VAR1, ..., VARn are all and only the variables that occur free in RULE and thus include all (and possibly only) the variables that occur free in CONDITION (i.e. as RULE and CONDITION explicitly appear in the KB browser, without consideration of their having \"implicit\" initial universal quantifiers).\n<p>\nThe above pragmaticallyNormal rule is used in inference as though it were a constraint rule.  If CONDITION does not hold for a given sequence of values <VAL1, ..., VALn> for its variables <VAR1, ..., VARn>, then those values are not \"pragmatically normal\" for RULE; and hence inference will not proceed using <VAL1, ..., VALn> with RULE.\n<p>\nThe effect of the foregoing is that any asserted rule RULE is implicitly treated by the Cyc inference engine as if it had the form\n<p>\n(implies\n(pragmaticallyNormal (TheList VAR1 ... VARn) RULE)\nRULE)\n<p>\n(with VAR1, ..., VARn as described above).\n<p>\nThis convention allows the logical content of a rule to be expressed independently of any pragmatic preconditions for its being used in inference.\n<p>\nAlso see abnormal, which is syntactically similar and has a related  interpretation that makes it roughly the complement of pragmaticallyNormal.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, pointQuantValue, "A NumericComparisonPredicate and a specialization of numericallyEquals, minQuantValue, and maxQuantValue (qq.v.).  pointQuantValue is essentially the relation numericallyEquals restricted to scalar point-values, with the additional proviso that its first argument must be given using a reifiable CycL term.  Thus a sentence of the form\n<p>\n\t<code>(pointQuantValue REIFIABLE-TERM OTHER-TERM)</code>\n<p>\nis true if and only if <code>REIFIABLE-TERM</code> is a CycLReifiableDenotationalTerm (q.v.), and <code>REIFIABLE-TERM</code> and <code>OTHER-TERM</code> denote the same ScalarPointValue (q.v.).\n<p>\nThis predicate is primarily used to state the equivalence of a reified scalar-denoting term (e.g. 'Zero', 'AvogadrosNumber', 'SpeedOfLight') with an appropriate unreifiable term.  For example, both of the following sentences hold:\n<p>\n<pre>\n  (pointQuantValue Zero 0)\n</pre>\n<p>\n<pre>\n  (pointQuantValue\n    SpeedOfLight\n    (PerFn (Mile 186000) (HoursDuration 1))'  .\n</pre>", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, performSubL, "<code>(performSubL SUBL)</code> states that the SubL expression <code>SUBL</code> has been successfully evaluated for side-effect.  performSubL is evaluated as late in an inference proof as possible.  See also trueSubL which evaluates usually as soon as possible in an inference.  For example, <code>(performSubL (ExpandSubLFn () (print \"Done\")))</code> will print out the string \"Done\" as a given proof path completes.  See ExpandSubLFn for a way to denote SubL within CycL.  See also EvaluateSubLFn.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, overlappingExternalConcept, "A predicate for mapping terms from an external data source to closely related concepts represented in Cyc.  <code>(overlappingExternalConcept THING SOURCE STRING)</code> means that in the external data source <code>SOURCE</code>, the meaning of <code>STRING</code> has significant semantic overlap with THING.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, or, "A LogicalConnective that represents disjunction in CycL. It is a VariableArityRelation, taking an arbitrary number of instances of CycLSentence-Assertible as arguments.  (or P Q ... Z) is true if and only if at least one of the sentences P, Q, ..., or Z is true.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, operatorFormulas, "A non-assertible MetaLanguagePredicate and specialization of termFormulas (q.v.) that relates CycL operators to CycL formulas in which they occur as the main operator.  <code>(operatorFormulas OPERATOR FORMULA)</code> means that <code>OPERATOR</code> occurs as the main operator (i.e. in the \"arg0\" position) of <code>FORMULA</code>.  \n<p>\nNote that both argument-places of operatorFormulas are implicitly \"quoted\" (see quotedArgument). So if the above operatorFormulas sentence is closed (see CycLClosedAtomicSentence), the two CycL expressions it mentions, <code>OPERATOR</code> and <code>FORMULA</code>, actually <i>appear in</i> that sentence -- as names of themselves.  Thus, the sentence \n\n<pre>  (operatorFormulas bordersOn (bordersOn France Germany))</pre> \n\nis true, due to the manifest fact that the <i>term</i> <code>bordersOn</code> occurs as the main operator in the sentence <code>(bordersOn France Germany)</code>. \n<p>\nNote that <code>FORMULA</code> in the above need not be true (if it's a sentence) or even semantically well-formed.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, openEntryFormatInArgs, "An instance of SpecificEntryFormatPredicate (q.v.).  <code>(openEntryFormatInArgs PRED N)</code> means that, for any particular way of fixing the other arguments to <code>PRED</code> besides the <code>N</code>th, there might be any number (including zero) of things such that, if taken as the <code>N</code>th argument, <code>PRED</code> holds of those arguments.  For example, openEntryFormatInArgs holds of biologicalMother with respect to its first argument-place, since a given female animal might have any number of offspring.  \n<p>\nUnlike the other reified instances of SpecificEntryFormatPredicate, openEntryFormatInArgs actually places no restriction at all on what <code>PRED</code> might or might not hold of with respect to the specified argument-place.  But one should not infer from this that openEntryFormatInArgs assertions are pointless; for they forestall duplication of effort by serving notice that the entry-format of a given argument-place has previously been considered and openEntryFormatInArgs was deemed appropriate.  \n<p>\nopenEntryFormatInArgs is the most commonly-encountered specific entry-format in the Cyc Knowledge Base.  Contrast with singleEntryFormatInArgs.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, opaqueArgument, "A binary MetaLanguagePredicate that can be used to state that a given argument-place of a given CycL relation-denoting expression is <i>denotationally opaque</i>.  \n<p>\n<code>(opaqueArgument REL N)</code> means that if in a closed compound expression built from the CycL expression for <code>REL</code> -- i.e. a ground atomic formula (or <i>gaf</i>) if <code>REL</code> is a predicate or a closed non-atomic term (or <i>nat</i>) if <code>REL</code> is a function -- the term appearing in <code>REL</code>'s <code>N</code>th argument-place is replaced with another term having the same denotatum (or truth-value, if the term is a sentence), there is no guarantee that the resulting gaf (or nat) will itself have the same truth-value (or denotatum) as the original.  \n<p>\nMost argument-places of most relation-denoting expressions do  allow such substitutions to be made freely, and are thus <i>denotationally transparent</i>.  For example, given that (equals Cicero Tully), the truth of <code>(residesInRegion Cicero CityOfRomeItaly)</code> entails the truth of  <code>(residesInRegion Tully CityOfRomeItaly)</code>.  This shows that residesInRegion's first argument-place is denotationally transparent. On the other hand, if Caesar were seeking Cicero and found him then (<code>objectFound-Definite CaesarsSearchForCicero Caesar Cicero)</code> would be true; but <code>(objectFound-Definite CaesarsSearchForCicero Caesar Tully)</code> might nevertheless be false, because Caesar might not know that Tully is Cicero and thus might not realize that in finding Cicero he had found Tully.  Having such a realization is a necessary condition for objectFound-Definite's holding, which shows that this relation's third argument-place is denotationally opaque.  \n<p>\nAccording to one well-known semantics for denotational opacity (viz. GottlobFrege's), a term appearing in an opaque context (in most cases) denotes (not its ordinary denotatum, but) what is ordinarily its <i>intensional meaning</i> or <i>sense</i> (or <i>Sinn</i>, in Frege's native German).  \n<p>\nquotedArgument (q.v.) is a specialization of opaqueArgument, and a term appearing in a <i>quoted</i> context is interpreted as denoting <i>itself</i> (rather than its usual denotatum).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, omitArgIsa, "<code>(omitArgIsa RELN N)</code> means that the relation <code>RELN</code> is not asserted to have a non-quoted argument constraint in its <code>N</code>th argument position, due to limitations of the Cyc system.  Since every relation relates things to other things, in principle every argument position for every relation should have an argIsa constraint; however, asserting some argIsa constraints will cause certain Cyc tests to fail.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, oldConstantName, "This bookkeeping predicate relates a CycL constant to a former \"name\" of that constant.  More accurately, (oldConstantName CONSTANT STRING) means that the underlying data structure currently associated with the CycL expression CONSTANT was formerly associated instead with the SubL string STRING.  If CONSTANT has undergone multiple \"renames\", STRING will \nnormally be its most recent former \"name\".  While oldConstantName sentences \ncan be asserted and edited by hand, they are asserted automatically when a Rename is done in the Knowledge Base.", 'BookkeepingMt', vStrMon).
assertedTinyKB(comment, numericallyEquals, "A NumericComparisonPredicate that is applicable to ScalarIntervals (<i>q.v.</i>) of all sorts, including quantitative intervals (see NumericInterval and Quantity) as well as point values (see ScalarPointValue).  <code>(numericallyEquals VALUE1 VALUE2)</code> means that <code>VALUE1</code> is equal to <code>VALUE2</code> with respect to some scale that they are both on.  More precisely, there is some TotallyOrderedScalarIntervalType <code>SCALE</code> that <code>VALUE1</code> and <code>VALUE2</code> are instances of and the minimum (see minQuantValue) of <code>VALUE1</code> is equal to the minimum of <code>VALUE2</code> and the maximum (see maxQuantValue) of <code>VALUE1</code> is equal to the maximum of <code>VALUE2</code>.\n<p>\nNote that numericallyEquals is <i>not</i> a specialization of equals (<i>q.v.</i>), as numeric values of different sorts can be \"numerically  equivalent\" without being considered identical (e.g. the Integer 1 and the RealNumber 1.0).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, nthSmallestElement, "(nthSmallestElement X N SET FUNCTION) means that X is an element of SET that has precisely N-1 other elements with a smaller value for FUNCTION. For example, (nthSmallestElement RhodeIsland-State 1 State-UnitedStates (FunctionToArg 2 areaOfRegion)). Yet there may be more nthSmallestElements. For example, (nthSmallestElement ?X 3 (TheSet 1 2 3 -3) AbsoluteValueFn) is true for both 3 and -3 - when the elements in the set are ordered according to their absolute value both 3 and -3 are 3rd smallest elements. ", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, nthLargestElement, "(nthLargestElement X N SET FUNCTION) means that X is an element of SET that has precisely N-1 other elements with a larger value for FUNCTION. For example, (nthLargestElement Alaska-State 1 State-UnitedStates (FunctionToArg 2 areaOfRegion)) means that Alaska is the largest state (no elements have a larger areaOfRegion). Yet there may be more nthLargestElements. For example, (nthLargestElement ?X 1 (TheSet 1 2 3 -3) AbsoluteValueFn) is true for both 3 and -3 ; when the elements in the set are ordered according to their absolute value both 3 and -3 are largest elements. See also nthSmallestElement.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, notAssertibleMt, "(notAssertibleMt MT) states that the Microtheory MT cannot be used as the microtheory of an assertion made to the KB; i.e., MT might be a microtheory used as scaffolding or one whose assertions are known to be complete.  See also notAssertibleCollection, and notAssertible.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, notAssertibleCollection, "A UnaryPredicate used for stating a certain restriction regarding the use of a given Collection in assertions to the Cyc Knowledge Base.  (notAssertibleCollection COL) means that no ground atomic formula (or \"GAF\"; see CycLClosedAtomicSentence) whose initial (or \"0th\" argument-place) term is `isa', and whose 2nd argument-place term denotes COL, can be asserted to the KB.  See also notAssertible, which constrains predicates in a similar fashion.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, notAssertible, "A MetaPredicate for stating a certain restriction regarding the use of a given Predicate in assertions to the Cyc Knowledge Base.  (notAssertible PRED) means that no ground atomic formula (or \"GAF\"; see CycLClosedAtomicSentence) whose initial (or \"0th\" argument-place) term denotes PRED can be asserted to the KB.  In many cases, PRED will be an EvaluatablePredicate whose extent is (re)computed as necessary and never cached in the KB.  \n<p>\nSee also notAssertibleCollection, which constrains collections \nin a similar fashion.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, not, "An instance of both LogicalConnective and UnaryRelation.  which takes an instance of #CycLSentence-Assertible as its argument. (not SENT) is true if and only if SENT is false (and false if and only if SENT is true).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, nonAbducibleWithValueInArg, "A ternary predicate that is an instance of AbductionConstraintConstant (q.v.) and that can apply to a predicate and a specified value for a specified argument-place. \n<p>\n(nonAbducibleWithValueInArg PRED VALUE N) means that, if asked a query of the form (PRED ... VALUE ...), where VALUE appears in the Nth argument-position and all of the other positions (>= 1) are filled with variables, the Inference Engine cannot use abduction to hypothesize that any non-abduced terms are legitimate bindings for those variables.\n<p>\nFor example, (nonAbducibleWithValueInArg hasMembers InternationalMonetaryFund 1) holds, so Cyc cannot use abduction to hypothesize that Sealand is a member of the IMF.  (Note that this does not mean that Cyc cannot prove that some abduced term is a member of the IMF.)", 'CoreCycLMt', vStrMon).
assertedTinyKB(comment, negationPreds, "A MetaPredicate for stating that two predicates are logical \"contraries\" of one another.  <code>(negationPreds PRED1 PRED2)</code> means that if <code>PRED1</code> holds among a given sequence of things, then <code>PRED2</code> does <i>not</i> hold among that sequence (and vice versa).  Thus it is equivalent to \n\n<pre>  (not (and (PRED1 . ARGS) (PRED2 . ARGS))) .</pre>  \n\nFor example, (negationPreds owns rents) holds, as one cannot both own and rent a given thing at the same time.   \n<p>\nNote that the argument types of <code>PRED1</code> and <code>PRED2</code> need not be the same, they merely must not be disjoint.  Note also that <code>PRED1</code> and <code>PRED2</code> are constrained (see e.g. interArgIsa) either to both having the same fixed-arity (see FixedArityRelation) or to both having variable-arity (see VariableArityRelations).     \n<p>\nSee also genlPreds and negationInverse.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, negationMt, "(negationMt MT-1 MT-2) means that the domain assumptions of the Microtheory MT-1 are inconsistent with those of the Microtheory MT-2, and no lifting can occur between MT-1 and MT-2 (i.e. assertions made in one microtheory should not be made visible to the other microtheory). For cases where two microtheories differ not in domain assumptions but purely in content (assertions made within those microtheories), see the less specialized contradictoryMt.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, negationInverse, "A MetaPredicate for stating that each of two binary predicates is a logical \"contrary\" of the other's inverse. <code>(negationInverse BINPRED1 BINPRED2)</code> means that if <code>BINPRED1</code> holds between a pair <code><THING1, THING2></code>, then <code>BINPRED2</code> does <i>not</i> hold between the inverse pair <code><THING2, THING1></code> (and vice versa).  In other words, <code>(negationInverse BINPRED1 BINPRED2)</code> is equivalent to <code>(not (and (BINPRED1 ARG1 ARG2) (BINPRED2 ARG2 ARG1)))</code>.\n<p>\nNote that any AsymmetricBinaryPredicate is related to itself by negationInverse.  For example, (negationInverse subordinates subordinates) holds, since if one person is a subordinate of another, the latter person cannot at the same time also be a subordinate of the former.  See also negationPreds and genlInverse.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, nearestIsa, "A TaxonomicSlotForAnyThing, and a specialization of isa (q.v.).  (nearestIsa OBJ COL) means that COL is a \"nearest\" collection of which OBJ is an instance.  That is, (isa OBJ COL) holds, OBJ is not identical to COL, and there is no reified Collection NEARER-COL distinct from OBJ and COL such that both (isa OBJ NEARER-COL) and (genls NEARER-COL COL) hold.  Note that nearestIsa is non-assertible (see notAssertible), since its extension at any given time depends upon (and so must be recomputed from) the current state of the isa and genls hierarchy in the Cyc Knowledge Base.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, nearestGenls, "A TaxonomicSlotForCollections and a KBDependentRelation (qq.v.) that is a specialization of genls. \n<code>(nearestGenls COL NEAR-COL)</code> means that <code>NEAR-COL</code> is a \"nearest\" generalization of <code>COL</code>.  More precisely:\n<p>\n(i) <code>(genls COL NEAR-COL)</code> holds, <br>\n(ii) <code>COL</code> is not identical to <code>NEAR-COL</code>, <br>\n(iii) both <code>COL</code> and <code>NEAR-COL</code> are reified, and <br>\n(iv) there is no reified Collection <code>NEARER-COL</code> distinct from <code>COL</code> and <code>NEAR-COL</code> such that both <code>(genls COL NEARER-COL)</code> and <code>(genls NEARER-COL NEAR-COL)</code> hold.\n<p>\nNote that nearestGenls is non-assertible (see notAssertible), since its extension at any given time depends upon (and so must be recomputed from) the current state of the genls hierarchy in the Cyc Knowledge Base.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, nearestGenlPreds, "A TaxonomicSlotForPredicates and a specialization of genlPreds (q.v.).  (nearestGenlPreds PRED NEAR-PRED) means that NEAR-PRED  is a \"nearest\" generalization of PRED.  That is, (genlPreds PRED NEAR-PRED)  holds, PRED is not identical to NEAR-PRED, and there is no reified Predicate  OTHER-PRED distinct from PRED and NEAR-PRED such that both  (genlPreds PRED OTHER-PRED) and (genlPreds OTHER-PRED NEAR-PRED) hold.  Note   that nearestGenlPreds is non-assertible (see notAssertible), since its  extension at any given time depends upon (and so must be recomputed from) the  current state of the genlPreds hierarchy in the Cyc Knowledge Base.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, nearestGenlMt, "A specialization of genlMt.  (nearestGenlMt MT NEAR-MT) means that NEAR-MT is a \"nearest\" microtheory of which MT is a specialization.  That is, (genlMt MT NEAR-MT) holds, MT is not identical to NEAR-MT, and there is no reified Microtheory NEARER-MT distinct from MT and NEAR-MT such that both (genlMt MT NEARER-MT) and (genlMt NEARER-MT NEAR-MT) hold.  Note that nearestGenlMt is non-assertible (see notAssertible), since its extension at any given time depends upon (and so must be recomputed from) the current state of the genlMt hierarchy in the Cyc Knowledge Base.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, nearestDifferentIsa, "(nearestDifferentIsa OBJ-1 OBJ-2 NEAR-DIFF) means that NEAR-DIFF is a \"nearest\" collection of which OBJ-1 is an instance, but OBJ-2 is not. That is, (isa OBJ-1 NEAR-DIFF) holds, but (isa OBJ-2 NEAR-DIFF) does not, and there is no reified Collection OTHER-COL distinct from NEAR-DIFF such that (isa OBJ-1 OTHER-COL) holds, (isa OBJ-2 OTHER-COL) does not hold, and (genls OTHER-COL NEAR-DIFF) holds. Note that this predicate is notAssertible, since it must always be recomputed from the current state of the isa and genls hierarchy. For comparison, see nearestDifferentGenls.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, nearestDifferentGenls, "(nearestDifferentGenls COL-1 COL-2 NEAR-DIFF) relates collections COL-1 and COL-2 to the nearest unsubsumed collections NEAR-DIFF of which COL-1 is a subset but COL-2 is not. This predicate is notAssertible, since it  must always be recomputed from the current state of the genls heirarchy.  For comparison, see nearestDifferentIsa.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, nearestCommonSpecs, "(nearestCommonSpecs COL-1 COL-2 NEAR-SPEC) relates collections COL-1 and COL-2 to the nearest unsubsumed collections NEAR-SPEC of which are subsets of both COL-1 and COL-2. This predicate is notAssertible, since it  must always be recomputed from the current state of the genls heirarchy.  For comparison, see also nearestCommonIsa and nearestCommonGenls.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, nearestCommonIsa, "(nearestCommonIsa THING1 THING2 NEAR-COL) means that NEAR-COL is a \"nearest\" collection of which both THING1 and THING2 are instances.  That is, both (isa THING1 NEAR-COL) and (isa THING2 NEAR-COL) hold, and there is no reified Collection NEARER-COL distinct from NEAR-COL such that (isa THING1 NEARER-COL), (isa THING2 NEARER-COL) and (genls NEARER-COL NEAR-COL) all hold.  Note that this predicate is non-assertible (see notAssertible), since its extension at any given time depends upon (and so must be computed from) the current state of the isa and genls hierarchies in the Cyc Knowledge Base. See also nearestCommonGenls and nearestCommonSpecs.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, nearestCommonGenls, "A TaxonomicPredicateForCollections that relates two collections to their nearest common generalizations represented in the Cyc Knowledge Base.  <code>(nearestCommonGenls COL1 COL2 NEAREST-GENL)</code> means that (i) <code>NEAREST-GENL</code> in known in the Cyc Knowledge Base to subsume (via genls) both <code>COL1</code> and <code>COL2</code> and (ii) there is no proper specialization of <code>NEAREST-GENL</code> that is known to subsume both <code>COL1</code> and <code>COL2</code>.\n<p>\nNote that nearestCommonGenls is <i>not</i> functional with respect to its third argument, as a pair of collections might have several nearest common generalizations, all orthogonal to each other.  Note also that this predicate is notAssertible, since it must always be recomputed from the current state of the represented genls heirarchy.  \n<p>\nSee also nearestCommonIsa and nearestCommonSpecs.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, nearestCommonGenlMt, "(nearestCommonGenlMt MT-1 MT-2 NEAR-MT) relates microtheories MT-1 and MT-2 to the nearest unsubsumed microtheories NEAR-MT of which both are spec microtheories.  This predicate is notAssertible, since it must always be recomputed from the current state of the genlMt hierarchy.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, natFunction, "(natFunction NAT FUNCTION) states that FUNCTION is the function used in the non-atomic term NAT.  For example,  (natFunction (JuvenileFn Dog) JuvenileFn).  More precisely, (termOfUnit NAT (FUNCTION ...)) implies  (natFunction NAT FUNCTION).", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, natArgumentsEqual, "(natArgumentsEqual NAT1 NAT2) means that the\narguments of NAT1 and NAT2 unify.  For example,  (natArgumentsEqual (FemaleFn Dog) (MaleFn Dog).  More precisely, (and (termOfUnit NAT1 (FUNCTION1 . ARGS)) (termOfUnit NAT2 (FUNCTION2 . ARGS))) implies  (natArgumentsEqual NAT1 NAT2).", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, natArgument, "(natArgument NAT N TERM) means that TERM is in the Nth argument position of the non-atomic term NAT.  For example,  (natArgument (JuvenileFn Dog) 1 Dog).  Note that (termOfUnit NAT (FUNCTION ... ARGN ...)) implies  (natArgument NAT N ARGN).", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, myCreator, "<code>(myCreator X Y)</code> means that <code>Y</code> is the constant representing the person who introduced the constant <code>X</code> into the Cyc vocabulary. In general, the editing interfaces to the Cyc KB only allow the KB to be modified when an instance of Cyclist is designated as the author of the changes.  See also sourceOfTerm-Person.", 'BookkeepingMt', vStrDef).
assertedTinyKB(comment, myCreationTime, "<code>(myCreationTime CONSTANT TIME)</code> means that the CycLConstant <code>CONSTANT</code> was created at <code>TIME</code>, an instance of CycUniversalDate.  The format of <code>TIME</code> is YYYYMMDD; that is, the first four digits give the year in which the constant was created, the next two digits give the month in which it was created, and the final two digits give the day of the month on which it was created. For example, 19910309 is March 9, 1991.", 'BookkeepingMt', vStrDef).
assertedTinyKB(comment, myCreationSecond, "(myCreationSecond CONSTANT SECOND) means that the CycLConstant CONSTANT was created at the CycUniversalSecond SECOND on the day CONSTANT was created (the related predicate myCreationTime (q.v.) relates a CycLConstant to the day it was created).  The format of SECOND is HHMMSS; that is, the first two digits give the hour of the day on which the constant was created, the second two digits give the minute of the hour at which the constant was created, and the last two digits give the second of the minute at which the constant was created.  For example, midnight is 000000 (or simply 0), noon is 120000, 3:42:59 pm is 154259, and 11:59:59 pm is 235959.", 'BookkeepingMt', vStrMon).
assertedTinyKB(comment, myCreationPurpose, "A BookkeepingPredicate and a DocumentationConstant that relates a CycL constant (or other reifiable denotational term) to the Cyc-based project for which the term was created.  (myCreationPurpose TERM PROJECT) means that TERM was created as part of work that was done for PROJECT, and implies that the creator of TERM (see myCreator) was working PROJECT at the time.", 'BookkeepingMt', vStrMon).
assertedTinyKB(comment, multiplicationUnits, "A ternary predicate that relates UnitOfMeasure (q.v.) functions.  <code>(multiplicationUnits UNIT1 UNIT2 PRODUNIT)</code> means that <code>PRODUNIT</code> is the unit-of-measure that always returns the product of the values returned by <code>UNIT1</code> and <code>UNIT2</code> for two respective arguments (or argument-sequences) when it is itself applied to the product of those arguments (or sequences).  That is, whenever <code>(UNIT1 . ARGS1) = VALUE1</code> and <code>(UNIT2 . ARGS2) = VALUE2</code>, then <code>(PRODUNIT (TimesFn ARGS1 ARGS2)) = (TimesFn VALUE1 VALUE2)</code>.\n<p>\nFor example, (multiplicationUnits Mile Mile SquareMile) holds, and thus (TimesFn (Mile 2) (Mile 3)) is equal to (SquareMile 6).\n<p>\nThe predicate multiplicationUnits corresponds to (see functionCorrespondingPredicate) both of the functions UnitProductFn and PerFn (qq.v.).  Thus,\n<p>\n\t<code>(multiplicationUnits UNIT1 UNIT2 PRODUNIT)</code>\n<p>\nis equivalent to\n<p>\n\t<code>(equals PRODUNIT (UnitProductFn UNIT1 UNIT2))</code>\n<p>\nis equivalent to\n<p>\n\t<code>(equals UNIT1 (PerFn PRODUNIT UNIT2))</code> .", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, mtVisible, "A unary EvaluatablePredicate that applies to a Microtheory.  <code>(mtVisible MT)</code> means that the contents of <code>MT</code> are visible in the current query context.  \n\nIn general, \n<pre>\n(genlMt MT1 MT2) \n</pre>\nentails \n<pre>\n(ist MT1 (mtVisible MT2),\n</pre>\nbut the converse does not hold.  In particular, it fails when <code>MT1</code> is a ProblemSolvingCntxt.  For example, \n<pre>\n(ist EverythingPSC (mtVisible HumanSocialLifeMt))\n</pre>\nholds (in BaseKB), but\n<pre>\n(genlMt EverythingPSC HumanSocialLifeMt)\n</pre>\ndoes not hold (in BaseKB).", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, minQuantValue, "A specialization of scalarBounds (q.v.) that relates a given ScalarInterval (q.v.) to the minimum ScalarPointValue (q.v.) it subsumes (see quantitySubsumes). <code>(minQuantValue SCALAR POINT)</code> means that the lower limit of <code>SCALAR</code> is <code>POINT</code>.\n<p>\nFor example, if all mailroom employees earned from five to eight dollars per hour, <code>(minQuantValue \"MailroomPayRange\" (DollarsPerHour 5))</code> would hold.  Other examples:\n<pre>\n  (minQuantValue (Mile 15 20) (Mile 15))\n\n  (minQuantValue (Unity 6 12) 6).\n</pre>\n<p>\nSee also maxQuantValue and pointQuantValue.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, minimizeExtent, "An instance of both MetaKnowledgePredicate and MetaPredicate (qq.v.) that is used to state that the Cyc system will \"assume\" that a (sequence of) thing(s) is not in the extension (see relationExtension) of a given predicate if the CycInferenceEngine is unable to prove that it is.  \n<p>\n<code>(minimizeExtent PRED)</code> means that, for any sequence of things <code><THING1, ..., THINGn></code> such that <code>(PRED THING1 ... THINGn)</code> holds, the fact that this holds is either expressed by some GAF (i.e. a \"ground atomic formula\"; see CycLClosedAtomicSentence) that is asserted in the Cyc Knowledge Base or is deducible via the inference engine from what is in the KB.  \n<p>\nThe practical import of a minimizeExtent assertion is that it reflects an underlying assumption that if the inference engine cannot prove some given sentence of the form <code>(PRED ARG1 ... ARGN)</code>, then that fact constitutes an argument for its negation <code>(not (PRED ARG1 ... ARGN))</code>; and, if the \"negation by failure\" inference parameter is turned on, the inference engine will actually conclude that this negation is true.  Note that a minimizeExtent assertion is weaker than the corresponding completeExtentEnumerable (q.v.) assertion would be, in that the latter does not require that the inference engine attempt to deduce <code>(PRED ARG1 ... ARGn)</code> before concluding that it is not true.  See also minimizeExtentForArg and the shared NoteOnClosedWorldAssumption.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, minimize, "minimize allows Cyc to assume that a statement is not\ntrue unless it is known to be true.  Specifically, if for some\nbindings of the variables that appear in the minimized formula the\nformula with the bindings substituted in cannot be proved, then assume\nthe negation of the formula with the bindings substituted in.  From an\nexample in the KB: (minimize (disjointWith ?Collection\n?Collection)) and binding ?Collection to Poodle means if we cannot\nprove (disjointWith Poodle Poodle) assume (not (disjointWith\nPoodle Poodle, i.e. assume every Collection is nonempty unless\nwe know otherwise.  In the case where we bind ?Collection to some\nother variable ?Y and substituting in means if we cannot show\n(disjointWith ?Y ?Y) then assume the negation, (not (forAll ?Y\n(disjointWith ?Y ?Y))) which is equivalent to (thereExists ?Y\n(not (disjointWith ?Y ?Y))). This is one of the predicates that\nhas been created to allow Cyc to do negation by failure.  Other\nrelated predicates are minimizeExtent and minimizeExtentForArg. ", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, microtheoryDesignationArgnum, "Used to specify which argument of a given MicrotheoryDesignatingRelation\ndesignates the microtheory in which to interpret some formula.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, meetsPragmaticRequirement, "A MetaKnowledgePredicate that is used to express that a pragmatic precondition on a given rule is satisfied.  The predicate takes as arguments a list of CycL variables and an asserted rule (see CycLRuleAssertion) in which those variables occur \"free\".  At the EL (\"epistemological level\"), meetsPragmaticRequirement sentences are not asserted as GAFs, but appear instead as the consequents of system-generated implies rules.  For a given sequence of values for the respective variables <code>VAR1</code>, ..., <code>VARn</code>, <code>(meetsPragmaticRequirement (TheList VAR1 ... VARn) RULE)</code> means that some pragmatic precondition placed on <code>RULE</code>'s being used by the Cyc inference engine (see pragmaticRequirement) is satisfied with respect to those values.\n<p>\nLet's make this more precise and explicit.  A pragmatic precondition for a rule is written like so:\n<p>\n<pre>\n   (pragmaticRequirement CONDITION RULE)\n</pre>\n<p>\nand gets canonicalized into a rule involving meetsPragmaticRequirement like so:\n<p>\n<pre>\n   (implies\n     CONDITION\n    (meetsPragmaticRequirement (TheList VAR1 ... VARn) RULE)),\n</pre>\n<p>\nwhere <code>VAR1, ..., VARn</code> are all and only the variables that occur free in <code>RULE</code> and thus include all (and possibly only) the variables that occur free in <code>CONDITION</code> (i.e. as <code>RULE</code> and <code>CONDITION</code> explicitly appear in the KB browser, without consideration of their having \"implicit\" initial universal quantifiers).\n<p>\nThe above meetsPragmaticRequirement rule is used in inference similarly to an abnormal rule.  If <code>CONDITION</code> is not known to hold for a given sequence of values <code><VAL1, ..., VALn></code> for its variables <code><VAR1, ..., VARn></code>, then those values do not \"meet the pragmatic requirement\" for <code>RULE</code>; and hence inference will not proceed using <code><VAL1, ..., VALn></code> with <code>RULE</code>.\n<p>\nThe effect of the foregoing is that any asserted rule <code>RULE</code> is implicitly treated by the Cyc inference engine as if it had the form\n<p>\n<pre>\n (implies\n  (meetsPragmaticRequirement (TheList VAR1 ... VARn) RULE)\n   RULE)\n</pre>\n<p>\n(with <code>VAR1, ..., VARn</code> as described above).\n<p>\nThis convention allows the logical content of a rule to be expressed independently of any pragmatic preconditions for its being used in inference.  If a rule has multiple pragmatic requirements, it must meet all of them to be used in inference.\n<p>\nAlso see abnormal, which is syntactically similar and has a related  interpretation.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, means, "A MetaLanguagePredicate (q.v.) that relates SubLSExpressions to their meanings: the things in the intended model of the CycL language that those terms denote, refer to, stand for, or express. <code>(means TERM THING)</code> means that <code>TERM</code> denotes, refers to, stands for, or expresses <code>THING</code>. <code>TERM</code> will often be explicitly quoted, by being wrapped in the syncategorematic quotation symbol 'Quote'. For example, the true sentence '(means (Quote Plato) Plato)' means that the CycL term 'Plato' means (denotes) the person Plato. (Thus means's first argument-place is <i>not</i> \"implicitly quoted\"; cf. quotedArgument).\n<p>\nBut note that the first argument of means might not be quoted at all. Suppose (e.g.) that the term 'Plato' were the CycL constant most beloved of Cyclists, and that a new constant 'CyclistsFavoriteConstant' were reified and defined so as to reflect this fact. Then 'CyclistsFavoriteConstant' would denote the CycL constant 'Plato', which in turn denotes the man Plato; and so the sentence '(means CyclistsFavoriteConstant Plato)' -- which involves no quotation -- would be true.\n<p>\nNote finally that the sentence '(means Plato Plato)' is of course <i>not</i> true, as it means that the man Plato is a CycL term that denotes the man Plato, which is a patent falsehood since no man is a CycL term and no man denotes anything.\n<p>\nSee also expresses, denotes, hasDenotatum, quotedIsa, EscapeQuote, and the shared NoteAboutQuotingInCycL.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, maxQuantValue, "A specialization of scalarBounds (q.v.) that relates a given ScalarInterval (q.v.) to the maximum ScalarPointValue (q.v.) it subsumes (see quantitySubsumes). <code>(maxQuantValue SCALAR POINT)</code> means that the upper limit of <code>SCALAR</code> is <code>POINT</code>.\n<p>\nFor example, if all mailroom employees earned from five to eight dollars per hour, <code>(maxQuantValue \"MailroomPayRange\" (DollarsPerHour 8))</code> would hold.  Other examples:\n<pre>\n  (maxQuantValue (Mile 15 20) (Mile 20))\n\n  (maxQuantValue (Unity 6 12) 12).\n</pre>\n<p>\nSee also minQuantValue and pointQuantValue.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, maxQuantValue, "(maxQuantValue SCALAR POINT) means that the upper limit of the quantity SCALAR is POINT, an instance of ScalarPointValue.  SCALAR is an instance of ScalarInterval.  For example, the maxQuantValue for the pay of mail room employees might be (DollarsPerHour 6.5); e.g., (maxQuantValue `MailPay' (DollarsPerHour 6.5)).  Another example: (maxQuantValue (Unity 5 10) 10).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, knownSentence, "A KBDependentRelation (q.v.) and  specialization of trueSentence (q.v.) that is used to state  that a given sentence is \"known\" to be true to the Cyc system. More precisely, (knownSentence SENT) means that SENT is provable  by the Cyc inference engine from sentences currently in the Knowledge  Base.  knownSentence is a non-assertible predicate (see  notAssertible).  Note that this predicate is not to be confused  with assertedSentence, which is used to state that a given  sentence is explicitly asserted in the KB.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, knownAntecedentRule, "A MetaKnowledgePredicate that is used to state a strong pragmatic directive to the CycInferenceEngine.  Asserting (knownAntecedentRule RULE) tells the inference engine to automatically generate a removal module to implement RULE; i.e. to solve queries unifying with the consequent of RULE by attempting to prove the substituted antecedent of RULE.  When this removal module is used during inference, it attempts to prove the substituted antecedent via removal only (see knownSentence).  It does not preclude other uses of RULE in inference.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, ist, "This predicate relates a microtheory to any sentence that is true in it.  (ist MT SENT) means that the CycL sentence SENT (or, if you prefer, the proposition SENT expresses) is true in the microtheory MT.  Note that SENT need not actually be _asserted_ in MT; MT might for example \"inherit\" SENT from a more general microtheory.  (Cf. ist-Asserted.)", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, isa, "A TaxonomicSlot (q.v.) that relates things of any  kind to collections (see Collection) of which they are instances.   <code>(isa THING COL)</code> means that <code>THING</code> is an instance of the collection <code>COL</code>.   isa is by far the most commonly-occurring predicate in the Cyc Knowledge  Base, and is one of the relations most fundamental to the Cyc ontology. An important logical feature of isa is that it \"transfers through\"  genls (q.v.): <code>(isa THING COL)</code> and <code>(genls COL SUPERCOL)</code> jointly  imply <code>(isa THING SUPERCOL)</code>.  This logical feature is expressed in a  rule that -- along with various other rules that also sanction the  derivation of isa sentences -- has been asserted to the Knowledge Base.   As a result, only a small fraction of the isa based ground atomic  formulas (or \"GAF\"s; see CycLClosedAtomicSentence) the Cyc system  \"knows\" to be true have been manually asserted; the vast majority  have been derived, or are derivable, automatically by the Cyc inference  engine via the use of such rules.  See also elementOf.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, irrelevantTerm, "A CycInferenceHeuristicRelevancePredicate. (irrelevantTerm TERM) states that the CycLClosedDenotationalTerm TERM should be heuristically considered less relevant to inferences made in the current Microtheory.  See also other instances of CycInferenceHeuristicRelevancePredicate.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, irrelevantPredAssertion, "(irrelevantPredAssertion PREDICATE ASSERTION) states that the given ASSERTION should be heuristically considered very unlikely to be relevant to inferences concluding uses of the given PREDICATE in the current mt.  See also other instances of CycInferenceHeuristicRelevancePredicate.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, irrelevantMt, "A CycInferenceHeuristicRelevancePredicate. (irrelevantMt MT) means that all assertions made in the Microtheory MT should be heuristically considered very unlikely to be relevant to inferences done in the Microtheory MT-1 in which (irrelevantMt MT) is asserted (where MT-1 and MT need not be the same).  As a consequence, note that when (irrelevantMt MT) is asserted in a Microtheory MT-1, each of the assertions in MT will be an irrelevantAssertion (q.v.) for inferences done in MT-1.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, irrelevantAssertion, "A CycInferenceHeuristicRelevancePredicate. (irrelevantAssertion ASSERTION) states that the CycLAssertion ASSERTION should be heuristically considered very unlikely to be relevant to inferences in the current Microtheory.  See also other instances of CycInferenceHeuristicRelevancePredicate.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, interArgResultIsaReln, "A quintary MetaRelation predicate for stating that a certain kind of complex, partly isa based relationship holds between a given argument to a given function and the corresponding value that is returned. (interArgResultIsaReln FUNC N RELATION RELATION-NAT-TERM-ARG RELATION-COLLECTION-ARG) means that, if there is a sentence asserted in the KB relating NAT-TERM and COLLECTION via RELATION and NAT-TERM is the RELATION-NAT-TERM-ARGth argument in the sentence and COLLECTION is the RELATION-COLLECTION-ARGth argument, then when NAT-TERM appears as the Nth argument to FUNC, then (regardless of what the other arguments to FUNC might be) the value (if any) of that function for those arguments is an instance of COLLECTION.  That is: if (RELATION ... NAT_TERM ... COLLECTION ...) or (RELATION ... COLLECTION ... NAT_TERM  ...) is an asserted sentence, and (FUNC ARG(1) ... ARG(N-1) NAT_TERM ...) = VALUE, then VALUE is an instance of COLLECTION. Obviously, COLLECTION must be a collection; so RELATION's RELATION-COLLECTION-ARGth argument-place is likely to be isa constrained (see argIsa) to Collection or some specialization thereof.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, interArgResultIsa, "A quaternary MetaRelation predicate for stating that a certain kind of complex, partly isa -based relationship holds between a given argument to a given function and the corresponding value that is returned.\n<p>\n<code>(interArgResultIsa FUNC N INDEP-ARG-COL DEP-ARG-COL)</code> means that, when an instance of <code>INDEP-ARG-COL</code> appears as the <code>N</code>th argument to <code>FUNC</code>, then (regardless of what the other arguments to <code>FUNC</code> might be) the value (if any) of that function for those arguments is an instance of <code>DEP-ARG-COL</code>.  That is: if <code>INST</code> is an instance of <code>INDEP-ARG-COL</code> and <code>(FUNC ARG1 ... ARGN-1 INST ...) = VALUE</code>, then <code>VALUE</code> is an instance of <code>DEP-ARG-COL</code>.\n<p>\nFor example, <code>(interArgResultIsa RoundUpFn 1 RealNumber Integer)</code> means that the rounding-up function RoundUpFn returns an integer whenever it is given a real number as its first (and only) argument.\n<p>\nNote that, unlike (e.g.) the InterArgTypePredicates, interArgResultIsa <i>cannot</i> be used to put semantic well-formedness constraints on functions.  See also the similar but less flexible ternary interArg1ResultIsa et al.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, interArgResultGenlReln, "A quintary MetaRelation predicate for stating that a certain  kind of complex, partly genls based relationship holds between a given  argument to a given function and the corresponding value that is returned.  (interArgResultGenlReln FUNC N RELATION RELATION-NAT-TERM-ARG RELATION-COLLECTION-ARG) means that, if there is a sentence asserted in the KB relating NAT-TERM and COLLECTION via RELATION and NAT-TERM is the RELATION-NAT-TERM-ARGth argument in the sentence and COLLECTION is the RELATION-COLLECTION-ARGth argument, then when NAT-TERM appears as the Nth argument to FUNC, then (regardless of what the other arguments to FUNC might be) the value (if any) of that function for those arguments is a subcollection of COLLECTION. That is: if (RELATION ... NAT_TERM ... COLLECTION ...) or  (RELATION ... COLLECTION ... NAT_TERM  ...) is an asserted sentence, and (FUNC ARG(1) ... ARG(N-1) NAT_TERM ...) = VALUE, then VALUE is a subcollection of COLLECTION. Obviously, COLLECTION must be a collection; so RELATION's RELATION-COLLECTION-ARGth argument-place is likely to be isa  constrained (see argIsa) to Collection or some specialization thereof.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, interArgResultGenl, "A quaternary MetaRelation predicate for stating that a certain kind of complex, partly genls based relationship holds between a given argument to a given function and the corresponding value that is returned. (interArgResultGenls FUNC N INDEPENDENT-ARG-COL DEPENDENT-ARG-COL) means that, when a subcollection of INDEPENDENT-ARG-COL appears as the Nth argument to FUNC, then (regardless of what the other arguments to FUNC might be) the value (if any) of that function for those arguments is a subcollection of DEPENDENT-ARG-COL.  That is: if INST is a subcollection of INDEPENDENT-ARG-COL and (FUNC ARG(1) ... ARG(N-1) INST ...) = VALUE, then VALUE is a subcollection of DEPENDENT-ARG-COL.  Note that, unlike (e.g.) the InterArgTypePredicates, interArgResultGenl _cannot_ be used to put semantic well-formedness constraints on functions.  See also the similar but less flexible ternary interArg1ResultGenls et al.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, interArgIsa, "A quintary instance of InterArgIsaPredicate (q.v.).   <code>(interArgIsa RELN INDEP-ARGNUM INDEP-COL DEP-ARGNUM DEP-COL)</code> means that,  when an instance of <code>INDEP-COL</code> appears as the <code>INDEP-ARGNUM</code>th argument to <code>RELN</code>,  a necessary condition for semantic well-formedness is that the <code>DEP-ARGNUM</code>th argument must be an instance of <code>DEP-COL</code>.  That is, if <code>INDEP-INST</code> is an instance of <code>INDEP-COL</code>, then <code>(RELN</code> ... <code>INDEP-INST</code> ...), where <code>INDEP-INST</code> is the <code>INDEP-ARGNUM</code>th (or \"independent\") argument to <code>RELN</code>, is semantically well-formed only if the <code>DEP-ARGNUM</code>th (or \"dependent\") argument (which is some item in the sequence <... <code>INDEP-INST</code> ...> other than the <code>INDEP-ARGNUM</code>th) is an instance of <code>DEP-COL</code>.\n<p>\nFor example, (interArgIsa performedBy 1 PurposefulAction 2 IntelligentAgent) means that, if <code>ACT</code> is a PurposefulAction, then <code>(performedBy ACT AGENT)</code> is semantically well-formed only if <code>AGENT</code> is an IntelligentAgent.\n<p>\nFor an explanation of semantic well-formedness, see CycLExpression-Assertible and its direct specializations.  For a more general explanation of independent and dependent arguments in the present sense, see InterArgConstraintPredicate.  For similar to but less flexible predicates than interArgIsa, which have already-fixed positions for the independent and dependent arguments, see the ternary interArgIsa1-2 et al.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, interArgDifferent, "A MetaRelation used for stating a certain kind of necessary condition for being an element of the domain of a given Relation (see relationDomain).  Thus (to put it in terms of the semantics of CycL expressions) interArgDifferent can be used for stating a certain kind of truth- or denotation-condition for a given relation-denoting expression.  (interArgDifferent RELN N M) means that RELN (if it is a Predicate or other TruthFunction) only holds among or (if it is a Function-Denotational) only has a value for sequences of arguments whose Nth and Mth members are distinct (see different).  That is (assuming without loss of generality that N < M): if RELN is a predicate or other \"truth-function\" then (RELN ... ARGN ... ARGM ...) holds only if ARGN and ARGM are distinct, and if RELN is a function then it is defined for (i.e. associates a value with) a sequence <THING-1, ..., THING-N, ..., THING-M, ...> only if THING-N and THING-M are distinct.  For example, (interArgDifferent opponentsInConflict 1 2) means that no-one is his or her own opponent in a conflict.\n<p>\nNote that this predicate trivially holds for any relation with respect those argument-places it has that are subject to mutually disjoint (see disjointWith and cf. cosatisfiableInArgs) argument-type constraints (see ArgTypePredicate).", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, integerBetween, "A ternary IntangibleObjectRelatingPredicate that holds among Integers only.  <code>(integerBetween LOW MED HIGH)</code> means that <code>HIGH</code> is greaterThanOrEqualTo <code>MED</code>, and <code>MED</code> is greaterThanOrEqualTo <code>LOW</code>.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, instanceElementType, "A binary FirstOrderCollectionPredicate that relates types of sets to the types of elements they have in common.  More precisely, <code>(instanceElementType SETTYPE COLLECTION)</code> means that every elementOf every instance of (see isa) <code>SETTYPE</code> is an instance of <code>COLLECTION</code>.  For example, both of these hold:\n<pre>\n  (instanceElementType PointSet Point)\n\n  (instanceElementType Set-Mathematical Thing) . \n</pre>\nSee the corresponding function SetOfTypeFn, which takes a given collection to the collection of <i>all</i> sets whose elements are instances of the former.  And see typeGenls for a similar predicate that relates collections of <i>collections</i> (rather than collections of sets) to their common element types.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, indexicalReferent, "(indexicalReferent INDCONCEPT THING) means that in the context of the assertion, the IndexicalConcept INDCONCEPT has the referent THING.  This is a StrictlyFunctionalSlot, in keeping with the idea that the predicate will return one and only one 'value' for the second argument place at any given point in context space.  However, be advised that the arg2 will change from context to context.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, independentArg, "A MetaPredicate that is used to state, of a given\n(ternary) InterArgConstraintPredicate, that it is (always) used to constrain a relation in such a way that a certain specified argument-place of the relation is for the \"independent\" argument (with respect to that constraint).  (independentArg INT-ARG-PRED N) means that any sentence of the form (INT-ARG-PRED RELN ...) constrains RELN in some way that treats RELN's Nth argument as independent.  For example, (independentArg interArgIsa3-4 3) holds.  See the comment on InterArgConstraintPredicate for an explanation of what it means to be an \"independent\" argument in this sense.  Note that independentArg is contrained to apply only to _ternary_ inter-argument constraint predicates, as only they have already-fixed positions for the corresponding independent and dependent arguments; thus it cannot (on pain of semantic malformedness) be applied to the quintary inter-argument constraint predicates, such as interArgIsa.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, implies, "A binary LogicalConnective (q.v.) that corresponds to the material implication operator of propositional calculus.  The implies relation takes two CycLSentence-Assertibles as its arguments; and the syntactic result of applying the term 'implies' to two sentences is itself a sentence, called a \"conditional\" or \"implication\".  A sentence of the form (implies ANTECEDENT CONSEQUENT) is true if and only if ANTECEDENT is false or CONSEQUENT is true (or both).  Equivalently: it is not the case that ANTECEDENT is true and CONSEQUENT is false.  For example,\n<p>\n<pre>\n  (implies\n    (knows Muffet Patches-Cat)\n    (likesAsFriend Muffet Patches-Cat))\n</pre>\n<p>\nmeans that if Muffet knows Patches then she likes him.\n<p>\nCf. the predicate sentenceImplies, which is not a logical connective, and is primarily used in rules involving quantification over CycL sentences.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, hypotheticalTerm, "(hypotheticalTerm TERM) states that TERM is a term that was hypothesized.  The most common reason a term is hypothesized is to pose a hypothetical query to Cyc.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, holdsIn, "An instance of both TemporalPredicate and ModalPredicate that is used to state (in a somewhat indirect way) that a given sentence is true during a certain time period.  <code>(holdsIn TEMP SENT)</code> means that <code>SENT</code> is true at every moment in the temporalExtent (q.v.) of the TemporalThing <code>TEMP</code>.\n<p>\nFor example, the sentence <code>(holdsIn (YearFn 2003) (hasPets Curtis Patches-Cat))</code> means that throughout all of the year 2003 Curtis had Patches as a pet.  This entails (e.g.) that Curtis had Patches on 5 July 2003:\n<pre>\n  (holdsIn\n    (DayFn 5 (MonthFn July (YearFn 2003)))\n    (hasPets Curtis Patches-Cat))</code> .\n</pre>\n<p>\nSimilarly, <code>(holdsIn Patches-Cat (hasPets Curtis Patches-Cat))</code> means that Curtis has Patches as a pet for Patches's entire life.\n<p>\nSee also the more general predicate holdsSometimeDuring.\n<p>\nNote that a sentence of the form <code>(holdsIn TEMP (PRED ... ARGi ...))</code>, where <code>ARGi</code> is a TemporalThing, does <i>not</i> in general imply that <code>ARGi</code> temporally subsumes or even temporally intersects <code>TEMP</code>.  For example, <code>(holdsIn (YearFn 2003) (awareOf Curtis GeorgeWashington))</code> obviously doesn't imply that GeorgeWashington was alive in 2003.  <code>ARGi</code>'s temporally subsuming <code>TEMP</code> <i>does</i> follow, however, if <code>PRED</code> is a CotemporalPredicate that is contemporaryInArg (q.v.) in its <code>i</code>th argument-place (as hasPets is, in both argument-places).\n<p>\nNote also that there are two other ways to temporally-qualify sentences in CycL, which do not involve using holdsIn (or holdsSometimeDuring).  Both involve temporally qualifying the Microtheory in which the (otherwise unqualified) sentence is asserted, and either can be used to state something roughly equivalent to a holdsIn sentence.  Consider the first Curtis/Patches example above.  First, one could assert <code>(hasPets Curtis Patches-Cat)</code> in some microtheory <code>MT</code> such that <code>(holdsInTime-Always MT (YearFn 2003))</code>.  Second, one could assert <code>(hasPets Curtis Patches-Cat)</code> in a microtheory <code>MT'</code> such that both <code>(mtTimeIndex MT' (YearFn 2003))</code> and <code>(mtTimeParameter MT' TimePoint)</code> hold.  This later method, being the most developed and well-supported, is generally preferred over the others.\n<p>\nNote finally that it would be incorrect to assert a sentence like <code>(hasPets Curtis Patches-Cat)</code> in a non-temporally-qualified microtheory like the BaseKB, since Curtis didn't have Patches when (e.g.) he was a young boy, let alone in 3500 BCE.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, hlPrototypicalInstance, "(hlPrototypicalInstance TERM COL) means that TERM is a prototypical instance of COL at the HL.  It is assumed that TERM has only two asserted assertions on it: one hlPrototypicalInstance assertion and one assertion of the form (isa TERM COL).  The CycInferenceEngine makes use of the prototypical instance during assertions to cache the work done by forward inference.  It is used when asserting the first isa assertion on a term with no other assertions about it yet.  <b>Do not assert comments, cyclistNotes or any other assertions on prototypical instances.</b>  They are intentionally minimal.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, highlyRelevantTerm, "A CycInferenceHeuristicRelevancePredicate. (highlyRelevantTerm TERM) states that the CycLClosedDenotationalTerm TERM should be heuristically considered highly relevant to inferences made in the current Microtheory.  See also other instances of CycInferenceHeuristicRelevancePredicate.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, highlyRelevantPredAssertion, "(highlyRelevantPredAssertion PREDICATE ASSERTION) states that the given ASSERTION should be heuristically considered highly relevant to inferences concluding uses of the given PREDICATE in the current mt.  See also other instances CycInferenceHeuristicRelevancePredicate.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, highlyRelevantMt, "A CycInferenceHeuristicRelevancePredicate. (highlyRelevantMt MT) means that all assertions in the Microtheory MT should be heuristically considered highly relevant to inferences done in the Microtheory MT-1 in which (highlyRelevantMt MT) is asserted (where MT-1 and MT need not be the same).  As a consequence, note that when (highlyRelevantMt MT) is asserted in a Microtheory MT-1, each of the assertions in MT will be a highlyRelevantAssertion (q.v.) for inferences done in MT-1.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, highlyRelevantAssertion, "A CycInferenceHeuristicRelevancePredicate. <code>(highlyRelevantAssertion ASSERTION)</code> states that the CycLAssertion <code>ASSERTION</code> should be heuristically considered highly relevant to inferences that are performed in a context in which <code>(highlyRelevantAssertion ASSERTION)</code> is visible.  See also other instances of CycInferenceHeuristicRelevancePredicate.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, greaterThanOrEqualTo, "A NumericComparisonPredicate (q.v.) that is a generalization of the mathematical greater-than-or equal-to <code>(>=)</code> relation to ScalarIntervals (q.v.) of all sorts, including quantitative intervals (see NumericInterval and Quantity) as well as point values (see ScalarPointValue).  <code>(greaterThanOrEqualTo VALUE1 VALUE2)</code> means that <code>VALUE1</code> is greater than or equal to <code>VALUE2</code> with respect to some scale that they are both on.  More precisely, there is some TotallyOrderedScalarIntervalType <code>SCALE</code> that both <code>VALUE1</code> and <code>VALUE2</code> are instances of and either (i) <code>SCALE</code> is a specialization of NumericInterval (e.g. RealNumber) and the minimum (see minQuantValue) of <code>VALUE1</code> is greater than or equal to the maximum (see maxQuantValue) of <code>VALUE2</code>, (ii) <code>(followingValueOnScale VALUE2 VALUE1 SCALE)</code> holds, or (iii) <code>(equals VALUE1 VALUE2)</code> holds.\n<p>\nSee also greaterThan and lessThanOrEqualTo.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, greaterThan, "A NumericComparisonPredicate that is a generalization of the  mathematical greater-than ( > ) relation to ScalarIntervals (q.v.) of all sorts, including quantitative intervals (see NumericInterval and MeasurableQuantity) as well as point values (see ScalarPointValue).  <code>(greaterThan VALUE1 VALUE2)</code> means that  <code>VALUE1</code> is greater than <code>VALUE2</code> with respect to some scale that they  are both on.  More precisely, there is some TotallyOrderedScalarIntervalType SCALE that both <code>VALUE1</code> and <code>VALUE2</code> are instances of and either (i) <code>SCALE</code> is a specialization of  NumericInterval (e.g. RealNumber) and the minimum (see minQuantValue) of <code>VALUE1</code> is greater than the maximum (see maxQuantValue) of <code>VALUE2</code> or (ii) <code>(followingValueOnScale VALUE2 VALUE1 SCALE)</code> holds.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, genMassNoun, "(genMassNoun TERM) means that the CycLReifiableDenotationalTerm TERM should be treated as a mass noun when CycL formulae containing TERM are paraphrased into English.  See also the related predicate prettyName.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, genls, "A instance of TaxonomicSlotForCollections (q.v.) and  a specialization of generalizations.  genls relates a given collection  (see Collection) to those collections that subsume it.  More precisely, <code>(genls SUBCOL SUPERCOL)</code> means that <code>SUPERCOL</code> is a supercollection of <code>SUBCOL</code>:  anything that is an instance of (see isa) <code>SUBCOL</code> is also an instance of <code>SUPERCOL</code>.  For example, <code>(genls Dog Mammal)</code> holds.  genls is one of the most commonly-occurring predicates in the Cyc Knowledge Base, and one of  the relations most fundamental to the Cyc ontology.  See also subsetOf.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, genlRules, "(genlRules RULE-SPEC RULE-GENL) means that the set of binding tuples that satisfy the open (universally quantified) variables in the consequent of RULE-SPEC via an application of RULE-SPEC will be a subset of the set of binding tuples that satisfy the open (universally quantified) variables in the consequent of RULE-GENL via an application of RULE-GENL.  For example, the following holds\n\n<pre>\n   (genlRules\n      (ist CCFBridgingMt\n        (implies\n          (and\n           (cCFCardiacValveRepairProcedure ?CVRP Plication-ValvularProcedure)\n           (rdf-type ?PROC HeartValveRepair-SurgicalProcedure)\n           (cCF-contains ?CVD ?CVRP)\n           (cCF-contains ?PROC ?CVD))\n          (isa ?PROC Plication-ValvularProcedure)))\n      (ist CCFBridgingMt \n       (implies\n         (rdf-type ?X HeartValveRepair-SurgicalProcedure)\n         (isa ?X HeartValveRepair-SurgicalProcedure)))) </pre>\n\n\nHence, if one was looking to return instances of HeartValveRepair-SurgicalProcedure, all other things being equal, there would be no need to query using both of these rules.  The rule in arg2 of genlRules here would get a superset of the answers that the rule in arg1 would return.\n ", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, genlPreds, "A MetaPredicate for stating that one predicate is a generalization of another.  <code>(genlPreds SPEC-PRED GENL-PRED)</code> means that <code>GENL-PRED</code> is a generalization of <code>SPEC-PRED</code>.  That is, <code>(GENL-PRED ARG1..ARGN)</code> holds whenever <code>(SPEC-PRED ARG1..ARGN)</code> holds.  For example, <code>(genlPreds touches near)</code> holds, as touching something implies being near it.\n<p>\nAs for the respective arities (see arity) of <code>SPEC-PRED</code> and <code>GENL-PRED</code>, (i) both predicates might have the same fixed-arity (see FixedArityRelation), (ii) both might have variable-arity (see VariableArityRelation), or (iii) <code>SPEC-PRED</code> might have a fixed-arity and <code>GENL-PRED</code> variable-arity.  (It cannot be the case that <code>SPEC-PRED</code> has variable-arity and <code>GENL-PRED</code> has a fixed-arity.)\n<p>\nSee also negationPreds, genlInverse, and negationInverse.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, genlMt, "A reflexive and transitive BinaryPredicate that relates a Microtheory to a Microtheory.  <code>(genlMt SPEC-MT GENL-MT)</code> means that <code>SPEC-MT</code> is a specialization or extension of <code>GENL-MT</code>.  (Note that it need not be a <i>proper</i> specialization or extension.)  In particular, this entails that everything that is true in <code>GENL-MT</code> is also true in <code>SPEC-MT</code>.  This relation is sometimes expressed informally by saying that <code>SPEC-MT</code> \"sees\" <code>GENL-MT</code>.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, genlInverse, "A MetaPredicate for stating that one binary  predicate is a generalization of the <i>inverse</i> of another binary predicate.   <code>(genlInverse PRED GENL-INV-PRED)</code> means that <code>GENL-INV-PRED</code> is a  \"generalized inverse\" of <code>PRED</code>.  That is, <code>(PRED ARG1 ARG2)</code> implies  <code>(GENL-INV-PRED ARG2 ARG1)</code>.  For example, <code>(genlInverse grandchildren ancestors)</code> means that grandparents are  ancestors of their grandchildren.  See also genlPreds and negationInverse.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, genlCanonicalizerDirectives, "A transitive binary predicate that relates a given \nCanonicalizerDirective (q.v.) to more general ones.\n(genlCanonicalizerDirectives SPEC-DIRECTIVE GENL-DIRECTIVE) \nmeans that SPEC-DIRECTIVE is at least as specific a (set of) \ndirection(s) to the CycCanonicalizer as GENL-DIRECTIVE.  \nThat is, all the commands indicated by GENL-DIRECTIVE (and\npossibly others as well) are indicated by SPEC-DIRECTIVE.  \nFor example, (genlCanonicalizerDirectives\nLeaveSomeTermsAtELAndAllowKeywordVariables \nAllowKeywordVariables) holds.", 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(comment, genKeyword, "An NLGenerationPredicate that\nrelates a given CycL denotational term to the SubL keyword \nthat is used to represent it in generating natural language \nfrom CycL.  (genKeyword CYCL-TERM KEYWORD) means that \nKEYWORD represents CYCL-TERM in the generation of natural \nlanguage paraphrases of CycL expressions, e.g. in genFormat \n(q.v.) assertions.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, genFormat, "The Common Lisp format string ARG2 can be applied to the argument list ARG3 to generate pseudo-English for the Cyc Relation ARG1", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, forwardNonTriggerLiteral, "An HLPredicate that is used to state which literals in a forward rule should not be allowed to re-trigger forward inference.  This is useful for placing pragmatic restrictions on the applicability of forward rules.  It is only useful when used via pragmaticRequirement on a forward rule.\n<p>\nA pragmatic requirement of the form\n<pre>\n(pragmaticRequirement (forwardNonTriggerLiteral FORMULA) RULE),\n</pre>\nwhere <code>FORMULA</code> is a literal in the antecedent of <code>RULE</code>, ensures that new assertions that are instantiations of <code>FORMULA</code> do not trigger <code>RULE</code>.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, formulaArity, "(formulaArity FORMULA INTEGER) means that the CycL formula FORMULA contains INTEGER arguments. See also FormulaArityFn.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, forAll, "A binary Quantifier that corresponds to the standard universal quantifier of predicate calculus.  The relation forAll takes as its arguments a variable (ELVariable) and a sentence (ELSentence-Assertible) in which, typically, that variable occurs free.  A closed formula (see CycLClosedFormula) of the form (forAll VAR SENT) is a \"universally quantified\" sentence that states (roughly) that every thing in the universe of discourse satisfies SENT.  For example,\n<p>\n<pre>\n  (forAll ?THING (isa ?THING Individual))\n</pre>\n<p>\nmeans that everything is an individual.  And the sentence\n<p>\n<pre>\n  (forAll ?X\n    (implies\n      (isa ?X Cat)\n      (eatsWillingly ?X Grass-Plant)))\n</pre>\n<p>\nmeans that all cats eat grass.\n<p>\nA more precise definition of forAll is as follows.  Any occurence of VAR that is free in SENT is bound in (forAll VAR SENT).  If VAR is the only variable free in SENT, then (forAll VAR SENT) is a closed sentence that is true if and only if every thing that meets all of the argument-type constraints (see ArgTypePredicate) to which the position(s) in SENT occupied by VAR is (are) subject to satisfies SENT. If the variable VAR does _not_ occur free in SENT, then (forAll VAR SENT) is equivalent to SENT (and the 'forAll' is said to be \"vacuous\").  If variables other than VAR occur free in SENT, then (forAll VAR SENT) is an open sentence in which those other variables are still free.\n<p>\nNote that, for the sake of convenience and readability, universally quantified assertions (i.e. \"rules\") in the Cyc Knowledge Base appear in the KB browser -- and may be asserted to the KB -- without (any of) their initial 'forAll's.  Such assertions are considered to be \"implicitly quantified\": they are interpreted by the system just as if their initial quantifiers were explicitly present.  Thus the above sentence about cats would actually appear in the KB as:\n<p>\n<pre>\n  (implies\n    (isa ?X Cat)\n    (eatsWillingly ?X Grass-Plant)) .\n</pre>\n<p>\nNote also that certain RuleMacroPredicates (e.g. those with 'All' in their names) can be used to abbreviate universally quantified sentences.  Thus the same statement about cats can be even more tersely expressed with the atomic sentence\n<p>\n<pre>\n  (relationAllInstance eatsWillingly Cat Grass-Plant) .\n</pre>\n<p>\nCf. the existential quantifier thereExists.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, followingValue, "An instance of both OrderingPredicate and ComparisonPredicate (qq.v.), and a specialization of both colinearQuantities and lessThan (qq.v.).  followingValue is simply the restriction of the very general lessThan relation to colinear Quantity[ies] (q.v.).  <code>(followingValue LO-QUANT HI-QUANT)</code> means that <code>LO-QUANT</code> and <code>HI-QUANT</code> are colinear quantities such that <code>HI-QUANT</code> is a higher or greater value than <code>LO-QUANT</code>.  It follows that there is some (unspecified) linear ordering (see TotallyOrderedQuantityType) to which both <code>LO-QUANT</code> and <code>HI-QUANT</code> belong.\n<p>\nNote that the above sentence would typically be asserted only if one or both of <code>LO-QUANT</code> and <code>HI-QUANT</code> are instances of GenericQuantity (or the more general NonNumericScalarQuantity), and -- as is usually the case -- they are not grounded in numerically-quantifiable units of measure (see NoteAboutGivingGenericValueFunctionsNumericValues).  If <code>LO-QUANT</code> and <code>HI-QUANT</code> <i>do</i> have numerical grounding, a followingValue assertion is unnecessary since numericallyEquals, greaterThanOrEqualTo, and greaterThan are automatically computable using arithmetic relations holding between the respective minimums and maximums (see minQuantValue and maxQuantValue) of <code>LO-QUANT</code> and <code>HI-QUANT</code>.  For example, one might well use followingValue to state that (HighAmountFn Glamour) is more glamorous than (LowAmountFn Glamour); but it is unnecessary to make a followingValue assertion about (MilesPerHour 5) and (MilesPerHour 25 35), since greaterThan is automatically computable in that case.\n<p>\nSee also GenericValueFunction and followingValueOnScale.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, fanOutArg, "<code>(fanOutArg PRED N)</code> means that transitively-related assertions using <code>PRED</code> usually \"fan out\" in the direction of argument position <code>N</code>.  For example, (fanOutArg geographicalSubRegions 2) means that usually a geographical region has more direct sub-regions than super-regions, so for any region <code>REG</code> there will likely be more assertions of the form <code>(geographicalSubRegions REG SUB)</code> than there are assertions of the form <code>(geographicalSubRegions SUPER REG)</code>.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, extentCardinality, "<code>(extentCardinality SETORCOL N)</code> means that there are <code>N</code> terms in the currently represented extent of SetOrCollection <code>SETORCOL</code>.  See also cardinality.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, extConceptOverlapsColAndReln, "(extConceptOverlapsColAndReln COL RELN SOURCE STRING) means\nthat the external structured data source SOURCE variously uses the term\nnamed by STRING as a value that semantically maps to the Cyc Collection\nCOL, and as a slot that maps to the Cyc BinaryPredicate RELN.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, expresses, "A MetaLanguagePredicate (q.v.) and a specialization of means (q.v.) that relates a CycL sentence to the Proposition (if any) it expresses with respect to the intended model of the CycL language.  <code>(expresses SENTENCE PROPOSITION)</code> means that <code>SENTENCE</code> expresses, or has as its <i>intensional</i> meaning, <code>PROPOSITION</code>.\nIn order to express a proposition (see CycLPropositionalSentence), a CycL sentence must at the very least be closed and obey the arity of its main operator.\n<p>\nFor example, the sentence\n<pre>\n  (likesAsFriend Muffet Murray)\n</pre>\nexpresses the proposition that Muffet likes Murray, and we can represent that fact as follows:\n<pre>\n  (expresses\n    (Quote (likesAsFriend Muffet Murray))\n    (ThatFn (likesAsFriend Muffet Murray)))\n</pre>\nNow the above sentence is of course nearly trivial, given the intimate connection that exists between the function ThatFn and the expresses relation.  But, as we shall see, not all <code>expresses</code> sentences are trivial.\n<p>\nAs the example illustrates, the first argument-term in an <code>expresses</code> statement might consist of a particular CycL sentence wrapped with <code>Quote</code>.  But note that this need not be the case.  Suppose the above <code>likesAsFriend</code> sentence happened to be the first CycL assertion made by Muffet.  We might then reify a constant named <i>MuffetsFirstCycLAssertion</i> to denote that sentence.  Then we could say:\n<pre>\n  (expresses\n    MuffetsFirstCycLAssertion\n    (ThatFn (likesAsFriend Muffet Murray)))\n</pre> \nAs the example also illustrates, the second argument-term in an <code>expresses</code> statement might consist of a non-atomic term formed by applying the functor <code>ThatFn</code> to a particular CycL sentence.  But this also need not be the case.  Suppose the proposition that Muffet likes Murray happened to be Murray's favorite proposition.  We might then reify a constant named <i>MurraysFavoriteProposition</i> to denote that proposition.  Then we could say:\n<pre>\n  (expresses\n    MuffetsFirstCycLAssertion\n    MurraysFavoriteProposition)\n</pre> \nSee also denotes.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, expansionDefn, "(expansionDefn <Relation> <Symbol>) denotes that during canonicalization\nthe subl function definition of <Symbol> is used to transform an EL expression\n(<Relation> . <args>) into the appropriate HL formula.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, expansion, "Some relations (namely, instances of MacroRelation (q.v.)) can be defined in terms of more basic or primitive constructs. <code>(expansion RELATION FORMULA)</code> associates <code>RELATION</code> with the <code>FORMULA</code> that defines it. The arg2 is allowed to reference generic-argument keywords, such as :ARG1 :ARG2 which represent respectively the arg1 and the arg2 within uses of <code>RELATION</code>.  For example, <code>(expansion genls (implies (isa ?object :ARG1) (isa ?object :ARG2)))</code> indicates that the gaf <code>(genls Poodle Dog)</code> is defined as <code>(implies (isa ?object Poodle) (isa ?object Dog)))</code>. Importantly, the expansion-formula arg2 must be necessary and sufficient; it denotes the definition of the uses of relation arg1; there can be only one expansion for any relation.  Furthermore, no two relations can share a common expansion; thus, there can be only one possible contraction from a formula that corresponds to an expansion into a compact form that references expandable relations.  For example, <code>(implies (isa ?object Poodle) (isa ?object Dog)))</code> has the unambiguous contraction of <code>(genls Poodle Dog)</code>. The expansion arg2 can (and should when possible) make use of relations that have expansions.  Note that the example above references implies which would itself have the expansion <code>(or (not :ARG1) :ARG2)</code>.  Thus, the full expansion of a relation can involve recursive expansions.  For example, the full expansion of genls would be <code>(or (isa ?object :ARG1) (not (isa ?object :ARG2))))</code>.  No relation may reference itself (either directly or indirectly via recursion) in its expansion (or in its full recursive expansion).  See ELRelation, TermMacroFunction, expansionAxiom.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, exceptWhen, "A binary ExceptionPredicate that relates a general CycLAssertion to a condition (specified by a CycLSentence-Assertible) under which the assertion fails to hold, and thus under which the assertion should not be used as justification for other inferences.  <code>(exceptWhen EXCEPTION ASSERTION)</code> means that <code>ASSERTION</code> fails to hold in the case of <code>EXCEPTION</code>.  A default assumption is that <code>ASSERTION</code> <i>does</i> hold for all cases other than those covered by <code>EXCEPTION</code> (or by any other exception assertions there might be on <code>ASSERTION</code>).  For example, \n<pre>\n  (exceptWhen\n    (spatiallySubsumes NorthPoleOfEarth ?THING)\n    (implies \n      (isa ?THING GeographicalThing) \n      (thereExists ?OTHER \n        (northOf ?OTHER ?THING)))\n</pre>\t\nmeans that every geographical thing has something to the north of it, except when the former is spatially subsumed by the North Pole.  \n<p>\nNormally, as in the foregoing example, the <code>ASSERTION</code> is an (implicitly) universally quantified sentence, and the <code>EXCEPTION</code>, in effect, places a restriction on the range of values (for the universally quantified variables in <code>ASSERTION)</code> for which <code>ASSERTION</code> is true.  Since implicit universal quantification is always interpreted as having the widest possible scope, in the above example the occurrence of the variable <code>?THING</code> in the exception-giving sentence is interpreted as if it were bound by the same wide-scope universal quantifer that binds the two occurrences of <code>?THING</code> in the implies rule.\n<p>\nA common special case of exceptWhen is handled by exceptFor (q.v.).  \n<p>\nNote that assertions made at the EL level with exceptWhen are canonicalized into statements that do not contain exceptWhen, but instead contain the predicate abnormal (q.v.).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, exceptMt, "(exceptMt MT) means that (except ASSERTION) is true for all ASSERTIONs asserted in MT. In other words, in the current microtheory ASSERTION is not known to be true.  If ASSERTION is a rule, it will not fire.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, exceptFor, "A binary ExceptionPredicate that relates a general CycLAssertion to a thing (specified by a CycLReifiableDenotationalTerm) for which the assertion fails to hold, and thus under which the assertion should not be used as justification for other inferences.  <code>(exceptFor TERM ASSERTION)</code> means that <code>ASSERTION</code> fails to hold for the denotatum of <code>TERM</code>.  A default assumption is that <code>ASSERTION</code> <i>does</i> hold for everything other than the denotatum of <code>TERM</code> (or any other known exceptions there might be on <code>ASSERTION</code>).  For example,\n<pre>\n     (exceptFor\n      Taiwan-RepublicOfChina\n      (implies\n        (isa ?X ChineseProvince)\n        (geopoliticalSubdivision China-PeoplesRepublic ?X)))\n</pre>\nmeans that Taiwan-RepublicOfChina is an exception to the rule that every Chinese province is a geo-political subdivision of the People's Republic of China.\n<p>\nexceptFor is a special case of exceptWhen (q.v.), and is only applicable when <code>ASSERTION</code> has exactly one (implicitly) universally quantified variable.  <code>(exceptFor TERM ASSERTION)</code> prevents <code>TERM</code> from binding to that variable, thereby blocking any conclusions about the denotatum of <code>TERM</code> that Cyc might otherwise draw from <code>ASSERTION</code>.\n<p>\nNote that assertions made at the EL level with exceptFor are canonicalized into statements that do not contain exceptFor, but instead contain the predicate abnormal (q.v.).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, except, "(except ASSERTION) means that there is an exception to ASSERTION in the current microtheory such that ASSERTION is not known to be true.  If ASSERTION is a rule, it will not fire.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, exampleAssertions, "(exampleAssertions TERM ASSERTION) means that the CycLAssertion ASSERTION provides a good example of how to use the CycLReifiableDenotationalTerm TERM.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, exactlyAssertedSentence, "A KBDependentRelation (q.v.) and specialization of assertedSentence (q.v.) that is used to state that a given CycLSentence-Assertible has been asserted in the KB (in some accessible Microtheory). More exactly, (exactlyAssertedSentence SENT) is true in microtheory MT precisely when SENT canonicalizes without commutative handling of the sentence args into a set of clauses of the same form as the canonicalized form of some assertion in a microtheory accessible to MT. (The predicate is thus true both of assertions entered into the KB by hand and assertions deduced by Cyc from forward rules.)\n<p>\nThis predicate enables Cyc to select a subset of information when answering queries, filtering out more generic (asserted-without-commutative-canonicalization) information. Thus, for example, the query:\n<p>\n(assertedSentence (bordersOn CentralUSATimeZone EasternUSATimeZone))\n<p>\nwill return True (in appropriate microtheories), whereas:\n<p>\n(exactlyAssertedSentence (bordersOn CentralUSATimeZone EasternUSATimeZone))\n<p>\nwill not.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, evaluationResultQuotedIsa, "A binary MetaRelation that holds between relations and collections. evaluationResultQuotedIsa is primarily used to indicate that any value returned by a given evaluatable function is a quoted instance of a given collection. Where FUNC is a Function-Denotational, (evaluationResultQuotedIsa FUNC COL) means that FUNC returns a quoted instance of COL for any sequence of arguments for which FUNC is defined. That is, (quotedIsa (FUNC ARG1 ... ARGn) COL) holds for any sequence <ARG1, ..., ARGN> for which FUNC has a value. For example, '(evaluationResultQuotedIsa SubstringFn SubLString)' holds, and it entails (e.g.) '(quotedIsa (SubstringFn \"ABC\" 1 2) SubLString)'.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, evaluationDefn, "A CycInferenceDescriptorPredicate and InferenceRelatedBookkeepingPredicate that is used to relate an Cyc-evaluatable function or predicate to the name of the piece of code that is used to evaluate it.  (evaluationDefn RELN NAME) means that the SubLSymbol NAME is the name of a piece of Heuristic Level (SubL) code in the Cyc system that is used to compute the value of closed CycL formulas built from (the CycL name of) the EvaluatableRelation RELN.  For example, the sentence '(evaluationDefn MinusFn CYC-MINUS)' is asserted in the Knowledge Base.'", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, evaluateImmediately, "(evaluateImmediately FUNCTION) means that the canonicalizer will translate each non-atomic term (see the collection CycLNonAtomicTerm) whose initial (or \"0th\" argument-place) term denotes FUNCTION into the value to which the non-atomic term evaluates.  For example, if (evaluateImmediately PlusFn) held, then the non-atomic term `(PlusFn 2 3 4)' would canonicalize as `9'.  Note that a non-atomic term containing a nested non-atomic term whose initial term denotes another instance of EvaluatableFunction (call that instance OTHER-FUNCTION) will not canonicalize in this way, unless (evaluateImmediately OTHER-FUNCTION) is also true.  For example, `(PlusFn 2 (DifferenceFn 3 4))' would not canonicalize as `1' unless    \n(evaluateImmediately DifferenceFn) were also true.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, evaluateAtEL, "(evaluateAtEL FUNCTION) means that the canonicalizer will translate each non-atomic term (see the collection CycLNonAtomicTerm) whose  initial (or \"0th\" argument-place) term denotes FUNCTION into the value to which the non-atomic term evaluates.  For example, if (evaluateAtEL PlusFn) holds in  a Microtheory MT, then the non-atomic term `(PlusFn 2 3 4)' will canonicalize as `9' in that MT.  Note that a non-atomic term containing a nested non-atomic term whose initial term denotes another instance of EvaluatableFunction (call that instance OTHER-FUNCTION) will not canonicalize in this way, unless (evaluateAtEL OTHER-FUNCTION) is also true in MT.  For example, `(PlusFn 2 (DifferenceFn 3 4))' will not canonicalize as `1' in MT unless    \n(evaluateAtEL DifferenceFn) is also true in MT.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, evaluate, "A binary MetaLanguagePredicate that relates a thing to a thing that is known to denote it.  <code>(evaluate THING TERM)</code> means that <code>TERM</code> evalutes to <code>THING</code>: the Cyc system \"knows\" that <code>TERM</code> denotes <code>THING</code>.\n<p>\nNote that evaluate is notAssertible (q.v.).  Its most common uses are in rules or queries, with its first argument-place filled (syntactically speaking) with a variable.  In a query, evaluate is typically used to establish a binding between such a variable and an evaluatable expression.  If VAR is a variable, a literal of the form <code>(evaluate VAR TERM)</code> is satisfied by an HL module that evaluates <code>TERM</code> and binds <code>VAR</code> to the result.  For example, the literal '<code>(evaluate ?SUM (PlusFn 1 2))</code>' would bind '<code>?SUM</code>' to 3.  If evaluate's arg1 position is filled instead with a closed expression, then the HL module checks to see if the arg2 term evaluates to the denotatum of that arg1 expression.  For example, if asked the sentence '<code>(evaluate 3 (PlusFn 1 2))</code>' the system will return 'True'.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, equiv, "A LogicalConnective that represents bi-directional implication in CycL.  It takes two arguments, each of which must be an instance of ELSentence-Assertible. (equiv FORMULA-1 FORMULA-2) means that FORMULA-1 is true precisely when FORMULA-2 is true; in other words, FORMULA-1 is true if and only if FORMULA-2 is true.  (An EL equiv formula is translated during canonicalization into an equivalent, less compact, conjunction of implies formulas.) See also the predicate sentenceEquiv.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, equalSymbols, "A binary MetaPredicate and a specialization of equals, both of whose arguments are quotedArguments (q.v.), that can be used to make identity assertions about symbols.  Stated loosely,  <code>(equalSymbols X Y)</code> means that <code>X</code> and <code>Y</code> are one and the same symbol.  Given that the arguments are \"quoted\", however, it is more accurate to say: A closed atomic formula consisting of the expression <code>equalSymbols</code> followed by CycL expressions <code>A</code> and <code>B</code> (all enclosed within a pair of parentheses) is true if and only if <code>A</code> and <code>B</code> are (two occurrences of) the same expression.\n<p>\nNote that this is stronger than merely saying that <code>A</code> and <code>B</code> denote the same thing.  As an example (using English expressions for convenience), the name 'Bertrand Russell' and the description 'the author of \"On Denoting\"' are two different expressions, even though they both denote the same person.  Two symbols can even share the same intensional meaning and still be different symbols; e.g. 'bachelor' and 'unmarried male'.  The relation equalSymbols <i>does</i> hold, however, between 'bachelor' and 'bachelor' (at least if we pretend that 'bachelor' is a CycL expression), as it does between the CycL constant <code>BertrandRussell</code> and the CycL constant <code>BertrandRussell</code>.\n<p>\nSee also differentSymbols.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, equals, "The binary identity relation.  <code>(equals THING1 THING2)</code> means that <code>THING1</code> and <code>THING2</code> are \"numerically\" (as opposed to \"qualitatively\") identical, i.e. they are one and the same thing.  A sentence of the above form is true if and only if the terms occupying the two argument-places of 'equals' denote the same thing.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, ephemeralTerm, "(ephemeralTerm TERM) states that TERM is a term that only has meaning in this particular copy of the knowledge base.  A such, it can be viewed as an ephemeral concept which could likely be forgotten at some future point in time, perhaps by an explicit 'forgetting' process.  See also termDependsOn.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, elInverse, "A binary RuleMacroPredicate and a specialization of genlInverse that relates a binary EL-only (see ELRelation-OneWay) predicate with its non-EL-only \"inverse correlate\".   (elInverse PRED EL-PRED) means that whenever a sentence of the form (EL-PRED ARG1 ARG2) is used to make an assertion, the CycCanonicalizer \"transforms\" it into the logically equivalent form (PRED ARG2 ARG1), and the latter is what actually gets stored in the Knowledge Base.\n<p>\nFor example, (genlInverse genls specs) entails that if I assert the sentence '(specs Animal Cat)', what gets stored in the KB is the sentence '(genls Cat Animal)'.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, elementOf, "A very general binary predicate that relates a thing to any set or collection (see SetOrCollection) that it is a member or element of. <code>(elementOf THING SETORCOL)</code> means that <code>THING</code> is an element of <code>SETORCOL</code>.  \n<p>\nelementOf is a more general relation than isa.  Whereas isa is used exclusively to talk about membership in Collections,  elementOf can also be used to talk about membership in mathematical sets (see Set-Mathematical).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, distributesOutOfArg, "(distributesOutOfArg <reln> <pred> <n>) is a directive to the canonicalizer that relation <reln> distrbutes out of a predicate <pred> when it appears as the top-most relation in the predicate's arg <n>.  Specifically, it denotes (distributesOutOfArg <reln> <pred> <n>) denotes that the canonicalizer will translate\n<p>\n(<pred> <arg-1> ... <arg-n-1> (<reln> <arg-n1> <arg-n2> ... <arg-nm>) <arg-n+1> ..)\n<p>\ninto\n<p>\n(<reln> (<pred> <arg-1> ... <arg-n-1> <arg-n1> <arg-n+1> ...)\n(<pred> <arg-1> ... <arg-n-1> <arg-n2> <arg-n+1> ...)\n...\n(<pred> <arg-1> ... <arg-n-1> <arg-nm> <arg-n+1> ...))", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, disjointWith, "A TaxonomicSlot predicate that relates Collections  (q.v.) that have no instances in common. <code>(disjointWith COL1 COL2)</code> means that <code>COL1</code> is disjoint with <code>COL2</code>: nothing is an instance of both. That is, there is no <code>THING</code> such that both <code>(isa THING COL1)</code> and <code>(isa THING COL2)</code> hold. For example, <code>(disjointWith Herbivore Carnivore)</code> holds because no animal is both a herbivore and a carnivore. Note that disjointWith is <b>not</b> irreflexive (see IrreflexiveBinaryPredicate): it is possible for a collection to be disjoint with itself, though only if it is empty (i.e. has no instances). Thus, for example, <code>(disjointWith Nothing Nothing)</code> holds.  Cf. intersectsWith.\n<p>\nAlso note that it is quite possible for two second (or higher) order collections to be disjoint even if an instance of one collection and an instance of the other collection themselves share instances.  Consider, for example, the disjoint collections SpatialThingTypeByShape and SpatialThingTypeByDimensionality.  RoundObject is an instance of the first and ThreeDimensionalThing is an instance of the second; and any solid spherical object is an instance of both of these latter collections.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, differentSymbols, "This variable-arity predicate (see VariableArityRelation), all of whose argument-places are quotedArguments (q.v.), is used to make non-identity statements about two or more symbols. Stated loosely, (differentSymbols X1 X2 ... Xn) means that each of the Xi is a symbol that is different from all of the others.  Given that the arguments are \"quoted\", however, it is more accurate to say: A ground atomic formula (or \"GAF\"; see CycLClosedAtomicSentence) consisting of the expression `differentSymbols' followed by the CycL expressions E1, ..., En (all enclosed within a pair of parentheses) is true if and only if each Ei is a different expression from all of the others.  Note that two symbols can denote the same thing (in ordinary circumstances) and still be different symbols.  As an example (using English expressions for convenience), the proper name `Bertrand Russell' and the descriptive phrase `the author of \"On Denoting\"' are two different expressions, even though they both denote the same person. Two symbols can even share the same intensional meaning and yet be different symbols; e.g. `bachelor' and `unmarried man'.  The sentence `(differentSymbols BertrandRussell BertrandRussell)', on the other hand, is false.  See also equalSymbols and different.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, different, "A variable-arity predicate (see VariableArityRelation) that is used to state the non-identity of two or more things. <code>(different THING1..THINGn)</code> means that for any <code>THING</code>i and <code>THING</code>j (where 0 <= i <= n, 0 <= j <= n, and i =/ j), <code>THING</code>i is not identical with <code>THING</code>j.  That is, each of <code>THING</code>1, ..., <code>THING</code>n is distinct from all of the others.  Cf. equals.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, denotes, "A MetaLanguagePredicate (q.v.) that relates CycLDenotationalTerm to their denotata: the things in the intended model of the CycL language that those terms denote or stand for.  <code>(denotes TERM THING)</code> means that <code>TERM</code> denotes <code>THING</code>.  <code>TERM</code> will often be explicitly quoted, by being wrapped in the syncategorematic quotation symbol 'Quote'.  For example, the true sentence '(denotes (Quote Plato) Plato)' means that the CycL term 'Plato' denotes the person Plato.  (Thus denotes's first argument-place is <i>not</i> \"implicitly quoted\"; cf. quotedArgument).\n<p>\nBut note that the first argument of denotes might <i>not</i> be quoted at all.  Suppose (e.g.) that the term 'Plato' were the CycL constant most beloved of Cyclists, and that a new constant 'CyclistsFavoriteConstant' were reified and defined so as to reflect this fact.  Then 'CyclistsFavoriteConstant' would refer to the CycL constant 'Plato', which in turn denotes the man Plato; and so the sentence '(denotes CyclistsFavoriteConstant Plato)' -- which involves no quotation -- would be true.\n<p>\nNote also that not all CycL terms denote, not even all CycLClosedDenotationalTerms (q.v.).  For example, the term '(BorderBetweenFn Canada Mexico)' fails to denote anything (except perhaps in certain counterfactual contexts).\n<p>\nNote finally that the sentence '(denotes Plato Plato)' is of course <i>not</i> true, as it means that the man Plato is a CycL term that denotes the man Plato, which is a patent falsehood since no man is a CycL term and no man denotes anything.\n<p>\nSee also means, expresses, hasDenotatum, quotedIsa, EscapeQuote, and the shared NoteAboutQuotingInCycL.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, defnSufficient, "A CycInferenceDescriptorPredicate.  (defnSufficient COL TEST) means that TEST is the name of a piece of code in the SubL implementation of Cyc that specifies, and tests for, a sufficient condition for a CycL term's denoting an instance of (see isa) the collection COL.  If TEST returns `T' (for `True') when applied to a particular term, then that term's denotatum is considered to be an instance of COL.  Note that TEST isn't necessarily a necessary test for membership in COL; that is, not all instances of COL must pass the test, unless TEST is also a defnNecessary for COL.  See the related predicates defnNecessary and defnIff.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, defnNecessary, "A CycInferenceDescriptorPredicate.  \n(defnNecessary COL TEST) means that TEST is the name of a piece \nof code in the SubL implementation of Cyc that specifies, and tests \nfor, a necessary condition for a CycL term's denoting an instance of \n(see isa) the collection COL.  Only if TEST returns `T' (for \n`True') when applied to a particular term can that term's \ndenotatum be considered an instance of COL; all terms that denote \ninstances of COL must fulfill TEST's requirements, although there \nmay be additional requirements for denoting an instance of COL as \nwell.  See also defnSufficient and defnIff.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, defnIff, "A CycInferenceDescriptorPredicate.  (defnIff COL TEST) means \nthat TEST is the name of a piece of code in the SubL implementation \nof Cyc that specifies, and tests for, a necessary and sufficient \ncondition for a CycL term's denoting an instance of (see isa) the \ncollection COL.  If and only if TEST returns `T' (for `True') when \napplied to a particular term can that term's denotatum be considered \nan instance of COL; all and only terms that denote instances of COL \nmust fulfill TEST's requirements.  See also defnNecessary and \ndefnSufficient.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, definingMt, "(definingMt TERM MT) states that TERM only begins to have semantic meaning in microtheory MT. In microtheories in which MT is not  accessible, TERM is undefined. Additionally,  (termDependsOn TERM MT).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, defaultReformulatorModePrecedence, "(defaultReformulatorModePrecedence PRIMARY-MODE\nSECONDARY-MODE TERTIARY-MODE ...), asserted in the microtheory MT,\nmeans that in MT or a specMt thereof (unless overridden),\nthe CycLReformulator will use PRIMARY-MODE as its primary mode,\nSECONDARY-MODE as its secondary mode, etc.  This helps the\nreformulator establish precedence of CycLReformulatorDirectives.\nDo not specify both tersify and verbosify.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, defaultReformulationDirectionInModeForPred, "If the CycLReformulator is operating in MT in the mode MODE, and it\nencounters a reformulation rule with no reformulationDirectionInMode\nmeta-assertion for MODE stated in MT or a genlMt thereof, the extent of this\npredicate will be used to determine the reformulation direction of the\nrule.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, decontextualizedPredicate, "(decontextualizedPredicate PRED) states that PRED is a predicate which is context-independent.  In effect, any use of PRED can be lifted into any microtheory.  Predicates which are labelled with decontextualizedPredicate typically have an argument which either implicitly or explicitly provides the implied context.  A good example of such a predicate is ist.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, decontextualizedCollection, "(decontextualizedCollection COL) states that COL is a collection in which membership is context-independent.  In effect, any instance of COL is an instance of COL in every microtheory.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, cycTransformationProofRule, "(cycTransformationProofRule PROOF RULE) means that RULE is the rule used by PROOF to prove its proven query.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, cycTransformationProofBindings, "(cycTransformationProofBindings TRANSFORMATION-PROOF BINDING) means that BINDING is an InferenceBinding (using the appropriate variable from the transformation rule for TRANSFORMATION-PROOF) proven by TRANSFORMATION-PROOF.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, constraint, "(constraint RULE) labels a given RULE assertion as a constraint.  Constraints are typically used to verify that a given logical expectation is already true, rather than to deduce (and then add) a new formula which would satisfy the expectation.  In other words, if a rule (implies P(?X) Q(?X)) is labelled as a constraint, then when P(?X) is determined to be true, we verify that Q(?X) is already true rather than add a new argument for Q(?X) using the rule and P(?X) as justification.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, constrainsArg, "A MetaRelation predicate for stating that a given meta-relation is used to put an argument-type or format constraint (see e.g. ArgConstraintPredicate) on a given argument-place of a relation. (constrainsArg METARELN N) means that METARELN is always used to put a constraint on a relation's Nth argument-place.  For example, (constrainsArg arg2Isa 2) holds.  A slight deviation from the above occurs when N is 0: we take (constrainsArg METARELN 0) to mean that METARELN is used to constrain _all_ of a relation's argument-places; see e.g. argsIsa and argsGenl.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, constantName, "(constantName CONSTANT STRING) means that the SubLString STRING is the \"name\" for the CycLConstant CONSTANT.  That is, STRING is the string of characters that make up CONSTANT, minus the initial \"#\" and the following \"$\".", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, constantID, "A predicate which relates each Cyc constant to an internal identification number for it. This number is unique within any given image, though not necessarily across images (for that, see constantGUID). <code>(constantID CONSTANT ID)</code> states that the NonNegativeInteger <code>ID</code> is the unique internal id for the CycLConstant <code>CONSTANT</code> (in the current image). For obvious reasons, this predicate is notAssertible.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, constantGUID, "A strictly functional slot used to associate CycL constants with the GUID strings they are assigned. <code>(constantGUID CONSTANT GUID-STR)</code> means that the CycLConstant <code>CONSTANT</code> is associated with the GUIDString <code>GUID-STR</code>.  The arg1 position of this predicate is \"quoted\", so, for example, (constantGUID Dog  \"bd58daa0-9c29-11b1-9dad-c379636f7270\") means that the constant \"Dog\" itself, not the collection of dogs, is associated with the GUIDString \"bd58daa0-9c29-11b1-9dad-c379636f7270\".", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, consistent, "A predicate which asserts of sentences that they do not contradict currently known facts. (consistent SENTENCE) means that the CycLSentence-Assertible SENTENCE is consistent with assertions known in the current context.  Consequently, (consistent SENTENCE) holds in a Microtheory MT just in case, for any assertion ASSERT that holds in MT, SENTENCE does not imply the negation of ASSERT.  Note that this predicate is notAssertible. See also inconsistentWithMt.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, conceptuallyRelated, "This predicate is used to state the fact of a conceptual link between two things, where a very complex sentence would be required in order to describe the precise nature of this link explicitly.  Examples of such conceptually-linked couples include PublicTransportationDevice / PublicTransportationScheduleDocument and Dog / DogFood.  The rationale for having such a predicate as conceptuallyRelated is similar to that behind many RuleMacroPredicates (q.v.).  Having complex relationships represented -- possibly redundantly -- in a more compact fashion makes for faster retrieval. Because things can be conceptually related in many different ways, no explicit definition for this predicate is provided.  Note that conceptuallyRelated is _not_ a SymmetricBinaryPredicate (q.v.); but see conceptuallyCoRelated for a specialization of this predicate that is symmetric.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, completelyEnumerableCollection, "A unary InferenceCompletenessPredicate that is a specialization of completelyDecidableCollection (qq.v.).  <code>(completelyEnumerableCollection COL)</code> means that the CycInferenceEngine can generate a list of all of (and only) the instances of <code>COL</code>.  More precisely: given a query of the form <code>(isa VAR COL)</code>, the Inference Engine can (without using transformations) return a list of terms -- bindings for the variable <code>VAR</code> -- such that every instance (and no non-instance) of the collection <code>COL</code> is denoted by some binding on the list.\n<p>\nFor example, SkolemFunction is a completely enumerable collection.  (But note that SkolemFunction does <i>not</i> satisfy the more specialized completelyAssertedCollection (q.v.), as most of its instances are only asserted to be instances of one of its specializations, such as FixedAritySkolemFunction.)\n<p>\nSee also completeExtentEnumerable, which applies to Predicates.", 'CoreCycLMt', vStrMon).
assertedTinyKB(comment, completelyDecidableCollection, "A unary InferenceCompletenessPredicate (q.v.) that applies to collections.  <code>(completelyDecidableCollection COL)</code> means that the CycInferenceEngine can determine if any given thing is an instance of <code>COL</code>.  More precisely: for any given instance <code>INST</code> whatsoever (and for no non-instances) of <code>COL</code>, there is a CycL term <code>INST-TERM</code> that denotes <code>INST</code> such that (without using transformations) the Inference Engine, given a query of the form <code>(isa INST-TERM COL)</code>, will return the answer <code>True</code>.\n<p>\nFor example, the collection Integer is completely decidable. Given any integer <code>INT</code>, the Cyc query <code>(isa INT Integer)</code> -- wherein <code>INT</code> is given its standard base-10 arabic numeral representation -- will come back <code>True</code>.\n<p>\nIf <code>COL</code> is completely decidable and Cyc fails to return <code>True</code> for some query <code>(isa TERM COL)</code>, that fact consitutes a strong argument for the truth of its negation <code>(not (isa TERM COL))</code>.  But note that it is not a conclusive argument: the normally-reliable \"unique name assumption\" might fail here, and the term <code>TERM</code> could conceivably denote something that Cyc can prove to be an instance of <code>COL</code> only under some <i>other</i> CycL name it has.  For suppose Pace's favorite number happens to be 3, but nobody has told that to Cyc.  Cyc can prove the sentence <code>(isa 3 Integer)</code>; but it might nevertheless fail to prove the equally true sentence\n<pre>\n  (isa (<b>FavoriteNumberOfFn</b> Pace) Integer) .\n</pre>\nSee also the more specific predicates completelyEnumerableCollection and completelyAssertedCollection.  And see completeExtentDecidable, which applies to Predicates.", 'CoreCycLMt', vStrMon).
assertedTinyKB(comment, completeExtentEnumerableViaBackchain, "A unary InferenceCompletenessPredicate and a specialization of  minimizeExtent (qq.v.) that applies to predicates whose entire extents can be enumerated by reference to the transformation rules currently asserted on it.  For example, surgicalIncisionEmployed is completeExtentEnumerableViaBackchain in the context of certain medical domain microtheories because the pair of rules on it are sufficient to completely generate its entire extent within those microtheories.", 'CoreCycLMt', vStrMon).
assertedTinyKB(comment, completeExtentEnumerableForValueInArg, "A ternary InferenceCompletenessPredicate and a specialization of completeExtentDecidableForValueInArg (q.v.) that can apply to a predicate and a specified value for a specified argument-place.  <code>(completeExtentEnumerableForValueInArg PRED VALUE N)</code> means that the CycInferenceEngine can enumerate every sequence in the extent of <code>PRED</code> whose <code>N</code>th item is <code>VALUE</code>.  In practical terms this means that, if asked a query of the form <code>(PRED ... VALUE ...)</code>, where <code>VALUE</code> appears in the <code>N</code>th argument-position and all of the other positions (>= 1) are filled with variables, the Inference Engine can return an extensionally complete list of binding-sequences for those variables.  That is, for every sequence <code>SEQ</code> in <code>PRED</code>'s extension whose <code>N</code>th member is <code>VALUE</code> (and for nothing else), the returned list contains a sequence of bindings (i.e. CycL terms) whose members denote, pointwise, the members of <code>SEQ</code> excepting <code>VALUE</code>.\n<p>\nFor example, (completeExtentEnumerableForValueInArg hasMembers InternationalMonetaryFund 1) holds, as Cyc can enumerate all the members of the International Monetary Fund.\n<p>\nIf PRED's extent is completely enumerable for <code>VALUE</code> in the <code>N</code>th argument and a given sequence of bindings <<code>TERM1</code>, ..., <code>TERM(N-1)</code>, <code>TERM(N+1)</code>, ...> (whose length matches the arity of <code>PRED</code>, if fixed) is <i>not</i> returned for the above query, that fact consitutes a strong argument for the truth of the negation (not <code>(PRED TERM1 ... TERM(N-1) VALUE TERM(N+1) ...))</code>.  But note that it is not a conclusive argument: the normally-reliable \"unique name assumption\" might fail here, and a term <code>TERM</code>i could conceivably denote something that Cyc can prove a member of a sequence in the extent of <code>PRED</code> only under some <i>other</i> CycL name it has.  For suppose Pace resides in Texas, but nobody has told that to Cyc.  Cyc can return the binding 'Texas-State' for the query '(cityInState CityOfDallasTX ?X)'; but it might nevertheless fail to return the equally correct binding '(StateOfResidenceFn Pace)'.\n<p>\nSee also the specialization completeExtentAssertedForValueInArg and see completeExtentEnumerableForArg.", 'CoreCycLMt', vStrMon).
assertedTinyKB(comment, completeExtentEnumerableForArg, "A binary InferenceCompletenessPredicate (q.v.) that can apply to a predicate and a specified argument-place.  (completeExtentEnumerableForArg PRED N) means that, for any given thing ARGN, the CycInferenceEngine can enumerate every sequence in the extent of PRED whose Nth item is ARGN (see relationExtension and relationHoldsAmong).  In practical terms this means that, if asked a query of the form (PRED ... ARGN ...), where all of PRED's argument-places save the Nth are filled with variables, the Inference Engine can return an extensionally complete list of binding-sequences for the other (i.e. non-Nth) arguments.  That is, for every sequence SEQ in PRED's extension whose Nth member is ARGN (and for nothing else), the returned list contains a sequence of bindings (i.e. CycL terms) whose members denote, pointwise, the members of SEQ excepting ARGN.\n<p>\nFor example, (completeExtentEnumerableForArg cityInState 1) holds: given any city, Cyc can return a list of all the states (i.e. the one state, if any) in which it is located.\n<p>\nIf PRED's extent is completely enumerable for the Nth argument and a given sequence of bindings <TERM1, ..., TERM(N-1), TERM(N+1), ...> (whose length matches the arity of PRED, if fixed) is not returned for the above query, that fact consitutes a strong argument for the truth of the negation (not (PRED TERM1 ... TERM(N-1) ARGN TERM(N+1) ...)).  But note that it is not a conclusive argument: the normally-reliable \"unique name assumption\" might fail here, and a term TERMi could conceivably denote something that Cyc can prove a member of a sequence in the extent of PRED only under some _other_ CycL name it has.  For suppose Pace resides in Texas, but nobody has told that to Cyc.  Cyc can return the binding 'Texas-State' for the query '(cityInState CityOfDallasTX ?X)'; but it might nevertheless fail to return the equally correct binding '(StateOfResidenceFn Pace)'.\n<p>\nSee also completeExtentEnumerable and completeExtentEnumerableForValueInArg).", 'CoreCycLMt', vStrMon).
assertedTinyKB(comment, completeExtentEnumerableForArg, "(completeExtentEnumerableForArg PRED ARGNUM) means that when the CycInferenceEngine   is asked a query of the form (PRED ... ARG ...) where ARG is any closed term in the                  ARGNUMth position, it can completely enumerate all possible bindings for the other argument          positions.                                                                                           This means that for any arguments (PRED ... NOT-ARGi ... ARG ... NOT-ARGj) for which the             NOT-ARGs are not a member of the enumerated bindings,                                                (not (PRED ... NOT-ARGi ... ARG ... NOT-ARGj)) is true.", 'CoreCycLMt', vStrMon).
assertedTinyKB(comment, completeExtentEnumerable, "A unary InferenceCompletenessPredicate and a specialization of completeExtentDecidable and minimizeExtent (qq.v.) that applies to predicates whose entire extents can be enumerated by the CycInferenceEngine.  <code>(completeExtentEnumerable PRED)</code> means that the Inference Engine can, without using transformations, generate a list of all of (and only) the sequences of things among which <code>PRED</code> holds (see relationExtension and relationHoldsAmong).\n<p>\nFor example, (completeExtentEnumerable assertedSentence) holds, as the Inference Engine could, if asked, list all of the assertions in the Knowledge Base.  Conversely, although the Inference engine could correctly determine if any given CycL sentence is in the extent of knownSentence (i.e completeExtentDecidable holds of knownSentence), it could not generate a list of all CycL sentences in the extent of knownSentence.\n<p>\nThe practical import of completeExtentEnumerable can be stated more precisely as follows.  Let's say that an N-length sequence of terms \"pointwise-denotes\" an N-length sequence of things just in case each term in the former denotes the corresponding item in the latter.  Suppose <code>(completeExtentEnumerable PRED)</code> holds.  If <code>PRED</code> is a FixedArityRelation of arity N and <code>VAR1...VARN</code> are N distinct CycLVariables, then, given a query of the form <code>(PRED VAR1 ... VARN)</code>, the Inference Engine can, without the use of Transformation Modules, return a list of N-length sequences of terms -- each sequence consisting of bindings for the respective variables <code>VAR1-VARN</code> -- such that every sequence in <code>PRED</code>'s extent (and nothing else) is pointwise-denoted by some term-sequence on the list.   If <code>PRED</code> is a VariableArityRelation, it is the same, except the given query should then have the form <code>(PRED . VARS)</code>, and there might be no constant length N shared by all of the term-sequences in the returned list.\n<p>\nIf <code>PRED</code>'s extent is completely enumerable and a given term-sequence <code><TERM-1, ..., TERM-N></code> is <i>not</i> in the list returned for the above query, that fact consitutes a <i>strong argument</i> for the truth of the negation <code>(not (PRED TERM-1 ... TERM-N))</code>, assuming that it's semantically well-formed.  But note that it is <i>not a conclusive argument</i>: the normally-reliable \"unique name assumption\" might fail here, and some term <code>TERM-I</code> could conceivably denote something that Cyc can prove to be a member of something in the extent of <code>PRED</code> only under some <i>other</i> CycL name it has.  For suppose Pace was also denoted by the (imaginary) CycL term <code>ErasmusCAnderson</code>, but Cyc did not know that Pace and Erasmus C. Anderson are the same person.  Cyc will return the term-sequence <<code>Pace, GeneralCycKE</code>> for the query <code>(cyclistPrimaryProject ?X ?Y)</code>; but it might nevertheless <i>fail</i> to return the sequence <<code>ErasmusCAnderson, GeneralCycKE</code>>, even though the sentence\n<pre>\n  (cyclistPrimaryProject ErasmusCAnderson GeneralCycKE)\n</pre>\nwas in fact true.", 'CoreCycLMt', vStrMon).
assertedTinyKB(comment, completeExtentDecidableForValueInArg, "(completeExtentDecidableForValueInArg PRED VALUE ARGNUM) means that when the            CycInferenceEngine                                                                                 is asked a closed query of the form (PRED ... VALUE ...) where VALUE appears in the                  ARGNUMth position, either it can prove (PRED ... VALUE ...) without transformation,                  or (not (PRED ... VALUE ...)) is true.", 'CoreCycLMt', vStrMon).
assertedTinyKB(comment, completeExtentDecidable, "A unary InferenceCompletenessPredicate (q.v.) that applies to predicates.  <code>(completeExtentDecidable PRED)</code> means that the CycInferenceEngine can determine if any given sequence of things is in the extent of <code>PRED</code> (see relationExtension and relationHoldsAmong).  More precisely: for any given n-length sequence <code>SEQ</code> among which <code>PRED</code> holds (and for nothing else), there are CycL terms <code>TERM<sub>1</sub></code>, ..., <code>TERM<sub>N</sub></code> that denote the respective items in <code>SEQ</code> such that (without using transformations) the Inference Engine, given a query of the form <code>(PRED TERM<sub>1</sub> ... TERM<sub>N</sub>)</code>, will return the answer <code>True<code>.\n<p>\nFor example, <code>(completeExtentDecidable integerBetween)</code> holds, as the Inference engine can correctly determine if any given triple of integers is such that the second member is numerically between the first and third.  Conversely, the extent of likesAsFriend is not decidable, as many of the friendships in the world are beyond Cyc's ken.\n<p>\nIf <code>PRED</code>'s extent is completely decidable and there are CycL terms <code>TERM<sub>1</sub>, ..., TERM<sub>N</sub></code> such that the sentence <code>(PRED TERM<sub>1</sub> ... TERM<sub>N</sub>)</code> is semantically well-formed but <i>not</i> provable by the Inference Engine, that fact consitutes a strong argument for the truth of its negation <code>(not (PRED TERM<sub>1</sub> ... TERM<sub>1</sub>))</code>.  But note that it is not a conclusive argument: the normally-reliable \"unique name assumption\" might fail here, and some <code>TERM<sub>I</sub></code> could conceivably denote something that Cyc can prove to be a member of a sequence in the extent of <code>PRED</code> only under some <i>other</i> CycL name it has.  For suppose Pace's favorite number happens to be 3, but nobody has told that to Cyc.  Cyc can prove the sentence <code>(integerBetween 1 2 3)</code>; but it might nevertheless fail to prove the equally true sentence\n<pre>\n  (integerBetween 1 2 (FavoriteNumberOfFn Pace)) .\n</pre>\nSee also the more specific predicates completeExtentEnumerable and completeExtentAsserted.  And see completelyDecidableCollection.", 'CoreCycLMt', vStrMon).
assertedTinyKB(comment, completeExtentAssertedForValueInArg, "A ternary InferenceCompletenessPredicate and a specialization of completeExtentEnumerableForValueInArg (q.v.) that can apply to a predicate and a specified value for a specified argument-place.  (completeExtentAssertedForValueInArg PRED VALUE N) means that for every sequence of arguments that PRED holds of and whose Nth member is VALUE, there is an explicit assertion to that effect in the Cyc Knowledge Base.  Thus, if asked a query of the form (PRED ... VALUE ...), where VALUE appears in the Nth argument-position and all of the other positions (>= 1) are filled with variables, the Inference Engine -- simply via lookup of assertions in the KB -- can return an extensionally complete list of binding-sequences for those variables.  That is, for every sequence SEQ in PRED's extension whose Nth member is VALUE (and for nothing else), the returned list contains a sequence of bindings (i.e. CycL terms) whose members denote, pointwise, the members of SEQ excepting VALUE.\n<p>\nFor example, (completeExtentAssertedForValueInArg hasMembers InternationalMonetaryFund 1) holds, as all the members of the International Monetary Fund are asserted to be such in the KB.\n<p>\nIf PRED's extent is completely asserted for VALUE in the Nth argument and a given sequence of bindings <TERM1, ..., TERM(N-1), TERM(N+1), ...> (whose length matches the arity of PRED, if fixed) is not returned for the above query, that fact consitutes a strong argument for the truth of the negation (not (PRED TERM1 ... TERM(N-1) VALUE TERM(N+1) ...)).  But note that it is not a conclusive argument: the normally-reliable \"unique name assumption\" might fail here, and a term TERMi could conceivably denote something that Cyc can prove a member of something in the extent of PRED only under some _other_ CycL name it has.  For suppose Pace resides in Texas, but nobody has told that to Cyc.  The KB contains the assertion '(cityInState CityOfDallasTX Texas-State)'; but it might nevertheless fail to contain the equally true sentence '(cityInState CityOfDallasTX (StateOfResidenceFn Pace))'.\n<p>\nSee also completeExtentAsserted.", 'CoreCycLMt', vStrMon).
assertedTinyKB(comment, completeExtentAsserted, "A unary InferenceCompletenessPredicate and a specialization of completeExtentEnumerable (q.v.) that applies to predicates whose entire extents are explicitly asserted in the Cyc Knowledge Base.  <code>(completeExtentAsserted PRED)</code> means that, for every sequence <code><THING1,..., THING<sub>N</sub>></code> that satisfies <code>PRED</code>, <code>(PRED THING1 ... THING<sub>N</sub>)</code> is asserted in the Knowledge Base.  That is, for each such sequence, there are reified CycL terms <code>PRED-NAME</code>, <code>TERM1</code>, ..., <code>TERM<sub>N</sub></code> -- which denote <code>PRED</code>, <code>THING1</code>, ..., <code>THING<sub>N</sub></code>, respectively -- such that the sentence <code>(PRED-NAME TERM1 ... TERM<sub>N</sub>)</code> built from those terms is an assertion in the KB.\n<p>\nIf completeExtentAsserted is true of <code>PRED</code>, then the CycInferenceEngine, when asked a query of the form <code>(PRED <b>. VARS</b>)</code>, can return a complete set of bindings for the variables in <code>VARS</code> simply via a lookup of assertions in the KB.  By a \"complete set of bindings\" is meant a set of sequences of terms such that, for each sequence <code><THING1, ..., THING<sub>N</sub>></code> in the extent of <code>PRED</code>, there is a corresponding sequence of terms <code><TERM1, ..., TERM<sub>N</sub>></code> returned wherein each <code>TERM<sub>I</sub></code> denotes <code>THING<sub>I</sub></code> (for 1 <= <code>I</code> <= <code>N</code>).\n<p>\nFor example, (completeExtentAsserted hourOfDayIndex-24Hour) holds.  Thus, the sentence <code>(hourOfDayIndex-24Hour TimeOfDay-1AM 1)</code> is one of twenty-four similar ground-atomic sentences asserted in the KB.  Conversely, (completeExtentAsserted argN) does <i>not</i> hold.  Thus, while the Inference Engine could generate the set of all true <code>argN</code> based ground-atomic sentences (i.e. completeExtentEnumerable holds of argN), the members of this set are not all asserted in the KB.\n<p>\nSee also completelyAssertedCollection, which applies to collections rather than predicates.", 'CoreCycLMt', vStrMon).
assertedTinyKB(comment, commutativeInArgsAndRest, "A variable-arity MetaRelation used for \nstating that a given PartiallyCommutativeRelation (q.v.) is \"commutative\" \nwith respect to two or more argument-places, including all argument-places that \ncome after the ordinally highest one that is explicitly specified.  \n(commutativeInArgsAndRest RELN ARGNUM-1 ARGNUM-2 ... ARGNUM-N) means that \nRELN is commutative in its ARGNUM-1th, ARGNUM-2th, ..., and ARGNUM-Nth \narguments-places, along with any of its argument-places whose ordinal positions \nare greater than the greatest of the ARGNUM-i.  Thus RELN admits unrestricted \npermutation among any of these arguments.  More precisely (and assuming without \nloss of generality that ARGNUM-N is the numerically greatest of the ARGNUM-i):  \n(i) if RELN is a Predicate that holds of a given argument-sequence SEQ, then \nRELN also holds of any other sequence SEQ-PERMUTE obtainable from SEQ by \npermuting some or all of SEQ's ARGNUM-1th, ARGNUM-2th, ..., ARGNUM-Nth, and \nsubsequent items (while leaving all of SEQ's other items unchanged).  \n(ii) if RELN is a Function-Denotational that associates a given \nargument-sequence SEQ with the value VALUE, then RELN also associates any \nsequence SEQ-PERMUTE (as described above) with VALUE.  For example, \n(commutativeInArgsAndRest commutativeInArgsAndRest 2) \nhas as a consequence that whenever a sentence of the form \n(commutativeInArgsAndRest RELN 2 3 5) holds, so do the corresponding \nsentences (commutativeInArgsAndRest RELN 2 5 3), \n(commutativeInArgsAndRest RELN 3 2 5), and so on.  Note that since RELN \nis an instance of PartiallyCommutativeRelation, it must have at \nleast two argument-places that are commutative with each other and at \nleast one that is _not_ commutative with any other argument-place.  See\nalso commutativeInArgs.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, commutativeInArgs, "A variable-arity MetaRelation used for stating that a given PartiallyCommutativeRelation (q.v.) is \"commutative\" with respect to two or more specified argument-places.\n<p>\n<code>(commutativeInArgs RELN ARGNUM-1 ... ARGNUM-N)</code> means that  <code>RELN</code> is commutative in its <code>ARGNUM-1</code>th, ..., and <code>ARGNUM-N</code>th arguments.  Thus <code>RELN</code> admits unrestricted permutation among  these arguments.  More precisely: (i) if <code>RELN</code> is a Predicate that  holds of a given argument-sequence <code>SEQ</code>, then <code>RELN</code> also holds of any other sequence <code>SEQ-PERMUTE</code> obtainable from <code>SEQ</code> by permuting some or all of <code>SEQ</code>'s <code>ARGNUM-1</code>th, ..., and <code>ARGNUM-N</code>th items (while leaving all of <code>SEQ</code>'s other items unchanged).  (ii) if <code>RELN</code> is a Function-Denotational that associates a given argument-sequence <code>SEQ</code> with the value <code>VALUE</code>, then <code>RELN</code> also associates any sequence <code>SEQ-PERMUTE</code> (as described above) with <code>VALUE</code>.\n<p>\nFor example, <code>(commutativeInArgs formsBorderBetween 2 3)</code> has as a consequence that whenever a sentence of the form <code>(formsBorderBetween BORDER REG1 REG2)</code> holds, so does the corresponding sentence  <code>(formsBorderBetween BORDER REG2 REG1)</code>.\n<p>\nIf <code>RELN</code> is commutative in at least two argument-places it is an AtLeastPartiallyCommutativeRelation.  If <code>RELN</code> is commutative in <i>all</i> argument-places it is, more specifically, a CommutativeRelation.  If <code>RELN</code> is commutative in at least two, but <i> not all</i>,\nargument-places it is, instead, a PartiallyCommutativeRelation.\n<p>\nNote that the fact that each argument-place of a given relation commutes with some other argument-place is not sufficient for its being fully commutative.  For example, a partially-commutative quaternary relation might be such that its first and third places commute with each other and its second and fourth places commute with each other.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, comment, "A DocumentationPredicate (q.v.) that is used to relate a CycLIndexedTerm (usually a CycLConstant) to a SubLString containing an English explanation of the term's meaning and use, as an aid to humans (whether Cyclists or not) browsing the Cyc Knowledge Base.  <code>(comment TERM STRING)</code> means that <code>STRING</code> is a piece of Cyc documentation that explains the meaning and use of <code>TERM</code>.  For example, the passage you are reading now is the comment for the CycL constant `comment'.  See also cyclistNotes.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, collectionIsaBackchainRequired, "<code>(collectionIsaBackchainRequired COLLECTION)</code>\n<p>\nmeans that rules that conclude\n<p>\n<code>(isa <anything> COLLECTION)</code>\n<p>\nmust be used in order to prove literals of the form\n<p>\n<code>(isa <anything> COLLECTION)</code>.\n<p>\nThis directs the inference engine to use such rules even if HL predicate transformation is disabled.  See also backchainRequired for the analogue of this predicate applicable to predicates rather than collections.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, collectionIsaBackchainEncouraged, "<p>\n(collectionIsaBackchainEncouraged COLLECTION)\n<p>\nmeans that rules that conclude\n<p>\n(isa <anything> COLLECTION)\n<p>\nare most likely going to have to be used in order to prove literals of the form\n<p>\n(isa <anything> COLLECTION).\n<p>\nThis directs the inference engine to use such rules even if HL predicate transformation is disabled.  Note that it will not necessarily use rules of the form\n<p>\n(isa <anything> <variable>)\n<p>\nwhere <variable> might bind to COLLECTION, and it will not necessarily use rules of the form\n<p>\n(isa <anything> SPEC),\n<p>\nwhere (genls SPEC COLLECTION).\n<p>\nSee also backchainEncouraged for the analogue of this predicate applicable to predicates rather than collections.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, collectionGenlsBackchainRequired, "<code>(collectionGenlsBackchainRequired COLLECTION)</code>\n<p>\nmeans that rules that conclude\n<p>\n<code>(genls <anything> COLLECTION)</code>\n<p>\nmust be used in order to prove literals of the form\n<p>\n<code>(genls <anything> COLLECTION)</code>.\n<p>\nThis directs the inference engine to use such rules even if HL predicate transformation is disabled. See also backchainRequired for the analogue of this predicate applicable to predicates rather than collections.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, collectionGenlsBackchainEncouraged, "<p>\n(collectionGenlsBackchainEncouraged COLLECTION)\n<p>\nmeans that rules that conclude\n<p>\n(genls <anything> COLLECTION)\n<p>\nare most likely going to have to be used in order to prove literals of the form\n<p>\n(genls <anything> COLLECTION).\n<p>\nThis directs the inference engine to use such rules even if HL predicate transformation is disabled.  Note that it will not necessarily use rules of the form\n<p>\n(genls <anything> <variable>)\n<p>\nwhere <variable> might bind to COLLECTION, and it will not necessarily use rules of the form\n<p>\n(genls <anything> SPEC),\n<p>\nwhere (genls SPEC COLLECTION).\n<p>\nSee also backchainEncouraged for the analogue of this predicate applicable to predicates rather than collections.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, collectionExpansion, "(collectionExpansion COL FORMULA) states that membership\nof a term in the collection COL is equivalent to FORMULA involving\nthat term being true.  The meta-variable :ARG1 is used to stand for\nthe term in FORMULA, and the meta-variable :ARG2 is used to stand for\nthe collection in FORMULA.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, collectionConventionMt, "(collectionConventionMt COL MT) means that assertions of the form (isa INS COL), for any INS, are by convention asserted in MT.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, collectionCompletelyEnumerableViaBackchain, "A unary InferenceCompletenessPredicate.  <code>(collectionCompletelyEnumerableViaBackchain COL)</code> means that the CycInferenceEngine can generate a list of all of (and only) the instances of <code>COL</code> by appeal to isa consequent rules.  For example, in certain medical domain microtheories, MazeProcedure-SurgicalProcedure is collectionCompletelyEnumerableViaBackchain because backchaining on its single rule is sufficient to generate all the relevant instances in those microtheories.", 'CoreCycLMt', vStrMon).
assertedTinyKB(comment, collectionBackchainRequired, "<code>(collectionBackchainRequired COLLECTION)</code>\n<p>\nmeans that rules that conclude\n<p>\n<code>(isa <anything> COLLECTION)</code>\n<p>\nmust be used in order to prove literals of the form\n<p>\n<code>(isa <anything> COLLECTION)</code>\n<p>\nand rules that conclude\n<p>\n<code>(genls <anything> COLLECTION)</code>\n<p>\nmust be used in order to prove literals of the form\n<p>\n<code>(genls <anything> COLLECTION)</code>.\n<p>\nThis directs the inference engine to use such rules even if HL predicate transformation is disabled.  See also backchainRequired for the analogue of this predicate applicable to predicates rather than collections.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, collectionBackchainEncouraged, "<p>\n(collectionBackchainEncouraged COLLECTION)\n<p>\nmeans that rules that conclude\n<p>\n(isa <anything> COLLECTION)\n<p>\nare most likely going to have to be used in order to prove literals of the form\n<p>\n(isa <anything> COLLECTION),\n<p>\nand rules that conclude\n<p>\n(genls <anything> COLLECTION)\n<p>\nare most likely going to have to be used in order to prove literals of the form\n<p>\n(genls <anything> COLLECTION).\n<p>\nThis directs the inference engine to use such rules even if HL predicate transformation is disabled. Note that it will not necessarily use rules of the form\n<p>\n([isa|genls] <anything> <variable>)\n<p>\nwhere <variable> might bind to COLLECTION, and it will not necessarily use rules of the form\n<p>\n([isa|genls] <anything> SPEC), where (genls SPEC COLLECTION).\n<p>\nSee also backchainEncouraged for the analogue of this predicate applicable to predicates rather than collections.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, coExtensional, "A TaxonomicSlotForCollections (q.v.) that holds between collections whose extents (see extent) are exactly the same. (coExtensional COL1 COL2) means that COL1 and COL2 have all their elements in common: every instance of (see isa) one is an instance of the other.  Note that since collections (see Collection), unlike mathematical sets (see Set-Mathematical), are \"intensionally defined\", two collections can be coextensional without thereby being identical (see equals).  See also \ncoextensionalSetOrCollections.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, canonicalizerDirectiveForArgAndRest, "A  CanonicalizerDirectivePredicate (q.v.) used (in conjunction with a  CanonicalizerDirective) to control the behavior of the CycCanonicalizer. (canonicalizerDirectiveForArgAndRest RELN N DIRECTIVE) means that  the CycCanonicalizer obeys DIRECTIVE when canonicalizing the Nth and subsequent (i.e. (N+1)th, (N+2)th, ...) arguments of any CycLFormula  whose main (or \"0th place\") operator denotes RELN.  See the instances  of CanonicalizerDirective for more information on how particular  directives affect canonicalization.  Also see canonicalizerDirectiveForArg and canonicalizerDirectiveForAllArgs.", 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(comment, canonicalizerDirectiveForArg, "A CanonicalizerDirectivePredicate  (q.v.) used (in conjunction with a CanonicalizerDirective) to control the  behavior of the CycCanonicalizer.  (canonicalizerDirectiveForArg RELN  N DIRECTIVE) means that the CycCanonicalizer obeys DIRECTIVE when  canonicalizing the Nth argument of a CycLFormula whose main (or \"0th place\") operator denotes RELN.  See the instances of CanonicalizerDirective  for more information on how particular directives affect canonicalization. Also see canonicalizerDirectiveForArgAndRest and  canonicalizerDirectiveForAllArgs.", 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(comment, canonicalizerDirectiveForAllArgs, "A  CanonicalizerDirectivePredicate (q.v.) used (in conjunction with a  CanonicalizerDirective) to control the behavior of the CycCanonicalizer. (canonicalizerDirectiveForAllArgs RELN DIRECTIVE) means that the  CycCanonicalizer obeys DIRECTIVE when canonicalizing any argument of a  CycLFormula whose main (or \"0th place\") operator denotes RELN.  See the  instances of CanonicalizerDirective for more information on how particular  directives affect canonicalization.  Also see canonicalizerDirectiveForArg and canonicalizerDirectiveForArgAndRest.", 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(comment, backchainRequired, "(backchainRequired PREDICATE) means that rules that conclude PREDICATE must be used in order to prove literals involving PREDICATE.  In other words, when performing inferences, all literals involving PREDICATE must be eliminated using rules since there won't be any other way to prove them.  See also backchainEncouraged, backchainDiscouraged, and backchainForbidden.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, backchainForbiddenWhenUnboundInArg, "backchainForbiddenWhenUnboundInArg is a predicate that\nallows users to prevent the inference engine from backchaining on a\nliteral when one or more of its arguments are unbound. That is, if\nPRED is a Predicate, N a positive integer less than or equal to the\narity of PRED, then (backchainForbiddenWhenUnboundInArg PRED N) that\nno rules concluding to a positive literal with PREDICATE as the arg0\n(in other words, no implies assertions in which a literal with\nPREDICATE as the arg0 appears in the consequent) will be used when\nattempting to prove (non-negated) literals with PREDICATE as the arg0\n*unless* argN in the literal is fully bound. For instance, the sentence\n<pre>\n(backchainForbiddenWhenUnboundInArg interestingSentence 1)\n</pre>\nprevents the inference engine from applying any rule concluding\ninterestingSentence, such as \n<pre>\n(implies\n  (maleficiary ?PROGRAM ?AGENT) \n  (interestingSentence ?AGENT (maleficiary ?PROGRAM ?AGENT)))\n</pre>\nunless and until <code>?AGENT</code> is bound.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, backchainForbidden, "backchainForbidden is a predicate that allows users to cut down on the number of rules used to prove certain literals, and thus to increase the speed of inferences that involve proving those literals.  <code>(backchainForbidden PREDICATE)</code> means that no rules containing a positive literal with <code>PREDICATE</code> as the arg0 (in other words, no implies assertions in which a literal with <code>PREDICATE</code> as the arg0 appears in the consequent) will be used when attempting to prove (non-negated) literals with <code>PREDICATE</code> as the arg0.  Asserting <code>(backchainForbidden PREDICATE)</code> is useful when all (non-negated) literals with <code>PREDICATE</code> as the arg0 are expected to be solvable by lookup of ground atomic formulas (GAF's) already in the KB, and so rules won't be needed to prove them.  However, asserting <code>(backchainForbidden PREDICATE)</code> is usually counter-productive in contexts where some literals with <code>PREDICATE</code> as the arg0 are expected to be proven via backchaining on rules containing a positive literal with <code>PREDICATE</code> as the arg0.  See also the related predicates backchainRequired, backchainEncouraged, and backchainDiscouraged.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, assertionUtility, "A CycInferenceHeuristicRelevancePredicate. (assertionUtility ASSERTION NUM) states that the CycLAssertion ASSERTION should be heuristically considered of utility NUM to inferences made in the current Microtheory. NUM should be a RealNumber between 1 and -1, with 1 indicating maximum utility, -1 indicating minimum utility, and 0 being agnostic with respect to utility.  (assertionUtility ASSERTION 1) is equivalent to (highlyRelevantAssertion ASSERTION). (assertionUtility ASSERTION -1) is equivalent to (irrelevantAssertion ASSERTION).  See also other instances of CycInferenceHeuristicRelevancePredicate.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, assertionDirection, "An AssertionDescriptorPredicate that \nis used to state that a given CycLAssertion has a certain inference \n\"direction\", which indicates something about how and when the assertion \ncan be used in inferences by the Cyc system. (assertionDirection ASSERTION DIRECTION) means that ASSERTION has DIRECTION as its CycLAssertionDirection (q.v.).  DIRECTION is normally Backward-AssertionDirection (q.v.) when \nASSERTION is a rule and Forward-AssertionDirection (q.v.) when ASSERTION is \na ground atomic formula (or \"GAF\"; see CycLClosedAtomicSentence).  Note \nthat a CycL sentence is given a direction at the time of its assertion to the \nKnowledge Base, and this fact _need_not_ in general be reflected in another, \nassertionDirection GAF's being asserted (as that would of course lead to an infinite regress).", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, assertedTermSentences, "(assertedTermSentences THING SENTENCE) means that SENTENCE has been asserted to the Cyc Knowledge Base (and is thus a  CycLAssertion) and that THING is mentioned in SENTENCE.  More precisely, and assuming the assertedTermSentences formula contains no free variables (and \nis thus a \"ground atomic formula\" or \"GAF\"): the CycL term immediately following the constant `assertedTermSentences' in the formula occurs in SENTENCE.  For example, (assertedTermSentences France (bordersOn France Germany)) holds.  See also assertedSentence and assertedPredicateArg for related predicates about assertions; and see termFormulas for a more general predicate that does not entail that SENTENCE has been asserted.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, assertedSentence, "A KBDependentRelation (q.v.) and specialization of knownSentence (q.v.) that is used to state that a given CycLSentence-Assertible has been asserted in the KB (in some accessible Microtheory). More exactly, (assertedSentence SENT) is true in microtheory MT precisely when SENT canonicalizes into a set of clauses of the same form as the canonicalized form of some assertion in a microtheory accessible to MT. (The predicate is thus true both of assertions entered into the KB by hand and assertions deduced by Cyc from forward rules.) For the more specific claim that SENT is asserted <b>in MT</b>, see the predicate ist-Asserted.\n<p>\nThis predicate enables Cyc to select a subset of information when answering queries, filtering out more generic (inferrable-but-not-asserted) information. Thus, for example, the query:\n<p>\n(genls Dog Thing)\n<p>\nwill return True (in appropriate microtheories), whereas:\n<p>\n(assertedSentence (genls Dog Thing))\n<p>\nwill not.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, assertedPredicateArg, "(assertedPredicateArg OBJ N PREDICATE) means that a ground atomic formula (or \"GAF\"; see CycLClosedAtomicSentence) whose initial (or \"0th\" argument-place) term denotes PREDICATE, and whose Nth argument-place term denotes OBJ, is asserted in the Cyc Knowledge Base. Note that this predicate is itself notAssertible (q.v.), since it must be computed from the state of the knowledge base.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, arityMin, "A MetaRelation for specifying the minimum number\nof arguments a given VariableArityRelation must take if the resulting formula is to be semantically well-formed.  <code>(arityMin RELN N)</code> means that semantic well-formedness requires that <code>RELN</code> take at least <code>N</code> arguments at a time.  More precisely: a formula <code>(RELN ARG<sub>1</sub> ... ARG<sub>M</sub>)</code> is semantically well-formed only if <code>M</code> is greater than or equal to <code>N</code>.  For example, the minimum-arity of any instance of UnitOfMeasure is 1.  Note that full semantic well-formedness requires obeying argument-type constraints (see ArgTypePredicate) as well as arity constraints. For a general explanation of semantic well-formedness, see CycLExpression-Assertible.  See also arityMax and arity.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, arityMax, "A MetaRelation for specifying the maximum number\nof arguments a given VariableArityRelation can take if the \nresulting formula is to be semantically well-formed.  <code>(arityMax RELN N)</code> means \nthat semantic well-formedness requires that <code>RELN</code> take at most <code>N</code> arguments at \na time.  More precisely: a formula <code>(RELN ARG<sub>1</sub> ... ARG<sub>M</sub>)</code> is semantically \nwell-formed only if <code>M</code> is less than or equal to <code>N</code>.  For example, the \nmaximum-arity of any instance of UnitOfMeasure is 2.  Note that full semantic \nwell-formedness requires obeying argument-type constraints (see \nArgTypePredicate) as well as arity constraints.  For a general explanation \nof semantic well-formedness, see CycLExpression-Assertible.  See also \narityMin and arity.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, arity, "A MetaRelation used for stating that a given  relation takes a specified number of arguments.  <code>(arity RELN N)</code>  means that that semantic well-formedness requires that <code>RELN</code> take  exactly <code>N</code> arguments at a time.  That is, a formula  <code>(RELN ARG<sub>1</sub> ... ARG<sub>M</sub>)</code> is semantically well-formed only if <code>M</code> = <code>N</code>.\n<p>\nFor example, the arity of any instance of BinaryPredicate is 2.\n<p>\nNote that full semantic well-formedness requires obeying argument-type constraints (see ArgTypePredicate) as well as arity constraints.  For a general explanation of semantic well-formedness, see CycLExpression-Assertible.  See also CycLExpression-Askable.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, argsQuotedIsa, "A binary ArgQuotedIsaPredicate (q.v.) that is used to put a specified quoted-isa based argument-type constraint on all of a given relation's argument-places at once. (argsQuotedIsa RELN COL) means that semantic well-formedness requires that each argument to which RELN is applied (regardless of argument-place) be a quoted instance of COL. For example, '(argsQuotedIsa and CycLSentence-Assertible)' means that the relation and must only be applied to assertible CycL sentences. argsQuotedIsa is particularly useful for constraining (any and all of) the arguments of a VariableArityRelation (the preceding example being a case in point); though argQuotedIsa may be applied to fixed-arity relations as well. For an explanation of semantic well-formedness, see CycLExpression-Assertible and its immediate specializations.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, argSometimesIsa, "(argSometimesIsa RELATION POSITIVE-INTERGER-N COLLECTION) means that semantic\nwell-formedness requires that anything given as the Nth argument to RELN must be\nan instance of COL at sometime or other.  More precisely, if (argSometimesIsa RELATION POSITIVE-INTERGER-N COLLECTION) then in order to assert: (RELATION ARG-N ... OTHER-ARGS)<MT TIME PAR>, it must be the case that there exists some time interval, t, such that (isa ARG-N COLLECTION)<MT t PAR>.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, argsIsa, "A binary ArgIsaPredicate (q.v.) that is used to put a specified isa based argument-type constraint on all of a given relation's argument-places at once.  (argsIsa RELN COL) means that semantic well-formedness requires that each argument to which RELN is applied (regardless of argument-place) be an instance of COL.  For example, '(argsIsa PlusFn ScalarInterval)' means that the function PlusFn must only be applied to scalar intervals.   argsIsa is particularly useful for constraining (any and all of) the arguments to a VariableArityRelation (the preceding example being a case in point); though argsIsa may be applied to fixed-arity relations as well.  For an explanation of semantic well-formedness, see CycLExpression-Assertible and its immediate specializations.  See also argsGenl.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, argsGenl, "A binary ArgGenlPredicate (q.v.) that is used to put \na specified genls based argument-type constraint on all of a given relation's \nargument-places at once.  (argsGenl RELN COL) means that semantic well-formedness requires that each argument to which RELN is applied (regardless of argument-place) be an subcollection of COL.  For example, `(argsGenl PerformSimultaneouslyFn Event)' means that the function PerformSimultaneouslyFn must only be applied to types of events.  argsGenl is particularly useful for constraining (any and all of) the arguments to a VariableArityRelation (the preceding example being a case in point); though argsGenl may be applied to fixed-arity relations as well.  For an explanation of semantic well-formedness, see CycLExpression-Assertible and its immediate specializations.  See also argsIsa.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, argQuotedIsa, "A ternary Predicate (argQuotedIsa RELN N COL) means that semantic well-formedness requires that the term given as the Nth argument to RELN must be an instance of the SubLExpressionType COL. That is, (RELN ... ARGN ...) is semantically well-formed only if (quotedIsa ARGN COL) holds. For example, (argQuotedIsa examplePredSentences 1 CycLSentence) holds. ", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, argIsa, "A ternary ArgIsaPredicate (q.v.).  <code>(argIsa RELN N COL)</code> means that semantic well-formedness requires that anything given as the <code>N</code>th argument to <code>RELN</code> must be an instance of <code>COL</code>.  That is, <code>(RELN ... ARG<sub>N</sub> ...)</code> is semantically well-formed only if <code>(isa ARG<sub>N</sub> COL)</code> holds.  For example, <code>(argIsa mother 1 Animal)</code> and <code>(argIsa argIsa 3 Collection)</code> both hold.  For an  explanation of semantic well-formedness, see CycLExpression-Assertible and its specializations.  For similar but less flexible binary predicates, see arg1Isa et al. See also argGenl.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, argAndRestQuotedIsa, "A ternary ArgQuotedIsaPredicate (q.v.) used to place a specified quoted isa based argument-type constraint on a given VariableArityRelation (q.v.) with respect to any of its argument-places whose ordinal position is greater than or equal to a specified number. (argAndRestQuotedIsa RELN N COL) means that, as a necessary condition for semantic well-formedness, anything given as the Nth or greater argument to RELN must be a quoted instance of COL. Thus a closed formula (RELN ARG1..ARG(N)..ARG(N+1)..) is well-formed only if each of ARG(N)..ARG(N+1).. is a quoted instance of COL. See also argsQuotedIsa.", 'BookkeepingMt', vStrMon).
assertedTinyKB(comment, argAndRestIsa, "A ternary ArgIsaPredicate (q.v.) used to \nplace a specified isa based argument-type constraint on a given \nVariableArityRelation (q.v.) with respect to any of its argument-places \nwhose ordinal position is greater than or equal to a specified number.\n(argAndRestIsa RELN N COL) means that, as a necessary condition for \nsemantic well-formedness, anything given as the Nth or greater argument \nto RELN must be an instance of COL.  Thus a closed formula\n(RELN ARG1..ARG(N)..ARG(N+1)..) is well-formed only if each of ARG(N)..ARG(N+1).. is an instance of COL.  See also argsIsa and argAndRestGenl.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, argAndRestGenl, "A ternary ArgGenlPredicate (q.v.) used to \nplace a specified genls based argument-type constraint on a given \nVariableArityRelation (q.v.) with respect to any of its argument-places \nwhose ordinal position is greater than or equal to a specified number.\n(argAndRestGenl RELN N COL) means that, as a necessary condition for \nsemantic well-formedness, anything given as the Nth or greater argument \nto RELN must be an specialization of COL.  Thus a closed formula \n(RELN ARG1..ARG(N)..ARG(N+1)..) is well-formed only if each of ARG(N)..ARG(N+1).. is an instance of COL.  See also argsGenl and argAndRestIsa.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, arg6SometimesIsa, "An ArgSometimesIsaPredicate and ArgTypeBinaryPredicate, <code>(arg6SometimesIsa\nRELATION COLLECTION)</code> means that semantic well-formedness requires that\nanything given as the sixth argument to <code>RELATION</code> must be an\ninstance of <code>COLLECTION</code> at some time.  More precisely, if\n<code>(arg6SometimesIsa RELATION COLLECTION)</code> holds then in order to\nassert <code>(RELATION ... ARG6 ...)</code>, it must only be the case that there\nexists some time interval (including Always-TimeInterval) in which\n<code>(isa ARG6 COLLECTION)</code> holds.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, arg6QuotedIsa, "A binary Predicate (arg6QuotedIsa RELN COL) means that semantic well-formedness requires that the term given as the sixth argument to RELN must be an instance of the SubLExpressionType COL. That is, (RELN ARG1 ARG2 ARG3 ARG4 ARG5 ARG6 ...) is semantically well-formed only if (quotedIsa ARG6 COL) holds.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, arg6Isa, "A binary ArgIsaPredicate (q.v.).  <code>(arg6Isa RELN COL)</code>  means that semantic well-formedness requires that anything given as the sixth argument to <code>RELN</code> must be an instance of <code>COL</code>.  That is,  <code>(RELN ARG1 ARG2 ARG3 ARG4 ARG5 ARG6 ...)</code> is semantically well-formed only if  <code>(isa ARG6 COL)</code> holds.  For an explanation of semantic well-formedness, see  CycLExpression-Assertible and its specializations.  See argIsa for a similar but more flexible ternary predicate.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, arg6Genl, "A binary ArgGenlPredicate (q.v.).  <code>(arg6Genl RELN COL)</code>  means that semantic well-formedness requires that anything given as the sixth argument to <code>RELN</code> must be a subcollection of <code>COL</code>.  That is,  <code>(RELN ARG1 ARG2 ARG3 ARG4 ARG5 ARG6 ...)</code> is semantically well-formed only if <code>(genls ARG6 COL)</code> holds.  For an explanation of semantic well-formedness, see  CycLExpression-Assertible and its specializations.  See argGenl for a  similar but more flexible ternary predicate.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, arg6Format, "An instance of ArgFormatPredicate (q.v.) used to place a particular Format (q.v.) constraint on the sixth (or \"arg6\") argument-place of a given predicate.  (arg6Format PRED FORMAT) means that PRED's arg6 is constrained to FORMAT.  See the reified instances Format for\nfurther details.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, arg5SometimesIsa, "An ArgSometimesIsaPredicate and ArgTypeBinaryPredicate, <code>(arg5SometimesIsa\nRELATION COLLECTION)</code> means that semantic well-formedness requires that\nanything given as the fifth argument to <code>RELATION</code> must be an\ninstance of <code>COLLECTION</code> at some time.  More precisely, if\n<code>(arg3SometimesIsa RELATION COLLECTION)</code> holds then in order to\nassert <code>(RELATION ... ARG5 ...)</code>, it must only be the case that there\nexists some time interval (including Always-TimeInterval) in which\n<code>(isa ARG5 COLLECTION)</code> holds.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, arg5QuotedIsa, "A binary Predicate (arg5QuotedIsa RELN COL) means that semantic well-formedness requires that the term given as the fifth argument to RELN must be an instance of the SubLExpressionType COL. That is, (RELN ARG1 ARG2 ARG3 ARG4 ARG5 ...) is semantically well-formed only if (quotedIsa ARG5 COL) holds.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, arg5Isa, "A binary ArgIsaPredicate (q.v.).  <code>(arg5Isa RELN COL)</code>  means that semantic well-formedness requires that anything given as the fifth argument to <code>RELN</code> must be an instance of <code>COL</code>.  That is,  <code>(RELN ARG1 ARG2 ARG3 ARG4 ARG5</code> ...) is semantically well-formed only if  <code>(isa ARG5 COL)</code> holds.  For an explanation of semantic well-formedness, see  CycLExpression-Assertible and its specializations.  See argIsa for a  similar but more flexible ternary predicate.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, arg5Genl, "A binary ArgGenlPredicate (q.v.).  <code>(arg5Genl RELN COL)</code>  means that semantic well-formedness requires that anything given as the fifth argument to <code>RELN</code> must be a subcollection of <code>COL</code>.  That is,  <code>(RELN ARG1 ARG2 ARG3 ARG4 ARG5 ...)</code> is semantically well-formed only if <code>(genls ARG5 COL)</code> holds.  For an explanation of semantic well-formedness, see  CycLExpression-Assertible and its specializations.  See argGenl for a  similar but more flexible ternary predicate.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, arg5Format, "An instance of ArgFormatPredicate (q.v.) used to place a particular Format (q.v.) constraint on the fifth (or \"arg5\") argument-place of a given predicate.  (arg5Format PRED FORMAT) means that PRED's arg5 is constrained to FORMAT.  See the reified instances Format for\nfurther details.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, arg4SometimesIsa, "An ArgSometimesIsaPredicate and ArgTypeBinaryPredicate, <code>(arg4SometimesIsa\nRELATION COLLECTION)</code> means that semantic well-formedness requires that\nanything given as the fourth argument to <code>RELATION</code> must be an\ninstance of <code>COLLECTION</code> at some time.  More precisely, if\n<code>(arg3SometimesIsa RELATION COLLECTION)</code> holds then in order to\nassert <code>(RELATION ... ARG4 ...)</code>, it must only be the case that there\nexists some time interval (including Always-TimeInterval) in which\n<code>(isa ARG4 COLLECTION)</code> holds.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, arg4QuotedIsa, "A binary Predicate (arg4QuotedIsa RELN COL) means that semantic well-formedness requires that the term given as the fourth argument to RELN must be an instance of the SubLExpressionType COL. That is, (RELN ARG1 ARG2 ARG3 ARG4 ...) is semantically well-formed only if (quotedIsa ARG4 COL) holds.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, arg4Isa, "A binary ArgIsaPredicate (q.v.).  <code>(arg4Isa RELN COL)</code>  means that semantic well-formedness requires that anything given as the fourth argument to <code>RELN</code> must be an instance of <code>COL</code>.  That is,  <code>(RELN ARG1 ARG2 ARG3 ARG4</code> ...) is semantically well-formed only if  <code>(isa ARG4 COL)</code> holds.  For an explanation of semantic well-formedness, see  CycLExpression-Assertible and its specializations.  See argIsa for a  similar but more flexible ternary predicate.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, arg4Genl, "A binary ArgGenlPredicate (q.v.).  <code>(arg4Genl RELN COL)</code>  means that semantic well-formedness requires that anything given as the fourth argument to <code>RELN</code> must be a subcollection of <code>COL</code>.  That is,  <code>(RELN ARG1 ARG2 ARG3 ARG4 ...)</code> is semantically well-formed only if  <code>(genls ARG4 COL)</code> holds.  For an explanation of semantic well-formedness, see  CycLExpression-Assertible and its specializations.  See argGenl for a  similar but more flexible ternary predicate.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, arg4Format, "An instance of ArgFormatPredicate (q.v.) used to place a particular Format (q.v.) constraint on the fourth (or \"arg4\") argument-place of a given predicate.  (arg4Format PRED FORMAT) means that PRED's arg4 is constrained to FORMAT.  See the reified instances Format for\nfurther details.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, arg3SometimesIsa, "An ArgSometimesIsaPredicate and ArgTypeBinaryPredicate, <code>(arg3SometimesIsa\nRELATION COLLECTION)</code> means that semantic well-formedness requires that\nanything given as the third argument to <code>RELATION</code> must be an\ninstance of <code>COLLECTION</code> at some time.  More precisely, if\n<code>(arg3SometimesIsa RELATION COLLECTION)</code> holds then in order to\nassert <code>(RELATION ... ARG3 ...)</code>, it must only be the case that there\nexists some time interval (including Always-TimeInterval) in which\n<code>(isa ARG3 COLLECTION)</code> holds.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, arg3QuotedIsa, "A binary Predicate (arg3QuotedIsa RELN COL) means that semantic well-formedness requires that the term given as the third argument to RELN must be an instance of the SubLExpressionType COL. That is, (RELN ARG1 ARG2 ARG3 ...) is semantically well-formed only if (quotedIsa ARG3 COL) holds.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, arg3Isa, "A binary ArgIsaPredicate (q.v.).  <code>(arg3Isa RELN COL)</code>  means that semantic well-formedness requires that anything given as the third argument to <code>RELN</code> must be an instance of COL.  That is, <code>(RELN ARG1 ARG2 ARG3</code> ...) is semantically well-formed only if <code>(isa ARG3 COL)</code> holds.  For an  explanation of semantic well-formedness, see CycLExpression-Assertible and its specializations.  See argIsa for a similar but more flexible ternary  predicate.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, arg3Genl, "A binary ArgGenlPredicate (q.v.).  <code>(arg3Genl RELN COL)</code>  means that semantic well-formedness requires that anything given as the third argument to <code>RELN</code> must be a subcollection of <code>COL</code>.  That is, <code>(RELN ARG1 ARG2 ARG3 ...)</code> is semantically well-formed only if <code>(genls ARG3 COL)</code> holds.  For an  explanation of semantic well-formedness, see CycLExpression-Assertible and its specializations.  See argGenl for a similar but more flexible ternary  predicate.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, arg3Format, "An instance of ArgFormatPredicate (q.v.) used to place a particular Format (q.v.) constraint on the third (or \"arg3\") argument-place of a given predicate.  (arg3Format PRED FORMAT) means that PRED's arg3 is constrained to FORMAT.  See the reified instances Format for\nfurther details.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, arg2SometimesIsa, "An ArgSometimesIsaPredicate and ArgTypeBinaryPredicate, <code>(arg2SometimesIsa\nRELATION COLLECTION)</code> means that semantic well-formedness requires that\nanything given as the second argument to <code>RELATION</code> must be an\ninstance of <code>COLLECTION</code> at some time.  More precisely, if\n<code>(arg2SometimesIsa RELATION COLLECTION)</code> holds then in order to\nassert <code>(RELATION ... ARG2 ...)</code>, it must only be the case that there\nexists some time interval (including Always-TimeInterval) in which\n<code>(isa ARG2 COLLECTION)</code> holds.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, arg2QuotedIsa, "A binary Predicate (arg2QuotedIsa RELN COL) means that semantic well-formedness requires that the term given as the second argument to RELN must be an instance of the SubLExpressionType COL. That is, (RELN ARG1 ARG2 ...) is semantically well-formed only if (quotedIsa ARG2 COL) holds.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, arg2Isa, "A binary ArgIsaPredicate (q.v.).  <code>(arg2Isa RELN COL)</code>  means that semantic well-formedness requires that anything given as the second argument to RELN must be an instance of <code>COL</code>.  That is, <code>(RELN ARG1 ARG2</code> ...) is semantically well-formed only if <code>(isa ARG2 COL)</code> holds.  For an  explanation of semantic well-formedness, see CycLExpression-Assertible and its specializations.  See argIsa for a similar but more flexible ternary  predicate.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, arg2Genl, "A binary ArgGenlPredicate (q.v.).  <code>(arg2Genl RELN COL)</code>  means that semantic well-formedness requires that anything given as the second argument to <code>RELN</code> must be a subcollection of <code>COL</code>.  That is, <code>(RELN ARG1 ARG2</code> ...) is semantically well-formed only if <code>(genls ARG2 COL)</code> holds.  For an  explanation of semantic well-formedness, see CycLExpression-Assertible and its specializations.  See argGenl for a similar but more flexible ternary  predicate.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, arg2Format, "An instance of ArgFormatPredicate (q.v.) used to place a particular Format (q.v.) constraint on the second (or \"arg2\") argument-place of a given predicate.  <code>(arg2Format PRED FORMAT)</code> means that <code>PRED</code>'s arg2 is constrained to <code>FORMAT</code>.  See the reified instances Format for\nfurther details.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, arg1SometimesIsa, "An ArgSometimesIsaPredicate and ArgTypeBinaryPredicate, <code>(arg1SometimesIsa RELATION\nCOLLECTION)</code> means that semantic well-formedness requires that anything\ngiven as the first argument to <code>RELATION</code> must be an instance of\n<code>COLLECTION</code> at some time.  More precisely, if\n<code>(arg1SometimesIsa RELATION COLLECTION)</code> holds then in order to\nassert <code>(RELATION ARG1 ...)</code>, it must only be the case that there\nexists some time interval (including Always-TimeInterval) in which\n<code>(isa ARG1 COLLECTION)</code> holds.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, arg1QuotedIsa, "A binary Predicate (arg1QuotedIsa RELN COL) means that semantic well-formedness requires that the term given as the first argument to RELN must be an instance of the SubLExpressionType COL. That is, (RELN ARG1 ...) is semantically well-formed only if (quotedIsa ARG1 COL) holds.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, arg1Isa, "A binary ArgIsaPredicate (q.v.).  <code>(arg1Isa RELN COL)</code>  means that semantic well-formedness requires that anything given as the first argument to <code>RELN</code> must be an instance of <code>COL</code>.  That is, <code>(RELN ARG<sub>1</sub> ...)</code> is semantically well-formed only if <code>(isa ARG<sub>1</sub> COL)</code> holds.  For an  explanation of semantic well-formedness, see CycLExpression-Assertible and its specializations.  See argIsa for a similar but more flexible ternary predicate.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, arg1Genl, "A binary ArgGenlPredicate (q.v.).  <code>(arg1Genl RELN COL)</code>  means that semantic well-formedness requires that anything given as the first argument to <code>RELN</code> must be a subcollection of <code>COL</code>.  That is, <code>(RELN ARG1</code> ...) is semantically well-formed only if <code>(genls ARG1 COL)</code> holds.  For an  explanation of semantic well-formedness, see CycLExpression-Assertible and its specializations.  See argGenl for a similar but more flexible  ternary predicate.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, arg1Format, "An instance of ArgFormatPredicate (q.v.) used to place a particular Format (q.v.) constraint on the first (or \"arg1\") argument-place of a given predicate.  (arg1Format PRED FORMAT) means that PRED's arg1 is constrained to FORMAT.  See the reified instances Format for\nfurther details.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, and, "A LogicalConnective that represents conjunction in CycL. It is a VariableArityRelation, taking an arbitrary number of ELSentence-Assertibles as arguments.  <code>(and P Q ... Z)</code> is true if and only if all of the sentences <code>P</code>, <code>Q</code>, ..., and <code>Z</code> are true.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, afterRemoving, "When a gaf is unasserted, afterRemovings are called on the gaf dependent on the predicate of the gaf.  (afterRemoving PRED HOOK) means that HOOK will be called on gaf whose predicate is PRED.  If the gaf predicate has multiple afterRemovings, the order of execution is not guaranteed.  Also, afterRemovings are retriggered on the removal of each of the arguments to a gaf.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, afterAdding, "Whenever a gaf is asserted, afterAddings are called on the gaf dependent on the predicate of the gaf.  (afterAdding PRED HOOK) means that HOOK will be called on gaf whose predicate is PRED.  If the gaf predicate has multiple afterAddings, the order of execution is not guaranteed.  Also, afterAddings are retriggered on the addition of new arguments to an existing gaf.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, admittedSentence, "(admittedSentence SENTENCE) states that SENTENCE is a CycLSentence which is both syntactically and semantically well-formed with respect to argument constraints only.  For example, (admittedSentence (bordersOn Canada France)) is true in WorldGeographyDualistMt, but not in WorldGeographyMt, since Canada and France are known to be instances of GeographicalRegion in the former microtheory, but not in the latter microtheory.  See also admittedArgument.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, admittedNAT, "(admittedNAT NAT) states that NAT is a CycLNonAtomicTerm which is both syntactically and semantically well-formed wrt arg constraints.  For example, (admittedNAT (MotherFn Muffet)) is true precisely in those mts in which Muffet satisfies all the applicable arg1 constraints imposed by MotherFn.  See also admittedSentence.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, admittedArgument, "A ternary MetaRelation predicate that is used to state that a given thing meets the argument-type constraints on a given argument-place of a given relation. <code>(admittedArgument THING ARGNUM RELN)</code> means that <code>THING</code> satisfies all of the (single-argument) argument-type constraints (see ArgIsaPredicate and ArgGenlPredicate) for the <b><code>ARGNUM</b>-th</code> argument position of <code>RELN</code>.  \n<p>\nFor example, both of the following sentences hold:\n<pre>  (admittedArgument AbrahamLincoln 1 wife)\n\n  (admittedArgument Cougar 1 JuvenileFn) .</pre>\nSee also admittedAllArgument and admittedSentence.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, admittedAllArgument, "A ternary MetaRelation predicate that relates a Collection to an integer (representing an argument-place) to a Relation such that every instance of the collection is an admittedArgument (q.v.) to the specified argument-place of the relation.  <code>(admittedAllArgument COL ARGNUM RELN)</code> means that every instance of <code>COL</code> satisfies all of the (single-argument) argument-type constraints (see ArgIsaPredicate and ArgGenlPredicate) for the <code>ARGNUM</code>th argument position of <code>RELN</code>.  Note that <code>COL</code> is required <i>not</i> to be an  EmptyCollection.\n<p>\nFor example, <code>(admittedAllArgument FemaleHuman 1 spouse)</code> and <code>(admittedAllArgument PersonTypeByActivity 1 JuvenileFn)</code> both hold.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, abnormal, "A binary MetaKnowledgePredicate that is used to state exceptions to a given general CycLAssertion.  Typically, an abnormal assertion will be the result of the CycCanonicalizer having \"transformed\" a sentence asserted at the EL level that was built from an ExceptionPredicate (i.e. exceptWhen or exceptFor).  While perhaps less common-sensically intuitive than exceptWhen or exceptFor, abnormal facilitates an efficient and uniform handling of exceptions.\n<p>\nHere, in more detail, is how abnormal is used.  Every default rule in our system, schematically:\n<p>\nP[X1 ... Xn] -> Q[X1 ... Xn]\n<p>\n(with X1, ..., Xn free in both P and Q) is implicitly treated as\n<p>\n(not (\"abnormal-for-this-rule\" X1 ... Xn)) & (P[X1 ... Xn] -> Q[X1 ... Xn]) .\n<p>\nThus rules without exceptions need never incur the overhead of default reasoning.  Since a different \"abnormality\" relation would otherwise be needed for every default rule in the system, we use instead a single predicate -- abnormal -- which takes the rule in question as an argument.  And the other argument to abnormal is a List of variables (or of a single closed term) over which abnormality is computed; this allows abnormal to be binary rather than variable-arity.  Hence a sentence of the form\n<p>\n(exceptWhen EXCEPTION RULE) ,\n<p>\nin which each of the variables X1, ..., Xn occurs free in both EXCEPTION and RULE, gets canonicalized to an implies rule that concludes to an abnormal sentence:\n<p>\n<pre>\n(implies\n  EXCEPTION\n  (abnormal (TheList X1 .... Xn) RULE)) .\n</pre>\n<p>\nAnd a sentence of the form\n<p>\n(exceptFor TERM RULE) ,\n<p>\nin which exactly one variable X occurs free in RULE, gets canonicalized to a sentence of the form\n<p>\n(abnormal (TheList TERM) RULE) .\n<p>\nSee also pragmaticallyNormal.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'WFFSupportedTerm', "The collection of all CycLTerms that have some kind of special support in the CycWellFormednessChecker.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'WFFSupportedPredicate', "The collection of all Predicates that are supported in some way by the CycWellFormednessChecker, either to satisfy, impose, or relax well-formedness constraints.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'WFFDirectivePredicate', "The collection of all Predicates which can affect what WFF standards to impose on a given sentence.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'WFFConstraintSatisfactionPredicate', "The collection of all Predicates which can satisfy well-formedness constraints.  More specifically, only assertions of the form (PRED . ARGS), where PRED is an instance of WFFConstraintPredicate, can directly satisfy a well-formedness constraint, i.e. cause any previously ill-formed sentence to become well-formed, given the same WFF standards.  Any assertion could _indirectly_ satisfy a well-formedness constraint, for instance by triggering a forward rule or an afterAdding.  A common case of this is the afterAddings on spec-preds of isa and genls.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'WFFConstraintPredicate', "The collection of all Predicates which can impose well-formedness constraints.  More specifically, only assertions of the form (PRED . ARGS), where PRED is an instance of WFFConstraintPredicate, can directly impose a well-formedness constraint, i.e. cause a previously well-formed sentence to become ill-formed, given the same WFF standards.  Any assertion could _indirectly_ impose a well-formedness constraint, for instance by triggering a forward rule or an afterAdding.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'Wednesday', "A collection of CalendarDays and an \ninstance of DayOfWeekType.  Wednesday is the collection of all \n(and only) wednesdays.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'VariableAritySkolemFunction', "The subcollection of SkolemFunctions with variable arity. These are only created when a sequence variable is in the scope of the skolem.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'VariableAritySkolemFuncN', "The subcollection of SkolemFuncNs with variable arity. These are only created when a sequence variable is in the scope of  a bounded existential.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'VariableArityRelation', "A specialization of Relation.  Each instance of VariableArityRelation is a relation that can take a variable number of arguments. The degree of variability for a given such relation can be constrained using the predicates arityMin and arityMax. Examples of VariableArityRelations include the predicate different and the function PlusFn.  Thus the terms '(PlusFn 1 2)' and '(PlusFn 1 2 3)' are both well-formed. Cf. FixedArityRelation.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'UnreifiableFunction', "A specialization of Function-Denotational instances of which are such  that their values are not reified in the Cyc system.  More precisely, an instance of UnreifiableFunction is such that closed \"NATs\" (see  CycLNonAtomicTerm) built from its standard CycL name are _not_ instances of  HLReifiedDenotationalTerm.   Constrast with ReifiableFunction.  Usually it is more efficient to make functions reifiable; but it is not desirable  to reify every non-atomic term, such as those built from (names of)  instances of FunctionFromQuantitiesToQuantities.  For example, it would be cumbersome to reify every term of the form (Inch N) that happened to appear in a CycL assertion.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'Unknown-HLTruthValue', "An instance of CycHLTruthValue. Unknown-HLTruthValue is the attribute of being neither known to be true nor known to be false.", 'BaseKB', vStrDef).
assertedTinyKB(comment, 'UniversalVocabularyMt', "This is the microtheory which contains the 'definitional' assertions about everything in Cyc's universe of discourse.  Definitional assertions about a concept are those which are intrinsic to the concept's nature and cannot be violated in any context.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'UniversalVocabularyImplementationMt', "This is the microtheory which contains the assertions about CycL terms which are necessary for Cyc's inference engine to reason about those terms.", 'BaseKB', vStrMon).
assertedTinyKB(comment, 'Unity', "An instance of ZeroDimensionalUnitOfMeasure (q.v.) that takes one or two numbers or other NumericIntervals (q.v.) as argument(s) and returns the continuous numeric-interval that spans between and includes those arguments.  Given one argument, Unity behaves like an identity function.\n<p>\nMore precisely: for any numeric-interval <code>NUM</code>, <code>(Unity NUM)</code> = <code>NUM</code>; and for any two numeric-intervals <code>LO</code> and <code>HI</code> such that <code>(greaterThanOrEqualTo HI LO)</code>, <code>(Unity LO HI)</code> is the numeric-interval that ranges from the least point-value (see Number-General) subsumed by (see quantitySubsumes) <code>LO</code> to the greatest point-value subsumed by <code>HI</code>.\n<p>\nIn practice, <code>LO</code> and <code>HI</code> will typically be two distinct RealNumbers, and <code>(Unity LO HI)</code> will be the continuous ProperIntervalOnNumberLine that ranges from <code>LO</code> to <code>HI</code>.  For example, (Unity 1 10) is the interval from 1 to 10 inclusive.  But note that <code>LO</code> and/or <code>HI</code> might themselves be proper intervals: (Unity (Unity 7 9) 11) is thus the interval from 7 to 11 inclusive.\n<p>\nUnity is classified as a UnitOfMeasure mainly in order to simplify the application of quasi-mathematical operations (e.g. PerFn, UnitProductFn) to units-of-measure generally.  For example, TimesPerDay is defined as the result of \"dividing\" (via PerFn) Unity by DaysDuration.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'UnitProductFn', "A binary UnitOfMeasureDenotingFunction that takes two UnitOfMeasure (q.v.) functions and returns the unit-of-measure function whose value for any given argument is the multiplicative \"product\" of the respective values yielded by the first two units, when one unit is applied to that same argument and the other unit is applied to 1.  That is, <code>(UnitProductFn UNIT1 UNIT2)</code> is the function <code>PRODUCT-FN</code> such that, for any number or other NumericInterval <code>NUM</code>, <code>(PRODUCT-FN NUM)</code> = <code>(TimesFn (UNIT1 NUM) (UNIT2 1))</code>.\n<p>\nFor example, (UnitProductFn Meter Meter) is SquareMeter; and (e.g.) (SquareMeter 5) is equal to (TimesFn (Meter 5) (Meter 1)). Also, (UnitProductFn  Kilowatt HoursDuration) is KilowattHour.\n<p>\nSee also PerFn.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'UnitOfMeasure', "A specialization of ScalarDenotingFunction (q.v.).  Each instance of UnitOfMeasure is a function that takes one or two numbers or other NumericIntervals as arguments, and returns as value a MeasurableQuantity (q.v.), such as a Distance or a Speed or a Volume.  If a unit of measure is applied to one number (see Number-General) the result is a precise quantity that is a ScalarPointValue; if applied to two (different) numbers -- or to one (or two) ProperIntervalOnNumberLine(s) -- the result is a closed-interval quantity that is a ScalarProperInterval.  For example, (Meter 5) is the distance five meters and (Meter 5 10) is the distance \"five to ten meters (inclusive)\".\n<p>\n(A partial exception to the above is the unit-of-measure Unity (q.v.), which always returns a NumericInterval rather than a MeasurableQuantity.)\n<p>\nSpecializations of UnitOfMeasure grouped by what they measure include UnitOfTime, UnitOfSpeed, and UnitOfVolume.  Other specializations are OneDimensionalUnitOfMeasure, MultiDimensionalUnitOfMeasure, UnitOfMeasureWithPrefix and UnitOfMeasureNoPrefix.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'UncanonicalizerAssertionFn', "UncanonicalizerAssertionFn is used by the CycUncanonicalizer and should rarely (if ever) need to be seen by users or referenced in assertions entered at the EL level.  It is used by the uncanonicalizer to denote an CycLAssertion after it is transformed to its canonical EL formula.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'UnaryRelation', "The collection of all fixed-arity relations of arity 1 (see arity).  The most notable specializations of UnaryRelation are UnaryPredicate and UnaryFunction (qq.v.).", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'UnaryPredicate', "A specialization of both UnaryRelation and Predicate.  UnaryPredicate is the collection of all predicates whose arity (see arity) is 1.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'UnaryFunction', "A specialization of both FixedArityFunction and UnaryRelation (qq.v.).  Each instance of UnaryFunction is a function that always takes a single argument, i.e. has an arity (see arity) of 1.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'Tuesday', "A collection of CalendarDays and an \ninstance of DayOfWeekType.  Tuesday is the collection of all \n(and only) tuesdays.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'TruthValue', "TruthValue is a collection of mathematical objects; it contains the abstract, logical objects True and False.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'TruthFunction', "A major subcollection of Relation that subsumes the collections Predicate, LogicalConnective, and Quantifier (qq.v.). Truth-functions, or rather the expressions that represent or denote them, are used to form sentences.  More precisely, any CycL expression that denotes an instance of TruthFunction (and only such an expression) can appear in the \"0th\" argument-position (i.e. as the term immediately following the opening parenthesis) of a CycLSentence.  \n<p>\nThe name 'TruthFunction' derives in part from the fact that the sentences thus formed (if semantically well-formed and quantificationally closed; see CycLSentence-Assertible and CycLClosedSentence) are the kind of expression that can be true or false (with respect to a given context and interpretation). Though not really functions (cf. Function-Denotational), many TruthFunctions are \"truth-functional\" in the sense that the truth-value of a (closed, semantically well-formed) sentence <code>(RELN ARG1..ARGN)</code> built using a truth-function <code>RELN</code> is uniquely determined (with respect to a given context) by <code>RELN</code> together with the argument(s) <code>ARG1..ARGN</code> to which it is applied.  For example, the sentence <code>(mother ChelseaClinton HillaryClinton)</code> is made true (in the actual world) by the fact that Chelsea Clinton's mother is Hillary Clinton.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'True', "An instance of TruthValue (q.v.).  True is the logical notion of truth.  That is, the term 'True' is used as a sentential constant of CycL that is true under every model theoretic interpretation.  For example, (booleanResult T/F True) means that the result obtained from the true-or-false test T/F is True.  Cf. False.", 'BaseKB', vStrDef).
assertedTinyKB(comment, 'TransitiveBinaryPredicate', "A BinaryPredicateTypeByLogicalFeature and thus a specialization of BinaryPredicate.  A binary predicate <code>PRED</code> is an instance of TransitiveBinaryPredicate only if it has the following property: For any <code>THING1</code>, <code>THING2</code>, and <code>THING3</code>, if both of these hold:\n<pre>\n  (PRED THING1 THING2)\n  (PRED THING2 THING3)\n</pre>\nThen so does this:\n<pre>\n  (PRED THING1 THING3) .\n</pre>\nNote that a necessary condition on <code>PRED</code>'s being transitive is that its two argument-places must be co-satisfiable; see cosatisfiableInArgs and NoteOnArgumentCosatisfiabilityRequirement.\n<p>\nInstances of TransitiveBinaryPredicate include greaterThan,\ngeographicalSubRegions, and cotemporal.  \n<p>\nCf. QuasiTransitiveBinaryPredicate and AntiTransitiveBinaryPredicate.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'TransformationModuleSupportedPredicate', "The collection of all Predicates which are supported by some CycTransformationModule.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'TransformationModuleSupportedCollection', "The collection of all Collections which are supported by some CycTransformationModule.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'TLVariableFn', "Denotes HL variables at the TL: arg1 is the HL index of the variable; arg2 is the EL string name of the variable.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'TLReifiedNatFn', "Denotes a reified nat term at the TL: arg1 is the formula of the nat.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'TLAssertionFn', "Denotes HL assertion terms at the TL (e.g., assertions appearing as terms within meta-assertions): arg1 is the mt of the assertion; arg2 is the formula of the assertion.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'TimesFn', "A VariableArityRelation that represents multiplication in CycL. (TimesFn MULT1 MULT2 ...) yields a quantity which is the result of multiplying MULT1 MULT2 (...) together. All arguments to TimesFn must be instances of ScalarInterval, as is its result. Thus (TimesFn 2 3 4) returns 24; (TimesFn Pi-Number E-LogarithmBase) returns pi times e. For division see QuotientFn.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'Thursday', "A collection of CalendarDays and an  instance of DayOfWeekType.  Thursday is the collection of all  (and only) thursdays.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'Thing', "Thing is the \"universal collection\": the collection which, by definition, contains everything there is.  Every thing in the Cyc ontology -- every Individual (of any kind), every Set-Mathematical, and every Collection -- is an instance of (see isa) Thing.  Similarly, every collection is a subcollection of (see genls) Thing.  Trivially, Thing is both an instance of and a subcollection of itself, and is not a subcollection of any other collection.  (Note that the above reference to \"every thing in the Cyc ontology\" is <i>not</i> meant to be limited to things actually <i>reified</i> in the Cyc system, but includes (e.g.) every instance -- reified or not, known or not -- of every collection recognized by Cyc.)", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'TheUser', "TheUser denotes the `current user' of an individual, running Cyc image.  Note that at any moment there may actually be many current users of an image, communicating with it through various sorts of API: HTML-based browser, telnet API connection, etc. TheUser serves as a placeholder allowing Cyc to keep track of relevant characteristics (including authorization, sophistication level) of each distinct user.", 'BaseKB', vStrDef).
assertedTinyKB(comment, 'TheTerm', "A special kind of term that allows back-reference to any individual thing that satisfies the constraints on the TheTerm.  E.g., 'Suppose a cat walks into a fish store.  The cat is likely to get into a lot of trouble.'  'The cat' in the second sentence refers back to 'a cat' in the first; i.e., any cat that walks into a fish store.  In Cyc, the constraints for a TheTerm in a given context are given by use of the predicate theTermConstraints on the unit representing that context.  In lifting assertions out of that context, the constraints are added as antecedents.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'TheSetOf', "A binary SetDenotingFunction and ScopingRelation that takes a variable and an open sentence to a set, where the open sentence specifies a necessary and sufficient membership condition for the set.  If <code>SENT</code> is an open CycLSentence-Assertible in which <code>VAR</code> is the only variable occuring free, (TheSetOf <code>VAR SENT</code>) is the Set-Mathematical of exactly those things that satisfy <code>SENT</code>.  For example, (TheSetOf ?X (and (isa ?X Dog) (mainColorOfObject ?X BlackColor))) is the set of black dogs.\n<p>\nNote that if <code>VAR</code> does not occur free in <code>SENT</code>, or is not the only variable occuring free in <code>SENT</code>, the term <code>(TheSetOf VAR SENT)</code> will be itself be open (see CycLOpenNonAtomicTerm) and thus will not denote anything.  Given that a true sentence is satisfied by <i>everything</i>, we stipulate that <code>(TheSetOf VAR SENT)</code> is undefined whenever <code>SENT</code> is closed in order to avoid commitment to a \"universal set\". \n<p>\nSee also TheSet, which is used to specify a set by enumerating its elements.  And see TheCollectionOf.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'TheSet', "A variable-arity SetDenotingFunction that is used to specify a set by enumerating its elements.  For any finite sequence <code>THING1,...,THING<sub>N</sub></code> (<code>N</code> >= 1), (TheSet <code>THING1...THING<sub>N</sub>)</code> is the Set-Mathematical whose elements (see elementOf) are precisely <code>THING1,...,THING<sub>N</sub></code>.  For example, (TheSet SonnyBono Cher) is the set whose only elements are Sonny and Cher.  \n<p>\nNote that in the degenerate case where <code>N</code> is zero, (TheSet) is TheEmptySet.  \n<p>\nSee also the related function TheSetOf, which is used to specify a set by giving a necessary and sufficient membership condition.  And see TheList and TheCollection.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'TheList', "TheList is a function that combines its arguments into a list.  For any ITEM(1), ..., ITEM(n), each of which is an instance of Thing, (TheList ITEM(1) ... ITEM(n)) gives the instance of List-Extensional whose first member is ITEM (1), ..., and whose last member is ITEM(n). Note that in general ITEM(1), ..., ITEM(n) do not have to be distinct, though they do if (TheList ITEM(1) ... ITEM(n)) is an instance of ListWithoutRepetition.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'TheEmptySet', "TheEmptySet is the empty (or \"null\") set: the unique set that has no elements.  Note that TheEmptySet is an instance of Set-Mathematical and thus _not_ an instance of Collection.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'TheEmptyList', "An instance of ListWithoutRepetition. TheEmptyList is a list that has no members (see listMembers).  Note that any list that has no members is identical with TheEmptyList; thus TheEmptyList is the only list whose length is 0.  Note also that TheEmptyList is a sublist (see subLists) of every list.  Note finally that TheEmptyList is not the same as TheEmptySet (q.v.).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'TheCollectionOf', "A collection denoting function that takes a CycL variable and an open formula with exactly one free variable to the collecion of things satisfying that formula.", 'BaseKB', vStrDef).
assertedTinyKB(comment, 'TernaryRelation', "The collection of all fixed-arity relations of arity 3 (see arity).  The most notable specializations of TernaryRelation are TernaryPredicate and TernaryFunction (qq.v.).", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'TernaryPredicate', "A specialization of both TernaryRelation and Predicate.  TernaryPredicate is the collection of all predicates whose arity (see arity) is 3.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'TernaryFunction', "A specialization of FixedArityFunction and TernaryRelation.  An instance FUNC of FixedArityFunction is an instance of TernaryFunction if and only if FUNC has an arity of three.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'TemporaryEnglishParaphraseMt', "This is a temporary MT for holding paraphrase assertions prior to review, after which time they will be moved to EnglishParaphraseMt", 'BaseKB', vStrDef).
assertedTinyKB(comment, 'SymmetricBinaryPredicate', "A specialization of both BinaryPredicate and CommutativeRelation (qq.v.).  A binary predicate <code>PRED</code> is an instance of SymmetricBinaryPredicate if and only if (i) for any things <code>X</code> and <code>Y</code>, if <code>(PRED X Y)</code> then <code>(PRED Y X)</code> and (ii) the single-argument argument type constraints (see argIsa and argGenls) on <code>PRED</code>'s two argument-places are co-satisfiable (see cosatisfiableInArgs and NoteOnArgumentCosatisfiabilityRequirement).  Note that if <code>PRED</code> satisfies condition (i), then it also satisfies condition (ii) as long as <code>(PRED A B)</code> holds for some <code>A</code> and <code>B</code>.\n<p>\nInstances of SymmetricBinaryPredicate include siblings, teammates, connectedTo, and bordersOn.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'Sunday', "A collection of CalendarDays and an  instance of DayOfWeekType.  Sunday is the collection of all  (and only) sundays.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'substring-CaseInsensitive', "<code>(substring-CaseInsensitive SUBSTRING STRING)</code> means that the <code>CharacterString SUBSTRING</code> is a substring of the <code>CharacterString STRING</code> with case ignored in both <code>SUBSTRING</code> and <code>STRING</code>. For case-sensitive tagging use the more specialized predicate, <code>substring</code>.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'SubLSymbol', "The collection of all SubLAtoms that are also \"symbols\" in the SubL language.  That is, each instance of SubLSymbol satisfies the defnIff SYMBOLP.  Note that `symbol' has a very specific, technical meaning in SubL.  Save for those that are variables (see SubLVariable), SubLSymbols are rarely used in CycL assertions, except within those built with certain CycInferenceDescriptorPredicates like defnIff. Examples of SubL symbols include the symbols 'GENLS' and 'CYC-SYSTEM-NON-VARIABLE-SYMBOL-P'. Note also that SubLSymbol is a \"quoted-collection\" (see quotedCollection).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'SubLString', "A subcollection of SubLAtomicTerm (q.v.) whose instances can be used to denote character-strings.  In the SubL language (as in English), one can refer to a particular character-string by simply putting a pair of quotation marks around it.  Semantically, what this amounts to is using a certain character-string to denote itself.  \n<p>\nMore precisely: a given SubLString STRING is a character-string such that, when it appears inside a pair of double-quotation marks, STRING is interpreted as denoting itself (i.e. STRING).  The surrounding quotation-marks are <i>not</i> considered to be parts of STRING; rather, they are syncategorematic symbols whose role is merely to indicate that a string is being referred to.  Thus, in the context of the sentence '(firstName Lenat \"Doug\")', the four-character string 'Doug' denotes itself: the string `Doug'.  \n<p>\nNote that <i>not</i> every CharacterString is a SubLString: there are some restrictions on what characters a SubL-string can contain. Note also that SubLStrings are <i>atomic</i> terms (see SubLAtomicTerm and CycLAtomicTerm), as they cannot be constructed out of other SubL (or CycL) terms via the syntax (grammar) of SubL (or CycL).  Thus although the string 'hotdog' can indeed be obtained from 'hot' and 'dog' via concatenation (see ConcatenateStringsFn), the <i>syntax</i> of SubL (or CycL) itself contains no rule that licenses such a construction (see e.g. the comments on SubLSExpression, CycLExpression, CycLTerm, CycLFormula, and various subcollections thereof).  Note finally that SubLString is a \"quoted-collection\" (see quotedCollection).  Thus the sentence '(isa \"hotdog\" SubLString)' means, just as one would expect, that the six-character string 'hotdog' (not the eight-character quote-inclusive '\"hotdog\"'; see above) is an instance of SubLString.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'SubLSExpression', "The collection of all expressions of the SubL language.  SubL is the implementation language of the Cyc system, and it subsumes the CycL language.  The CycL grammar is more strict than the SubL grammar. Thus, while every CycLExpression is a SubLSExpression, the converse is not true. Examples of SubLSExpressions that are not CycLExpressions include Arabic decimal numeric expressions such as '123', expressions like '(1 2 3)' that denote lists of numbers, and \"dotted pair\" expressions like '(Cat . Dog)'.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'SubLRealNumber', "The collection of all number-denoting expressions in the CycL language that are _not_ CycL constants or NATs, but are terms of SubL, the underlying implementation language of the Cyc system. SubLRealNumbers are numeric strings of the Arabic decimal system, including the decimal point and scientific notation.  Examples include the terms `212' and `3.14159d0'.  Non-examples include the expressions `One', `(Meter 6)', `(Unity 3)', `:34', `PlusInfinity', and `Avogadro's number'.  Note that this collection, like most instances of CycLExpressionType, is \"quoted\" (see quotedCollection).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'SubLQuoteFn', "<code>(SubLQuoteFn SUBL-EXPRESSION)</code> is one of exactly two escapes to SubL from CycL, the other being ExpandSubLFn.  These are the only two ways to represent arbitrary SubL in CycL.  SubLQuoteFn encapsulates <code>SUBL-EXPRESSION</code> such that it will not be rejected by the CycL wff-checker as ill-formed CycL.  For example, <code>(SubLQuoteFn (+ 1 2))</code>, which <i>is</i> a CycLExpression, denotes the SubLSExpression (+ 1 2), which itself is <i>not</i> a CycLExpression.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'SubLPositiveInteger', "The collection of all positive-integer-denoting expressions in the CycL language that are <i>not</i> CycL constants or NATs, but are terms of SubL, the underlying implementation language of the Cyc system.  SubLPositiveIntegers  are numeric strings of the Arabic decimal system (not including the decimal point or scientific notation).  Examples include the expressions '2', '12', and '4'.  Non-examples include '0', '4.012', '(Meter 6)', '(Unity 3.3)', ':34', and 'PlusInfinity'.  Note that SubLPositiveInteger is a \"quoted-collection\" (see quotedCollection); thus the sentence '(isa 12 SubLPositiveInteger)' means that the expression '12' (not the number 12) is an instance of SubLPositiveInteger.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'SubLNonVariableSymbol', "The collection of all SubLSymbols except SubLVariables (qq.v.); a subcollection of CycLClosedAtomicTerm.  Note that `symbol' has a very specific, technical meaning in SubL; SubLNonVariableSymbols are rarely used in CycL assertions, except within those built with certain CycInferenceDescriptorPredicates like defnIff and those whose arguments are KeywordVariableTemplates (qq.v.). Examples of SubL non-variable symbols include the symbols `GENLS', `:ARG1', and `CYC-SYSTEM-NON-VARIABLE-SYMBOL-P'.  Note that this collection, like most instances of CycLExpressionType, is \"quoted\" (see quotedCollection).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'SubLNonVariableNonKeywordSymbol', "The collection of all SubLSymbols except SubLVariables (q.v.) and SubLKeywords (q.v.); a subcollection of CycLClosedAtomicTerm.  Note that `symbol' has a very specific, technical meaning in SubL; SubLNonVariableNonKeywordSymbols are rarely used in CycL assertions, except within those built with certain CycInferenceDescriptorPredicates like defnIff. Examples of SubL non-variable non-keyword symbols include the symbols `GENLS' and `CYC-SYSTEM-NON-VARIABLE-NON-KEYWORD-SYMBOL-P'.  Note that this collection, like most instances of CycLExpressionType, is \"quoted\" (see quotedCollection).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'SubLNonNegativeInteger', "The collection of all non-negative-integer-denoting expressions in the CycL language that are _not_ CycL constants or NATs, but are terms of SubL, the underlying implementation language of the Cyc system.  SubLNonNegativeIntegers \nare numeric strings of the Arabic decimal system (not including the decimal point or scientific notation).  Examples include the expressions `0', `12', and `4'.  Non-examples include `4.012', `(Meter 6)', `(Unity 3.3)', `:34', and `PlusInfinity'.  Note that SubLNonNegativeInteger is a \"quoted-collection\" (see quotedCollection); thus the sentence `(isa 12 SubLNonNegativeInteger)' means that the expression `12' (and not \nthe number 12) is an instance of SubLNonNegativeInteger.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'SubLList', "A collection of list-denoting expressions that are not represented in CycL (i.e. they are not CycLConstants or CycLNonAtomicTerms) but are represented in SubL, the underlying implementation language of the Cyc system.  Each instance of SubLList is a sequence of SubLListOrAtoms (q.v.) enclosed in parentheses.  SubL lists are those things that pass the defnIff LISTP. Note that this collection is \"quoted\" (see quotedCollection).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'SubLKeyword', "The subcollection of SubLSymbol consisting of all SubL keywords.  Instances include the symbols `:KEYWORD', `:OBJECT', and `:PLURAL'.  Every instance of SubLKeyword satisfies (in the sense relevant to defnIff) `KEYWORDP'.  Note that SubLKeyword, like most instances of CycLExpressionType, is \"quoted\" (see quotedCollection).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'SubLInteger', "The collection of all integer-denoting expressions in the CycL language that are _not_ CycL constants or NATs, but are terms of SubL, the underlying implementation language of the Cyc system.  SubLIntegers  are numeric strings of the Arabic decimal system (including the negative-value symbol `-', but _not_ the decimal point or scientific notation) that denote integers.  Examples include the expressions `0', `12', and `-4' (which denote the integers 0, 12, and -4, respectively).  Non-examples include `4.012', `(Meter 6)', `(Unity 3.3)', `:34', and `PlusInfinity'.  Note that SubLInteger is a \"quoted-collection\" (see quotedCollection). Thus the sentence `(isa 12 SubLInteger)' means that the expression `12' (and not the number 12) is an instance of SubLInteger.  Similarly, the assertion `(genls SubLInteger Integer)' means (not that each SubL integer is an integer, but) that each  instance of SubLInteger _denotes_ an instance of Integer (see the shared NoteAboutUseVersusMention).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'SubLExpressionType', "A collection of collections.  Each instance of SubLExpressionType is a type (i.e. a subcollection) of SubLSExpression.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'SubLCharacter', "The collection of all character-denoting terms in the CycL language that are SubLAtomicTerms (q.v.). (SubL, which subsumes CycL, is the underlying implementation language of the Cyc system.)  A given SubLCharacter CHAR-TERM is itself a string consisting of the hash-symbol (`#'), followed by the backslash (`\\'), followed (in most cases) by the character CHAR that CHAR-TERM denotes.  For example, the SubLCharacter `#\\A'\ndenotes the character `A'.  (An exception to the above is when CHAR is a non-printing or control character, in which case a specially-designated string\nappears after the `#\\'.)", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'SubLAtomicTerm', "The collection of all atomic denotational terms in the CycL language that are not explicitly represented in CycL (i.e. they are neither CycLConstants nor CycLVariables) but are represented in SubL, the underlying implementation language of the Cyc system.  \"Atomic\" here means not constructable from other terms via the SubL syntax.  Examples include the terms '212', ':NOUN', '#x', and 'VARIABLE-P'. Do not confuse this collection with SubLAtom, most of whose instances, while they are expressions of SubL, are <i>not</i> part of CycL.  Note that this collection, like most instances of CycLExpressionType, is \"quoted\".", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'SubLAtom', "A collection of SubLExpressions that are atomic: they cannot be decomposed into other SubL expressions. Save for certain variables (see SubLVariable), instances of SubLAtom are rarely used in CycL assertions (other than assertions built with certain CycInferenceDescriptorPredicates like defnIff). Many SubL atoms are not even CycLExpressions.  Do not confuse this collection with SubLAtomicTerm, which is a CycLExpressionType (though its instances are neither CycL constants nor CycL variables).  Note that SubLAtom is a \"quoted-collection\" (see quotedCollection).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'SkolemFunctionFn', "SkolemFunctionFn is used by the CycCanonicalizer and should rarely (if ever) need to be seen by users or referenced in assertions entered at the EL level.  It is used by the canonicalizer to denote a skolem function before it is reified, when the skolem is derived from a formula asserted at the EL level that uses thereExists. Its arity is 3: the first argument is a list of the term variable arguments of the denoted skolem function, (term variables which are in the scope of the existential), the second argument is a variable which uniquely identifies the existentially quantified variable by which the denoted skolem will be represented in the canonical version of the formula, and the third is  a sequence variable if there is a sequence variable argument of the denoted skolem function (which there will be iff there is a sequence variable in the scope of the existential), and NIL otherwise.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'SkolemFunction', "A specialization of IndeterminateTermDenotingFunction and ReifiableFunction (qq.v.).  SkolemFunction is a collection of system-generated functions that implement existential quantification in Cyc.  Whenever someone asserts to the Knowledge Base a sentence that contains 'thereExists' (in an arg0 position), Cyc automatically creates a new instance of SkolemFunction and rewrites the assertion using that Skolem function.\n<p>\nFor example, suppose we want Cyc to know that every animal has a birth date.   So we assert the following sentence:\n<p>\n<pre>\n  (implies\n    (isa ?X Animal)\n    (thereExists ?Y\n      (birthDate ?X ?Y))) .\n</pre>\n<p>\nIn response, Cyc automatically reifies a new unary instance of SkolemFunction (call it 'BirthDateFn') that takes any given animal to its date of birth, and then rewrites our rule using BirthDateFn instead of thereExists, as\n<p>\n<pre>\n  (implies\n    (and\n      (isa ?X Animal)\n      (termOfUnit ?Y (BirthDateFn ?X)))\n    (birthDate ?X ?Y)) .\n</pre>\n<p>\nNote that actual Cyc-generated Skolem function names currently (02/04) consist of the prefix 'SKF-' follow by a numeral.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'SkolemFuncNFn', "SkolemFuncNFn is used by the CycCanonicalizer and should rarely\n(if ever) need to be seen by users or referenced in assertions entered\nat the EL level.  It is used by the canonicalizer to denote a skolem\nfunction before it is reified, when the skolem is derived from a formula\nasserted at the EL level that uses thereExistAtLeast,\nthereExistAtMost, or thereExistExactly.  Its arity is 4: the first\nargument is a list of the term variable arguments of the denoted skolem function,\n(term variables which are in the scope of the bounded existential).\nThe second argument is a variable which uniquely identifies the\nexistentially quantified variable by which the denoted skolem will\nbe represented in the canonical version of the formula.\nThe third is a sequence variable if there is a sequence variable\nargument of the denoted skolem function (which there will be iff there\nis a sequence variable in the scope of the bounded existential), and NIL otherwise.\nThe fourth is an interval specifying the number of things which may satisfy the formula.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'SkolemFuncN', "SkolemFuncN is a collection of Cyc system-generated functions that partially implement existential quantifications in Cyc.  Whenever someone asserts to Cyc an expression that contains a 'thereExistAtLeast', a 'thereExistAtMost', or a 'thereExistExactly' quantifier, Cyc automatically creates a new instance of SkolemFuncN and rewrites the assertion using this skolem function instead of that existential quantifier.  See also termOfUnit. At this time (3/98), skolem functions are automatically named by the Cyc system using the prefix 'SKF-' followed by a number.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'SingleEntry', "An instance of Format (q.v.) that can be specified to hold of a given predicate with respect to a given argument-place (see argFormat).  (argFormat PRED N SingleEntry) means that, for any particular way of fixing the other arguments to PRED besides the Nth, there is at most one thing such that, if taken as the Nth argument, PRED holds of those arguments.  That is, if the sequences <... ARGN ...> and <... ARGN-PRIME ...> differ at most in their Nth items and both (PRED ... ARGN ...) and (PRED ... ARGN-PRIME ...) hold, then ARGN = ARGN-PRIME (see equals).  For example, the format of biologicalMother's second argument-place is single-entry, since an animal can only have one biological mother.  A predicate with a single-entry format argument-place is thus a StrictlyFunctionalPredicate (q.v.) that is strictly functional with respect to that argument-place (see strictlyFunctionalInArgs).  Contrast with SetTheFormat.", 'BaseKB', vStrDef).
assertedTinyKB(comment, 'SiblingDisjointCollectionType', "A KBDependentCollection of collections of  collections (and thus an instance of CollectionTypeType and a specialization of CollectionType).  A sibling-disjoint collection type is such that its known  (i.e. KB-represented) instances are collections that -- save for any that are related to each other by  genls and any that are explicitly asserted to be exceptions (see  siblingDisjointExceptions) -- are disjoint from each other. \n<p>\nMore precisely, each instance <code>SIB</code> of SiblingDisjointCollectionType is a collection of collections that has the following KB-dependent property: \n<p>\nFor any two known instances <code>COL1</code> and <code>COL2</code> of   <code>SIB</code>, at least one of the following is known to hold: \n<pre>\n  (a) (genls COL1 COL2)\n  (b) (genls COL2 COL1)\n  (c) (siblingDisjointExceptions COL1 COL2)\n  (d) (disjointWith COL1 COL2)\n</pre>  \nMoreover, note that if <code>MT</code> is a context (see Microtheory) in which (i) both <code>(isa COL1 SIB)</code> and <code>(isa COL2 SIB)</code> hold and (ii)  neither <code>(genls COL1 COL2)</code> nor <code>(genls COL2 COL1)</code> nor <code>(siblingDisjointExceptions COL1 COL2)</code> is known to hold (see knownSentence), then \n<code>(disjointWith COL1 COL2)</code> holds by default in <code>MT</code>.   \n<p>\nFor example, in BiologyMt both Person and Dog are instances of the  sibling-disjoint collection type BiologicalSpecies, while neither  (genls Person Dog) nor (genls Dog Person) nor  (siblingDisjointExceptions Person Dog) is known to hold in that  context; consequently, (disjointWith Person Dog) holds by default  in BiologyMt.  Instances of SiblingDisjointCollectionType include  BiologicalTaxon (and its specializations), OrganismPartType, and RelationshipTypeByArity.\n<p>\nSee the generalization SiblingDisjointSetOrCollectionType.  Also cf. the stronger notion of DisjointCollectionType.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'SiblingDisjointAttributeType', "A collection of collections.  Each instance of SiblingDisjointAttributeType is a collection of quantities.  If COL is such a collection, then nothing can have two instances of COL as quantities unless those two instances are related in a quantitySubsumes relationship to each other.  See also SiblingDisjointCollectionType.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'SetTheFormat', "An instance of Format (q.v.) that can be specified to hold of a given predicate with respect to a given argument-place (see argFormat).  (argFormat PRED N SetTheFormat) means that, for any particular way of fixing the other arguments to PRED besides the Nth, there might be any number (including zero) of things such that, if taken as the Nth argument, PRED holds of those arguments.  For example, the format of biologicalMother's first argument-place is SetTheFormat, since a female animal might have any number of offspring.  Unlike the other reified instances of Format, SetTheFormat actually places no restriction at all on what PRED might or might not hold of with respect to the relevant argument-place.  But one should not infer from this that entry-format assertions using SetTheFormat are pointless; for they forestall duplication of effort by serving notice that the entry-format of a given argument-place has previously been considered and SetTheFormat was deemed the appropriate format.  SetTheFormat is the most commonly-encountered format in the Cyc Knowledge Base.  Contrast with SingleEntry.", 'BaseKB', vStrDef).
assertedTinyKB(comment, 'SetOrCollection', "A specialization of MathematicalThing.  Something is an instance of SetOrCollection just in case it is a collection (i.e. an instance of Collection) or a mathematical set (i.e. an instance of Set-Mathematical).  Instances of Set-Mathematical and instances of Collection (and thus instances of SetOrCollection) share some basic common features.  All instances of Collection and all instances of Set-Mathematical (and thus all instances of SetOrCollection) are abstract entities, lacking spatial and temporal properties.  Nearly all instances of Collection (except \"empty\" collections) and nearly all instances of Set-Mathematical (except the empty set; see TheEmptySet) have \"elements\" (i.e. instances or members; see elementOf); hence set-or-collections may stand to one another in generalized set-theoretic relations such as subsetOf and disjointWith (qq.v.).  (It is this shared feature of having elements that provides the basic rationale for reifying the collection SetOrCollection.)  Nevertheless, sets and collections differ in two important ways.  First, each collection is intrinsically associated with an intensional criterion for membership -- a more or less natural property (or group of properties) possessed by all of (and only) its elements.  Collections are thus akin to kinds.  In contrast, the elements of a set are not required to be homogeneous in any respect: any things whatsoever may together constitute the elements of a set.  The second major difference between sets and collections is that no two distinct sets can be coextensional (i.e. have exactly the same elements; see coExtensional).  Sets can thus be identified purely on the basis of their extensions (see extent).  Collections, on the other hand, are individuated by their intensional criteria for membership.  So collections that have exactly the same elements might nevertheless be distinct, differing in their respective membership criteria.  (Note that the general relationship between collections and their \"intensional criteria for membership\" in the above sense is not something that is currently represented explicitly in the Knowledge Base (though this seems a worthwhile area for future work); still the comment and other \"definitional\" assertions on a given collection should ideally convey a reasonably clear and precise idea of its associated membership criterion.)", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'Set-Mathematical', "A specialization of SetOrCollection (q.v.); the collection of mathematical sets.  An instance of Set-Mathematical can be any arbitrary set of Things.  A good way to explain this notion with respect to the Cyc ontology is to contrast Set-Mathematical with Collection (q.v.).  First, while the instances of a given collection all have some more-or-less significant (often \"natural\") property or properties in common, the elements (see elementOf) in a given set might have nothing in common (besides membership in that set).  Second, while it is in principle possible for two distinct collections to have exactly the same elements (with respect to a given context), this cannot happen in the case of sets, which are individuated strictly in terms of their extensions (see extent).  Third (and specifically regarding their expression in the CycL language), unlike with collections, rarely will it be desirable to create a new constant to denote a particular set.  Instead, a set will often be either (a) intensionally specified by a defining property via TheSetOf (q.v.), as in `(TheSetOf ?X (and (isa ?X Integer) (greaterThan ?X 42)))', or (b) extensionally specified by enumerating its elements via TheSet (q.v.), as in `(TheSet 3 4 5)'; see also ThePartition and TheCovering.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'September', "A specialization of CalendarMonth.  Each instance of September is the ninth month of a particular year in the GregorianCalendar (q.v.).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'SententialRelation', "A collection of mathematical objects.  Each instance of SententialRelation is by definition either a LogicalConnective or a Quantifier.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'ScopingRelation', "A specialization of Relation whose instances are used to determine a \"scope\" with respect to one or more variables and to bind any free occurrences of those variables that are inside that scope.  Each instance of ScopingRelation takes as its arguments (at least) a variable or list of variables (see CycLVariable and CycLVariableList) and a formula (see CycLExpression-Assertible).  The former argument is the scoping relation's \"scoping\" argument (see scopingArg), and the latter its \"scoped formula\" argument (see scopedFormulaArg).\n<p>\nSyntactically, the formula (SCOPINGRELN VAR SENT) might either be a sentence or a non-atomic term (see CycLNonAtomicTerm), depending on which ScopingRelation it is built from.  Suppose for simplicity that the sentence SENT itself contains no ScopingRelation expressions, so that any variables occurring in SENT are not bound (i.e. they are _free_).  Then, in the formula (SCOPINGRELN VAR SENT), the _scope_ of the occurrence of the term SCOPINGRELN is SENT, and any free occurrence of the variable VAR in SENT is said to be _bound_ by that occurrence of SCOPINGRELN, and thus is bound (and hence not free) with respect to the entire formula.  (The occurrence of VAR immediately to the right of SCOPINGRELN is also considered bound with respect to the entire formula.)\n<p>\nSemantically, if the formula (SCOPINGRELN VAR SENT) is _closed_ (i.e. if it contains no free occurrence of any variable), then it will in some sense be \"about\" the value(s) of VAR that satisfy SENT.  That is, if (SCOPINGRELN VAR SENT) is a closed sentence it will state something about those values, while if (SCOPINGRELN VAR SENT) is a closed NAT it will (purport to) denote something related to those values.  For an example of the former case see thereExists; for the latter case see TheSetOf.  (If there are no free occurrences of VAR inside SENT, then (SCOPINGRELN VAR SENT) is a \"vacuous\" application of SCOPINGRELN that means exactly what SENT means.)\n<p>\nInstances of ScopingRelation include all of the Quantifiers and Lambda.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'ScalarPointValue', "A specialization of ScalarInterval (q.v.).  Each instance of ScalarPointValue is a specific number or quantity, as opposed to a range of numbers or quantities (cf. ScalarProperInterval).  Instances of ScalarPointValue include all reals numbers and other Number-Generals (q.v.), as well as specific instances of Quantity such as (Meter 3) and (SecondsDuration 10).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'ScalarInterval', "A specialization of TupleOfIntervals (q.v.).  Roughly put, this is the collection of all things that can be ranked according to some one-dimensional scale.  Instances of ScalarInterval are numbers or quantities possessing only sign and magnitude.  They are construed as <i>one-tuples</i> (see Tuple) of intervals.  They are to be contrasted with VectorIntervals (q.v.), which possess a direction as well as a magnitude, and are construed as two-membered tuples of intervals.\n<p>\nScalarInterval is partitioned into the two collections NumericInterval (which is the collection of numbers and number-ranges of all kinds) and Quantity (qq.v).  A Quantity is usually specified with a numeric-interval, as with (Meter 3)), but it might also be given in a generically-ranked way, as with (HighAmountFn Happiness); see the specializations MeasurableQuantity and NonNumericQuantity.  The magnitude of a scalar might be given by a specific number (see ScalarPointValue) or by a proper range of numbers (see ScalarProperInterval).\n<p>\nNote that the instances of MathematicalFunctionOnScalars (q.v.), which include artithmetic functions such as addition (see PlusFn) and division (see QuotientFn), are defined broadly so as to apply not only to numbers, but to (numerically-measured) scalar intervals generally.  Thus (PlusFn (Meter 3) (Meter 5)) is equal to (Meter 8).", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'ScalarIntegralValue', "A specialization of ScalarPointValue (q.v.).  Each instance of ScalarIntegralValue is either an Integer or a MeasurableQuantity  (q.v.) that is the value returned when some UnitOfMeasure (q.v.) function is applied to an Integer.  In the latter case, the quantity is said to be \"integral with respect to\" that unit-of-measure (see integralWRTUnit).\n<p>\nFor example, both 6 and (Inch 6) are scalar integral values.  The latter is integral with respect to Inch.\n<p>\nScalarIntegralValues are the admitted arguments for, and the values returned by, GreatestCommonDivisorFn and LeastCommonMultipleFn (qq.v.).\n<p>\nNote that, despite appearances to the contrary, (Foot-UnitOfMeasure 0.5) is a scalar integral value that is integral with respect to Inch, as it is equal to the scalar integral (Inch 6).  It might even be argued that, in principle, <i>every</i> MeasurableQuantity is integral with respect to some (reified or not) unit-of-measure or other.  But that is a contentious issue on which we need not take sides.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'Saturday', "A collection of CalendarDays and an \ninstance of DayOfWeekType.  Saturday is the collection of all \n(and only) saturdays.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'RuleTemplate', "Terms denoting formulas (typically without support for efficient inference) that can be (partially) instantiated as Cyc assertions (typically with support for efficient inference); see trueRule and ruleTemplateAssertion.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'RoundUpFn', "An instance of EvaluatableFunction.  When applied to an instance INTERVAL of ScalarInterval, RoundUpFn returns an instance ROUNDED-INTERVAL of ScalarInterval in which the minimum and maximum ranges of INTERVAL have been rounded upwards to integer values.  For example, (RoundUpFn (Meter 2.5 5.2)) is (Meter 3 6).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'RoundDownFn', "(RoundDownFn QUANTITY) converts QUANTITY into one where the maximum and minimum ranges have been rounded downwards to integer values.  For example, (RoundDownFn (Meter 2.5)) denotes (Meter 2).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'RoundClosestFn', "(RoundClosestFn QUANTITY) converts QUANTITY into one where the maximum and minimum ranges have been rounded to the closest integer values.  For example,  (RoundClosestFn (Meter 2.41)) denotes (Meter 2),  (RoundClosestFn (Meter 2.7)) denotes (Meter 3), and (RoundClosestFn (Meter 1.6 4.2)) denotes  (Meter 2 4). If QUANTITY is exactly between two integers (that is, in the form integer+0.5), then it is rounded to the one that is even. So, (RoundClosestFn (Meter 2.5)) denotes (Meter 2), and (RoundClosestFn (Meter 7.5)) denotes (Meter 8). See also RoundUpFn, RoundDownFn.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'RemovalModuleSupportedPredicate-Specific', "The collection of all Predicates which are supported by some CycRemovalModule-Specific.  Sentences of the form (PRED . ARGS), where PRED is an instance of RemovalModuleSupportedPredicate-Specific, have special inference support.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'RemovalModuleSupportedPredicate-Generic', "The collection of all Predicates which are supported by some CycRemovalModule-Generic.  An assertion of the form (PRED . ARGS), where PRED is an instance of RemovalModuleSupportedPredicate-Generic, may affect the provability of sentences other than just sentences whose predicate is PRED.  This is what is meant by 'generic' in this sense.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'RemovalModuleSupportedCollection-Generic', "The collection of all Collections which are supported by some CycRemovalModule-Generic.  An assertion of the form (isa INS COL), where COL is an instance of RemovalModuleSupportedCollection-Generic, may affect the provability of sentences that do not mention COL explicitly.  In particular, it may affect the provability of sentences mentioning INS.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'RelaxArgTypeConstraintsForVariables', "A CanonicalizerDirective  (q.v.) that directs the CycCanonicalizer (specifically, the  CycWellFormednessChecker) to relax the argument-type constraints it usually imposes on variables.  For example, this canonicalizer directive  would allow the sentence `(and (isa ?X Collection) (isa ?X Individual))'  to be admitted, though it would otherwise be rejected as ill-formed due to  the mutually disjoint argument-type constraints (see ArgTypePredicate) on the positions occupied by the two occurrences of the variable `?X'.", 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(comment, 'RelationInstanceExistsFn', "(relationInstanceExists PRED THING COLL) says that THING stands in the relation PRED to some (not necessarily known) instance of the Collection COLL. (RelationInstanceExistsFn PRED THING COLL) denotes this instance of COLL.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'RelationExistsInstanceFn', "(relationExistsInstance PRED COLL THING) says that some (not necessarily known) instance INS of the Collection COLL stands in the relation PRED to THING. (RelationExistsInstanceFn PRED COLL THING) denotes INS.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'RelationExistsAllFn', "The predicate relationExistsAll states that for every instance of a collection, some other term exists in a certain relationship.  An arbitrary such term is a function of the instance, the predicate, the collection, and the type of the other term.  (RelationExistsAllFn TERM PRED DEP-COL INDEP-COL) allows one to denote this `arbitrary such term that so exists' in a named fashion.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'RelationAllExistsFn', "An IndeterminateTermDenotingFunction (q.v.) that is closely related to relationAllExists.  If both (relationAllExists PRED INDEP-COL DEP-COL) and (isa INDEP-INS INDEP-COL) hold,  then (PRED INDEP-INS (RelationAllExistsFn INDEP-INS PRED INDEP-COL DEP-COL) also holds.  Thus the term '(RelationAllExistsFn INDEP-INS PRED INDEP-COL DEP-COL)' \"indeterminately denotes\" some instance of DEP-COL that is related to INDEP-INS by PRED.  For instance, since (relationAllExists citizens Country Person) and (isa Malaysia Country) both hold, so does (citizens Malaysia (RelationAllExistsFn Malaysia citizens Country Person)).", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, tRelation, "A specialization of MathematicalObject and the collection of all relations.  Each instance of Relation is a relation that can hold among one or more things, depending on whether the relation is unary, binary, ternary, or whatever (see arity and relationalArity).  A unary relation (such as unknownSentence) is a sort of degenerate case that holds of  certain individual things (in this case, all sentences that are unknown to Cyc).  A binary relation (such as likesAsFriend) relates one thing to another (in this case, it relates one sentient animal to another just in case the first likes the second).  A ternary relation relates certain triples of things.  And so on.  There are also relations of no particular fixed arity; see VariableArityRelation.\n<p>\nNames of relations can be used to construct sentences and other formulas.  More precisely, CycL terms that denote Relations can appear in the \"0th\" argument (or \"arg0\") position of a CycLFormula (q.v.), i.e. as the term immediately following the formula's opening parenthesis.\n<p>\nAn important subcollection of Relation is TruthFunction (q.v.), whose instances are intimately related to truth-values, as reflected in the fact that the CycL expressions that denote truth-functions can appear in the arg0 position of a CycLSentence; and a sentence (if quantificationally closed; see CycLClosedSentence), will generally be either true or false (with respect to a given context or interpretation).  The major subcollections of TruthFunction are Predicate, LogicalConnective, and Quantifier (qq.v.).\n<p>\nAnother important subcollection of Relation is Function-Denotational (q.v.), the collection of all functions.  A CycL term that denotes a function can appear in the arg0 position of a CycLNonAtomicTerm (q.v.).\n<p>\nSee also relationExtension and relationHoldsAmong.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'ReifiableFunction', "A specialization of Function-Denotational.   Each instance of ReifiableFunction is denoted by a CycL constant that can stand in the 0th (or \"arg0\") position in a CycLReifiableNonAtomicTerm  (q.v.).  For example, GovernmentFn is a reifiable function, so the term  `(GovernmentFn France)' is a reifiable non-atomic term (or \"NAT\").   And since this particular term actually _is_ reified in the Cyc Knowledge  Base, it is, more specifically, a CycLNonAtomicReifiedTerm (or \"NART\").   The NART `(GovernmentFn France)' is treated more or less the same as if  it were a CycL constant (named, say, `GovernmentOfFrance').  Similary, the constant for GovernmentFn can be applied to the constant (or other  reified or reifiable term) for _any_ instance of GeopoliticalEntity to form a reifiable NAT that denotes that region's government; and should this NAT appear in a sentence that is asserted to the KB, it will thereby become a NART. Note, however, that not all NATs are such that it is desireable that  they should become reified (i.e. become NARTs) if they appear in  assertions; for more on this see UnreifiableFunction.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'ReformulatorIrrelevantFORT', "The collection of Cyc FORTs that are not relevant to the reformulator.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'ReformulatorHighlyRelevantFORT', "The collection of Cyc FORTs that are highly relevant to the reformulator.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'ReformulatorHighlyRelevantFORT', "The collection of Cyc FORTs that are highly relevant to the reformulator.           An example of such a FORT would be one that is referenced in a large           number of reformulator rules in the KB (see intances of            CycLReformulationRulePredicate).", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'ReformulatorDirectivePredicate', "The collection of Predicates which can affect the\nbehaviour of the CycLReformulator or its submodules.  When\nreformulator directive GAFs are asserted, they are only relevant to\nthe reformulator when it is reformulating expressions in the\nmicrotheory in which the directive is asserted, or a specMt thereof.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'ReformulationNeitherDirection', "A meta-property of a CycLReformulatorDirective,\nmeaning that no arg is to be interpreted as either the 'from' or 'to' arg.\nSee reformulationDirectionInMode for how this\ndirection can be used.", 'BaseKB', vStrMon).
assertedTinyKB(comment, 'ReformulationForwardDirection', "A meta-property of a CycLReformulatorDirective, meaning\nthat there exist two arguments in the directive such that the\nlower-numbered arg (e.g. arg1 for a binary predicate) is the 'from'\narg, the input to the reformulator, and that the higher-numbered arg\n(e.g. arg2 for a binary predicate) is the 'to' arg, the output of the\nreformulator.  Its semantics are more fully determined by context.\nThis is the default preferredReformulationDirection for\nreformulatorRules.  See reformulationDirectionInMode for how this\ndirection can be used.", 'BaseKB', vStrMon).
assertedTinyKB(comment, 'ReformulationBackwardDirection', "A meta-property of a CycLReformulatorDirective, meaning\nthat there exist two arguments in the directive such that the\nhigher-numbered arg (e.g. arg2 for a binary predicate) is the 'from'\narg, the input to the reformulator, and that the lower-numbered arg\n(e.g. arg1 for a binary predicate) is the 'to' arg, the output of the\nreformulator.  Its semantics are more fully determined by context.\nSee reformulationDirectionInMode for how this\ndirection can be used.", 'BaseKB', vStrMon).
assertedTinyKB(comment, 'ReflexiveBinaryPredicate', "The specialization of BinaryPredicate whose instances are reflexive relations.  A reflexive binary predicate relates anything that meets the predicate's argument constraints to that thing itself.  Typically, a reflexive predicate has precisely the same constraints on both of its argument-places.\n<p>\nMore precisely: a binary predicate <code>PRED</code> is an instance of ReflexiveBinaryPredicate if and only if both (i) for every <code>X</code> that satisfies the constraints on (i.e is an admittedArgument for) <i>both</i> argument-places of <code>PRED</code>, <code>(PRED X X)</code> holds and (ii) <code>PRED</code>'s two argument-places are \"co-satisfiable\" with respect to their (single-argument) type constraints (see cosatisfiableInArgs and NoteOnArgumentCosatisfiabilityRequirement).\n<p>\nInstances of ReflexiveBinaryPredicate include physicalParts, inRegion, genls, and equals.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'RealNumber', "The collection of real numbers; a specialization of both  IntervalOnNumberLine and ScalarPointValue (qq.v.).  Each  instance of RealNumber is a single point on the real number  line, which has no upper or lower bounds.  Specializations  of this collection include Integer, RationalNumber, and  NegativeNumber.  Note that RealNumber is also a specialization  of ComplexNumber (q.v.), and any instance of the former  constitutes a degenerate case of the latter, in that the value  along the real's \"imaginary axis\" is zero (cf. ImaginaryNumber).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'QuotientFn', "An instance of both BinaryFunction and EvaluatableFunction.  When applied to an instance DIVIDEND of ScalarInterval and an instance DIVISOR of ScalarInterval, QuotientFn returns an instance of ScalarInterval that is the result of dividing DIVIDEND by DIVISOR.  For example, (QuotientFn 24 6) is 4, (QuotientFn (Meter 3) (SecondsDuration 2)) is (MetersPerSecond 1.5) (i.e., 1.5 meters per second), and (QuotientFn (SecondsDuration 2) (Meter 3)) is ((PerFn SecondsDuration Meter) 0.6666666666666666) (i.e., 0.6666666666666666 seconds per meter).  Note that (QuotientFn DIVIDEND 0) is undefined for any instance DIVIDEND of ScalarInterval.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'Quote', "The symbol 'Quote' is used in CycL as a device for referring to particular CycL expressions, in much the same way that quotation marks are often used in English in order to \"mention\" (rather than simply \"use\") an English word or phrase.  (And in much the same way that single-quotes are used in the preceding sentence in order to refer to a particular CycL symbol.)  If <code>EXPR</code> is a CycL expression, the term <code>(Quote EXPR)</code> -- formed by writing 'Quote' followed by <code>EXPR</code> and enclosing the result in parentheses -- is interpreted as denoting <code>EXPR</code> itself, as opposed to whatever it is (if anything) that <code>EXPR</code> ordinarily denotes (i.e. what it denotes when not inside the scope of <code>Quote</code> or in a quotedArgument position).  For example, while the CycL constant <code>Plato</code> denotes a certain Greek philosopher, the compound expression <code>(Quote Plato)</code> denotes the term <code>Plato</code> itself.  Similarly, the expression <code>(Quote <b>?X</b>)</code> denotes the variable <code><b>?X</b></code>, and the expression <code>(Quote (isa Plato Philosopher))</code> denotes the sentence <code>(isa Plato Philosopher)</code>.\n<p>\n<code>Quote</code> is also used in conjunction with the symbol <code>EscapeQuote</code> (q.v.), as a device for making <i>general</i> statements about CycL expressions.  Let <code>EXPR = (E<sub>1</sub>...E<sub>n</sub>)</code> be a well-formed CycL expression whose <b>n</b> immediate constituents are the CycL expressions <code>E<sub>1</sub></code>, ..., and <code>E<sub>n</sub></code> (where <b>n</b> >= 1).  The expression \n<pre>\n  (Quote EXPR) = (Quote (E<sub>1</sub>...E<sub>n</sub>))\n</pre> \n-- consisting of the symbols <code>Quote</code>, <code>EXPR</code>, and a surrounding pair of parentheses -- is a term that denotes <code>EXPR</code>.  The expression (call it <i><b>EQ</b></i>) \n<pre>\n  (Quote (E<sub>1</sub>...(EscapeQuote E<sub>i</sub>) ...E<sub>n</sub>)\n</pre> \n(where 1 <= <b>i <= n</b>) is a term whose meaning is similar to <code>(Quote EXPR)</code>, except that any free occurrence of a variable in <code>E<sub>i</sub></code> remains free with respect to <b>EQ</b> as a whole.  If <code>E<sub>i</sub></code> contains no free variables, then <b>EQ</b> is a closed term (see CycLClosedDenotationalTerm) that denotes <code>EXPR</code>, and is equivalent to <code>(Quote EXPR)</code>.  If <code>E<sub>i</sub></code> does contain free variables, then <b>EQ</b> is an open term (see CycLOpenDenotationalTerm) in which exactly the same variables occur free; and any closed instantiation of <b>EQ</b> denotes the corresponding instantiation of <code>EXPR</code>.  (A <i>closed instantiation</i> of an open expression is any <i>closed</i> expression that results from simultaneously replacing each free occurrence of a variable in the open expression with some closed term, replacing any two occurrences of the same variable by the same closed term.)\n<p>\nFor a simple example, the variable <code><b>?X</b></code> occurs free in the term\n<pre>\n  (Quote (EscapeQuote (MotherFn <b>?X</b>)) ;\n</pre>\nand one instantiation of this is the closed term\n<pre>\n  (Quote (EscapeQuote (MotherFn Plato)) ,\n</pre>\nwhich denotes the non-atomic term <code>(MotherFn Plato)</code>.  \n<p>\nFor a more interesting example, consider a case where <i>some but not all</i> of the free variables in a term are quoted.  In the expression\n<pre>\n  (Quote (loves (EscapeQuote <b>?X</b>) <b>?Y</b>))\n</pre>\nonly <code><b>?X</b></code> occurs free -- the <code><b>?Y</b></code> is quoted. Thus this instantiation of the above:\n<pre>\n  (Quote loves (EscapeQuote Plato) <b>?Y</b>)\n</pre>\nis a closed term that denotes the <i>open</i> formula <code>(loves Plato <b>?Y</b>)</code>.  \n<p>\nNote that the sort of quotation done in the first example above can also be done -- and done more elegantly -- using just QuasiQuote instead of Quote and EscapeQuote.  But the sort of quotation done in the second example cannot be accomplished with QuasiQuote.\n<p>\nSee also QuasiQuote, EscapeQuote, denotes, quotedIsa, quotedArgument, NoteAboutQuotingInCycL, and NoteAboutSyncategorematicSymbols.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'QuintaryRelation', "The collection of all fixed-arity relations of arity 5 (see arity).  The most notable specializations of QuintaryRelation are QuintaryPredicate and QuintaryFunction (qq.v.).", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'QuintaryPredicate', "A specialization of Predicate and QuintaryRelation.  QuintaryPredicate is the collection of all predicates whose arity (see arity) is 5.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'QuintaryFunction', "A specialization of both QuintaryRelation and Function-Denotational. An instance of Function-Denotational FUNC is an instance of QuintaryFunction if and only if FUNC has an arity of 5.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'QueryMt', "The instance of IndexicalConcept used specifically for referring to 'the microtheory in which this particular query is being run'.  This allows for a certain amount of reflection in queries, since it allows one to pose a query about the Microtheory of the very same Ask.  It is useful for cases where one wants to obtain certain facts about the context of an Ask without specifying anything more about that context.", 'BaseKB', vStrMon).
assertedTinyKB(comment, 'QuaternaryRelation', "The collection of all fixed-arity relations of arity 4 (see arity).  The most notable specializations of QuaternaryRelation are QuaternaryPredicate and QuaternaryFunction (qq.v.).", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'QuaternaryPredicate', "A specialization of both QuaternaryRelation and Predicate.   QuaternaryPredicate is the collection of all predicates whose arity (see arity) is 4.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'QuaternaryFunction', "A specialization of both FixedArityFunction and QuaternaryRelation (qq.v.).  Each instance of QuaternaryFunction is a function that always takes four arguments at a time, i.e. has the arity (see arity) 4.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'QuasiQuote', "A quotation device for making general statements about CycL expressions.  QuasiQuote allows for any free variables occurring inside an expression to which it is applied to \"escape\" (i.e. remain free with respect to) the quotation.  It is thus similar in function to, though less flexible than, the combination of Quote and EscapeQuote (qq.v.).\n<p>\nTo be more precise: the syncategorematic symbol <code>QuasiQuote</code> is a device for allowing genuinely free variables to occur inside quoted expressions, in order that one may meaningfully \"quantify into\" such expressions and thereby <i>generalize</i> over them.  It can thus be instructively compared to the symbol <code>Quote</code> (q.v.), which is used to make statements about <i>particular</i> CycL expressions.  Let <code>EXPR</code> be a well-formed CycL expression.  The expression <code>(Quote EXPR)</code> -- consisting of the symbols <code>Quote</code>, <code>EXPR</code>, and a surrounding pair of parentheses -- is a term that denotes <code>EXPR</code>.  The expression <code>(QuasiQuote EXPR)</code> is a term whose meaning is similar to <code>(Quote EXPR)</code>, except that any free occurrence of a variable in <code>EXPR</code> remains free with respect to <code>(QuasiQuote EXPR)</code> as a whole.  If <code>EXPR</code> contains no free variables, then <code>(QuasiQuote EXPR)</code> is a closed term (see CycLClosedDenotationalTerm) that denotes <code>EXPR</code>, and is equivalent to <code>(Quote EXPR)</code>.  If <code>EXPR</code> contains any free occurrences of variables, then <code>(QuasiQuote EXPR)</code> is an open term (see CycLOpenDenotationalTerm) in which exactly the same variables occur free; and any closed instantiation of <code>(QuasiQuote EXPR)</code> denotes the corresponding instantiation of <code>EXPR</code>.  (A <i>closed instantiation</i> of <code>EXPR</code> is any closed expression that results from replacing each free occurrence of a variable in <code>EXPR</code> with some closed term, and replacing any two occurrences of the same variable by the same closed term.)\n<p>\nFor an example, the variable <code>?X</code> occurs free in the term\n<pre>\n  (QuasiQuote (MotherFn ?X)) ;\n</pre>\nand one instantiation of this is the closed term\n<pre>\n  (QuasiQuote (MotherFn Plato)) ,\n</pre>\nwhich denotes the non-atomic term <code>(MotherFn Plato)</code>.  And the (implicitly quantified) rule\n<pre>\n  (isa (QuasiQuote (MotherFn ?X)) CycLNonAtomicTerm)\n</pre>\nmeans, in effect, that any closed instantiation of the open term <code>(MotherFn ?X)</code> -- e.g. <code>(MotherFn Plato)</code> -- is a non-atomic term of CycL.\n<p>\nSee also denotes, quotedIsa, quotedArgument, NoteAboutQuotingInCycL, and NoteAboutSyncategorematicSymbols.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'QuantityConversionFn', "(QuantityConversionFn UNIT QUANTITY) converts QUANTITY into an equivalent quantity expressed using UNIT as the unit of measure.  For example, (QuantityConversionFn Inch (Foot-UnitOfMeasure 2)) denotes (Inch 24).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'Quantifier', "A specialization of SententialRelation and ScopingRelation (qq.v.).  Each instance of Quantifier takes as its arguments (at least) a variable (see CycLVariable) and a sentence (see CycLSentence-Assertible), and is used to make a certain kind of generic quantitative statement regarding the things that satisfy the sentence.  Typically, the variable VAR will occur free in the sentence SENT, and in the quantified sentence (QUANT VAR SENT ...) these occurrences of VAR are bound by that occurrence of QUANT.  (If VAR does not occur free in SENT, then the quantified sentence is a \"vacuous quantification\" that is equivalent to SENT by itself.  For the definitions of 'free' and 'bound' occurrences of variables, see ScopingRelation.)  For example, '(thereExists ?X (isa ?X Dog))' means that there exists at least one dog.  Other instances of Quantifier are forAll, thereExistExactly, thereExistAtLeast, and thereExistAtMost.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'ProblemSolvingCntxt', "A specialization of Microtheory.\nProblemSolvingCntxts are microtheories that are used to reason about \nparticular situations.  Queries posed in ProblemSolvingCntxts are\nexpected to draw -- via the genlMt relation -- on a large number\nof other microtheories.  A ProblemSolvingCntxt is usually created \nfor temporary use with a problem at hand, and is discarded after the \nproblem is dealt with.  In contrast, a GeneralMicrotheory (q.v.), e.g., \nis created for lasting use.  Specializations of ProblemSolvingCntxt \ninclude ParsingContext and ScenarioTestingMicrotheory.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'prettyString-Canonical', "(prettyString TERM STRING) means that STRING is the English word or expression (sequence of words) commonly used to refer to TERM.  The predicate prettyString is used by the code which generates CycL to English paraphrases, but its applicability is not restricted to this use.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'PredicateTypeByArity', "A collection of collections.  Each instance of PredicateTypeByArity is a collection of Predicates having the same arity.  Instances include UnaryPredicate, BinaryPredicate, and TernaryPredicate.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, tPred, "A specialization of TruthFunction (q.v.).  Each instance of Predicate is either a property of things (see UnaryPredicate) or a relationship holding between two or more things.  Like other truth-functions, predicates, or rather the expressions that represent or denote them, are used to form sentences.  More precisely, any CycL expression that denotes an instance of Predicate (and only such an expression) can appear in the \"0th\" (or \"arg0\") position (i.e. as the term following the opening parenthesis) of a CycLAtomicSentence (q.v.).  Important specializations of Predicate include UnaryPredicate, BinaryPredicate, TernaryPredicate, QuaternaryPredicate, and QuintaryPredicate.  Note that, despite its name, Predicate is a collection of <i>relations</i>, and not a collection of expressions that represent or denote such relations.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'PositiveInteger', "A specialization of Integer.  An instance INT of Integer is an instance of PositiveInteger just in case INT is an integer greater than 0.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'PlusFn', "A variable-arity MathematicalFunctionOnScalars that is an extension of the arithmetical operation of addition to measurable ScalarIntervals (q.v.) generally.  Where  <code>ADDEND1</code>, ..., and <code>ADDENDn</code> are pairwise numericallyComparable (q.v.), <code>(PlusFn ADDEND1 ... ADDENDn)</code> is the arithmetic sum of <code>ADDEND1</code>, ..., and <code>ADDENDn</code>.  For example, (PlusFn 2 3 4) is 9, and (PlusFn (Meter 1.5) (Meter 0.7)) is (Meter 2.2).\n<p>\nNote that the term <code>(PlusFn ADDEND1 ... ADDENDn)</code> is undefined if there are <code>ADDENDi</code> and <code>ADDENDj</code> (1 <code><= i,j <= n)</code> that are not comparable.  For example, <code>(PlusFn (MinutesDuration 1) (Meter 3))</code> is undefined, since (MinutesDuration 1) is a Time-Quantity and (Meter 3) is a Distance, and time-quantities are not comparable with distances.\n<p>\nFor subtraction, see DifferenceFn.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'PlusAll', "A NumericQuantifier function that takes a SetOrCollection and a UnaryFunction as its arguments. (PlusAll <b>SETORCOL FUNC</b>) is the result of adding up the results of successively applying <b>FUNC</b> to each element of <b>SETORCOL</b>.  For example:\n<pre>\n    (PlusAll (TheSet 4 9) SquareRootFn)\n  = (PlusFn (SquareRootFn 4) (SquareRootFn 9))\n  = (PlusFn 2 3)\n  = 5.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'PerFn', "A binary UnitOfMeasureDenotingFunction (q.v.) that takes two UnitOfMeasure (q.v.) functions and returns a UnitOfRatio (q.v.) composed of them.  <code>(PerFn UNIT1 UNIT2)</code> is a unit <code>RATIO-FN</code> for measuring the ratio of <code>UNIT1</code> units to <code>UNIT2</code> units.   That is, for any number or other NumericInterval <code>NUM</code>, <code>(RATIO-FN NUM)</code> = <code>(QuotientFn (UNIT1 NUM) (UNIT2 1))</code>.\n<p>\nFor example, (PerFn Meter SecondsDuration) is a UnitOfSpeed function that measures meters-per-second.  When applied to (e.g.) the integer 20, this unit-of-speed returns the particular Speed equal to\n<pre>\n  (QuotientFn (Meter 20) (SecondsDuration 1))\n</pre>\nor 20 meters-per-second.\n<p>\nNote that <code>UNIT1</code> and <code>UNIT2</code> must <i>not</i> be interconvertibleUnits (q.v.), or <code>(PerFn UNIT1 UNIT2)</code> is undefined.  Otherwise, <code>UNIT1</code> and <code>UNIT2</code> would effectively \"cancel each other out\", and the value returned by PerFn for those arguments would not be a UnitOfRatio.\n<p>\nSee also UnitProductFn.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'Percent', "A variable-arity MathematicalFunctionOnScalars (q.v.).  When applied to a number or other NumericInterval (pair of numeric-intervals), Percent returns the instance of IntervalOnNumberLine that is its argument (the interval between its two arguments) divided by 100.  For example (Percent 110) is 1.1, and (Percent 10 20) is (Unity 0.1 0.2): the interval between 0.1 and 0.2 inclusive.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'PartiallyCommutativeRelation', "An instance of RelationTypeByLogicalFeature (q.v.) and a specialization of AtLeastPartiallyCommutativeRelation.  Each instance  of PartiallyCommutativeRelation <code>PARTCOMRELN</code> is a predicate or function that is commutative in some, but not all, of its argument-places (see  commutativeInArgs).  More precisely, suppose for example that <code>PARTCOMRELN</code> is a predicate (function) that is commutative only in its odd-numbered  argument-places, and that <code>PARTCOMRELN</code> holds among (has the value <code>VAL</code> for) a given sequence of arguments <code>SEQ</code>.  It follows that <code>PARTCOMRELN</code> also holds among (has the same value <code>VAL</code> for) any other sequence <code>SEQ-PRIME</code> obtainable from <code>SEQ</code> by permuting some or all of the odd-numbered members of <code>SEQ</code> while keeping all of its even-numbered members fixed.\n<p>\nNote that <code>PARTCOMRELN</code> must  have an arity (see arity) of at least three and <i>cannot</i> be an instance of CommutativeRelation (as any instance of the latter is commutative in <i>all</i> of its argument-places).\n<p>\nInstances of PartiallyCommutativeRelation include pathsJoinAt, formsBorderBetween, and BlockOfStreetBetweenFn.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'October', "A specialization of CalendarMonth.  Each instance of October is the tenth month of a particular year in the GregorianCalendar (q.v.).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'November', "A specialization of CalendarMonth. Each instance of November is the eleventh month of a particular year in the GregorianCalendar (q.v.).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'NonNegativeScalarInterval', "A specialization of ScalarInterval.  An instance INTERVAL of ScalarInterval is also an instance of NonNegativeScalarInterval just in case INTERVAL is a non-negative number or quantity.  Instances of NonNegativeScalarInterval include all instances of NonNegativeNumber (q.v.), as well as non-negative quantities such as (Meter 212), (Kilogram 5), and (SecondsDuration 0).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'NonNegativeInteger', "NonNegativeInteger is the sub-collection of Integer that excludes the negative integers.  Each instance of NonNegativeInteger is a whole number greater than or equal to zero -- for example, 0, 1, 2, 3, ....", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'Multigraph', "An instance of PathSystemType-Structural and a subcollection of PathSystem.  Each instance of Multigraph is an instance of PathSystem in which the only points are nodes in the system and all paths are made of links (i.e., no intermediate points along links). Sometime such a system is called a graph or multi-graph in graph theory.  A Multigraph consists of nodes interconnected by links, with loops on single nodes allowed, and with multiple links between the same two nodes also allowed.  (For a graph with no parallel links and no loops, see SimpleGraph-GraphTheoretic.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'MtUnionFn', "(MtUnionFn . MTS) denotes the ProblemSolvingCntxt where each of MTS and all of their genlMts are relevant.  This microtheory effectively contains all of the assertions from all of MTS, regardless of any contradictions.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'MtTimeWithGranularityDimFn', "An unreifiable BinaryFunction that takes a TimeInterval and a TimeParameter and returns a TemporalMicrotheory.  <code>(ist (MtTimeWithGranularityDimFn INTERVAL PAR) ASSERTION)</code> holds just in case <code>ASSERTION</code> holds at <code>INTERVAL</code> to granularity <code>PAR</code>.  See also MtTimeDimFn.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'MtTimeDimFn', "An unreifiable UnaryFunction that takes a TimeInterval and returns a TemporalMicrotheory.  <code>(ist (MtTimeDimFn INTERVAL) ASSERTION)</code> holds just in case <code>ASSERTION</code> holds at <code>INTERVAL</code> to granularity Null-TimeParameter.  See also MtTimeWithGranularityDimFn.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'MtSpace', "(MtSpace MT-1 ... MT-N) denotes the microtheory whose set of domain assumptions is the union of the assertions true in each of MT-1 ... MT-N. Consequently, (MtSpace MT-1 ... MT-N) has each of MT-1 ... MT-N as one of its genlMts. Typically, but not always, there will be assertions true in (MtSpace MT-1 ... MT-N) that are not true in any of its genlMts. For example,\n<p>\n(MtSpace WorldHistoryMt (MtDim mtTimeIndex (YearFn 1790)))\n<p>\ndenotes the microtheory whose domain assumption are precisely those of the WorldHistoryMt (whose basic assumption is that we are in the context of actual world history) and those of the microtheory (MtDim mtTimeIndex (YearFn 1790)) (whose basic assumption is that 1790 is the present year -- see MtDim). The conjunction of these domain assumptions implies everything that is true in real world history in the year 1790. For example, these domain assumptions imply that (president UnitedStatesOfAmerica GeorgeWashington) is true. Consequently, this assertion is true in (MtSpace WorldHistoryMt (MtDim mtTimeIndex (YearFn 1790))).", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'MonthOfYearType', "A collection of Collections.\nInstances of MonthOfYearType are the canonical subcollections of CalendarMonth.  There are twelve of these in the JulianCalendar; for example, September is the collection of all Septembers.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'MonotonicallyTrue', "An instance of CycHLTruthValue.  MonotonicallyTrue is the attribute of being indefeasibly true.", 'BaseKB', vStrDef).
assertedTinyKB(comment, 'MonotonicallyFalse', "An instance of CycHLTruthValue.  MonotonicallyFalse is the attribute of being indefeasibly false.", 'BaseKB', vStrDef).
assertedTinyKB(comment, 'Monday', "A collection of CalendarDays and an \ninstance of DayOfWeekType.  Monday is the collection of all \n(and only) mondays.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'ModuloFn', "A binary function that takes a scalar and a comparable (non-null) point-value scalar to another comparable scalar, ModuloFn is a generalization of a basic notion of modular arithmetic, broadened to apply to ScalarIntervals of all sorts.\n<p>\n(ModuloFn <code>SCALAR BASE</code>) is the value of <code>SCALAR</code> modulo <code>BASE</code>, determined as follows.  (i) If <code>SCALAR</code> and <code>BASE</code> are both positive or both negative values, <code>SCALAR-MOD-BASE</code> is the remainder left when <code>BASE</code> is successively subtracted from <code>SCALAR</code> (zero or more times) until the result is a value that is closer to the comparable null-value (see ScalarNullValue) than <code>BASE</code> is.  (ii) If <code>SCALAR</code> and <code>BASE</code> differ in their numeric signs, <code>SCALAR-MOD-BASE</code> is the remainder left when <code>BASE</code> is successively <i>added</i> to <code>SCALAR</code> (zero or more times) until the result is a value <i>whose numeric sign agrees with that of</i> <code>BASE</code> or is null, and which is closer to the comparable null-value than <code>BASE</code> is.  (iii) If <code>SCALAR</code> is already a null-value, <code>SCALAR-MOD-BASE</code> is just <code>SCALAR</code> itself.  \n<p>\nFor example, (ModuloFn 8 3) = 2, (ModuloFn (Meter 9) (Meter -4)) = (Meter -3), and (ModuloFn (Inch -12) (Inch -4)) = (Inch 0).\n<p>\nNote that in case (i) above, if the absolute value of <code>SCALAR</code> is any value lessThan the absolute value of <code>BASE</code>, <code>SCALAR-MOD-BASE</code> is equal to <code>SCALAR</code>.  In all cases, if <code>SCALAR</code> numericallyEquals <code>BASE</code>, <code>SCALAR-MOD-BASE</code> is the comparable null-value.  In all cases, the numeric sign of the returned value <code>SCALAR-MOD-BASE</code> agrees with that of <code>BASE</code> (unless the returned value is null).  Also note that <code>(ModuloFn SCALAR BASE)</code> is undefined if <code>SCALAR</code> and <code>BASE</code> are not numericallyComparable (q.v.), or if <code>BASE</code> is null. \n<p>\nIn practice, <code>BASE</code> will usually be a positive integral value, and both <code>SCALAR</code> and the returned value will often be integral as well (see ScalarIntegralValue).  Note that if <code>SCALAR</code> and <code>BASE</code> are given in <i>different</i> (but comparable) UnitOfMeasures (e.g. Meter and (Centi Meter)), the result returned by Cyc will be given in the same units as <code>BASE</code>.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'MinRangeFn', "An instance of both VariableArityRelation and EvaluatableFunction.  When applied to instances <code>QUANTITY1</code>, ..., <code>QUANTITYN</code>  of ScalarInterval, MinRangeFn yields an instance of ScalarInterval that is the largest interval subsumed by each of <code>QUANTITY1</code> through <code>QUANTITYN</code>.  \n<p>\nFor example, (MinRangeFn  (Meter 1 3) (Meter 2 4)) is (Meter 2 3). \n<p>\nNote that if one of the instances <code>QUANTITY1</code>, ..., <code>QUANTITYN</code> fails to intersect with at least one of the other instances, then the result of applying MinRangeFn to <code>QUANTITY1</code>, ..., <code>QUANTITYN</code> is undefined (for example, both (MinRangeFn (Meter 1 1.5) (Meter 2 4) (Meter 0 5)) and (MinRangeFn (SecondsDuration 3 5) (Meter 1 4)) are undefined).  See also MaxRangeFn.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'Minimum', "Computes the minimum of a unary function's values over all elements in a given set or collection.  That is, (Minimum SETORCOL FUNC) denotes the value of FUNC for the element ELEM of SETORCOL taken as argument (if any) such that (FUNC ELEM) is less than or equal to (FUNC OTHER) for any element OTHER of SETORCOL other than ELEM.  Note that (Minimum SETORCOL IdentityFn) denotes the minimum element of SETORCOL itself.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'MicrotheoryDesignatingRelation', "The collection of Relations which specify that a ELSentence-Assertible is to be interpreted in a given Microtheory.  It will be canonicalized and checked for well-formedness with respect to that microtheory. Each microtheory-designating relation has an argument which denotes a microtheory, and another argument which denotes a ELSentence-Assertible.  It may have other arguments as well. Use microtheoryDesignationArgnum and sentenceDesignationArgnum to specify these argument positions for each microtheory-designating relation.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'Microtheory', "A specialization of AspatialInformationStore and AbstractIndividual (qq.v.).  Each instance of Microtheory is an atemporal, aspatial, informational thing that represents a context in Cyc.  Each microtheory (or 'mt') serves to group a set of assertions together that share some common assumptions; the assertions in an mt constitute the content of that mt.  Note that each assertion in the Cyc knowledge base must be explicitly stated to be true in at least one microtheory.  Assertions stated to be true in one mt will also be true  (by inference) in more specialized mts that depend on the content of that mt.  For example, if something is true in the HumanSocialLifeMt (q.v.), then it should by default be true in the more specialized UnitedStatesSocialLifeMt (q.v.).  Specialized microtheories are related to the more general microtheories on which they depend by the predicate genlMt (q.v.).  Note that every query is made in some mt, and the answer one gets to a query depends on the mt in which it is asked, since the only assertions which can be used to answer a query in an mt are those  explicitly stated to be true in that mt, or in some more general mt.  See also the predicate ist, which is used to relate an assertion to the microtheories in which it is true.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'MeaningInSystemFn', "A reifiable BinaryFunction that returns the meaningful entities indexed by a particular character string in a Cyc-external information source. More precisely, (MeaningInSystemFn INFOSOURCE STRING), applied to the CharacterString STRING and the IndexedInformationSource INFOSOURCE, returns whatever is indexed by STRING in that system.  For example, (MeaningInSystemFn WordNet-1997Version \"N03585958\") returns the WordNet `synset' (`synonym set') represented by (rampart|bulwark|wall), meaning \"an embankment built around a space for defensive purposes\".\n<p>\nSTRING can have any format chosen by the person who builds the representation of the external system.  In addition, STRING may contain arbitrary further characters or information, depending on how the external information is selected and processed.  This function makes it possible to relate a concept in an external system to an arbitrarily complicated expression composed of Cyc concepts.  If the external concept has a direct, exact mapping to a single Cyc constant, then use the predicate synonymousExternalConcept rather than this function.  If there is correspondence only to one Cyc constant, but it is only approximate, use overlappingExternalConcept.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'May', "A specialization of CalendarMonth. Each instance of May is the fifth month of a particular year in the GregorianCalendar (q.v.).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'MaxRangeFn', "<code>(MaxRangeFn QUANTITY<sub>1</sub> ... QUANTITY<sub>N</sub>)</code> denotes a quantity which subsumes each of <code>QUANTITY<sub>1</sub></code> through <code>QUANTITY<sub>N</sub></code>.  For example, <code>(MaxRangeFn (Meter 1 3) (Meter 2 4))</code> denotes (Meter 1 4).  See also MinRangeFn.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'Maximum', "A NumericQuantifier.  Used to denote the maximum quantity which results from applying the function specified in the second argument to all of the elements of the set expression which appears in the first argument.--Rode 3/15/98", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'March', "A specialization of CalendarMonth. Each instance of March is the third month of a particular year in the GregorianCalendar (q.v.).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'LogicalTruthMt', "This is a microtheory which contains only the assertions required to represent the logical system used in the Cyc knowledge base.  In other words, these are the assertions in CycL which must be present in order to use CycL to represent logical truths.", 'BaseKB', vStrMon).
assertedTinyKB(comment, 'LogicalTruthImplementationMt', "This is a microtheory which contains only the assertions required for the Cyc theorem prover and its underlying HL representation of the EL to function properly.  In other words, these are the assertions in CycL which are required by Cyc in order to perform any logical inferences using CycL formulas.", 'BaseKB', vStrMon).
assertedTinyKB(comment, 'LogicalConnective', "A collection of mathematical objects, including the basic logical connectives.  Each instance of LogicalConnective is a Relation which takes one or more truth-valued expressions (sentences) as arguments and returns a truth-valued sentence.  The instances of LogicalConnective include and, or, not, and implies.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'LogFn', "A unary EvaluatableFunction that returns the natural logarithm of the number taken as its argument.  (LogFn NUM) is the exponent to which e is raised to get NUM (where e is E-LogarithmBase). Its inverse (cf. inverseQuantFunctions-Nonsymmetric) is ExpFn.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'List', "A specialization of Tuple.  Each instance of List is a  finite sequence of things with a first and last member-position, with each member-position other than the last having a successor member-position.   As with tuples generally, lists allow for repetition of their members, so that the same item can appear at multiple member-positions in the same list.  A list can be represented formally as a function from a finite index set of counting numbers, beginning with one, into the domain of all Things (but note that Lists are _not_ explicitly represented as functions in the Cyc ontology).  Unlike an instance of Series (q.v.), a list is purely abstract (i.e. both aspatial and atemporal), and the only implied relation between an item and its successor in a list is the successor relation of the list itself.  Technically, List is more specific than Tuple only in that the index set (see tupleIndexSet) for a given list must be the counting numbers in their usual order (or some initial segment thereof), whereas the index set for a tuple, generally speaking, might be any set whatsoever.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'LeaveVariablesAtEL', "A CanonicalizerDirective (q.v.) that directs the canonicalizer to refrain from canonicalizing ELVariables into HLVariables.\nA consequence of this is that any CycLAssertion that contains no HL variables, regardless of its form, will be treated by the canonicalizer as if it were a GAF (see CycLClosedAtomicSentence) as opposed to a rule.  Note that this will inhibit nat reification if there are variables within the scope of the reifiable function.", 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(comment, 'LeaveSomeTermsAtELAndAllowKeywordVariables', "A CanonicalizerDirective which combines the directives LeaveSomeTermsAtEL and AllowKeywordVariables.", 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(comment, 'LeaveSomeTermsAtELAndAllowKeywordVariables', "A  CanonicalizerDirective (q.v.) that is a specialization (see  genlCanonicalizerDirectives) of both LeaveSomeTermsAtEL and  AllowKeywordVariables (qq.v.), and thus combines the commands of both of those directives.", 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(comment, 'LeaveSomeTermsAtEL', "A CanonicalizerDirective (q.v.) that combines the following three commands:\n<p>\n(1) Do not canonicalize ELVariables into HLVariables.\n(2) Do not expand CycLFormulas whose operators are instances of ELRelation.\n(3) Do not reify CycLReifiableNonAtomicTerms.\n<p>\nA consequence of (1) is that any CycLAssertion that contains no HL variables, regardless of its form, will be treated by the canonicalizer as if it were a GAF (see CycLClosedAtomicSentence) as opposed to a rule.", 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(comment, 'KnowledgeBase', "A specialization of Database-AbstractContent. Each instance of KnowledgeBase is a database (considered as an abstract repository of information rather than a physical storage device) containing knowledge about at least part of the world.  A notable specialization of KnowledgeBase is CycKB, the collection of all Cyc knowledge bases.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'Kappa', "A binary PredicateDenotingFunction and a ScopingRelation (qq.v.), Kappa is used to define a predicate on the basis of a sentence (see CycLSentence-Assertible) and a list of variables (see CycLVariableList) some or all of which typically occur free in the sentence.  The resulting predicate holds of just those sequences that would make the sentence true.\n<p>\nMore precisely, if <code>VAR1,...,VAR<sub>N</sub></code> include all of the CycLVariables that occur free in <code>SENT</code>, then the term\n<pre>\n  (Kappa (VAR1 ... VAR<sub>N</sub>) SENT)\n</pre>\ndenotes the <code>N</code>-ary relation (i.e. the Predicate) that holds of any admitted sequence of arguments <code>ARG1...ARG<sub>N</sub></code> if and only if <code>SENT[ARG<sub>I</sub>/VAR<sub>I</sub>]</code> is true, where <code>SENT[ARG<sub>I</sub>/VAR<sub>I</sub>]</code> is the result of simultaneously replacing each free occurrence of <code>VAR<sub>I</sub></code> in <code>SENT</code> with a CycL name of the corresponding <code>ARG<sub>I</sub></code> (for 1 <= <code>I</code> <= <code>N</code>). \n<p>\n(With respect to the above, <code>ARG1...ARG<sub>N</sub></code> is an <i>admitted sequence of arguments</i> to <code>(Kappa (VAR1 ... VAR<sub>N</sub>) SENT)</code> just in case (i) each <code>ARG<sub>I</sub></code> satisfies any argument-type constraints applicable to the position(s) occupied by <code>VAR<sub>I</sub></code> in <code>SENT</code> and (ii) if any two variables <code>VAR<sub>I</sub></code> and <code>VAR<sub>J</sub></code> are the same then the corresponding sequence-members <code>ARG<sub>I</sub></code> and <code>ARG<sub>J</sub></code> are identical.)\n<p>\nA few examples.  (Kappa (<code>?X</code>) (greaterThan <code>?X</code> 1)) is a unary predicate that holds of all numbers greater than 1. (Kappa (<code>?X ?Y</code>) (greaterThan <code>?X</code> 1)) is a binary predicate that holds of any ordered pair of argument values whose first member is a number greater than 1. (Kappa (<code>?X</code>) (greaterThan 2 1)) is a unary predicate that holds of any thing.  (Kappa (<code>?X</code>) (greaterThan 1 2)) is a unary predicate that holds of no thing.  (Kappa (<code>?X ?X</code>) (greaterThan <code>?X 1</code>)) is a binary predicate that holds of any ordered pair of numbers whose first and second members are the same number <b>K</b>, where <b>K</b> is greater than 1.\n<p>\nMost of the above examples are uses of Kappa that have little utility.  The first example, however, is an example of a common and important use of Kappa, which is to reduce the arity of a predicate by fixing the value for one or more of its arguments. For example, (Kappa (<code>?COUNTRY ?RATE</code>) (exportRate <code>?COUNTRY</code> Oil <code>?RATE</code>)) defines a binary predicate that relates a country to its export rate of oil, whereas (Kappa (<code>?COUNTRY</code>) (exportRate <code>?COUNTRY</code> Oil (MillionBarrelsPerDay 2)))</code> defines a unary predicate that holds of any country that exports oil at the rate of two million barrels per day.\n<p>\nThe sentence that is an argument to Kappa may be arbitrarily complex.  For example, it may be an existentially quantified conjunction.  Thus,\n<pre>\n   (Kappa (?PERSON ?NAME)\n    (thereExists ?FATHER\n      (and\n        (isa ?PERSON Person)\n        (father ?PERSON ?FATHER)\n        (lastName ?FATHER ?NAME))\n</pre>\n<p>\nreturns a predicate that holds of any ordered pair <b><PERSON, NAME></b>, such that <b>PERSON</b> is a person whose father's last name is <b>NAME</b>.\n<p>\nSometimes it is useful to construct an expression of the form <code>(Kappa LIST SENT)</code> where some variables that occur free in <code>SENT</code> do <i>not</i> occur in <code>LIST</code>.  For example, <code>(Kappa (?X) (greaterThan ?X ?Y))</code> might be used in a context where the <code>?Y</code> appears within the scope of a quantifier that occurs outside of the Kappa expression.\n<p>\nKappa is a cousin of the function Lambda (q.v.), which is used to define a <i>function</i> on the basis of a list of variables and a non-logical term.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'June', "A specialization of CalendarMonth.  Each instance of June is the sixth month of a particular year in the GregorianCalendar (q.v.).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'July', "The collection of all Julys,\n the seventh month of the year in the GregorianCalendar.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'January', "A specialization of CalendarMonth.  Each instance of January is the first month of a particular year in the GregorianCalendar (q.v.).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'ist-Asserted', "A MicrotheoryDesignatingPredicate that is used to relate CycL sentences to microtheories in which they are explicitly asserted. (ist-Asserted MT SENT) states that there is a CycLAssertion for SENT in the Microtheory MT.  This predicate is therefore a more specialized form of ist (q.v.) with the additional requirement that there be an actual assertion for SENT in MT.\n<p>\nNote that the above is also more precise than (ist MT (assertedSentence SENT)), which states that there is an assertion for SENT in some microtheory visible from (see genlMt) MT.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'IrreflexiveBinaryPredicate', "The collection of BinaryPredicates that are irreflexive.  A binary predicate <code>PRED</code> is an instance of IrreflexiveBinaryPredicate only if, for every <code>THING</code> that satisfies the single-argument type-constraints (i.e. argIsa and argGenls; see admittedArgument) on both of <code>PRED</code>'s argument-places, <code>(not (PRED THING THING))</code> holds.\n<p>\nTo rule out \"vacuous\" cases, there is an additional necessary condition for irreflexivity:  the constraints on <code>PRED</code>'s two argument-places must be co-satisfiable (see cosatisfiableInArgs).  Without this requirement, any binary predicate whose arguments were constrained in mutually-disjoint ways would trivially (and counterintuitively) count as irreflexive.  See NoteOnArgumentCosatisfiabilityRequirement\n<p>\nExamples of irreflexive binary predicates include spouse, causes-ThingProp, northOf, and temporallyDisjoint.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'IntervalMinFn', "<code>(IntervalMinFn SCALAR)</code> returns an interval of the same type as <code>SCALAR</code> whose minimum value is the minimum value of <code>SCALAR</code> and whose maximum value is PlusInfinity.  For example, (IntervalMinFn (Mile 3)) is the same as `the interval from three miles to an infinite number of miles', in other words, `at least three miles'.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'IntervalMaxFn', "<code>(IntervalMaxFn SCALAR)</code> returns an interval of the same type as <code>SCALAR</code> whose maximum value is the maximum value of <code>SCALAR</code> and whose minimum value is minus infinity.  For example, (IntervalMaxFn (Mile 3)) is the same as `the interval from negative infinity miles to three miles'. [Technical Note: if that expression were to denote a strictly absolute, as opposed to a relative-or-absolute, distance, then it would mean `the interval from 0 miles to 3 miles'.]   (IntervalMaxFn (Unity 1)) is the same as `the interval from negative infinity to 1', in other words, `no greater than one'.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'IntervalEntry', "An instance of Format (q.v.) that can be specified to hold of a given predicate with respect to a given argument-place (see argFormat), where the argument-place in question is one constrained (via argIsa) to instances of ScalarInterval.   (argFormat PRED N IntervalEntry) means that, for any particular way of fixing the other arguments to PRED besides the Nth, there may be more than one instance of ScalarInterval such that, if taken as the Nth argument, PRED holds of those arguments.  However, if there is more than one instance of ScalarInterval taken as the Nth argument in such a situation, it must be the case that each of the instances of ScalarInterval intersect one another (see quantityIntersects).  That is, if the sequences <... ARGN-1 ...>, <... ARGN-2 ...>, ..., <... ARGN-M ...> differ at most in their Nth items and each of (PRED ... ARGN-1 ...), (PRED ... ARGN-2 ...), ..., (PRED ... ARGN-M ...) holds, then for any distinct ARGN-K and ARGN-L, where K and L are greater than or equal to 1, and less than or equal to M, (quantityIntersects ARGN-K ARGN-L). For example, the format of volumeOfObject's second argument-place is IntervalEntry.", 'BaseKB', vStrDef).
assertedTinyKB(comment, 'InterArgIsaPredicate', "The subcollection of both InterArgTypePredicate and ArgIsaPredicate (qq.v.) whose instances are used to put conditional isa based argument-type constraints on polyadic relations in regards to two of their argument-places.  Each instance of InterArgIsaPredicate specifies, with respect to a given Relation, that one of its arguments (the \"dependent\" one) must be an instance of (isa) a certain collection, contingent upon another of its argument's (the \"independent\" one's) being an instance of a certain (possibly different) collection.  An inter-argument-isa predicate PRED has argument-places for designating the relation and the two collections serving as argument-types; the (numerically-specified) identities of the relation's corresponding dependent and independent arguments is in most cases fixed (as in interArgIsa1-2), but is in some cases variable and specified via two additional argument-places of PRED's (as in interArgIsa).  In cases of the former sort, where the relation's argument-places are fixed, PRED is a TernaryPredicate that takes as it first argument (or \"arg1\") a relation, as its arg2 the type specified for the relation's independent argument, and as its arg3 the type specified (contingently) for the dependent argument.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'interArgIsa5-4', "A ternary instance of InterArgIsaPredicate (q.v.).   (interArgIsa5-4 RELN INDEPENDENT-ARG-COL DEPENDENT-ARG-COL) means that,  when an instance of INDEPENDENT-ARG-COL appears as the fifth argument to RELN,  a necessary condition for semantic well-formedness is that the fourth argument  must be an instance of DEPENDENT-ARG-COL.  That is, if INST is an instance of INDEPENDENT-ARG-COL, then  (RELN ARG1 ARG2 ARG3 ARG4 INST ... ARGN) is semantically  well-formed only if ARG4 is an instance of DEPENDENT-ARG-COL.  For an explanation  of semantic well-formedness, see CycLExpression-Assertible and its direct  specializations.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'interArgIsa5-3', "A ternary instance of InterArgIsaPredicate (q.v.).   (interArgIsa5-3 RELN INDEPENDENT-ARG-COL DEPENDENT-ARG-COL) means that,  when an instance of INDEPENDENT-ARG-COL appears as the fifth argument to RELN,  a necessary condition for semantic well-formedness is that the third argument  must be an instance of DEPENDENT-ARG-COL.  That is, if ARG-INST is an instance of INDEPENDENT-ARG-COL, then  (RELN ARG1 ARG2 ARG3 ARG4 INST ... ARGN) is semantically well-formed  only if ARG3 is an instance of DEPENDENT-ARG-COL.  For an explanation of semantic  well-formedness, see CycLExpression-Assertible and its direct specializations.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'interArgIsa5-2', "A ternary instance of InterArgIsaPredicate (q.v.).   (interArgIsa5-2 RELN INDEPENDENT-ARG-COL DEPENDENT-ARG-COL) means that,  when an instance of INDEPENDENT-ARG-COL appears as the fifth argument to RELN,  a necessary condition for semantic well-formedness is that the second argument  must be an instance of DEPENDENT-ARG-COL.  That is, if INST is an instance of INDEPENDENT-ARG-COL, then  (RELN ARG1 ARG2 ARG3 ARG4 INST ... ARGN) is semantically well-formed  only if ARG2 is an instance of DEPENDENT-ARG-COL.  For an explanation of semantic  well-formedness, see CycLExpression-Assertible and its direct specializations.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'interArgIsa5-1', "A ternary instance of InterArgIsaPredicate (q.v.).   (interArgIsa5-1 RELN INDEPENDENT-ARG-COL DEPENDENT-ARG-COL) means that,  when an instance of INDEPENDENT-ARG-COL appears as the fifth argument to RELN,  a necessary condition for semantic well-formedness is that the first argument  must be an instance of DEPENDENT-ARG-COL.  That is, if INST is an instance of INDEPENDENT-ARG-COL, then  (RELN ARG1 ARG2 ARG3 ARG4 INST ... ARGN) is semantically  well-formed only if ARG1 is an instance of DEPENDENT-ARG-COL.  For an explanation  of semantic well-formedness, see CycLExpression-Assertible and its direct  specializations.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'interArgIsa4-5', "A ternary instance of InterArgIsaPredicate (q.v.).  \n(interArgIsa4-5 RELN INDEPENDENT-ARG-COL DEPENDENT-ARG-COL) means that, \nwhen an instance of INDEPENDENT-ARG-COL appears as the fourth argument to RELN, \na necessary condition for semantic well-formedness is that the fifth argument \nmust be an instance of DEPENDENT-ARG-COL.  That is, if INST is\nan instance of INDEPENDENT-ARG-COL, then \n(RELN ARG1 ARG2 ARG3 INST ARG5 ... ARGN) is semantically \nwell-formed only if ARG5 is an instance of DEPENDENT-ARG-COL.  For an explanation \nof semantic well-formedness, see CycLExpression-Assertible and its direct \nspecializations.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'interArgIsa4-3', "A ternary instance of InterArgIsaPredicate (q.v.).  \n(interArgIsa4-3 RELN INDEPENDENT-ARG-COL DEPENDENT-ARG-COL) means that, \nwhen an instance of INDEPENDENT-ARG-COL appears as the fourth argument to RELN, \na necessary condition for semantic well-formedness is that the third argument \nmust be an instance of DEPENDENT-ARG-COL.  That is, if INST is\nan instance of INDEPENDENT-ARG-COL, then \n(RELN ARG1 ARG2 ARG3 INST ... ARGN) is semantically well-formed only \nif ARG3 is an instance of DEPENDENT-ARG-COL.  For an explanation of semantic \nwell-formedness, see CycLExpression-Assertible and its direct specializations.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'interArgIsa4-2', "A ternary instance of InterArgIsaPredicate (q.v.).   (interArgIsa4-2 RELN INDEPENDENT-ARG-COL DEPENDENT-ARG-COL) means that,  when an instance of INDEPENDENT-ARG-COL appears as the fourth argument to RELN,  a necessary condition for semantic well-formedness is that the second argument  must be an instance of DEPENDENT-ARG-COL.  That is, if INST is an instance of INDEPENDENT-ARG-COL, then  (RELN ARG1 ARG2 ARG3 INST ... ARGN) is semantically well-formed only  if ARG2 is an instance of DEPENDENT-ARG-COL.  For an explanation of semantic  well-formedness, see CycLExpression-Assertible and its direct specializations.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'interArgIsa4-1', "A ternary instance of InterArgIsaPredicate (q.v.).  \n(interArgIsa4-1 RELN INDEPENDENT-ARG-COL DEPENDENT-ARG-COL) means that, \nwhen an instance of INDEPENDENT-ARG-COL appears as the fourth argument to RELN, \na necessary condition for semantic well-formedness is that the first argument \nmust be an instance of DEPENDENT-ARG-COL.  That is, if INST is\nan instance of INDEPENDENT-ARG-COL, then \n(RELN ARG1 ARG2 ARG3 INST ... ARGN) is semantically well-formed only \nif ARG1 is an instance of DEPENDENT-ARG-COL.  For an explanation of semantic \nwell-formedness, see CycLExpression-Assertible and its direct specializations.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'interArgIsa3-5', "A ternary instance of InterArgIsaPredicate (q.v.).  \n(interArgIsa3-5 RELN INDEPENDENT-ARG-COL DEPENDENT-ARG-COL) means that, \nwhen an instance of INDEPENDENT-ARG-COL appears as the third argument to RELN, \na necessary condition for semantic well-formedness is that the fifth argument \nmust be an instance of DEPENDENT-ARG-COL.  That is, if INST is\nan instance of INDEPENDENT-ARG-COL, then \n(RELN ARG1 ARG2 INST ARG4 ARG5 ... ARGN) is semantically \nwell-formed only if ARG5 is an instance of DEPENDENT-ARG-COL.  For an explanation \nof semantic well-formedness, see CycLExpression-Assertible and its direct \nspecializations.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'interArgIsa3-4', "A ternary instance of InterArgIsaPredicate (q.v.).  \n(interArgIsa3-4 RELN INDEPENDENT-ARG-COL DEPENDENT-ARG-COL) means that, \nwhen an instance of INDEPENDENT-ARG-COL appears as the third argument to RELN, \na necessary condition for semantic well-formedness is that the fourth argument \nmust be an instance of DEPENDENT-ARG-COL.  That is, if INST is\nan instance of INDEPENDENT-ARG-COL, then \n(RELN ARG1 ARG2 INST ARG4 ... ARGN) is semantically well-formed only \nif ARG4 is an instance of DEPENDENT-ARG-COL.  For an explanation of semantic \nwell-formedness, see CycLExpression-Assertible and its direct specializations.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'interArgIsa3-2', "A ternary instance of InterArgIsaPredicate (q.v.).   (interArgIsa3-2 RELN INDEPENDENT-ARG-COL DEPENDENT-ARG-COL) means that,  when an instance of INDEPENDENT-ARG-COL appears as the third argument to RELN,  a necessary condition for semantic well-formedness is that the second argument  must be an instance of DEPENDENT-ARG-COL.  That is, if INST is an instance of INDEPENDENT-ARG-COL, then  (RELN ARG1 ARG2 INST ... ARGN) is semantically well-formed only  if ARG2 is an instance of DEPENDENT-ARG-COL.  For an explanation of semantic  well-formedness, see CycLExpression-Assertible and its direct specializations.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'interArgIsa3-1', "A ternary instance of InterArgIsaPredicate (q.v.).   (interArgIsa3-1 RELN INDEPENDENT-ARG-COL DEPENDENT-ARG-COL) means that,  when an instance of INDEPENDENT-ARG-COL appears as the third argument to RELN,  a necessary condition for semantic well-formedness is that the first argument  must be an instance of DEPENDENT-ARG-COL.  That is, if INST is an instance of INDEPENDENT-ARG-COL, then  (RELN ARG1 ARG2 INST ... ARGN) is semantically well-formed only  if ARG1 is an instance of DEPENDENT-ARG-COL.  For an explanation of semantic  well-formedness, see CycLExpression-Assertible and its direct specializations.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'interArgIsa2-5', "A ternary instance of InterArgIsaPredicate (q.v.).  \n(interArgIsa2-5 RELN INDEPENDENT-ARG-COL DEPENDENT-ARG-COL) means that, \nwhen an instance of INDEPENDENT-ARG-COL appears as the second argument to RELN, \na necessary condition for semantic well-formedness is that the fifth argument \nmust be an instance of DEPENDENT-ARG-COL.  That is, if INST is\nan instance of INDEPENDENT-ARG-COL, then \n(RELN ARG1 INST ARG3 ARG4 ARG5 ... ARGN) is semantically \nwell-formed only if ARG5 is an instance of DEPENDENT-ARG-COL.  For an explanation \nof semantic well-formedness, see CycLExpression-Assertible and its direct \nspecializations.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'interArgIsa2-4', "A ternary instance of InterArgIsaPredicate (q.v.).  \n(interArgIsa2-4 RELN INDEPENDENT-ARG-COL DEPENDENT-ARG-COL) means that, \nwhen an instance of INDEPENDENT-ARG-COL appears as the second argument to RELN, \na necessary condition for semantic well-formedness is that the fourth argument \nmust be an instance of DEPENDENT-ARG-COL.  That is, if INST is\nan instance of INDEPENDENT-ARG-COL, then \n(RELN ARG1 INST ARG3 ARG4 ... ARGN) is semantically well-formed only \nif ARG4 is an instance of DEPENDENT-ARG-COL.  For an explanation of semantic \nwell-formedness, see CycLExpression-Assertible and its direct specializations.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'interArgIsa2-3', "A ternary instance of InterArgIsaPredicate (q.v.).  \n(interArgIsa2-3 RELN INDEPENDENT-ARG-COL DEPENDENT-ARG-COL) means that, \nwhen an instance of INDEPENDENT-ARG-COL appears as the second argument to RELN, \na necessary condition for semantic well-formedness is that the third argument \nmust be an instance of DEPENDENT-ARG-COL.  That is, if INST is\nan instance of INDEPENDENT-ARG-COL, then \n(RELN ARG1 INST ARG3 ... ARGN) is semantically well-formed only \nif ARG3 is an instance of DEPENDENT-ARG-COL.  For an explanation of semantic \nwell-formedness, see CycLExpression-Assertible and its direct specializations.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'interArgIsa2-1', "A ternary instance of InterArgIsaPredicate (q.v.).   <code>(interArgIsa2-1 RELN INDEPENDENT-ARG-COL DEPENDENT-ARG-COL)</code> means that,  when an instance of <code>INDEPENDENT-ARG-COL</code> appears as the second argument to <code>RELN</code>,  a necessary condition for semantic well-formedness is that the first argument  must be an instance of <code>DEPENDENT-ARG-COL</code>.  That is, if <code>INST</code> is an instance of <code>INDEPENDENT-ARG-COL</code>, then <code>(RELN ARG1 INST ... ARGN)</code>  is semantically well-formed only if <code>ARG1</code> is an instance of <code>DEPENDENT-ARG-COL</code>. For an explanation of semantic well-formedness, see CycLExpression-Assertible  and its direct specializations.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'interArgIsa1-5', "A ternary instance of InterArgIsaPredicate (q.v.).  \n(interArgIsa1-5 RELN INDEPENDENT-ARG-COL DEPENDENT-ARG-COL) means that, \nwhen an instance of INDEPENDENT-ARG-COL appears as the first argument to RELN, \na necessary condition for semantic well-formedness is that the fifth argument \nmust be an instance of DEPENDENT-ARG-COL.  That is, if INST is\nan instance of INDEPENDENT-ARG-COL, then \n(RELN INST ARG2 ARG3 ARG4 ARG5 ... ARGN) is semantically \nwell-formed only if ARG5 is an instance of DEPENDENT-ARG-COL.  For an explanation \nof semantic well-formedness, see CycLExpression-Assertible and its direct \nspecializations.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'interArgIsa1-4', "A ternary instance of InterArgIsaPredicate (q.v.).  \n(interArgIsa1-4 RELN INDEPENDENT-ARG-COL DEPENDENT-ARG-COL) means that, \nwhen an instance of INDEPENDENT-ARG-COL appears as the first argument to RELN, \na necessary condition for semantic well-formedness is that the fourth argument \nmust be an instance of DEPENDENT-ARG-COL.  That is, if INST is\nan instance of INDEPENDENT-ARG-COL, then \n(RELN INST ARG2 ARG3 ARG4 ... ARGN) is semantically well-formed only \nif ARG4 is an instance of DEPENDENT-ARG-COL.  For an explanation of semantic \nwell-formedness, see CycLExpression-Assertible and its direct specializations.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'interArgIsa1-3', "A ternary instance of InterArgIsaPredicate (q.v.).  \n(interArgIsa1-3 RELN INDEPENDENT-ARG-COL DEPENDENT-ARG-COL) means that, \nwhen an instance of INDEPENDENT-ARG-COL appears as the first argument to RELN, \na necessary condition for semantic well-formedness is that the third argument \nmust be an instance of DEPENDENT-ARG-COL.  That is, if INST is\nan instance of INDEPENDENT-ARG-COL, then \n(RELN INST ARG2 ARG3 ... ARGN) is semantically well-formed only \nif ARG3 is an instance of DEPENDENT-ARG-COL.  For an explanation of semantic \nwell-formedness, see CycLExpression-Assertible and its direct specializations.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'interArgIsa1-2', "A ternary instance of InterArgIsaPredicate (q.v.).  <code>(interArgIsa1-2 RELN INDEPENDENT-ARG-COL DEPENDENT-ARG-COL)</code> means that, when an instance of <code>INDEPENDENT-ARG-COL</code> appears as the first argument to <code>RELN</code>, a necessary condition for semantic well-formedness is that the second argument must be an instance of <code>DEPENDENT-ARG-COL</code>.  That is, if <code>INST</code> is an instance of <code>INDEPENDENT-ARG-COL</code>, then <code>(RELN INST ARG2 ... ARGN)</code> is semantically well-formed only if <code>ARG2</code> is an instance of <code>DEPENDENT-ARG-COL</code>.\n<p>\nFor example, (interArgIsa1-2 performedBy PurposefulAction IntelligentAgent) means that, if <code>ACT</code> is a purposeful action, then (performedBy <code>ACT AGENT</code>) is semantically well-formed only if <code>AGENT</code> is an intelligent agent.  For an explanation of semantic well-formedness, see  CycLExpression-Assertible and its direct specializations.  See interArgIsa for a similar but more general predicate that is quintary, allowing the user to specify the positions of the independent and dependent arguments.\n<p>\nUse interArgCondIsa1-2 to conclude that arg2 is an instance of <code>DEPENDENT-ARG-COL</code> instead of having that as a constraint.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'interArgGenl1-2', "(interArgGenl1-2 REL INDEPENDENT-COL DEPENDENT-COL) means that, when a spec of INDEPENDENT-COL appears as the first argument to REL, the second argument is constrained to be a spec of DEPENDENT-COL.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'InterArgFormatPredicate', "The subcollection of both InterArgConstraintPredicate and ArgFormatPredicate (qq.v.) whose instances are used to specify, for a given predicate PRED, a certain Format requirement on one of PRED's arguments (the \"dependent\" one), contingent upon one (usually, but not always, a different one) of PRED's arguments (the \"independent\" one) being an instance of (isa) a certain collection.  Currently, each instance of InterArgFormatPredicate is ternary, where its first argument (or \"arg1\") is the predicate PRED upon which the constraint is being placed, its arg2 the collection serving as the isa condition on PRED's independent argument, and its arg3 the Format that PRED's dependent argument is (conditionally) constrained to have.  The (numerically-specified) identities of the arguments of PRED's that are to serve as the independent and dependent arguments are fixed for each instance of \nInterArgFormatPredicate.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'interArgFormat1-2', "An instance of InterArgFormatPredicate (q.v.).\n(interArgFormat1-2 PRED COL FORMAT) means that FORMAT is a Format (q.v.)\nrequirement for the second argument-place of PRED when PRED's first argument\nis an instance of COL.  That is, with respect to a sentence of the form \n(PRED ARG1 ARG2 ... ARGN) in which ARG1 is an instance of COL, PRED's arg2\nposition (i.e. the position occupied by the metavariable `ARG2' in the \npreceding sentence-form) is subject to FORMAT.  See Format and its instances \nfor further explanation.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'Integer', "A specialization of RationalNumber.  Each instance of Integer is a whole number with no fractional remainder.  An integer may be positive (e.g. 42), zero, or negative (e.g. -42).\n<p>\nNote that, in the KB browser, a fixed- or floating-point number representation such as `42.00' should not be assumed to refer to the integer 42. For it might only appear to correspond to that integer within the tolerance of its representation, and might in fact be an approximation to a non-integer number such as 42.0003.\n<p>\nAlso note that, unlike Integer, SubLInteger (q.v.) is a collection of integer-denoting expressions in the SubL programming language rather than a collection of integers themselves. Still, (genls SubLInteger Integer) holds, but only under a special interpretation of genls forced by the fact that SubLInteger is a quotedCollection (q.v).)", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'InferenceSupportedTerm', "The collection of all CycLTerms that are supported in some way by the CycInferenceEngine.  This support may be provided by, for example, a CycHLModule or an evaluationDefn.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'InferenceSupportedPredicate', "The collection of all Predicates that are supported in some way by the CycInferenceEngine.  This support may be provided by, for example, a CycHLModule or an evaluationDefn.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'InferenceSupportedFunction', "The collection of all Function-Denotationals that are supported in some way by the CycInferenceEngine.  This support may be provided by, for example, an evaluationDefn.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'InferenceSupportedCollection', "The collection of all CycL terms that denote collections, where these terms are supported in some way by the CycInferenceEngine.  If a term T denoting the collection COL is an InferenceSupportedCollection, this means that the inference engine treats instances of COL specially.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'InferenceRelatedBookkeepingPredicate', "A collection of predicates.  Each instance of InferenceRelatedBookkeepingPredicate is a predicate involved in assertions used by the Cyc application to direct inferencing.  Examples: defnIff, defnSufficient, termOfUnit, afterAdding.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'InferencePSC', "A problem solving context in which all assertions in the entire KB are initially visible.  However, down each inference path, the chain of microtheories used is required to have some common descendent microtheory which is capable of inheriting all of the microtheories in the chain.  Thus, queries made in InferencePSC in effect compute locations in the space of microtheories in which the query is satisfiable.  This context is used internally by the inference engine for certain recursive calls to itself, including forward inference.  See also EverythingPSC.", 'BaseKB', vStrMon).
assertedTinyKB(comment, 'Individual', "Individual is the collection of all individuals:  things that are <i>not</i> sets or collections.  Individuals might be concrete or abstract, and include (among other things) physical objects, events, numbers,  relations, and groups.  An instance of Individual might have parts or  structure (including discontinuous parts); but <i>no</i> individual has elements  or subsets (see elementOf and subsetOf). Thus, an individual that has parts (e.g. physicalParts or groupMembers) is <i>not</i> the same thing as either the set or the collection containing those same parts.  For example, your car is an individual, but the collection of all the parts of your car is not an individual but an instance of Collection.  This collection (unlike the car itself) is abstract: it doesn't have a location, mass, or a top speed; but it does have instances, subcollections, and supercollections.  In partial contrast, the Group (q.v.) of parts of your car (while also not the same thing as the car itself) <i>is</i> an individual that has location and mass.  Another example: A given company, the group consisting of all the company's employees, the collection of those employees, and the set of those employees are four distinct things, and only the first two are individuals.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'IndeterminateTermDenotingFunction', "IndeterminateTermDenotingFunction is the collection of all functions that denote indeterminate terms.  See also IndeterminateTerm, SkolemTerm, and SkolemFunction.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'IndeterminateTerm', "A specialization of CycLClosedDenotationalTerm.  Each instance of IndeterminateTerm is a CycL symbol for which, in oreder to establish its denotation, it is not sufficient to establish every aspect of the context of its use.\n<p>\nIn other words, instances of this collection are terms used to denote something which is known or assumed to exist, but whose precise identity -- i.e. which particular thing or things it is -- is unknown (unless, of course, the term is known to satisfy equals with another term whose precise identity is known).\n<p>\nFor instance, if Cyc knows (relationAllExists physicalExtent University SchoolCampus), and (isa MelbourneUniversity University), then Cyc knows that there is at least one instance of SchoolCampus, <i>IndeterminateCampus</i>, for which (physicalExtent MelbourneUniversity <i>IndeterminateCampus</i>) is true. This campus (or these campuses, if there happens to be more than one) would be denoted in CycL using the IndeterminateTerm:\n<p>\n(RelationAllExistsFn MelbourneUniversity physicalExtent University SchoolCampus).\n<p>\nAnalogously, instances of SkolemTerm are also instances of IndeterminateTerm, as are terms built from SomeFn, GenericInstanceFn, ArbitraryInstanceFn, et al (see the specialization NonSkolemIndeterminateTerm).", 'BaseKB', vStrMon).
assertedTinyKB(comment, 'HypotheticalContext', "A MicrotheoryType.  Each instance of  HypotheticalContext consists of assertions that are posited strictly for the purpose of exploring their consequences, without alleging their actual truth.   A hypothetical context can be used to analyze hypothetical outcomes of actions or to examine the hypothetical consequences of assuming some theory to be true.  Also, various alternative choices might be asserted, each in its own hypothetical context, so their ramifications can be generated and compared.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'HumanCyclist', "A specialization of Cyclist and Person.  Each instance of  HumanCyclist is a person who is entitled to inspect and modify the Cyc knowledge base.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'HLPrototypicalTerm', "The collection of all CycLTerms that are the hlPrototypicalInstance of some collection.  All HLPrototypicalTerms are IndeterminateTerms.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'HLExternalIDString', "HLExternalIDString is the collection of all SubLStrings\nwhich represent valid external ID strings for CycLExpressions.\nMembership in this collection is determined for given strings by\nevaluation of the underlying SubL code which implements the object to\nID mapping.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'Guest', "An instance of HumanCyclist.  A Cyc user logged in                            \nas `Guest' will be able to browse the Cyc knowledge base to some extent, but will not have full rights to inspect and modify it.", 'BaseKB', vStrDef).
assertedTinyKB(comment, 'genls-SpecDenotesGenlInstances', "An instance of TaxonomicSlotForCollections (q.v.) and a specialization of generalizations. genls-SpecDenotesGenlInstances relates a collection (see Collection) to those collections which denote instances of it. More precisely, (genls-SpecDenotesGenlInstances SUBCOL SUPERCOL) means that SUPERCOL is a quoted supercollection of SUBCOL: anything that is quoted instance of (see quotedIsa) SUBCOL is an instance (see isa) of SUPERCOL. For example, (genls-SpecDenotesGenlInstances List-Extensional List) holds.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'genls-GenlDenotesSpecInstances', "A instance of TaxonomicSlotForCollections (q.v.) and a specialization of generalizations. genls-GenlDenotesSpecInstances relates a given SubLExpressionType collection (see Collection) to those collections whose instances it denotes. More precisely, (genls-GenlDenotesSpecInstances SUBCOL SUPERCOL) means that SUBCOL is a quoted subcollection of SUPERCOL: anything that is an instance of (see quotedIsa) SUBCOL is a quoted instance (see isa) of SUPERCOL.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'FunctionToArg', "A binary FunctionDenotingFunction (q.v.) that takes as argument a FunctionalPredicate (and an integer indicating an argument-place in which that predicate is functional) and returns the corresponding function (whose value is always equal to the predicate's corresponding argument in the indicated place).\n<p>\nMore precisely: if <code>PRED</code> is an <code>N</code>-ary functional predicate that is functional in its <code>M</code>th argument (see functionalInArgs), then <code>(FunctionToArg M PRED)</code> is the (<code>N</code>-1)-ary function <code>FUNC-TO-ARGM</code> such that <code>(PRED ARG(1) ... ARG(N))</code> holds if and only if <code>(FUNC-TO-ARGM ARG(1) ... ARG(M-1) ARG(M+1) ... ARG(N)) = ARG(M)</code>.  If <code>PRED</code> is not functional in its <code>M</code>th argument, then <code>(FunctionToArg PRED M)</code> is undefined.\n<p>\nFor example, (FunctionToArg 2 age) is the function that returns the age of a given person.  Thus ((FunctionToArg 2 age) GeorgeWBush) = (YearsDuration 50) just in case (age GeorgeWBush (YearsDuration 50)) is true.\n<p>\nSee also Lambda and Kappa.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, tFunction, "A specialization of Relation (q.v.) and the collection of all functions.  Each instance of Function-Denotational is a many-one relation that represents, with respect to any given context, a mapping from one set of things (the function's relationDomain) to another set of things (its relationRange).  As a many-one relation, a function maps each thing in its domain to exactly one thing in its range.  A function might be unary, binary, ternary, etc. (see arity; but cf. relationalArity), depending on whether the members of its domain are singletons, ordered pairs, ordered triples, etc.  In general, the domain of an N-ary function with respect to a given context is a set of ordered N-tuples (construed in CycL as Lists of length N).  The function is said to take the items from any of these N-tuples as its N <i>arguments</i> and to return a member of its range as its corresponding <i>value</i> (see valueOfFunctionForArgs).  There are also functions that are not of any particular fixed arity; see VariableArityFunction.\n<p>\nFor example, GovernmentFn is the unary function that takes each GeopoliticalEntity to its RegionalGovernment, and PlusFn is the variable-arity function that takes any sequence of two or more ScalarIntervals\n(q.v.) to their arithmetic sum.\n<p>\nNote that the domain and range (i.e. the extension) of a given function might vary from context to context.  For example, as the government of a country can change over time, GovernmentFn will in such cases map the same country to different governments with respect to different times.  Thus, an instance of Function-Denotational is closer to what is sometimes called a \"function-in-intension\" than to the purely set-theoretical notion of a \"function-in-extension\".\n<p>\nCycL terms that denote functions can be used to form non-atomic terms (or \"NATs\"; see CycLClosedNonAtomicTerm).  Specifically, when such a function-denoting expression is appropriately combined with other expressions (i.e. the former is in the 0th argument position and the latter are of the correct number and type) the resulting expression is a new CycL term (a NAT) that may then freely appear as a component in other CycL expressions.  The NAT will itself denote the value (if any) of the function denoted by the former expression for the sequence of arguments denoted, respectively, by the latter expressions.  For example, GovernmentFn is a unary function, and so the CycL constant 'GovernmentFn' requires one syntactic argument (such as the constant 'France') to form a NAT (in this case, the expression '(GovernmentFn France)').  This NAT, which denotes the government of France, can in turn serve as a syntactic argument in any CycL expression in which a term for an instance of RegionalGovernment can legally occur.\n<p>\nImportant subcollections of Function-Denotational include IndividualDenotingFunction (whose instances always return instances of Individual), CollectionDenotingFunction, SetDenotingFunction, and FunctionDenotingFunction (which is itself a subcollection of the first).  NATs formed using terms that denote instances of FunctionDenotingFunction denote instances of Function-Denotational themselves.  Thus, like most other things, functions can be denoted in CycL either by constants  (e.g. 'GovernmentFn') or -- although this is less common -- by NATs (e.g.  '(FunctionToArg 2 biologicalMother)').\n<p>\nAn important partition of Function-Denotational is into TotalFunction and PartialFunction (qq.v.).\n<p>\nNote that Function-Denotational does not include any of the so-called TruthFunctions (q.v.): Predicates, Quantifiers, or LogicalConnectives. For these relations (as construed in CycL) are not really functions at all, even though it can be heuristically useful to think of them as if they were functions from sequences of arguments to truth values.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'Friday', "A collection of CalendarDays and an \ninstance of DayOfWeekType.  Friday is the collection of all \n(and only) fridays.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'Forward-AssertionDirection', "An instance of CycLAssertionDirection (q.v.).  A CycL assertion that\nhas the Forward-AssertionDirection can be used in inferences carried \nout at the time the assertion is added to the Knowlege Base as well as \nthose carried out at when a query is asked.  This is the default direction \nfor ground atomic assertions (see CycLClosedAtomicSentence).  Contrast \nwith Backward-AssertionDirection and Code-AssertionDirection.  Also \nsee assertionDirection.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'FormulaArityFn', "An instance of EvaluatableFunction.  When applied to a CycLFormula FORM, FormulaArityFn returns the number of arguments given to the relation (an instance of Relation (q.v.)) appearing in the initial (\"arg0\") argument place of FORM.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'FormulaArgSetFn', "(FormulaArgSetFn RELATION-EXPRESSION) denotes\na set of the arguments of the given CycLFormula RELATION-EXPRESSION.  For example, (FormulaArgSetFn (genls Dog Animal)) denotes (TheSet Dog Animal).  See also FormulaArgFn and FormulaArityFn.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'FormulaArgListFn', "(FormulaArgListFn RELATION-EXPRESSION) denotes a list of the arguments in RELATION-EXPRESSION.  For example, (FormulaArgListFn (genls Dog Animal)) denotes (TheList Dog Animal).  See also FormulaArgFn and FormulaArityFn.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'FormulaArgFn', "A binary function that returns an instance of CycLTerm when given an instance of NonNegativeInteger and an instance of CycLFormula as arguments.  (FormulaArgFn N RELATION-EXPRESSION) denotes the term appearing as the Nth argument within RELATION-EXPRESSION. (Note that RELATION-EXPRESSION may be a sentence or a NAT). For example:\n<p>\n(FormulaArgFn 2 (loves Gilbert Muffet)) and\n(FormulaArgFn 1 (BirthFn Muffet))\n<p>\nboth denote Muffet. Cf. ArgPositionFn.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'Format', "A collection of argument entry-formats that can be  specified for Predicates with respect to particular argument-places (see argFormat).  An argument entry-format is a kind of restriction on  a predicate regarding how many things, or the range of things, that the  predicate holds of with respect to a given one of its argument-places.  More  precisely: given any particular way of fixing the arguments in the rest of  the predicate's argument-places, the entry-format tells us something about  the number of different things, or the range of things, that can occupy the  given argument-place such that the relation holds of those arguments.  That is, supposing the given argument-place is the Nth, the entry-format tells us  something about the number or range of different sequences of arguments  of which the predicate holds and that differ from each other only in their Nth items.  For example, the format SingleEntry (q.v.) is used to state  that in every case there is at most only one such sequence, the format  SetTheFormat (q.v.) to state that there is no particular (upper or lower)  limit to the number of such sequences that applies to every case, and the  format IntervalEntry (q.v.) to state that the Nth items of any two such  sequences must be ScalarIntervals that \"intersect\" (see quantityIntersects). Thus, the first argument-place of biologicalMother has the format (see  arg1Format) SetTheFormat, since a given female animal might have any  number (including zero) of offspring; but the second argument-place of  this predicate has (see arg2Format) SingleEntry format, since any  given animal has at most (in fact, exactly) one biological mother.  And  the format of the second argument-place of bodyTemperature is IntervalEntry because, while a given creature (at a given moment in time) has a single  exact (see ScalarPointValue) body temperature, we want the predicate bodyTemperature to be flexible enough to allow us to specify this  temperature with varying degrees of precision (e.g. as \"98.6 degrees Fahrenheit\" or as \"between 98 and 99 degrees\" or as \"less than 100 degrees\").  See the various instances of Format for further details.  See also ArgFormatPredicate.  Note that, in contrast with what ArgTypePredicates  are used for, specifying an argument entry-format for a predicate does  _not_ impose any sort of necessary condition for semantic well-formedness.   A violation of a legitimate entry-format constraint necessarily involves  two or more statements, and at least one them must be _untrue_;  but there is no implication that any of them is malformed.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'FOL-TermFn', "(FOL-TermFn TERM) denotes a first-order constant symbol\nbased on the CycL term TERM.  For example, (FOL-TermFn Dog)\ndenotes a first-order term based on the collection Dog,\n(FOL-TermFn 212) denotes a first-order term based on the integer\n212, and (FOL-TermFn isa) denotes a first-order term based on the\npredicate isa.  See also (FOL-PredicateFn isa 2) for the\nfirst-order binary predicate based on isa.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'FOL-PredicateFn', "(FOL-PredicateFn TERM ARITY) denotes a predicate that has\narity ARITY in the first-order projection of CycL based on the CycL\nterm TERM, which must be either a predicate or a collection.  For\nexample, (FOL-PredicateFn eventOccursAt 2) denotes the binary\nfirst-order predicate associated with eventOccursAt,\n(FOL-PredicateFn different 2) denotes the first-order binary\nversion of the predicate different, and (FOL-PredicateFn Date 1)\ndenotes the unary first-order predicate associated with Date", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'FOL-FunctionFn', "(FOL-FunctionFn FUNC ARITY) denotes a function that has\narity ARITY in the first-order projection of CycL based on the CycL\nfunction FUNC.  For example, (FOL-FunctionFn YearFn 1) denotes the\nunary first-order function associated with YearFn, and\n(FOL-FunctionFn PlusFn 2) denotes the first-order binary function\nassociated with PlusFn", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'FixedAritySkolemFunction', "The subcollection of SkolemFunctions whose arity is fixed. This is the most common type of skolem function, since variable- arity skolem functions are only created when a sequence variable is in the scope of the skolem.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'FixedAritySkolemFuncN', "The collection of SkolemFuncNs (q.v.) whose arity is fixed.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'FixedArityRelation', "A specialization of Relation.  A Relation is an instance  of FixedArityRelation just in case it takes a fixed number  of arguments.  Most relations reified in the Cyc ontology are  of fixed arity.  For example, likesAsFriend always takes two  arguments and pointOfContact three.  This collection is  disjoint with VariableArityRelation.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'February', "The collection of all Februaries,  the second month of the year in the GregorianCalendar.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'False', "An instance of TruthValue (q.v.).  False is the logical notion of falsehood.  That is, the term 'False' is used as a sentential constant of CycL that is false under every model theoretic interpretation.  For example, (booleanResult T/F False) means that the result obtained from the true-or-false test T/F is False.  Cf. True.", 'BaseKB', vStrDef).
assertedTinyKB(comment, 'ExpFn', "A unary EvaluatableFunction that is the CycL version of the exponential operator. It takes instances of ComplexNumber and returns instances of ComplexNumber. (ExpFn NUM) is e^NUM, i.e. e raised to the power of NUM (where e is E-LogarithmBase).  When NUM is a RealNumber, (ExpFn NUM) is necessarily a PositiveNumber. In particular, (ExpFn 1) is e.  The inverse of this function (cf. inverseQuantFunctions-Nonsymmetric\n) is LogFn. Note that although the arg constraint for ExpFn is ComplexNumber, its evaluationDefn only evaluates to a value when NUM is a RealNumber. See also ExponentFn, a binary function which returns the result of raising a specified number to a specified exponent.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'ExpandSubLFn', "<code>(ExpandSubLFn PARAMETERS SUBL-TEMPLATE)</code> denotes the SubL expression resulting from expanding the SubL template <code>SUBL-TEMPLATE</code> once all <code>PARAMETERS</code> are known.  For example, <code>(ExpandSubLFn (?X) (+ 1 ?X))</code> will denote the SubL expression <code>(+ 1 2)</code> when the parameter <code>?X</code> is bound to 2.  See also EvaluateSubLFn, trueSubL and performSubL.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'ExistentialQuantifier-Bounded', "A specialization of ExistentialQuantifier (q.v.).  Each instance of ExistentialQuantifier-Bounded is a ternary relation that can be used to make a certain kind of statement about the existence of a given bounded quantity of things meeting a given criterion.  For example, '(thereExistAtLeast 9 ?X (isa ?X Cat))' means that there exist at least nine cats.  What distinguishes _bounded_ existential quantifiers from existential quantifiers generally is that the former require one to specify explicitly (at least a boundary for) how many things exist that meet the specified criterion.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'ExistentialQuantifier', "A specialization of Quantifier (q.v.).  Each instance of ExistentialQuantifier can be used to make a certain kind of assertion regarding the existence of some thing(s) meeting a specified criterion.  For example, `(thereExistAtLeast 9 ?X (isa ?X Cat))' means that there exist at least nine cats.  Other instances of this collection are thereExists and thereExistExactly.  Cf. forAll.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'ExceptionPredicate', "A collection of mathematical objects, which are the LogicalConnectives used to express exceptions to rules.  Elements include exceptWhen and exceptFor.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'EverythingPSC', "A problem solving context in which all assertions in the entire KB are visible.  This context is only appropriate for use in queries which do not care about the consequences of possible contradictions due to conflicting information from mutually inconsistent microtheories.  See also InferencePSC.", 'BaseKB', vStrMon).
assertedTinyKB(comment, 'EvaluateSubLFn', "<code>(EvaluateSubLFn SUBL)</code> denotes the SubL term resulting from the invocation of the SubL EVAL facility on the expression <code>SUBL</code>.  For example, <code>(EvaluateSubLFn (ExpandSubLFn () (+ 1 2)))</code> evaluates to 3.  See ExpandSubLFn for a way to denote SubL within CycL.  See also trueSubL.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'EvaluatableRelation', "A specialization of Relation.  Each instance of EvaluatableRelation is\na function or predicate for which there is some piece of system code that \ncan be invoked to evaluate (i.e. to determine the denotation or truth-value\nof) a closed expression built from that function or predicate (i.e. a closed \nexpression that has the constant that denotes that function or predicate in \nits initial or \"0th\" argument-place).  An evaluation of this sort is carried \nout, for example, when the system is queried using an evaluate (q.v.) \nsentence.  As one might expect, most evaluatable relations are mathematical \nor syntactic in nature; for numbers, sets, lists, and strings are the sorts \nof things that are related in various ways that can be calculated \nalgorithmically.  Examples include PlusFn, greaterThan, JoinListsFn, \nand substring.  In the case of a function that is evaluatable (see \nEvaluatableFunction), the practical result of evaluating the relevant \nexpression is another _term_ -- one that has the same denotatum as the \noriginal expression, but that is syntactically simpler and constitutes a \nmore straightforward way of referring to that denotatum.  For example, \nthe term `(PlusFn (Inch 3) (Inch 1))', when evaluated, results in \nthe term `(Inch 4)'.  So if a query using the open sentence\n`(evaluate ?X (PlusFn (Inch 3) (Inch 1)))' is asked, the answer \n(or \"binding\" for the variable `?X') returned will be the term `(Inch 4)'.  \nEvaluating a sentence built from (a constant that denotes) an \nEvaluatablePredicate, on the other hand, yields a _truth-value_.  For \nexample, the sentence `(greaterThan (Inch 3) (Inch 1))' evaluates \nto (and so if used to ask a query will return the answer) `True'.  The \npredicate evaluationDefn (q.v.) is used to specify the name of the piece \nof system code used to evaluate expressions formed with a given \nevaluatable relation.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'EvaluatablePredicate', "A specialization of both EvaluatableRelation and Predicate (qq.v.).   Each instance of EvaluatablePredicate is a  predicate associated (via evaluationDefn) with a piece of HL (\"heuristic level\") code that computes the resulting truth-value when the predicate is applied to legal \narguments. These truth-values can, of course, be computed only when all of the predicate's argument positions are bound: thus Cyc inference will not generate viable inference tactics for non-fully-bound literals with evaluatable predicates in the arg 0 position.  As one might expect, most evaluatable predicates are mathematical or syntactic in nature; for numbers, sets, lists, and strings are the sorts of things that are related in various ways that can be calculated \nalgorithmically.  Examples include greaterThan and substring. Thus the sentence `(greaterThan 3 1)' evaluates to (and so if used to ask a query will return the answer) `True'.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'EvaluatableFunction', "A specialization of both EvaluatableRelation and Function-Denotational (qq.v.).  Each instance of EvaluatableFunction is a function that is associated (via evaluationDefn) with a piece of HL (\"heuristic level\") code that computes the result of applying the function to arguments for which that function is defined.  An evaluation of this sort is carried out, for example, when the system is queried using an evaluate (q.v.) sentence.  As one might expect, most evaluatable functions are mathematical or syntactic in nature; for, unlike with functions generally, operations on numbers, sets, lists, and strings can in many cases be calculated algorithmically.  Examples include PlusFn and JoinListsFn.  The practical result of evaluating a term built from (a constant that denotes) an evaluatable function is another _term_ -- one that has the same denotatum as the former term, but that is syntactically simpler and constitutes a more straightforward way of referring to that denotatum.  For example, the term '(PlusFn 2 3 4)', when evaluated, results in the term '9'.  So if a query using the open sentence '(evaluate ?X (PlusFn 2 3 4))' is asked, the answer (or \"binding\" for the free variable '?X') returned will be the term `9'.  By way of contrast, consider the non-evaluatable function BorderBetweenFn and the following arbitrarily-chosen non-atomic term built with its CycL name: '(BorderBetweenFn France Germany)'.  As there is no general algorithm for finding simpler or \"standard\" terms for given geographical borders, it is not possible for the Cyc system to \"evaluate\" non-atomic terms like this one.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'EscapeQuote', "A quotation-related device for making general statements about CycL expressions.  EscapeQuote is used to allow certain free variables occurring inside an expression that is quoted to \"escape\" (i.e. remain free with respect to) the quotation.  It is thus similar in function to, though more flexible than, QuasiQuote (q.v.).\n<p>\nTo be more precise: the syncategorematic symbol <code>EscapeQuote</code> is used in conjunction with the special quotation symbol <code>Quote</code> (q.v.) as a device for allowing genuinely free variables to occur inside quoted expressions, in order that one may meaningfully \"quantify into\" such expressions and thereby generalize over them.  Thus, <code>EscapeQuote</code> is used to indicate that the free variables occurring within its scope (which is itself inside the wider scope of an occurrence of <code>Quote</code>) are <i>not</i> themselves to be interpreted as being quoted.\n<p>\nThe syntax of <code>EscapeQuote</code> is such that it can only be used in conjunction with <code>Quote</code>.  For any CycL expression <code>EXPR</code>, <code>(EscapeQuote EXPR)</code> is not by itself a syntactically well-formed CycL expression; but the latter can appear as <i>part of</i> a well-formed expression, subject to the following restrictions.  (i) Any occurrence of <code>EscapeQuote</code> in a CycL expression must itself be inside the scope of an occurrence of <code>Quote</code>.  (ii) One occurrence of <code>EscapeQuote</code> can be inside the scope of another only if there is an intermediate occurrence of <code>Quote</code> (i.e. one whose scope subsumes that of the former and is subsumed by that of the latter).\n<p>\nThe semantics of <code>EscapeQuote</code> is such that a formula <code>(Quote ... (EscapeQuote EXPR) ...)</code> that contains only one occurrence of <code>EscapeQuote</code> means just what the corresponding formula <code>(Quote ... EXPR ...)</code> means, except that any free occurrence of a variable in <code>EXPR</code> is to be interpreted as still being genuinely free with respect to <code>(Quote ... (EscapeQuote EXPR) ...)</code>.  In <code>(Quote ... EXPR ...)</code>, by contrast, any such variables are taken to be regular quoted constituents of a quoted compound expression; thus they do not function there as variables, but as <i>quoted-names of</i> variables -- i.e. as terms that denote variables.  \n<p>\nFor example, while the term <code>(Quote (isa ?X Cat))</code> simply denotes the open sentence <code>(isa ?X Cat)</code>, the expression\n<pre>\n  (Quote (EscapeQuote (isa ?X Cat)))\n</pre>\nis itself an open term in which <code>?X</code> occurs free; it thus does not denote in its own right, though many <i>instantiations</i> of it do denote.  E.g. the instantiation <code>(Quote (EscapeQuote (isa Patches-Cat Cat)))</code> denotes the sentence <code>(isa Patches-Cat Cat)</code>).\n<p>\nThe foregoing explanation generalizes to cases where multiple occurrences of <code>EscapeQuote</code> are within the scope of the same <code>Quote</code>.  For example, in the expression\n<pre>\n  (Quote (loves (EscapeQuote ?X) (EscapeQuote ?Y)))\n</pre>\n-- which is equivalent to <code>(Quote (EscapeQuote (loves ?X ?Y)))</code> -- both <code>?X</code> and <code>?Y</code> occur free.\n<p>\nAs mentioned above, the purpose of the <code>EscapeQuote</code> device is to enable \"quantifying into\" quoted contexts: to provide a coherent interpretation of formulas in which an occurrence of a Quantifier (or other ScopingRelation) that is outside the scope of a given occurrence of <code>Quote</code> can be viewed as binding occurrences of variables that are <i>inside</i> the scope of that <code>Quote</code>.  For example, the sentence\n<pre>\n  (thereExists ?X\n    (and\n      (isa ?X Cat)\n      (isa (Quote (EscapeQuote ?X)) CycLAtomicTerm)))\n</pre>\nsays that there is at least one cat that is denoted by a CycL atomic term.  Without the <code>EscapeQuote</code> wrapper, the second conjunct of the above would be a <i>closed</i> sentence, and the entire quantified sentence would express the far less interesting claim that there exists at least one cat and the expression <code>?X</code> is an atomic term of CycL.\n<p>\nNote that the above (interesting) existential claim could be expressed more tersely using QuasiQuote.  EscapeQuote is indispensible only in cases where one wants to allow <i>some but not all</i> of the free variables in a given expression to escape quotation.  For example, in the (implicitly quantified) rule\n<pre>\n  (isa\n    (Quote (loves ?X (EscapeQuote ?Y))) \n    CycLOpenSentence)\n</pre>\nonly the variable <code>?Y</code> occurs free; the <code>?X</code> is part of what gets quoted (and thus functions like a closed term that <i>denotes</i> the CycL variable <code>?X</code>).  What the rule says, in effect, is that any well-formed expression built with the predicate-expression <code>loves</code> followed by the variable <code>?X</code> followed by a CycL term is an open sentence of CycL.\n<p>\nFor more on the use of EscapeQuote and Quote for quantifying into quoted contexts, see the shared NoteAboutQuotingInCycL. See also denotes, quotedIsa, quotedArgument, and NoteAboutSyncategorematicSymbols.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'equalStrings-CaseInsensitive', "(equalStrings-CaseInsensitive STRING1 STRING2) means that the CharacterStrings STRING1 and STRING2 contain the same characters in the same order, although some of the characters in STRING1 may differ in case from some of the characters in STRING2.  For example, (equalStrings-CaseInsensitive \"Foo\" \"fOo\") holds.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'EnglishParaphraseMt', "An instance of both ParaphraseDataMicrotheory and GeneralMicrotheory.  EnglishParaphraseMt is the default context used for generating English paraphrases for CycL expressions.  Many of the assertions required for English paraphrase generation, including those with the predicates genFormat and genPhrase (qq.v.), can be found in this context.", 'BaseKB', vStrDef).
assertedTinyKB(comment, 'ELRelation-Reversible', "A specialization of ELRelation (q.v.) instances of which appear only at the \"epistemological level\" (or EL) of the Cyc system, but whose original forms, or logically equivalent variants thereof, are retrievable via the CycUncanonicalizer.  Each instance of ELRelation-Reversible is associated, via the expansion (q.v.) or expansionDefn relation, to a sentence template to which the former is essentially equivalent and for which the former serves as a convenient alternative.  Furthermore, each instance of ELRelation-Reversible is also associated with a piece of code which can perform the inverse transformation.  Since each instance of ELRelation-Reversible requires special code support, this is a notAssertibleCollection.  More precisely:  A GAF (see CycLClosedAtomicSentence) whose main functor (or \"0th argument\") is a term that denotes a reversible EL relation can occur only at the EL, and not at the underlying HL (\"heuristic level\") of the system.  Thus, although one can use an EL-relation-based GAF to make an assertion to the system, the GAF that actually gets stored as an assertion in the Cyc Knowledge Base is a different (though logically equivalent) one that is related to the first via the expansion or expansionDefn assertion on the EL relation.  Upon assertion, the first GAF is transformed into the second GAF by the CycCanonicalizer.  Upon presentation to the user, the second GAF is transformed back into the first GAF, or a GAF which is logically equivalent, by the CycUncanonicalizer.  For example, willAlwaysBe is a reversible EL relation whose expansionDefn and associated piece of uncanonicalization code perform the following transformation:\n<p>\n(ist (MtSpace (MtTimeDimFn TIME) OTHER-DIMS) (willAlwaysBe P)\n<->\n(ist (MtSpace (MtTimeDimFn (IntervalStartedByFn TIME)) OTHER-DIMS) P)\n<p>\nSo if one makes an assertion into an MT with time index T using the sentence `(willAlwaysBe P)', the assertion that actually shows up in the KB is `P' in an MT with time index (IntervalStartedByFn T).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'ELRelation-OneWay', "A specialization of ELRelation (q.v.) instances of which appear only when input at the \"epistemological level\" (or EL) of the Cyc system, and whose original EL form is thereafter irretrievable.  Each instance of ELRelation-OneWay is associated, via the expansion or expansionDefn relation, to a sentence template to which the former is essentially equivalent and for which the former serves as a convenient alternative.  More precisely: A GAF (see CycLClosedAtomicSentence) whose main  functor (or \"0th argument\") is a term that denotes a one-way EL relation can  occur only at the EL, and not at the underlying HL (\"heuristic level\") of the system.  Thus, although one can use a one-way-EL-relation-based GAF to make an assertion to the system, the GAF that actually gets stored as an assertion in the Cyc Knowledge Base is a different (though logically  equivalent) one that is related to the first via the expansion assertion  on the EL relation.  Upon assertion, the first GAF is \"transformed into\" the second GAF by the CycCanonicalizer.  For example, lessThan is a one-way EL relation whose expansion correlate is the template (greaterThan :ARG2 :ARG1).  So if one makes an assertion using the sentence `(lessThan 1 2)', the assertion that actually shows up in the KB is `(greaterThan 2 1)'.  Note that terms for one-way EL relations _do_ appear in stored assertions in which  they occur in argument places other than the 0th; e.g. the sentence `(isa lessThan OrderingPredicate)' is in the KB.  One-way EL relations afford cyclists the convenience of having alternative forms of expression, while their expansions serve to minimize redundancy in the types of GAFs that the system has to store and reason with.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'ELRelation', "A specialization of MacroRelation (q.v.) instances of which appear only at the \"epistemological level\" (or EL) of the Cyc system.  Each instance of ELRelation is associated, via the expansion or expansionDefn relation, to a sentence template to which the former is essentially equivalent and for which the former serves as a convenient alternative.  Some assertions using instances of ELRelation are irretrievable after being input to the Cyc System (ELRelation-OneWay), and others' EL forms are reconstructed dynamically by the system (ELRelation-Reversible).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'DontReOrderCommutativeTerms', "A CanonicalizerDirective (q.v.) that directs the CycCanonicalizer not to re-order commutative terms that appear in the CycL assertions.", 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(comment, 'DocumentationPredicate', "A PredicateType whose instances are Predicates specifically designed for in-KB documentation purposes, such as  facilitating Cyclists in their understanding of the Cyc system, tracking knowledge representation work being done in the Cyc Knowledge Base, or noting cleanup work to be done.  \n<p>\nNote that documentation predicates are usually not involved in inference.  They may be excluded from knowledge bases in which available memory is a premium without affecting the performance of applications. DocumentationPredicate is used in code to determine which documentation to show to the user when they request to see documentation for a first-order reified term (or \"FORT\").", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'DocumentationConstant', "A collection of CycL constants whose purpose is to facilitate users in their understanding of the system, tracking knowledge representation work being done, noting cleanup work to be done, etc. Documentation constants are usually not involved in inference.  Instances may be excluded from versions of the knowledge base in which available memory is a premium without affecting the performance of applications.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'DistributingMetaKnowledgePredicate', "A subcollection of MetaKnowledgePredicate (q.v.).  Each instance of DistributingMetaKnowledgePredicate is a meta-knowledge predicate that can be used to make meta-assertions (i.e it can take a CycLAssertion as an argument) and is such that, when applied to an EL-level assertion that polycanonicalizes (i.e. gets transformed by the Cyc canonicalizer into multiple HL-level assertions), it is automatically \"distributed\" over each of the multiple assertions resulting from the polycanonicalization.\n<p>\nLet METAPRED be an instance of DistributingMetaKnowledgePredicate. Suppose that one asserts <code>(METAPRED ASSERTION FOO)</code> and that <code>ASSERTION</code> polycanonicalizes into <code>ASSERTION1</code> and <code>ASSERTION2</code>.  Then <code>(METAPRED ASSERTION1 FOO)</code> and <code>(METAPRED ASSERTION2 FOO)</code> will both be asserted to the Knowledge Base automatically.\n<p>\nFor example, if I assert this at the EL-level:\n<pre>\n  (comment\n    (and (isa Muffet Dog) (likesAsFriend Muffet Patches-Cat))\n    \"Muffet digs Patches.\"),\n</pre>\n<p>\nboth of these will automatically be asserted a the HL-level:\n<p>\n\t<code>(comment (isa Muffet Dog) \"Muffet digs Patches.\")</code>\n<p>\n\t<code>(comment (likesAsFriend Muffet Patches-Cat) \"Muffet digs Patches.\")</code> .\n<p>\nSee also the shared note MetaAssertionsForPolycanonicalizingAssertions.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'DisjointCollectionType', "A collection of collections of collections and a specialization of SiblingDisjointCollectionType (q.v.).  A disjoint collection type is such that its instances are collections that are all disjoint from one another.  That is, each instance <code>DISCOLTYPE</code> of DisjointCollectionType is a collection whose instances are mutually disjoint collections: no two instances of <code>DISCOLTYPE</code> have any instances in common.  Instances of DisjointCollectionType include BiologicalSpecies and SportsTeamTypeBySport.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'DirectedMultigraph', "A specialization of both DirectedPathSystem and Multigraph.  Each instance of DirectedMultigraph is a multigraph in which every link has one direction.  Note that there can be loops and multiple links between a pair of nodes in a given instance of DirectedMultigraph.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'DifferenceFn', "A binary MathematicalFunctionOnScalars and an extension of the arithmetic subtraction operation to ScalarIntervals (q.v.) generally.  When applied to two arithmetically-comparable scalars, MINUEND and SUBTRAHEND, DifferenceFn yields the scalar that is the result of subtracting SUBTRAHEND from MINUEND.  For example, (DifferenceFn 88 11) is 77 and (DifferenceFn (Kilogram 4.2) (Kilogram 3)) is (Kilogram 1.2).\n<p>\nNote that when MINUEND and SUBTRAHEND are not arithmetically-comparable, (DifferenceFn MINUEND SUBTRAHEND) is undefined.  For example, (DifferenceFn (MinutesDuration 1) (Meter 3)) is undefined, since (MinutesDuration 1) is a Time-Quantity and (Meter 3) is a Distance, and time-quantities are not comparable with distances.\n<p>\nFor addition, see PlusFn.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'DefaultTrue', "An instance of CycHLTruthValue.  DefaultTrue is the attribute of being assumed true unless otherwise known to be false.", 'BaseKB', vStrDef).
assertedTinyKB(comment, 'DefaultMonotonicPredicate', "A collection of predicates.  Each instance of DefaultMonotonicPredicate is a predicate whose use as the predicate of a locally asserted ground formula causes that formula to be entered, by default, as :MONOTONIC.  Examples: isa, genls, disjointWith, equals, arity, arg1Isa.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'DefaultFalse', "An instance of CycHLTruthValue.  DefaultFalse is the attribute of being assumed false unless otherwise known to be true.", 'BaseKB', vStrDef).
assertedTinyKB(comment, 'December', "A specialization of CalendarMonth.  Each instance of December is the twelth and final month of a particular year in the GregorianCalendar (q.v.).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'DayOfWeekType', "A collection of collections and a specialization of WeeklyTemporalObjectType.\nEach instance of DayOfWeekType is a collection of CalendarDays, all of\nwhose instances correspond to the same particular \"day of the week\" in \nthe respective weeks in which they occur.  For example, Monday -- the \ncollection of all mondays -- is an instance of DayOfWeekType.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'DateEncodeStringFn', "(DateEncodeStringFn TEMPLATE DATE) returns a string encoding of DATE (an instance of Date) in the format described by the TEMPLATE string.  For example,    (DateEncodeStringFn 'MM/DD/YYYY'      (DayFn 20 (MonthFn July (YearFn 1969))))  would return '07/20/1969'.  See also DateDecodeStringFn.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'DateDecodeStringFn', "(DateDecodeStringFn TEMPLATE DATE-STRING) returns a Date which is the result of decoding DATE-STRING by the format described by the TEMPLATE string.  For example,   (DateDecodeStringFn 'MM/DD/YYYY' '07/20/1969') would return (DayFn 20 (MonthFn July (YearFn 1969))).   See also DateEncodeStringFn.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'CycTransformationProof', "The nearestGenls of CycProof each of whose instances uses a CycLRuleAssertion to prove a query.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, ftVar, "The collection of all variables in the CycL language.\nA CycLVariable is a character string consisting of a question mark '?' (as its initial character) followed by one or more characters, where each of these latter characters is either an (upper- or lower-case) Roman letter, an Arabic numeral (i.e. '0' through '9'), a hyphen ('-'), an underscore ('_'), or another question mark.  (The letters occurring in a CycL variable used in an actual assertion will typically be all uppercase; but this convention is not enforced in any formal way.)  Examples: '?WHAT', '?OBJ-TYPE', and '?var0'.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'CycLTruthValueSentence', "A collection of CycL sentences containing only the CycL sentences <code>True</code> and <code>False</code>, both of which are sentential constants.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'CycLTerm', "The collection of all syntactically well-formed   expressions in the CycL language that can be used as terms, i.e. that can be combined with other expressions to form non-atomic terms or formulas.  Since the grammar of the CycL language allows any CycL expression to be used as a term, CycLTerm and CycLExpression are coextensional collections.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'CycLSentence-ClosedPredicate', "The subcollection of CycLSentences whose arg0 does not contain a free variable although free variables may occupy other argument positions.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'CycLSentence-Assertible', "An instance of CycLExpressionType and a specialization of CycLExpression-Assertible and CycLSentence-Askable.  This is the collection of all CycL sentences that could be asserted to the Cyc Knowledge Base.  More precisely, each instance of CycLSentence-Assertible is a CycL sentence that is both syntactically and semantically well-formed.  By definition, any CycL sentence is syntactically well-formed.  To be semantically well-formed, a CycL sentence must be constructible via the syntax of CycL without violating any applicable arity or argument-type constraints (see arity and ArgTypePredicate).  A CycL sentence must be semantically well-formed in order to be interpretable as having a \"semantic value\", which for sentences means having a truth value.  Note that being \"assertible\" in the present sense does not require a sentences's actually being asserted in the KB.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'CycLSentence-Askable', "The collection of CycLSentences that are askable as queries to the Cyc system.  More precisely, each  instance of CycLSentence-Askable is a CycL sentence that is  constructible via the syntax of CycL without violating any applicable  arity constraints (see arity).  Note that askable CycL sentences do  not necessarily obey other semantic constraints beyond arity, such as  argument-type constraints (see ArgTypePredicate); thus they are  not always semantically well-formed in the fullest sense (cf.  CycLSentence-Assertible).  The idea behind this criterion of  \"askability\" is that such a sentence, even if it isn't true or false (which it can't be unless it also obeys all argument-type  constraints), at least \"makes enough sense\" to be asked as a query  to the Cyc system.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'CycLSentence', "The collection of syntactically well-formed sentences of the CycL language.  Each instance of CycLSentence consists of a CycL expression denoting an instance of TruthFunction (e.g. an instance of Predicate or SententialRelation) followed by one or more CycL terms (see CycLTerm), with the entire sequence enclosed in parentheses.  \n<p>\nFor example, (isa Collection Thing) and (genls ?FOO SpatialThing) are both CycL sentences.  Note that CycLSentences <i>need not</i> obey arity constraints (see arity) or other semantic constraints (such as argument type constraints; see ArgTypePredicate).  Thus, for example, (genls ?FOO SpatialThing EiffelTower) is a CycL sentence.\n<p>\nCycLSentences are also called \"logical formulas\", and are to be distinguished from \"denotational formulas\" (which are also known as \"NAT\"s; see CycLNonAtomicTerms).  Note that this notion of a CycL sentence is broader than the notion of \"sentence\" standardly used in formal logic, where a sentence is defined as a <i>closed</i> well-formed formula: CycL sentences may be <i>open</i> (i.e. they may contain free variables; see the specialization CycLOpenSentence).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'CycLRuleAssertion', "The subcollection of semantically well-formed CycLAssertions whose formulas are rules.\nMore precisely, the formulas are not\nGAFs (see CycLGAFAssertion), so they either have more than one literal (and therefore are\nnon-atomic) or they quantify over some free variables (and therefore are non-ground).\nAny free variables are implicitly universally quantified.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'CycLRepresentedTerm', "The collection of all denotational terms that are represented in the CycL language, instead of being defined in SubL, the underlying implementation language used by Cyc.  That is, each instance of CycLRepresentedTerm is either (i) an atomic term, and thus also an instance of CycLRepresentedAtomicTerm (q.v.), or (ii) a non-atomic term (or \"NAT\"), and has a CycLRepresentedTerm as its arg0 functor (the other arguments in the NAT\nneed not be CycL represented terms).  Thus CycLRepresentedTerm has as instances all CycLConstants, all CycLVariables, and all CycLNonAtomicTerms.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'CycLRepresentedAtomicTerm', "A specialization of CycLAtomicTerm.  An instance ATOM of CycLAtomicTerm is also an instance of CycLRepresentedAtomicTerm just in case ATOM is explicitly represented in the CycL language (as opposed to being represented in SubL, the underlying implementation language of the Cyc system).  Important specializations of CycLRepresentedAtomicTerm include CycLVariable and CycLConstant.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'CycLReifiedDenotationalTerm', "The collection of denotational terms in the CycL language which are\nreified in the KB.  Examples include Muffet and (JuvenileFn Dog); a\ncounterexample would be (JuvenileFn Platypus) because that term is not\ncurrently reified in the KB.  These are often called 'FORTs', which stands for\n'first-order reified terms'", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'CycLReifiableNonAtomicTerm', "A collection of Cyc terms that are NATs (CycLNonAtomicTerms; see\nFunction-Denotational) whose functor is an instance of\nReifiableFunction. E.g., since GovernmentFn is an instance of\nReifiableFunction, it is true that (GovernmentFn France) is a\nCycLReifiableNonAtomicTerm.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'CycLReifiableDenotationalTerm', "A subcollection of both CycLClosedDenotationalTerm and CycLIndexedTerm (qq.v.).  CycLReifiableDenotationalTerm is the collection of all CycL terms that both may be reified and may denote something in the universe of discourse. It thus includes all instances of CycLConstant as well as any NAT (see CycLNonAtomicTerm) whose main functor denotes an instance of ReifiableFunction.\n<p>\nFor example, the NAT '(GovernmentFn France)' is a CycLReifiableDenotationalTerm, since GovernmentFn is a ReifiableFunction.  Similarly,  '(JuvenileFn Platypus)' is a CycL reifiable denotational term; although it is not currently reified in the KB, it is reifiable and denotational (see CycLClosedDenotationalTerm).  Finally, '(BorderBetweenFn Canada Mexico)' is a CycL reifiable denotational term; although it happens not to denote anything in the universe of discourse, it is nonetheless the kind of NAT that can and usually does denote.\n<p>\nNote that CycLVariables are not considered reifiable terms.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'CycLReformulationRulePredicate', "The collection of Predicates which may appear as the operator in a CycLReformulatorRule.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'CycLPropositionalSentence', "The collection of CycL sentences that express propositions (see Proposition).  Two necessary conditions for a CycL sentence's expressing a proposition is that it be closed (see CycLClosedSentence) and not violate any applicable arity constraints (see CycLSentence-Askable).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'CycLOpenSentence', "A specialization of both CycLOpenExpression and CycLSentence. The collection of CycL sentences that contain one or more free variables.  Note that those CycL sentences that are treated (in the context of representing assertions in the Cyc Knowledge Base) as implicitly containing initial universal quantifiers are in fact CycLOpenSentences.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'CycLOpenNonAtomicTerm', "The collection of denotational CycLNonAtomicTerms that have free variables. Examples: `(JuvenileFn ?X)', `(JuvenileFn ?X ?Y ?Z)'.  Counterexample: `(TheSetOf ?X (objectHasColor ?X GreenColor))'.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'CycLOpenFormula', "A specialization of both CycLOpenExpression and CycLFormula (qq.v.).  The collection of compound CycL expressions that contain one or more free variables.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'CycLOpenExpression', "A specialization of CycLExpression.  The collection of CycL expressions that contain one or more free variables.  A CycLVariable VAR occurs _free_ in an expression EXPR if and only if there is an occurrence of VAR in EXPR that is not bound by another term in EXPR that denotes a Quantifier or other ScopingRelation (q.v.).  For example, the expression `(isa ?X Cat)' is open, but `(thereExists ?X (isa ?X Cat))' is not.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'CycLOpenDenotationalTerm', "The collection of all open denotational terms in the CycL language.  An expression is \"open\" if it contains one or more free variables (see CycLOpenExpression).  A CycL term is said to be \"denotational\" if it is the right sort of term to have a denotation (or value) in the universe of discourse (see CycLDenotationalTerm).  Each instance of CycLOpenDenotationalTerm is either a CycLOpenNonAtomicTerm (i.e. a \"NAT\" with a free variable) or a CycLVariable itself.  Examples include `?X', `(JuvenileFn ?X)', and `(JuvenileFn isa ?X genls JuvenileFn)' (even though the latter is semantically ill-formed).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'CycLNonAtomicTerm-ClosedFunctor', "The subcollection of denotational CycLNonAtomicTerms which have no free variable in the arg0 position.\nExamples: (JuvenileFn Platypus), (JuvenileFn isa genls), (TheSetOf ?X (colorOfType ?X GreenColor)), (JuvenileFn ?X).  Counterexample: (?SOMEFN Gold) ((USDollarFn ?YEAR) 5).", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'CycLNonAtomicTerm-Assertible', "A CycLExpressionType and a specialization of both CycLExpression-Assertible and CycLNonAtomicTerm (qq.v.).  The collection of all CycL non-atomic terms that could appear within a sentence that could be asserted to the Cyc Knowledge Base.  More precisely, each instance of CycLNonAtomicTerm-Assertible is a non-atomic term that is both syntactically and semantically well-formed.  By definition, any CycL non-atomic term is syntactically well-formed.  To be semantically well-formed, a non-atomic term sentence must be constructible via the syntax of CycL without violating any applicable arity or argument-type constraints (see arity and ArgTypePredicate).  A CycL term must be semantically well-formed in order to be interpretable as having a \"semantic value\", which for terms means having a denotation.  Note that being \"assertible\" in the present sense does not require a sentence's actually being asserted in the KB.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'CycLNonAtomicTerm-Askable', "The collection of CycLNonAtomicTerms\nthat can appear within sentences that are askable as queries to the Cyc system\n(see CycLSentence-Askable).  More precisely, each instance of \nCycLNonAtomicTerm-Askable is a CycL non-atomic term that is constructible via \nthe syntax of CycL without violating any applicable arity constraints (see \narity).  Note that askable CycL non-atomic terms do not necesarily obey other \nsemantic constraints beyond arity, such as argument-type constraints (see \nArgTypePredicate); thus they are not always semantically well-formed in \nthe fullest sense (cf. CycLNonAtomicTerm-Assertible).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'CycLNonAtomicTerm', "A CycLExpressionType and a specialization of both CycLFormula \nand CycLRepresentedTerm (qq.v.).  CycLNonAtomicTerm is the \ncollection of non-atomic denotational terms in the CycL language.  \nA CycL term is _non-atomic_ if it is constructible from other CycL \nterms via the syntax of CycL.  A CycL term is said to be \n\"denotational\" if it is the type of term that can have a \ndenotatum (or assigned value; see CycLDenotationalTerm).  \nCycLNonAtomicTerm thus includes all CycL denotational terms \nexcept constants and variables.  A CycL non-atomic term (or \"NAT\") \nconsists of a CycL expression denoting a Function-Denotational \nfollowed by one or more CycL terms, with the entire sequence \nenclosed in parentheses.  The NAT itself denotes the value (if any) \nof this function for the denotations of the other terms taken as \narguments.  (If there is no such value then the NAT has no denotatum;\nsee undefined.)  NATs are also known as \"denotational formulas\", \nin contrast to \"logical formulas\" (i.e. sentences).  Currently, \nthere are two main types of NAT: (i) HLNonAtomicReifiedTerms (or \n\"NART\"s), which are a type of HLReifiedDenotationalTerm and are \nimplemented with data structures that have indexing that enables all \nuses of the NAT to be retrieved, and (ii) ELNonAtomicTerms (or \n\"NAUT\"s), which have no such indexing and remain in the \nform of an EL expression in the assertions in which\nthey occur.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'CycLNonAtomicReifiedTerm', "The subcollection of CycLReifiableNonAtomicTerms that are reified in the KB. Example: (JuvenileFn Dog).  Counterexample: (JuvenileFn Platypus), because that term is not currently reified in the KB.  These are often called NARTs, which stands for 'non-atomic reified term'.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'CyclistDefinitionalMt', "The microtheory in which instances of Cyclist are defined.  Assertions about them belong in CyclistsMt.", 'BaseKB', vStrMon).
assertedTinyKB(comment, 'Cyclist', "A specialization of IndividualAgent. Each instance of Cyclist is an agent (usually a person) entitled to inspect and modify the Cyc knowledge base.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'CycLIndexedTerm', "The collection of indexed or indexable terms in the CycL language.\nThis includes reified HL terms as well as reifiable EL NATs and assertions.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'CycLGenericRelationFormula', "A subcollection of CycLFormula (q.v.).  Each instance of that CycLGenericRelationFormula is a CycL formula that begins (immediately after the opening parenthesis) with a variable or other open expression (see CycLOpenExpression); i.e. it has an open expression in its \"0th\" or \"arg0\" position.  A CycL generic relation formula thus consists \nof an open expression followed by some number of terms, with the entire sequence \nenclosed in parentheses.  But note that the open expression in the formula's \narg0 position must be such that, given the syntax and intended semantics of CycL, it could conceivably have a Relation -- i.e. a Function-Denotational or a TruthFunction (such as a Predicate or LogicalConnective) -- as its semantic value.  Hence the arg0 open expression might be a variable, as in the generic relation formula `(?RELATION Muffet Dog)'; or it might be an appropriate open non-atomic term (or \"NAT\"; see CycLNonAtomicTerm), as in \n`((Kappa (?ARG1) (knows ?ARG1 ?ARG2)) Muffet)'; or it might itself be \na generic relation formula, as in `((?REL ?ARG1 Dog) Muffet)'.  On the \nother hand, `((BorderBetweenFn ?ARG1 ?ARG2) Muffet Dog)' is not a \nCycLGenericRelationFormula, since BorderBetweenFn only returns instances \nof Border, which is disjoint with Relation; thus the open NAT \n`(BorderBetweenFn ?ARG1 ?ARG2)' couldn't possibly have a Relation as its \nsemantic value, no matter what values were assigned to the variables `?ARG1' \nand `?ARG2'.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'CycLGAFAssertion', "A CycLExpressionType and a specialization of both CycLAtomicAssertion and CycLClosedAtomicSentence (qq.v.).  This is the collection of all and only the closed atomic CycL sentences that have been asserted to the Knowledge Base or deduced there by the inference engine.  GAF assertions typically express particular facts (as opposed to general rules) about the world.  The acronym `GAF' stands for \"ground atomic formula\"; see CycLClosedAtomicSentence.\n<p>\nAt the epistemological level (see ELExpression), a GAF assertion contains no free variables and is thus (at least) \"ground\".  At the heuristic level (see HLExpression), however, the HLAssertion(s) representing the GAF assertion -- the sentence(s) that are actually stored in the KB -- contain no variables whatsoever and are thus \"_fully_ ground\" (see CycLFullyGroundAtomicSentence).  For example, if the ground atomic sentence\n<p>\n(isa (TheSetOf ?X (objectHasColor ?X GreenColor)) Thing)\n<p>\nwere asserted it would be a GAF assertion, and it would be represented in the KB by some fully ground atomic sentence(s) containing no variables at all.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'CycLFormulaicSentence', "A subcollection of syntactically well-formed sentences of the CycL language. Each instance of CycLFormulaicSentence consists of a CycL expression denoting an instance of TruthFunction (e.g., an instance of Predicate or SententialRelation) followed by one or more CycL terms (see CycLTerm), with the entire sequence enclosed in parentheses. For example, (isa Collection Thing) and (genls ?FOO SpatialThing) are both formulaic CycL sentences. The only two CycL sentences that are not formulaic are True and False. Note that CycLFormulaicSentences need not obey arity constraints (see arity) or other semantic constraints (such as argument type constraints ; see ArgTypePredicate). CycLFormulaicSentences are also called \"logical formulas\", and are to be distinguished from \"denotational formulas\" (which are also known as \"NAT\"s; see CycLNonAtomicTerms). Note that this notion of a formulaic CycL sentence is broader than the notion of \"sentence\" standardly used in formal logic, where a sentence is defined as a _closed_ well-formed formula: formulaic CycL sentences may be _open_ (i.e., contain free variables; see CycLOpenSentence).", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'CycLFormula', "The collection of compound CycL expressions.  Each instance of CycLFormula consists of a CycL expression that denotes a relation (e.g. a Predicate, Function-Denotational, or TruthFunction) -- or at least an expression that could be interpreted as having a relation as its semantic value (see CycLGenericRelationFormula) -- followed by one or more CycL terms (see CycLTerm), with the entire sequence enclosed in parentheses.  For example, (isa Muffet Poodle) and (BirthFn Muffet) are both CycL formulas.  Two important specializations of CycLFormula are CycLNonAtomicTerm (whose instances are also called \"denotational formulas\") and CycLSentences (whose instances are also called \"logical formulas\").  Note that this notion of \"formula\" differs somewhat from that used in formal logic, where a formula is normally defined as an (atomic or non-atomic, quantificationally closed or open) sentence.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, ttFormatType, "A collection of collections.  Each instance of CycLExpressionType is a type (i.e. a subcollection) of CycLExpression.  Note that, while CycLExpressionType is not itself a quotedCollection (q.v.), most of its reified instances are quoted-collections.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'CycLExpression-Assertible', "A CycLExpressionType.  The collection  of all compound CycL expressions that either could themselves be asserted to the  Cyc Knowledge Base (see CycLSentence-Assertible) or could appear as denotational terms within sentences that could be so asserted (see CycLDenotationalTerm-Assertible).  More precisely, each instance of CycLExpression-Assertible is a CycL expression that is both syntactically and semantically well-formed.  By definition, any compound CycL expression is  syntactically well-formed.  To be semantically well-formed, a CycL expression  must be constructible via the syntax of CycL without violating any applicable arity or argument-type constraints (see arity and ArgTypePredicate).  A CycL expression must be semantically well-formed in order to be interpretable as having a \"semantic value\", such as a truth-value (if the expression is a sentence) or a denotation (if it's a CycLDenotationalTerm).  Note that being \"assertible\" in the present sense does not require an expression's actually being asserted in (or being a component of something asserted in) the KB.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'CycLExpression-Askable', "The collection of CycLExpressions\nthat are either themselves askable as queries to the Cyc system (see \nCycLSentence-Askable) or could appear as non-atomic terms within \nsentences that could be so asked (see CycLNonAtomicTerm-Askable). \nMore precisely, each instance of CycLExpression-Askable is a CycL \nexpression that is constructible via the syntax of CycL without \nviolating any applicable arity constraints (see arity).  Note that \naskable CycL expressions do not necesarily obey other semantic \nconstraints beyond arity, such as argument-type constraints (see \nArgTypePredicate); thus they are not always semantically \nwell-formed in the fullest sense (cf. CycLExpression-Assertible).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'CycLExpression', "The collection of all (and only) expressions in the CycL language.  This includes all constants, variables, and formulas (i.e. non-atomic terms and sentences).  Each CycL expression is, trivially, a <i>syntactically</i> well-formed expression of CycL; but note that it might or might not be \"<i>semantically</i> well-formed\" (see CycLExpression-Assertible).  Also note that, since the CycL syntax allows any CycL expression to be used as a term, CycLExpression is coextensional with CycLTerm (q.v.).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'CycLDenotationalTerm-Assertible', "A CycLExpressionType and a specialization of both CycLDenotationalTerm and CycLExpression-Assertible (qq.v.).  This is the collection of all CycL denotational terms that could appear within a sentence that could be asserted to the Cyc Knowledge Base.  More precisely, each instance of CycLDenotationalTerm-Assertible is a denotational (i.e. non-logical) term that is both syntactically and semantically well-formed.  By definition, any CycL term is syntactically well-formed.  To be semantically well-formed, denotational term sentence must be either be atomic (see CycLAtomicTerm) or constructible via the syntax of CycL (see CycLNonAtomicTerm-Assertible) without violating any applicable arity or argument-type constraints (see arity and ArgTypePredicate).  A CycL term must be semantically well-formed in order to be interpretable as having a \"semantic value\", which for denotational terms means having a denotation.  Note that being \"assertible\" in the present sense does not require a sentence's actually being asserted in the KB.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'CycLDenotationalTerm', "The collection of all CycL terms that are not sentences (cf. CycLSentence), and thus are either CycLAtomicTerms (such as constants or variables) or CycLNonAtomicTerms (also known as \"NAT\"s).   CycLDenotationalTerms are so-called, not because they all have denotations (not all of them do), but because they are in a certain sense the right kind of term for having a denotation.  That is, an instance of CycLDenotationalTerm -- if it is semantically well-formed and closed (i.e. contains no free variables) -- might denote something in the universe of discourse.  (Even so, it will not _necessarily_ denote something, considering (e.g.) the fact that a function need not be defined for every (sequence of) thing(s) satisfying its argument type constraints; see PartialFunction.)  But note that neither semantic well-formedness nor being closed is a requirement for being a CycL denotational term: `(JuvenileFn isa ?X genls JuvenileFn)', for example, is a NAT and thus a denotational term.  Other examples of denotational terms are the expressions: `Muffet', `?X', `(JuvenileFn ?X)', `(TheSetOf ?X (objectHasColor ?X GreenColor))', and `212'.  Note also that, like most instances of CycLExpressionType, CycLDenotationalTerm is a quotedCollection (q.v.).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'CycLDeducedAssertion', "The subcollection of semantically well-formed CycLAssertions that are supported by at least one argument which is a deduction by Cyc's inference engine, as opposed to having been explicitly asserted to Cyc. A given assertion can have more than one argument, and can therefore be both a CycLAssertedAssertion and a CycLDeducedAssertion.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'CycLConstant', "The collection of all constants in the CycL language. CycLConstant has as instances all CycLAtomicTerms other than CycLVariables and SubLAtomicTerms (qq.v.).  Orthographically, CycL constants are those atomic terms (i.e. terms not constructable from other terms via CycL syntax) that are prefixed by '' in their printed (as opposed to their HTML-displayed) representations.  For example, 'Dog' and 'isa' are CycL constants, while other CycL terms like '?X', '42', and  '(GovernmentFn France)' are not.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'CycLClosedSentence', "A specialization of both CycLSentence and CycLClosedExpression.  The collection of CycL sentences that contain no free variables.  Note that those CycL sentences that are treated (in the context of representing assertions in the Cyc Knowledge Base) as implicitly containing universal quantifiers are <i>not</i> closed sentences (cf. CycLOpenSentence).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'CycLClosedNonAtomicTerm', "The collection of closed, non-atomic denotational terms of the CycL language.  Each instance of CycLClosedNonAtomicTerm is a CycL term that contains no free variables, is constructible from other CycL terms via the syntax of CycL, and can have a denotatum (this last requirement excludes closed CycL sentences from CycLClosedNonAtomicTerm).  Examples: `(JuvenileFn Platypus)', `(JuvenileFn isa genls)', and `(TheSetOf ?X (objectHasColor ?X GreenColor))'.  Non-example: `(JuvenileFn ?X)'.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'CycLClosedFormula', "A specialization of both CycLFormula and CycLClosedExpression.  The collection of compound expressions of CycL that contain no free variables.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'CycLClosedExpression', "The collection of CycLExpressions that contain no free variables.  (A variable VAR occurs _free_ in an expression EXPR if and only if there is an occurrence of VAR in EXPR that is not bound by a quantifier or other ScopingRelation (q.v.) in EXPR.)  Note that those CycL sentences that are treated (in the context of representing assertions in the Cyc Knowledge Base) as implicitly containing universal quantifiers are _not_ closed expressions (see CycLClosedSentence). Also cf. CycLOpenExpression.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'CycLClosedDenotationalTerm', "The collection of all closed denotational terms in the CycL language.  An expression is said to be \"closed\" if it contains no free variables (see CycLClosedExpression).  A CycL term is said to be \"denotational\" if it is the right sort of term to have a denotation (or value) in the universe of discourse (see CycLDenotationalTerm).  CycL sentences, while terms of CycL, are not considered denotational terms.  Each instance of CycLClosedDenotationalTerm is either a CycLClosedAtomicTerm (i.e. a CycLConstant or SubLAtomicTerm) or a CycLClosedNonAtomicTerm (i.e. a \"NAT\" with no free variables).  Examples of closed denotational terms include `Muffet', `(JuvenileFn Dog)', `(TheSetOf ?X (objectHasColor ?X GreenColor))', and `212'.  Note that these are also examples: `(BorderBetweenFn Canada Mexico)' (despite the fact that it fails actually to denote anything) and `(JuvenileFn isa genls JuvenileFn)'\n(despite the fact that it is not semantically well-formed).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'CycLClosedAtomicTerm', "The collection of all closed CycLAtomicTerms.  \"Closed\" here means not containing any free (i.e. unbound) variables.  Since a variable itself is the only type of _atomic_ term that contains a variable (and contains it _free_, moreover, as a single occurrence of a variable can't bind itself), CycLClosedAtomicTerm has as instances all CycLAtomicTerms except CycLVariables.  Like all CycL atomic terms, Cycl closed atomic terms are \"denotational\" (see CycLDenotationalTerm).  Note that this collection, like most instances of CycLExpressionType, is \"quoted\" (see quotedCollection).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'CycLClosedAtomicSentence', "A CycLExpressionType and a specialization of both CycLAtomicSentence and CycLClosedSentence (qq.v.).  This is the collection of all and only the syntactically well-formed atomic sentences in the CycL language that contain no free variables.  Syntactically, each instance of CycLClosedAtomicSentence consists of a CycL expression denoting a Predicate followed by one or more (closed) CycL terms, with the entire sequence enclosed in parentheses.  Such sentences are sometimes called \"GAFs\" (an acronym for \"ground atomic formulas\"); see also the specialization CycLFullyGroundAtomicSentence.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'CycLAtomicTerm', "The collection of all atomic CycLDenotationalTerms (q.v.).  \"Atomic\" here means not constructible  from other CycL terms via the syntax of CycL.  Thus, subcollections  of CycLAtomicTerm include CycLConstant, CycLVariable, and SubLAtomicTerm.  Note that CycLAtomicTerm, like most instances of CycLExpressionType, is \"quoted\" (see quotedCollection).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'CycLAtomicSentence', "The collection of syntactically well-formed atomic sentences in the CycL language. Each instance of CycLAtomicSentence consists of a CycL constant denoting a Predicate followed by one or more (closed or open) CycL terms, with the entire sequence enclosed in parentheses.  Thus CycL atomic sentences never contain other sentences as truth-functional components (see TruthFunction).  Note that \"atomic\" as used here specifically in connection with _sentences_, has a less strict meaning than it does when applied to terms generally, where it means \"not constructible from other terms via CycL syntax\" (see CycLAtomicTerm).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'CycLAtomicAssertion', "A specialization of CycLAtomicSentence.  An instance ATOM of CycLAtomicSentence is also an instance of CycLAtomicAssertion just in case ATOM has been explicitly asserted to the Cyc Knowledge Base (see CycLAssertedAssertion), or deduced in the Knowledge Base by the Cyc inference engine (see CycLDeducedAssertion).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'CycLAssertionDirection', "The collection of possible inference \"directions\" that a CycLAssertion\ncan have.  A given CycL assertion's direction (see assertionDirection) \nindicates something about how and when the assertion can be used in inferences\nby the Cyc system.  More precisely: Backward-AssertionDirection indicates\nthat the assertion can only be used in inferences carried out when a query\nis asked; Forward-AssertionDirection indicates that the assertion can be used \nin inferences carried out at the time the assertion is added to the Knowledge \nBase as well as those carried out at ask-time; and Code-AssertionDirection\nindicates that the assertion itself cannot be used in either backward \n(ask-time) or forward (assert-time) inferences, but is instead implemented \nin the underlying code of the Cyc system.  Each CycL assertion has exactly \none of the above three directions; the default direction is Forward for \nground atomic assertions (see CycLClosedAtomicSentence) and Backward for \nrule assertions.  Note that a CycL sentence is given a direction at the time \nof its assertion to the system, and this fact _need_not_ be reflected in \nanother, assertionDirection assertion's being added to the system (as\nthat would of course lead to an infinite regress).", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'CycLAssertion', "The collection of semantically well-formed CycLSentences asserted to the Cyc Knowledge Base.  Each instance of CycLAssertion is either (1) an HL assertion, i.e. a CycL sentence that corresponds to a data structure actually in the Cyc KB), or (2) an EL assertion : an Epistemological Level CycL sentence that can be canonicalized into one or more already extant HL assertions.  CycLAssertion is used as a quoted argument type constraint for certain meta-predicates, such as overrides.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'CycLAssertedAssertion', "A specialization of CycLAssertion.  An instance ASSERT of CycLAssertion is also an instance of CycLAssertedAssertion  just in case ASSERT was explicitly asserted to the Cyc Knowledge Base by one of its users (see the collection Cyclist), as opposed to having been deduced by Cyc's inference engine (in which case it would be an instance of CycLDeducedAssertion (q.v.)).  Note that since a single assertion can be both explicitly asserted to the knowledge base and also deduced by the inference engine, the collections CycLAssertedAssertion and CycLDeducedAssertion are not disjoint.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'CycInferenceBindingsDataStructure', "A specialization of CycInferenceDataStructure.  Each\ninstance of CycInferenceBindingsDataStructure is a component of one\nor more CycInferenceAnswers, and encodes an assignment of bindings\nto the free variables in the query which yielded that answer\n(i.e., the query which triggered the CycInference of which that\nanswer is a part).  If the triggering query is closed, the binding\nlist value is NIL.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'CycInferenceAnswerJustification', "A specialization of CycInferenceDataStructure.  Each\ninstance of CycInferenceAnswerJustification is a component of one or\nmore CycInferenceAnswers, and, in each case, encodes a complete set\nof supports (cf., CycSupportDatastructure) for that answer's binding\nlist.  See also CycInferenceBindingsDataStructure.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'CycInferenceAnswer', "A specialization of CycInferenceDataStructure.  Each\ninstance of CycInferenceAnswer is a complex data structure that is a\ncomponent of one or more CycInferences (specifically, of certain\ninferences whose root problem is proven).  A CycInferenceAnswer has\ntwo components: an assigment of bindings to query variables and sets of justifications for those bindings.  For information about the components, see the predicates inferenceAnswerBindings and inferenceAnswerJustification.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'CycHLTruthValue', "The truth/strength combinations used in the Cyc HL implementation of CycLAssertions and arguments.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'CycHLSupportDatastructure', "A specialization of both CycHLDatastructure and\nCycSupportDatastructure (qq.v.) instances of which\nare Cyc HL datastructures that can be used as supports\nwithin a CycDeductionDatastructure (q.v.).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'CycAdministrator', "This constant is for use by Cyc administrators responsible for installation, setup and maintenance of Cyc images.", 'BaseKB', vStrMon).
assertedTinyKB(comment, 'CurrentWorldDataCollectorMt-NonHomocentric', "The Microtheory which collects together all of the instances of GeneralMicrotheory (including instances of DataMicrotheory) as genlMts (excepting HomoCentricNaturalismMt), so that any scenario or project microtheory which needs wide access to the KB but needs to accept either non-human Persons or supernatural things can use this as a genlMt and be assured that all generally defined terms are available.  If no need exists to access instances of TemporalThing, WorldLikeOursCollectorMt-NonHomocentric should be used instead.  If for the purposes of the project all persons are human and no supernatural things are being reasoned about use the CollectorMicrotheory CurrentWorldDataCollectorMt or WorldLikeOursCollectorMt.", 'BaseKB', vStrMon).
assertedTinyKB(comment, 'CoreCycLMt', "This is a microtheory which contains only the assertions required to represent useful logical truths in CycL.  It extends the LogicalTruthMt with additional assertions which are so useful as to be considered `core' to the CycL language.", 'BaseKB', vStrMon).
assertedTinyKB(comment, 'CoreCycLImplementationMt', "This is a microtheory which contains only the `core' assertions required for the Cyc theorem prover and its underlying HL representation of the EL to conclude useful inferences.  It extends the LogicalTruthImplementationMt with assertions necessary for Cyc's implementation to make use of the terms defined in the CoreCycLMt.", 'BaseKB', vStrMon).
assertedTinyKB(comment, 'CommutativeRelation', "An instance of RelationTypeByLogicalFeature (q.v.) and a specialization of AtLeastPartiallyCommutativeRelation (q.v.).  Each instance of CommutativeRelation <code>COMRELN</code> is a predicate or function that is commutative in all of its argument-places.  That is, if <code>COMRELN</code> is a predicate (function) that holds among (has a value <code>VAL</code> for) a given sequence of arguments, then <code>COMRELN</code> also holds among (has the same value <code>VAL</code> for) any permutation of that  sequence.  \n<p>\nExamples of commutative relations include PlusFn, or, bordersOn, temporallyIntersects, and teammates.  Specialization include SymmetricBinaryPredicate.  \n<p>\nNote that most relations are <i>not</i> commutative.  Cf. the disjoint collection  PartiallyCommutativeRelation.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'CollectionRuleTemplateFn', "(CollectionRuleTemplateFn COL) denotes the rule template unique to collection COL.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'CollectionDenotingFunction', "The subcollection of Function-Denotational whose instances return instances of Collection.  Examples include SwimmingEventFn, GroupFn, and MoleculeFn.  For example, (MoleculeFn Oxygen) denotes the collection of all oxygen molecules.  See also the collections IndividualDenotingFunction and SetDenotingFunction.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, tCol, "A specialization of SetOrCollection (q.v.).  This is the collection of all collections of things.  Each Collection is a kind or type of thing whose instances share a certain property, attribute, or feature.  For example, Cat is the collection of all and only cats, and BinaryFunction is the collection of all and only functions taking two arguments.\n<p>\nThe notion of collection is fundamental to the Cyc ontology, and is thus difficult to define in a precise and substantive way.  But it is instructive to compare it to the mathematical notion of a set (see Set-Mathematical).  Like a set, a collection is an AbstractThing (i.e. aspatial and atemporal) that is not an Individual (cf.), but instead has elements (see elementOf).  Unlike a set, however, the elements or \"instances\" (see isa) of a given collection can vary from context to context, and it is possible for distinct collections to have exactly the same elements (i.e. to have the same extent) with respect to a given context. For example, the (non-reified) collections \"Chordate\" and \"Renate\" are co-extensional in the context of the present-day actual world, but have differring extents with respect to hypothetical contexts in which there exist creatures having hearts but not kidneys.  This difference is sometimes summarized by saying that sets are \"extensional\" things and collections are \"intensional\" things.\n<p>\nMany, though by no means all, of the collections reified in the Cyc ontology correspond to natural kinds or classes.  It is particulary useful to reify collections that are difficult to define precisely, but about which there are many common-sense rules and other things to state.  For example, it would not be worthwile to introduce a constant 'WhiteCat', both because it's easy to define the collection of white cats in terms of more general, already-reified notions (e.g. '(CollectionIntersection2Fn Cat WhiteColor)'), and because there's not much to say about that particular collection.  WhiteCollarWorker, on the other hand, is a good collection to have reified, as it is hard to define precisely, yet is a collection about which there are many things to say.\n<p>\nSome of the many reified specializations of Collection are FirstOrderCollection, TimeDependentCollection, and ObjectType.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'Code-AssertionDirection', "An instance of CycLAssertionDirection (q.v.).  A CycL assertion that\nhas the Code-AssertionDirection cannot itself be used in either \nbackward (ask-time) or forward (assert-time) inferences, but is instead \nimplemented in the underlying code of the Cyc system.  Contrast with \nBackward-AssertionDirection and Forward-AssertionDirection.  Also \nsee assertionDirection.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'CharacterString', "A specialization of AbstractInformationStructure.  Each instance of CharacterString is a string of characters or an abstract sequence of symbols.  Note that an instance of CharacterString is <i>not</i> any particular physical, tangible representation, since different encodings may represent the same string of characters.  An instance of CharacterString is a list (see the collection List) of characters (instances of Character-Abstract) from some fixed character set. An instance of CharacterString may be any finite length, including zero (the zero-length string is the empty string, which has no characters).  Notable specializations of CharacterString include EMailAddress, AreaCode, PhoneNumber, and TelephoneCountryCode.  Note that a CharacterString is ordered formally as a List (rather than physically left-to-right or top-to-bottom); thus the 'first' character in the CharacterString for an Arabic word happens to be the rightmost (first pronounced) character, not the leftmost character, due to the letter-order and word-order convention for Arabic writing.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'CanonicalizerDirective', "A specialization of AspatialInformationStore.  Instances  of CanonicalizerDirective are directives (or \"commands\") that can be  given to the CycCanonicalizer (via certain CanonicalizerDirectivePredicates) in order to control its behavior in certain ways during asserts and queries.   Examples include AllowGenericArgVariables and LeaveSomeTermsAtEL. See e.g. the directive predicate canonicalizerDirectiveForArg for more  information on how to use these directives.", 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(comment, 'BroadMicrotheory', "The collection of those microtheories that contain so many assertions that they are not useful for `relevance' focusing during inference.  (A BroadMicrotheory is not used internally in Cyc's indexing scheme during inference.)  Examples: BaseKB and EnglishMt.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'BookkeepingPredicate', "A PredicateType whose instances are predicates used to make assertions about the reification (or \"creation\") and internal representation of particular CycL terms (usually constants) in the Cyc system.  Bookkeeping predicates neither specify nor constrain the semantics of CycL terms.  Examples include  myCreator, myCreationTime, termOfUnit, and defnSufficient.  Many (but not all) bookkeeping predicates are also MetaKnowledgePredicates (q.v.).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'BookkeepingMt', "A Microtheory for stating basic bookkeeping information regarding the Cyc Knowledge Base, such as assertions using myCreator or myCreationTime.", 'BaseKB', vStrDef).
assertedTinyKB(comment, 'BinaryRelation', "The collection of all fixed-arity relations of arity 2 (see arity).  The most notable specializations of BinaryRelation are BinaryPredicate and BinaryFunction (qq.v.).", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'BinaryPredicate', "A specialization of both BinaryRelation and Predicate.  BinaryPredicate is the collection of all predicates whose arity (see arity) is 2.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'BinaryFunction', "A specialization of both BinaryRelation and Function-Denotational.  An instance of Function-Denotational FUNC is an instance of BinaryFunction if and only if FUNC has an arity of 2.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'BaseKB', "BaseKB is the most general Microtheory currently in use.  Assertions in this context are `accessible' from any other Microtheory via the genlMt relation.  In the partial order of microtheories, all microtheories have access to BaseKB.  An assertion which is true here will by default be true in every context.  The `content' of BaseKB consists of very general assertions which are expected to be usable in most or all applications of Cyc, as well as Cyc's most fundamental assertions that it uses in inference, and all completely universal, timeless truths.", 'BaseKB', vStrDef).
assertedTinyKB(comment, 'Backward-AssertionDirection', "An instance of CycLAssertionDirection (q.v.).  A CycL assertion that\nhas the Backward-AssertionDirection can only be used in inferences that \nare carried out when a query is asked. This is the default direction for \nrule assertions.  Contrast with Forward-AssertionDirection and Code-AssertionDirection.  Also see assertionDirection.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'Average', "Computes the average of the function values over all elements in the Set.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'August', "The collection of all Augusts,\n the eighth month of the year in the GregorianCalendar.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'AtemporalNecessarilyEssentialCollectionType', "A collection of collections.  Each instance <code>COL</code> of AtemporalNecessarilyEssentialCollectionType (<i>ANECT</i>) is a collection satisfying three conditions: (1) <code>COL</code> is disjoint with (see disjointWith) TemporalThing, (2) every instance <code>INST</code> of <code>COL</code> is an instance of <code>COL</code> essentially (i.e. <code>INST</code> is an instance of <code>COL</code>, and could not exist without being an instance of <code>COL</code>), and (3) condition (2) is a necessary truth about <code>COL</code>.\n<p>\nPositive examples of ANECTs include Collection, Integer, and Relation (each of which is a collection of atemporals and is such that, necessarily, all of its instances are in it essentially).  Negative examples include SpatialThing (though arguably it is necessary that all of its instances are essentially instances of it, it is not disjoint with TemporalThing) and UniqueAnatomicalPartType (which, though disjoint with TemporalThing, has instances, such as Heart, that could exist even if they weren't instances of it; e.g. it might have been the case that every creature with a heart had at least two hearts).  There are no known examples of Cyc-reified collections satisfying conditions (1) and (2) but not (3), but one can be contrived.  Suppose that all of today's winning lottery numbers were primes.  Now consider the collection:\n<p>\n (CollectionUnionFn \n   (TheSet PrimeNumber <i>TodaysWinningLotteryNumbers</i>))\n<p>\nThis collection is clearly disjoint with TemporalThing and, by hypothesis, all of its instances are in it essentially (as each prime number is essentially a prime number).  But this last fact is not <i>necessarily</i> true of this collection: the collection might have had instances that belonged to it only contingently (i.e. not essentially), as it might have been the case that one of today's winning lottery numbers was non-prime, and no number is such that it is essentially one of today's winning lottery numbers.\n<p>\nWhen asserting that something is an instance or specialization of a given instance of ANECT, it is appropriate to do so in the UniversalVocabularyMt (q.v.).  Indeed, ANECT was specially defined to facilitate the movement of appropriate assertions to that microtheory.\n<p>\nCf. PragmaticallyDecontextualizedCollection.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'AsymmetricBinaryPredicate', "An instance of BinaryPredicateTypeByLogicalFeature and a specialization of AntiSymmetricBinaryPredicate (q.v.).  A binary predicate <code>BINPRED</code> is an instance of AsymmetricBinaryPredicate if and only if (i) for any <code>THING1</code> and <code>THING2</code>, <code>(BINPRED THING1 THING2)</code> implies <code>(not (BINPRED THING2 THING1))</code> and (ii) the single-argument argument type (i.e. argIsa and argGenl) constraints on <code>BINPRED</code>'s two respective argument-places are \"co-satisfiable\" (see cosatisfiableInArgs and NoteOnArgumentCosatisfiabilityRequirement).\n<p>\nExamples of asymmetric binary predicates include northOf, children, greaterThan, and overrides.  Cf. SymmetricBinaryPredicate.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'AssociativeRelation', "The collection of polyadic Relations having the property of <i>associativity</i>.  Roughly speaking, a relation is associative if certain different sequences of recursive applications of it lead to the same final result.\n<p>\nMore precisely:  If <b>RELN</b> is binary, it is an instance of AssociativeRelation if and only if (for any appropriate arguments <b>A</b>, <b>B</b>, and <b>C</b>) the corresponding formulas <b>(RELN A (RELN B C))</b> and <b>(RELN (RELN A B) C)</b> are (extensionally) equivalent: if <b>RELN</b> is a Function-Denotational both formulas have the same denotatum (or both have no denotatum), while if <b>RELN</b> is a Predicate or LogicalConnective both formulas have the same truth value.  If <b>RELN</b> has a higher arity than two, the definition is similar, but with the relevant formula schemata appropriately rewritten.  If <b>RELN</b> is variable-arity (see VariableArityRelation), it is an AssociativeRelation if and only of it behaves associatively with respect to each of the particular arities it subsumes (its arityMin to arityMax).  No unary relation is associative. \n<p>\nIt follows from the above definition that that each argument-place of an associative relation must admit exactly the same class of arguments (see admittedArgument), and that its results must also be of that same class (so that it can be applied recursively).\n<p>\nExamples of associative relations include PlusFn, TimesFn, JoinListsFn, SpatialSumFn, or, and and.\n<p>\nNote that, while many AssociativeRelations are CommutativeRelations (q.v.), this is not always the case.  Consider for example ConcatenateStringsFn.  Since it is associative, (('c'^'a')^'t') = ('c'^('a'^'t')) = 'cat'.  But it is certainly <i>not</i> commutative: 'cat' =/ 'act'.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'assertionUtility-1', "A CycInferenceHeuristicRelevancePredicate. (assertionUtility ASSERTION NUM) states that the CycLAssertion ASSERTION should be heuristically considered of utility NUM to inferences made in the current Microtheory. NUM should be a RealNumber between 1 and -1, with 1 indicating maximum utility, -1 indicating minimum utility, and 0 being agnostic with respect to utility.  (assertionUtility ASSERTION 1) is equivalent to (highlyRelevantAssertion ASSERTION). (assertionUtility ASSERTION -1) is equivalent to (irrelevantAssertion ASSERTION).  See also other instances of CycInferenceHeuristicRelevancePredicate.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'ArgTypeTernaryPredicate', "Those instances of both TernaryPredicate and ArgTypePredicate used to specify the required isa or genls or quotedIsa of an argument of a Relation; the arg1 is the Relation; the arg2 is the argument constrained; the arg3 is the required type: a Collection.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'ArgTypePredicate', "The collection of ArgConstraintPredicates used to put semantic well-formedness constraints on the type of argument(s) appropriate for a given argument-place (or -places) of a given relation.  A \"type\" of argument can be specified in terms of isa or genls; see the various specializations of ArgTypePredicate for more detail. Violation of such a constraint results in an expression that is semantically malformed.  For a general explanation of semantic well-formedness, see CycLExpression-Assertible and its specializations.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'ArgTypeBinaryPredicate', "Those instances of both BinaryPredicate and ArgTypePredicate used to specify the required isa or genls or quotedIsa of an argument of a Relation; the arg1 is the Relation; the arg2 is the required type, a Collection.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'ArgSometimesIsaPredicate', "The collection of ArgTypePredicates (q.v.) that specify argument-types\ndirectly (by referencing certain collections) and impose constraints that\nrequire an argument of a predicate being an instance of a SubLExpressionType\ncollection at some time.  More precisely, each instance\nof ArgSometimesIsaPredicate PRED takes a Relation RELN as its first argument (or\n\"arg1\"), and has at least one other argument-place (say the Mth) for\nspecifying an argument-type for one of RELN's argument-places (say the\nNth). (The value of N might be fixed or might be given by yet another of PRED's\narguments.) Suppose M=2 and N=1. PRED then takes a SubLExpressionType Collection\nas its second argument, and a closed atomic sentence (or \"GAF\") of the form\n(PRED RELN COL ..) puts a \"sometimes isa\" constraint on RELN's first\nargument-place that is based on COL. If PRED is a \"single-argument\" constraint\npredicate, the GAF entails that a closed formula of the form (RELN ARG1 ..) is\nsemantically well-formed only if ARG1 is an instance of \nSubLExpressionType COL in some time interval\n(including Always-TimeInterval).", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'ArgQuotedIsaTernaryPredicate', "A specialization of ArgQuotedIsaPredicate (q.v.). Each instance of ArgQuotedIsaTernaryPredicate. is a ternary predicate used to place an \"quoted isa\" constraint on (and thereby specify an argument-type for) one or more argument-places of a relation. To be more precise, each instance PRED of ArgQuotedIsaTernaryPredicate takes a Relation RELN as its first argument, a NonNegativeInteger N as its second argument, and a SubLExpressionType collection COL as its third argument. PRED places an \"quoted isa\" constraint on RELN's Nth argument-place that is based on COL, so that a ground atomic sentence (GAF) of the form (RELN ARG1..ARGN..) is semantically well-formed only if ARGN is a quoted instance of COL. (Note that if N = 0 then this same constraint is placed on _all_ of RELN's argument-places. An important instance of ArgQuotedIsaTernaryPredicate is argQuotedIsa.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'ArgQuotedIsaPredicate', "The collection of ArgTypePredicates (q.v.) that specify argument-types directly (by referencing certain collections) and impose constraints that require a thing's being an instance of a SubLExpressionType collection thus specified. More precisely, each instance of ArgQuotedIsaPredicate PRED takes a Relation RELN as its first argument (or \"arg1\"), and has at least one other argument-place (say the Mth) for specifying an argument-type for one of RELN's argument-places (say the Nth). (The value of N might be fixed or might be given by yet another of PRED's arguments.) Suppose M=2 and N=1. PRED then takes a SubLExpressionType Collection as its second argument, and a closed atomic sentence (or \"GAF\") of the form (PRED RELN COL ..) puts an \"quoted isa\" constraint on RELN's first argument-place that is based on COL. If PRED is a \"single-argument\" constraint predicate, the GAF entails that a closed formula of the form (RELN ARG1 ..) is semantically well-formed only if ARG1 is an instance of (i.e. quotedIsa) SubLExpressionType COL.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'ArgQuotedIsaBinaryPredicate', "A specialization of ArgQuotedIsaPredicate . Each instance of ArgQuotedIsaBinaryPredicate takes a Relation RELN as its first argument, and a SubLExpressionType Collection COL as its second argument, and places a constraint based on COL on at least one of the argument-places of RELN. To be more precise, suppose that PRED is an ArgIsaBinaryPredicate that specifies an argument-type for the Nth argument-place of RELN. Then a sentence of the form (PRED RELN COL) entails that a closed formula of the form (RELN ... ARGN ...) is semantically well-formed only if ARGN is an instance (i.e. quotedIsa) of COL.", 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(comment, 'ArgIsaTernaryPredicate', "A specialization of both ArgTypeTernaryPredicate and ArgIsaPredicate (q.v.).  Each instance of ArgIsaTernaryPredicate is a ternary predicate used to place an \"isa\" constraint on (and thereby specify an argument-type for) one or more argument-places of a relation.  To be more precise, each instance PRED of ArgIsaTernaryPredicate takes a Relation RELN as its first argument, a NonNegativeInteger N as its second argument, and a Collection COL as its third argument.  PRED places an \"isa\" constraint on RELN's Nth argument-place that is based on COL, so that a ground atomic sentence (GAF) of the form (RELN ARG1..ARGN..) is semantically well-formed only if ARGN is an instance of COL. (Note that (i) if N = 0 then this same constraint is placed on _all_ of RELN's argument-places and (ii) if PRED is argAndRestIsa then this constraint is placed on all of RELN's argument-places whose ordinal positions are greater than or equal to the Nth.)  An important instance of ArgIsaTernaryPredicate is argIsa.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'ArgIsaPredicate', "The collection of ArgTypePredicates (q.v.) that specify argument-types directly (by referencing certain collections) and impose constraints that require a thing's being an instance of a collection thus specified.  More precisely, each instance of ArgIsaPredicate PRED takes a Relation RELN as its first argument (or \"arg1\"), and has at least one other argument-place (say the Mth) for specifying an argument-type for one of RELN's argument-places (say the Nth).  (The value of N might be fixed or might be given by yet another of PRED's arguments.)  Suppose M=2 and N=1.  PRED then takes a Collection as its second argument, and a closed atomic sentence (or \"GAF\") of the form (PRED RELN COL ..) puts an \"isa\" constraint on RELN's first argument-place that is based on COL.  If PRED is a \"single-argument\" constraint predicate, the GAF entails that a closed formula of the form (RELN ARG1 ..) is semantically well-formed only if ARG1 is an instance of (i.e. isa) COL.  If PRED is an \"inter-argument\" constraint predicate, the GAF expresses a slightly more complicated, conditional isa constraint on a pair of RELN's argument-places (see InterArgIsaPredicate).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'ArgIsaBinaryPredicate', "A specialization of both ArgTypeBinaryPredicate and ArgIsaPredicate.  Each instance of ArgIsaBinaryPredicate takes a Relation RELN as its first argument, and a Collection COL as its second argument, and places a constraint based on COL on at least one of the argument-places of RELN.  To be more precise, suppose that PRED is an ArgIsaBinaryPredicate that specifies an argument-type for the Nth argument-place of RELN.  Then a sentence of the form (PRED RELN COL) entails that a closed formula of the form (RELN ... ARGN ...) is semantically well-formed only if  ARGN is an instance of COL.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'ArgGenlTernaryPredicate', "A specialization of ArgTypeTernaryPredicate and ArgGenlPredicate.  Each instance of ArgGenlTernaryPredicate is used to specify that a certain collection is required to stand in the genls relation to anything that is acceptable in a particular argument slot of a given instance of Relation.  With each instance of ArgGenlTernaryPredicate, the first argument is the relation constrained; the second argument is the argument constrained; and the third argument is the required collection that the relation's specified argument is required to be a specialization of.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'ArgGenlQuantityTernaryPredicate', "A specialization of both ArgTypeTernaryPredicate and ArgGenlAttributePredicate.  Each instance of ArgGenlAttributeTernaryPredicate is a ternary predicate used to place a \"quantitySubsumes\" constraint on (and thereby specify an argument-type for) one or more argument-places of a relation.  To be more precise, each instance PRED of ArgGenlAttributeTernaryPredicate takes a Relation RELN as its first argument, a NonNegativeInteger N as its second argument, and an Quantity QUANT as its third argument. PRED places a \"quantitySubsumes\" constraint on RELN's Nth argument-place that is based on QUANT, so that a ground atomic sentence (GAF) of the form (RELN ARG1..ARGN..) is semantically well-formed only if ARGN is subsumed by QUANT (in the sense that (quantitySubsumes QUANT ARGN) holds).  An important instance of ArgGenlAttributeTernaryPredicate is argGenlAttribute.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'ArgGenlQuantityBinaryPredicate', "Those instances of both ArgTypeBinaryPredicate and ArgGenlAttributePredicate used to specify the required quantity of an argument of Relation.  Each instance PRED of this collection is a binary predicate with the following properties: ARG1 is an instance of Relation, and ARG2 is an instance of Quantity.  (PRED ARG1 ARG2) means that some argument of ARG1 is constrained to be subsumed by (via quantitySubsumes) ARG2, where PRED determines the argument place in question.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'ArgGenlBinaryPredicate', "Those instances of both BinaryPredicate and ArgGenlPredicate used to specify the required genls of an argument of a Relation; the arg1 is the Relation; the arg2 is the required genls Collection.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'ArgConstraintPredicate', "The collection of MetaRelations whose instances are used to put semantic well-formedness or entry-format constraints on one or more argument-places of a given Relation.  Such a constraint might concern an argument's <i>type</i>, an argument-place's Format (q.v.), a conditional relationship between two argument(-place)s' types or formats, or some other sort of relationship between two arguments.  For a fuller account, see the various specializations of ArgConstraintPredicate.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'April', "The collection of all Aprils, \nthe fourth month of the year in the GregorianCalendar.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'AntiTransitiveBinaryPredicate', "A BinaryPredicateTypeByLogicalFeature and a specialization of  IrreflexiveBinaryPredicate (q.v.).  A binary predicate PRED is an instance of  AntiTransitiveBinaryPredicate only if it has this property: for any THING1, THING2, and THING3 such that both (PRED THING1 THING2) and (PRED THING2 THING3) hold, (not (PRED THING1 THING3)) holds.  Equivalently: for every X, Y, and Z that satisfy the (single-argument) argument-type constraints  (see admittedArgument) for the relevant argument positions of PRED,  (not (and (PRED X Y)(PRED Y Z)(PRED X Z))) holds.  Note that  PRED's two agument-positions must also be \"co-satisfiable\" with respect to their type constraints; see cosatisfiableInArgs and NoteOnArgumentCosatisfiabilityRequirement.\n<p>\nFor example, divorcedFrom is an instance of AntiTransitiveBinaryPredicate.\n<p>\nNote also that, while not strictly disjoint with TransitiveBinaryPredicate (q.v.), in practice few if any reified predicates should be instances of both of these collections. An important specialization of AntiTransitiveBinaryPredicate is DirectBinaryPredicate (q.v.).", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'AntiSymmetricBinaryPredicate', "A BinaryPredicateTypeByLogicalFeature and thus a specialization of BinaryPredicate.  A binary predicate <code>PRED</code> is an AntiSymmetricBinaryPredicate if and only if it has the following two properties.  (i) For any <code>THING1</code> and <code>THING2</code> such that both <code>(PRED THING1 THING2)</code> and <code>(PRED THING2 THING1)</code> hold, <code>THING1</code>  = <code>THING2</code>.  (ii) <code>PRED</code>'s two argument-places must be \"co-satisfiable\" with respect to their (single-argument) type constraints (see cosatisfiableInArgs and NoteOnArgumentCosatisfiabilityRequirement).\n<p>\nInstances of AntiSymmetricBinaryPredicate include greaterThanOrEqualTo, parts, and subEvents.  See also the specialization AsymmetricBinaryPredicate; and cf. SymmetricBinaryPredicate.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(comment, 'AllowKeywordVariables', "A CanonicalizerDirective (q.v.)  that is a specialization (see genlCanonicalizerDirectives) of  AllowGenericArgVariables.  AllowKeywordVariables directs the  CycCanonicalizer to allow all \"keyword variables\" (e.g. `:NOUN'  and `:ARG1') to appear in CycL assertions and to treat them as if they  were CycLVariables.", 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(comment, 'AllowGenericArgVariables', "A CanonicalizerDirective (q.v.) that directs the CycCanonicalizer to allow \"generic argument keyword variables\" (e.g. `:ARG1' and `:ARG2') to appear in CycL assertions and  to treat them as if they were CycLVariables.  For a specialization (see genlCanonicalizerDirectives) of this directive that is used to  direct the canonicalizer to allow _all_ keyword variables, see AllowKeywordVariables.", 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(comment, 'AbsoluteValueFn', "AbsoluteValueFn is the unary mathematical function that returns the absolute value of its argument; e.g., (AbsoluteValueFn -2) returns 2, and (AbsoluteValueFn 2) returns 2.", 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(collectionExpansion, 'TransitiveBinaryPredicate', implies(and(':ARG1'('$VAR'('X'), '$VAR'('Y')), ':ARG1'('$VAR'('Y'), '$VAR'('Z'))), ':ARG1'('$VAR'('X'), '$VAR'('Z'))), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(collectionExpansion, 'SymmetricBinaryPredicate', implies(':ARG1'('$VAR'('X'), '$VAR'('Y')), ':ARG1'('$VAR'('Y'), '$VAR'('Z'))), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(collectionExpansion, 'ReflexiveBinaryPredicate', ':ARG1'('$VAR'('X'), '$VAR'('X')), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(collectionExpansion, 'IrreflexiveBinaryPredicate', not(':ARG1'('$VAR'('X'), '$VAR'('X'))), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(collectionExpansion, 'AsymmetricBinaryPredicate', implies(':ARG1'('$VAR'('X'), '$VAR'('Y')), not(':ARG1'('$VAR'('Y'), '$VAR'('Z')))), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(collectionConventionMt, 'VariableAritySkolemFunction', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'VariableArityRelation', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'UnreifiableFunction', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'UnitOfMeasure', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'UnaryRelation', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'UnaryPredicate', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'UnaryFunction', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'TruthFunction', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'TransitiveBinaryPredicate', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'Thing', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'TheTerm', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'TernaryRelation', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'TernaryPredicate', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'TernaryFunction', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'SymmetricBinaryPredicate', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'SubLSymbol', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'SubLString', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'SubLSExpression', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'SubLRealNumber', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'SubLPositiveInteger', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'SubLNonVariableSymbol', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'SubLNonVariableNonKeywordSymbol', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'SubLNonNegativeInteger', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'SubLList', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'SubLKeyword', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'SubLInteger', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'SubLExpressionType', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'SubLCharacter', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'SubLAtomicTerm', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'SubLAtom', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'SkolemFunction', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'SiblingDisjointCollectionType', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'SiblingDisjointAttributeType', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'SetOrCollection', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'Set-Mathematical', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'SententialRelation', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'ScopingRelation', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'ScalarPointValue', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'ScalarInterval', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'ScalarIntegralValue', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, tRelation, 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'ReifiableFunction', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'ReformulatorDirectivePredicate', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'ReflexiveBinaryPredicate', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'RealNumber', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'QuintaryRelation', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'QuintaryPredicate', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'QuintaryFunction', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'QuaternaryRelation', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'QuaternaryPredicate', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'QuaternaryFunction', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'Quantifier', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'ProblemSolvingCntxt', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, tPred, 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'PositiveInteger', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'PartiallyCommutativeRelation', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'NonNegativeScalarInterval', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'NonNegativeInteger', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'Multigraph', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'MonthOfYearType', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'MicrotheoryDesignatingRelation', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'Microtheory', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'LogicalConnective', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'List', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'IrreflexiveBinaryPredicate', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'InterArgIsaPredicate', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'InterArgFormatPredicate', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'Integer', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'InferenceRelatedBookkeepingPredicate', 'BaseKB', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'Individual', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'HypotheticalContext', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'HLExternalIDString', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, tFunction, 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'Format', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'FixedAritySkolemFunction', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'FixedAritySkolemFuncN', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'FixedArityRelation', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'ExistentialQuantifier-Bounded', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'ExistentialQuantifier', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'ExceptionPredicate', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'EvaluatableRelation', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'EvaluatableFunction', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'ELRelation-Reversible', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'ELRelation-OneWay', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'ELRelation', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'DistributingMetaKnowledgePredicate', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'DisjointCollectionType', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'DirectedMultigraph', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'DefaultMonotonicPredicate', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, ftVar, 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'CycLTruthValueSentence', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'CycLTerm', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'CycLSentence-Assertible', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'CycLSentence-Askable', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'CycLSentence', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'CycLRuleAssertion', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'CycLRepresentedTerm', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'CycLRepresentedAtomicTerm', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'CycLReifiedDenotationalTerm', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'CycLReifiableNonAtomicTerm', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'CycLReifiableDenotationalTerm', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'CycLPropositionalSentence', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'CycLOpenSentence', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'CycLOpenNonAtomicTerm', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'CycLOpenFormula', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'CycLOpenExpression', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'CycLOpenDenotationalTerm', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'CycLNonAtomicTerm-Assertible', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'CycLNonAtomicTerm-Askable', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'CycLNonAtomicTerm', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'CycLNonAtomicReifiedTerm', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'CycLIndexedTerm', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'CycLGenericRelationFormula', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'CycLGAFAssertion', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'CycLFormulaicSentence', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'CycLFormula', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, ttFormatType, 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'CycLExpression-Assertible', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'CycLExpression-Askable', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'CycLExpression', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'CycLDenotationalTerm-Assertible', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'CycLDenotationalTerm', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'CycLDeducedAssertion', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'CycLConstant', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'CycLClosedSentence', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'CycLClosedNonAtomicTerm', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'CycLClosedFormula', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'CycLClosedExpression', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'CycLClosedDenotationalTerm', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'CycLClosedAtomicTerm', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'CycLClosedAtomicSentence', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'CycLAtomicTerm', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'CycLAtomicSentence', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'CycLAtomicAssertion', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'CycLAssertionDirection', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'CycLAssertion', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'CycLAssertedAssertion', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'CommutativeRelation', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'CollectionDenotingFunction', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, tCol, 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'CanonicalizerDirective', 'CoreCycLImplementationMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'BroadMicrotheory', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'BroadMicrotheory', 'BaseKB', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'BookkeepingPredicate', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'BinaryRelation', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'BinaryPredicate', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'BinaryFunction', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'AtemporalNecessarilyEssentialCollectionType', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'AsymmetricBinaryPredicate', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'AssociativeRelation', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'ArgTypeTernaryPredicate', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'ArgTypePredicate', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'ArgTypeBinaryPredicate', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'ArgQuotedIsaTernaryPredicate', 'UniversalVocabularyMt', 'BaseKB', vStrMon).
assertedTinyKB(collectionConventionMt, 'ArgIsaTernaryPredicate', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'ArgIsaBinaryPredicate', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'ArgGenlTernaryPredicate', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'ArgGenlQuantityTernaryPredicate', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'ArgGenlQuantityBinaryPredicate', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'ArgGenlBinaryPredicate', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'ArgConstraintPredicate', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'AntiTransitiveBinaryPredicate', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(collectionConventionMt, 'AntiSymmetricBinaryPredicate', 'UniversalVocabularyMt', 'BaseKB', vStrDef).
assertedTinyKB(coExtensional, 'List', 'List', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(coExtensional, 'CycLExpression', 'CycLTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(canonicalizerDirectiveForArg, trueRule, 2, 'LeaveSomeTermsAtEL', 'UniversalVocabularyImplementationMt', vStrMon).
assertedTinyKB(canonicalizerDirectiveForArg, reformulatorRule, 2, 'LeaveSomeTermsAtEL', 'UniversalVocabularyImplementationMt', vStrMon).
assertedTinyKB(canonicalizerDirectiveForArg, reformulatorRule, 1, 'LeaveSomeTermsAtEL', 'UniversalVocabularyImplementationMt', vStrMon).
assertedTinyKB(canonicalizerDirectiveForArg, reformulatorEquiv, 2, 'LeaveSomeTermsAtEL', 'UniversalVocabularyImplementationMt', vStrMon).
assertedTinyKB(canonicalizerDirectiveForArg, reformulatorEquiv, 1, 'LeaveSomeTermsAtEL', 'UniversalVocabularyImplementationMt', vStrMon).
assertedTinyKB(canonicalizerDirectiveForArg, reformulatorEquals, 2, 'LeaveSomeTermsAtEL', 'UniversalVocabularyImplementationMt', vStrMon).
assertedTinyKB(canonicalizerDirectiveForArg, reformulatorEquals, 1, 'LeaveSomeTermsAtEL', 'UniversalVocabularyImplementationMt', vStrMon).
assertedTinyKB(canonicalizerDirectiveForArg, reformulationPrecondition, 2, 'LeaveSomeTermsAtEL', 'UniversalVocabularyImplementationMt', vStrMon).
assertedTinyKB(canonicalizerDirectiveForArg, formulaArity, 1, 'LeaveSomeTermsAtEL', 'UniversalVocabularyImplementationMt', vStrDef).
assertedTinyKB(canonicalizerDirectiveForArg, expansion, 2, 'LeaveSomeTermsAtEL', 'UniversalVocabularyImplementationMt', vStrMon).
assertedTinyKB(canonicalizerDirectiveForArg, expansion, 2, 'AllowGenericArgVariables', 'UniversalVocabularyImplementationMt', vStrMon).
assertedTinyKB(canonicalizerDirectiveForArg, collectionExpansion, 2, 'LeaveSomeTermsAtEL', 'UniversalVocabularyImplementationMt', vStrDef).
assertedTinyKB(canonicalizerDirectiveForArg, collectionExpansion, 2, 'AllowGenericArgVariables', 'UniversalVocabularyImplementationMt', vStrDef).
assertedTinyKB(canonicalizerDirectiveForArg, 'FormulaArityFn', 1, 'LeaveSomeTermsAtEL', 'UniversalVocabularyImplementationMt', vStrMon).
assertedTinyKB(canonicalizerDirectiveForArg, 'FormulaArgSetFn', 1, 'LeaveSomeTermsAtEL', 'UniversalVocabularyImplementationMt', vStrMon).
assertedTinyKB(backchainRequired, sentenceTruth, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(backchainForbidden, unknownSentence, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(backchainForbidden, unknownSentence, 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(backchainForbidden, trueSubL, 'BaseKB', vStrMon).
assertedTinyKB(backchainForbidden, termOfUnit, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(backchainForbidden, termOfUnit, 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(backchainForbidden, termExternalIDString, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(backchainForbidden, termDependsOn, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(backchainForbidden, termChosen, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(backchainForbidden, termChosen, 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(backchainForbidden, sentenceImplies, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(backchainForbidden, sentenceEquiv, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(backchainForbidden, sentenceEquiv, 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(backchainForbidden, salientAssertions, 'BaseKB', vStrDef).
assertedTinyKB(backchainForbidden, resultIsaArgIsa, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(backchainForbidden, quotedArgument, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(backchainForbidden, pragmaticRequirement, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(backchainForbidden, performSubL, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(backchainForbidden, performSubL, 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(backchainForbidden, operatorFormulas, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(backchainForbidden, omitArgIsa, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(backchainForbidden, nthSmallestElement, 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(backchainForbidden, nearestIsa, 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(backchainForbidden, nearestGenls, 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(backchainForbidden, nearestGenlPreds, 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(backchainForbidden, nearestGenlMt, 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(backchainForbidden, nearestDifferentIsa, 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(backchainForbidden, nearestDifferentGenls, 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(backchainForbidden, nearestCommonSpecs, 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(backchainForbidden, nearestCommonIsa, 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(backchainForbidden, nearestCommonGenls, 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(backchainForbidden, nearestCommonGenlMt, 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(backchainForbidden, natFunction, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(backchainForbidden, natFunction, 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(backchainForbidden, natArgumentsEqual, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(backchainForbidden, natArgumentsEqual, 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(backchainForbidden, natArgument, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(backchainForbidden, natArgument, 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(backchainForbidden, myCreator, 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(backchainForbidden, myCreator, 'BookkeepingMt', vStrDef).
assertedTinyKB(backchainForbidden, myCreationTime, 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(backchainForbidden, myCreationTime, 'BookkeepingMt', vStrDef).
assertedTinyKB(backchainForbidden, myCreationSecond, 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(backchainForbidden, myCreationSecond, 'BookkeepingMt', vStrDef).
assertedTinyKB(backchainForbidden, myCreationPurpose, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(backchainForbidden, myCreationPurpose, 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(backchainForbidden, mtVisible, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(backchainForbidden, knownSentence, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(backchainForbidden, knownSentence, 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(backchainForbidden, integerBetween, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(backchainForbidden, integerBetween, 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(backchainForbidden, instanceElementType, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(backchainForbidden, indexicalReferent, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(backchainForbidden, hypotheticalTerm, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(backchainForbidden, formulaArity, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(backchainForbidden, formulaArity, 'BaseKB', vStrMon).
assertedTinyKB(backchainForbidden, extentCardinality, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(backchainForbidden, exactlyAssertedSentence, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(backchainForbidden, exactlyAssertedSentence, 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(backchainForbidden, evaluate, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(backchainForbidden, evaluate, 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(backchainForbidden, equalSymbols, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(backchainForbidden, equalSymbols, 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(backchainForbidden, elInverse, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(backchainForbidden, differentSymbols, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(backchainForbidden, differentSymbols, 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(backchainForbidden, different, 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(backchainForbidden, definingMt, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(backchainForbidden, cycTransformationProofRule, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(backchainForbidden, cycTransformationProofRule, 'BaseKB', vStrMon).
assertedTinyKB(backchainForbidden, cycTransformationProofBindings, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(backchainForbidden, cycTransformationProofBindings, 'BaseKB', vStrMon).
assertedTinyKB(backchainForbidden, cycTacticID, 'BaseKB', vStrMon).
assertedTinyKB(backchainForbidden, cycProofID, 'BaseKB', vStrMon).
assertedTinyKB(backchainForbidden, cycProblemStoreTerms, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(backchainForbidden, cycProblemStoreTerms, 'BaseKB', vStrMon).
assertedTinyKB(backchainForbidden, cycProblemStoreProofs, 'BaseKB', vStrMon).
assertedTinyKB(backchainForbidden, cycProblemStoreProofCount, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(backchainForbidden, cycProblemStoreProofCount, 'BaseKB', vStrMon).
assertedTinyKB(backchainForbidden, cycProblemStoreProblems, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(backchainForbidden, cycProblemStoreProblems, 'BaseKB', vStrMon).
assertedTinyKB(backchainForbidden, cycProblemStoreProblemCount, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(backchainForbidden, cycProblemStoreProblemCount, 'BaseKB', vStrMon).
assertedTinyKB(backchainForbidden, cycProblemStoreLinks, 'BaseKB', vStrMon).
assertedTinyKB(backchainForbidden, cycProblemStoreLinkCount, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(backchainForbidden, cycProblemStoreLinkCount, 'BaseKB', vStrMon).
assertedTinyKB(backchainForbidden, cycProblemStoreInferences, 'BaseKB', vStrMon).
assertedTinyKB(backchainForbidden, cycProblemStoreInferenceCount, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(backchainForbidden, cycProblemStoreInferenceCount, 'BaseKB', vStrMon).
assertedTinyKB(backchainForbidden, cycProblemStoreID, 'BaseKB', vStrMon).
assertedTinyKB(backchainForbidden, cycProblemQueryTerms, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(backchainForbidden, cycProblemQueryTerms, 'BaseKB', vStrMon).
assertedTinyKB(backchainForbidden, cycProblemQuerySentence, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(backchainForbidden, cycProblemQuerySentence, 'BaseKB', vStrMon).
assertedTinyKB(backchainForbidden, cycProblemProvabilityStatus, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(backchainForbidden, cycProblemProvabilityStatus, 'BaseKB', vStrMon).
assertedTinyKB(backchainForbidden, cycProblemLinkID, 'BaseKB', vStrMon).
assertedTinyKB(backchainForbidden, cycProblemID, 'BaseKB', vStrMon).
assertedTinyKB(backchainForbidden, cycProblemDependentLinks, 'BaseKB', vStrMon).
assertedTinyKB(backchainForbidden, cycProblemArgumentLinks, 'BaseKB', vStrMon).
assertedTinyKB(backchainForbidden, cycInferenceRelevantProblems, 'BaseKB', vStrMon).
assertedTinyKB(backchainForbidden, cycInferenceAnswerLink, 'BaseKB', vStrMon).
assertedTinyKB(backchainForbidden, constantName, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(backchainForbidden, constantName, 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(backchainForbidden, constantID, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(backchainForbidden, constantID, 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(backchainForbidden, constantGUID, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(backchainForbidden, constantGUID, 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(backchainForbidden, consistent, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(backchainForbidden, conceptuallyRelated, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(backchainForbidden, comment, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(backchainForbidden, collectionIsaBackchainRequired, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(backchainForbidden, collectionIsaBackchainEncouraged, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(backchainForbidden, collectionGenlsBackchainRequired, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(backchainForbidden, collectionGenlsBackchainEncouraged, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(backchainForbidden, collectionBackchainEncouraged, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(backchainForbidden, backchainRequired, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(backchainForbidden, backchainForbiddenWhenUnboundInArg, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(backchainForbidden, backchainForbidden, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(backchainForbidden, backchainForbidden, 'BaseKB', vStrMon).
assertedTinyKB(backchainForbidden, assertionDirection, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(backchainForbidden, assertionDirection, 'BaseKB', vStrMon).
assertedTinyKB(backchainForbidden, assertedTermSentences, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(backchainForbidden, assertedTermSentences, 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(backchainForbidden, assertedSentence, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(backchainForbidden, assertedSentence, 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(backchainForbidden, assertedPredicateArg, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(backchainForbidden, assertedPredicateArg, 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(backchainForbidden, admittedSentence, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(backchainForbidden, admittedSentence, 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(backchainForbidden, admittedNAT, 'BaseKB', vStrMon).
assertedTinyKB(backchainForbidden, admittedArgument, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(backchainForbidden, admittedArgument, 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(backchainForbidden, admittedAllArgument, 'BaseKB', vStrMon).
assertedTinyKB(backchainForbidden, 'ist-Asserted', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(backchainForbidden, 'ist-Asserted', 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(backchainForbidden, 'equalStrings-CaseInsensitive', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(backchainForbidden, 'equalStrings-CaseInsensitive', 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(arityMin, differentSymbols, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arityMin, different, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arityMin, commutativeInArgsAndRest, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arityMin, commutativeInArgs, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arityMin, and, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arityMin, 'Unity', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arityMin, 'TimesFn', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arityMin, 'TheSet', 0, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arityMin, 'PlusFn', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arityMin, 'Percent', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arityMin, 'MinRangeFn', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arityMin, 'MaxRangeFn', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arityMax, 'Unity', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arityMax, 'Percent', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, xor, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, unknownSentence, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, unitMultiplicationFactor, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, trueSubL, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, trueSentence, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, trueRule, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, transitiveViaArgInverse, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, transitiveViaArg, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, thereExists, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, thereExists, 2, 'LogicalTruthMt', vStrDef).
assertedTinyKB(arity, thereExistExactly, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, thereExistAtMost, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, thereExistAtLeast, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, termOfUnit, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, termOfUnit, 2, 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(arity, termExternalIDString, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, termDependsOn, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, termChosen, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, synonymousExternalConcept, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, substring, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, subsetOf, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, skolemizeForward, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, skolem, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, singleEntryFormatInArgs, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, siblingDisjointExceptions, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, sharedNotes, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, sentenceTruth, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, sentenceImplies, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, sentenceEquiv, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, sentenceDesignationArgnum, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, scopingArg, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, salientAssertions, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, ruleTemplateDirection, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, ruleAfterRemoving, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, ruleAfterAdding, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, rewriteOf, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, resultQuotedIsa, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, resultIsaArgIsa, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, resultIsaArg, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, resultIsa, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, resultIsa, 2, 'LogicalTruthMt', vStrDef).
assertedTinyKB(arity, resultGenlArg, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, resultGenl, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, requiredArg3Pred, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, requiredArg2Pred, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, requiredArg1Pred, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, relationMemberInstance, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, relationInstanceMember, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, relationInstanceExists, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, relationInstanceAll, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, relationExpansion, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, relationExistsMinAll, 4, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, relationExistsMaxAll, 4, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, relationExistsInstance, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, relationExistsCountAll, 4, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, relationExistsAll, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, relationAllInstance, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, relationAllExistsMin, 4, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, relationAllExistsMax, 4, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, relationAllExistsCount, 4, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, relationAllExists, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, relationAll, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, reformulatorRuleProperties, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, reformulatorRule, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, reformulatorEquiv, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, reformulatorEquals, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, reformulationPrecondition, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, reformulationDirectionInMode, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, ratioOfTo, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, quotedIsa, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, quotedDefnSufficient, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, quotedDefnNecessary, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, quotedDefnIff, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, quotedArgument, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, querySentence, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, quantitySubsumes, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, quantityIntersects, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, prettyString, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, preservesGenlsInArg, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, predicateConventionMt, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, pragmaticRequirement, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, pragmaticallyNormal, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, pointQuantValue, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, performSubL, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, overlappingExternalConcept, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, operatorFormulas, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, openEntryFormatInArgs, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, opaqueArgument, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, omitArgIsa, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, oldConstantName, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, numericallyEquals, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, nthSmallestElement, 4, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, nthLargestElement, 4, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, notAssertibleMt, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, notAssertibleCollection, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, notAssertible, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, not, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, not, 1, 'LogicalTruthMt', vStrDef).
assertedTinyKB(arity, nonAbducibleWithValueInArg, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, negationPreds, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, negationMt, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, negationInverse, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, nearestIsa, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, nearestGenls, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, nearestGenlPreds, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, nearestGenlMt, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, nearestDifferentIsa, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, nearestDifferentGenls, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, nearestCommonSpecs, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, nearestCommonIsa, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, nearestCommonGenls, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, nearestCommonGenlMt, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, natFunction, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, natArgumentsEqual, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, natArgument, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, myCreator, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, myCreationTime, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, myCreationSecond, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, myCreationPurpose, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, multiplicationUnits, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, mtVisible, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, minQuantValue, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, minimizeExtent, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, minimize, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, microtheoryDesignationArgnum, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, meetsPragmaticRequirement, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, means, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, maxQuantValue, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, knownSentence, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, knownAntecedentRule, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, ist, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, ist, 2, 'LogicalTruthMt', vStrDef).
assertedTinyKB(arity, isa, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, isa, 2, 'LogicalTruthMt', vStrDef).
assertedTinyKB(arity, irrelevantTerm, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, irrelevantPredAssertion, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, irrelevantMt, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, irrelevantAssertion, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, interArgResultIsaReln, 5, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, interArgResultIsa, 4, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, interArgResultGenlReln, 5, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, interArgResultGenl, 4, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, interArgIsa, 5, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, interArgDifferent, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, integerBetween, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, instanceElementType, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, indexicalReferent, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, independentArg, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, implies, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, implies, 2, 'LogicalTruthMt', vStrDef).
assertedTinyKB(arity, hypotheticalTerm, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, holdsIn, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, hlPrototypicalInstance, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, highlyRelevantTerm, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, highlyRelevantPredAssertion, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, highlyRelevantMt, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, highlyRelevantAssertion, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, greaterThanOrEqualTo, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, greaterThan, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, genMassNoun, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, genls, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, genls, 2, 'LogicalTruthMt', vStrDef).
assertedTinyKB(arity, genlRules, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, genlPreds, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, genlMt, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, genlMt, 2, 'LogicalTruthMt', vStrDef).
assertedTinyKB(arity, genlInverse, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, genlCanonicalizerDirectives, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, genKeyword, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, genFormat, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, forwardNonTriggerLiteral, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, formulaArity, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, forAll, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, forAll, 2, 'LogicalTruthMt', vStrDef).
assertedTinyKB(arity, followingValue, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, fanOutArg, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, extentCardinality, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, extConceptOverlapsColAndReln, 4, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, expresses, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, expansionDefn, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, expansion, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, exceptWhen, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, exceptMt, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, exceptFor, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, except, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, exampleAssertions, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, exactlyAssertedSentence, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, evaluationResultQuotedIsa, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, evaluationDefn, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, evaluateImmediately, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, evaluateAtEL, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, evaluate, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, equiv, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, equalSymbols, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, equals, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, equals, 2, 'LogicalTruthMt', vStrDef).
assertedTinyKB(arity, ephemeralTerm, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, elInverse, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, elementOf, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, distributesOutOfArg, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, disjointWith, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, disjointWith, 2, 'LogicalTruthMt', vStrDef).
assertedTinyKB(arity, denotes, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, denotes, 2, 'LogicalTruthMt', vStrDef).
assertedTinyKB(arity, defnSufficient, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, defnNecessary, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, defnIff, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, defnIff, 2, 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(arity, definingMt, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, defaultReformulationDirectionInModeForPred, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, decontextualizedPredicate, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, decontextualizedCollection, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, cycTransformationProofRule, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, cycTransformationProofBindings, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, cycTacticID, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, cycProofID, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, cycProblemStoreTerms, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, cycProblemStoreProofs, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, cycProblemStoreProofCount, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, cycProblemStoreProblems, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, cycProblemStoreProblemCount, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, cycProblemStoreLinks, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, cycProblemStoreLinkCount, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, cycProblemStoreInferences, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, cycProblemStoreInferenceCount, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, cycProblemStoreID, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, cycProblemQueryTerms, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, cycProblemQuerySentence, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, cycProblemProvabilityStatus, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, cycProblemLinkID, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, cycProblemID, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, cycProblemDependentLinks, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, cycProblemArgumentLinks, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, cycInferenceRelevantProblems, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, cycInferenceAnswerLink, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, constraint, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, constrainsArg, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, constantName, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, constantID, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, constantGUID, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, consistent, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, conceptuallyRelated, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, completelyEnumerableCollection, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, completelyDecidableCollection, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, completeExtentEnumerableViaBackchain, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, completeExtentEnumerableForValueInArg, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, completeExtentEnumerableForArg, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, completeExtentEnumerable, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, completeExtentDecidableForValueInArg, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, completeExtentDecidable, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, completeExtentAssertedForValueInArg, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, completeExtentAsserted, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, comment, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, collectionIsaBackchainRequired, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, collectionIsaBackchainEncouraged, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, collectionGenlsBackchainRequired, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, collectionGenlsBackchainEncouraged, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, collectionExpansion, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, collectionConventionMt, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, collectionCompletelyEnumerableViaBackchain, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, collectionBackchainRequired, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, collectionBackchainEncouraged, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, coExtensional, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, canonicalizerDirectiveForArgAndRest, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, canonicalizerDirectiveForArg, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, canonicalizerDirectiveForAllArgs, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, backchainRequired, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, backchainForbiddenWhenUnboundInArg, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, backchainForbidden, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, assertionUtility, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, assertionDirection, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, assertedTermSentences, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, assertedSentence, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, assertedPredicateArg, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, arityMin, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, arityMax, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, arity, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, arity, 2, 'LogicalTruthMt', vStrDef).
assertedTinyKB(arity, argsQuotedIsa, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, argSometimesIsa, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, argsIsa, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, argsGenl, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, argQuotedIsa, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, argIsa, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, argIsa, 3, 'LogicalTruthMt', vStrDef).
assertedTinyKB(arity, argAndRestQuotedIsa, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, argAndRestIsa, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, argAndRestIsa, 3, 'LogicalTruthMt', vStrDef).
assertedTinyKB(arity, argAndRestGenl, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, arg6SometimesIsa, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, arg6QuotedIsa, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, arg6Isa, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, arg6Genl, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, arg6Format, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, arg5SometimesIsa, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, arg5QuotedIsa, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, arg5Isa, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, arg5Genl, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, arg5Format, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, arg4SometimesIsa, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, arg4QuotedIsa, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, arg4Isa, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, arg4Genl, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, arg4Format, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, arg3SometimesIsa, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, arg3QuotedIsa, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, arg3Isa, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, arg3Genl, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, arg3Format, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, arg2SometimesIsa, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, arg2QuotedIsa, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, arg2Isa, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, arg2Genl, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, arg2Format, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, arg1SometimesIsa, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, arg1QuotedIsa, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, arg1Isa, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, arg1Genl, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, arg1Format, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, afterRemoving, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, afterRemoving, 2, 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(arity, afterAdding, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, afterAdding, 2, 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(arity, admittedSentence, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, admittedNAT, 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, admittedArgument, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, admittedAllArgument, 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, abnormal, 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'UnitProductFn', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'UncanonicalizerAssertionFn', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'TLVariableFn', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'TLReifiedNatFn', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'TLAssertionFn', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'TheSetOf', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'ThePrototypicalTransitiveBinaryPredicate', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'ThePrototypicalBinaryPredicate', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'TheCollectionOf', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'substring-CaseInsensitive', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'SubLQuoteFn', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'SkolemFunctionFn', 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'SkolemFuncNFn', 4, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'RoundUpFn', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'RoundDownFn', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'RoundClosestFn', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'RelationInstanceExistsFn', 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'RelationExistsInstanceFn', 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'RelationExistsAllFn', 4, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'RelationAllExistsFn', 4, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'QuotientFn', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'Quote', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'QuasiQuote', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'QuantityConversionFn', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'prettyString-Canonical', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'PlusAll', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'PerFn', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'MtTimeWithGranularityDimFn', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'MtTimeDimFn', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'ModuloFn', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'Minimum', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'MeaningInSystemFn', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'Maximum', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'LogFn', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'larkc-pluginByDataConnectsTo', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'larkc-hasUri', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'larkc-hasScalability', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'larkc-hasOutputType', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'larkc-hasInputType', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'larkc-hasEndpoint', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'larkc-hasCostPerInvocation', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'Kappa', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'ist-Asserted', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'IntervalMinFn', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'IntervalMaxFn', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'interArgIsa5-4', 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'interArgIsa5-3', 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'interArgIsa5-2', 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'interArgIsa5-1', 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'interArgIsa4-5', 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'interArgIsa4-3', 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'interArgIsa4-2', 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'interArgIsa4-1', 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'interArgIsa3-5', 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'interArgIsa3-4', 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'interArgIsa3-2', 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'interArgIsa3-1', 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'interArgIsa2-5', 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'interArgIsa2-4', 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'interArgIsa2-3', 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'interArgIsa2-1', 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'interArgIsa1-5', 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'interArgIsa1-4', 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'interArgIsa1-3', 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'interArgIsa1-2', 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'interArgGenl1-2', 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'interArgFormat1-2', 3, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'genls-SpecDenotesGenlInstances', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'genls-GenlDenotesSpecInstances', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'FunctionToArg', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'FormulaArityFn', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'FormulaArgSetFn', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'FormulaArgListFn', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'FormulaArgFn', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'FOL-TermFn', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'FOL-PredicateFn', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'FOL-FunctionFn', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'ExpFn', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'ExpandSubLFn', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'EvaluateSubLFn', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'EscapeQuote', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'equalStrings-CaseInsensitive', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'DifferenceFn', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'DateEncodeStringFn', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'DateDecodeStringFn', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'CycTacticFn', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'CycProofFn', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'CycProblemStoreFn', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'CycProblemLinkFn', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'CycProblemFn', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'CycInferenceFn', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'CollectionRuleTemplateFn', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'Average', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'assertionUtility-1', 2, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arity, 'AbsoluteValueFn', 1, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argsQuotedIsa, or, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argsQuotedIsa, or, 'CycLSentence-Assertible', 'BaseKB', vStrDef).
assertedTinyKB(argsQuotedIsa, differentSymbols, 'CycLExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argsQuotedIsa, and, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argsQuotedIsa, and, 'CycLSentence-Assertible', 'BaseKB', vStrDef).
assertedTinyKB(argsIsa, different, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argsIsa, defaultReformulatorModePrecedence, 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argsIsa, 'Unity', 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argsIsa, 'TimesFn', 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argsIsa, 'TheSet', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argsIsa, 'TheList', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argsIsa, 'PlusFn', 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argsIsa, 'Percent', 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argsIsa, 'MtUnionFn', 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argsIsa, 'MtSpace', 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argsIsa, 'MinRangeFn', 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argsIsa, 'MaxRangeFn', 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, xor, 2, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, xor, 2, 'CycLSentence-Assertible', 'BaseKB', vStrDef).
assertedTinyKB(argQuotedIsa, xor, 1, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, xor, 1, 'CycLSentence-Assertible', 'BaseKB', vStrDef).
assertedTinyKB(argQuotedIsa, unknownSentence, 1, 'CycLSentence', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, trueSubL, 1, 'CycLNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, trueSentence, 1, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, trueRule, 2, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, thereExists, 2, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, thereExists, 2, 'CycLSentence-Assertible', 'LogicalTruthMt', vStrDef).
assertedTinyKB(argQuotedIsa, thereExists, 1, ftVar, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, thereExists, 1, ftVar, 'LogicalTruthMt', vStrDef).
assertedTinyKB(argQuotedIsa, thereExistExactly, 3, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, thereExistExactly, 2, ftVar, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, thereExistAtMost, 3, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, thereExistAtMost, 2, ftVar, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, thereExistAtLeast, 3, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, thereExistAtLeast, 2, ftVar, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, termOfUnit, 2, 'CycLReifiableNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, termOfUnit, 1, 'CycLReifiableNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, termOfUnit, 1, 'CycLReifiableNonAtomicTerm', 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(argQuotedIsa, termExternalIDString, 1, 'CycLExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, termDependsOn, 2, 'CycLReifiableDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, termDependsOn, 1, 'CycLReifiableDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, sharedNotes, 2, 'DocumentationConstant', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, sharedNotes, 1, 'CycLIndexedTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, sentenceImplies, 2, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, sentenceImplies, 1, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, sentenceEquiv, 2, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, sentenceEquiv, 1, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, salientAssertions, 2, 'CycLAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, salientAssertions, 1, 'CycLReifiableDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, ruleAfterRemoving, 2, 'CycLNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, ruleAfterAdding, 2, 'CycLNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, rewriteOf, 2, 'CycLClosedDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, rewriteOf, 1, 'CycLReifiableDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, relationExpansion, 2, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, reformulatorRuleProperties, 2, 'CycLAtomicAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, reformulatorRule, 2, 'CycLExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, reformulatorRule, 1, 'CycLExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, reformulatorEquiv, 2, 'CycLSentence', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, reformulatorEquiv, 1, 'CycLSentence', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, reformulatorEquals, 2, 'CycLDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, reformulatorEquals, 1, 'CycLDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, reformulationPrecondition, 3, 'CycLAtomicAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, reformulationDirectionInMode, 3, 'CycLAtomicAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, quotedDefnSufficient, 2, 'CycLNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, quotedDefnNecessary, 2, 'CycLNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, quotedDefnIff, 2, 'CycLNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, querySentence, 1, 'CycLSentence', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, prettyString, 2, 'SubLString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, pragmaticRequirement, 2, 'CycLRuleAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, pragmaticRequirement, 1, 'CycLSentence-Askable', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, pragmaticallyNormal, 2, 'CycLAssertion', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(argQuotedIsa, pointQuantValue, 1, 'CycLReifiableDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, performSubL, 1, 'CycLNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, or, 1, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, operatorFormulas, 2, 'CycLFormula', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, operatorFormulas, 1, 'CycLClosedDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, oldConstantName, 2, 'SubLString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, oldConstantName, 2, 'SubLString', 'BookkeepingMt', vStrDef).
assertedTinyKB(argQuotedIsa, oldConstantName, 1, 'CycLConstant', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, oldConstantName, 1, 'CycLConstant', 'BookkeepingMt', vStrDef).
assertedTinyKB(argQuotedIsa, not, 1, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, not, 1, 'CycLSentence-Assertible', 'LogicalTruthMt', vStrDef).
assertedTinyKB(argQuotedIsa, not, 1, 'CycLSentence-Assertible', 'BaseKB', vStrDef).
assertedTinyKB(argQuotedIsa, natFunction, 1, 'CycLReifiableNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, natArgumentsEqual, 2, 'CycLReifiableNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, natArgumentsEqual, 1, 'CycLReifiableNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, natArgument, 1, 'CycLReifiableNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, myCreator, 1, 'CycLReifiableDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, myCreator, 1, 'CycLReifiableDenotationalTerm', 'BookkeepingMt', vStrDef).
assertedTinyKB(argQuotedIsa, myCreationTime, 1, 'CycLConstant', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(argQuotedIsa, myCreationTime, 1, 'CycLConstant', 'BookkeepingMt', vStrDef).
assertedTinyKB(argQuotedIsa, myCreationSecond, 1, 'CycLConstant', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, myCreationSecond, 1, 'CycLConstant', 'BookkeepingMt', vStrDef).
assertedTinyKB(argQuotedIsa, myCreationPurpose, 1, 'CycLReifiableDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, myCreationPurpose, 1, 'CycLReifiableDenotationalTerm', 'BookkeepingMt', vStrDef).
assertedTinyKB(argQuotedIsa, minimize, 1, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, meetsPragmaticRequirement, 2, 'CycLAssertion', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(argQuotedIsa, knownSentence, 1, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, knownAntecedentRule, 1, 'CycLRuleAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, ist, 2, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, ist, 2, 'CycLSentence-Assertible', 'LogicalTruthMt', vStrDef).
assertedTinyKB(argQuotedIsa, irrelevantTerm, 1, 'CycLReifiableDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, irrelevantPredAssertion, 2, 'CycLAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, irrelevantAssertion, 1, 'CycLAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, indexicalReferent, 1, 'IndeterminateTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, implies, 2, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, implies, 2, 'CycLSentence-Assertible', 'LogicalTruthMt', vStrDef).
assertedTinyKB(argQuotedIsa, implies, 2, 'CycLSentence-Assertible', 'BaseKB', vStrDef).
assertedTinyKB(argQuotedIsa, implies, 1, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, implies, 1, 'CycLSentence-Assertible', 'LogicalTruthMt', vStrDef).
assertedTinyKB(argQuotedIsa, implies, 1, 'CycLSentence-Assertible', 'BaseKB', vStrDef).
assertedTinyKB(argQuotedIsa, hypotheticalTerm, 1, 'CycLReifiableDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, holdsIn, 2, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, hlPrototypicalInstance, 1, 'HLPrototypicalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, hlPrototypicalInstance, 1, 'CycLIndexedTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, highlyRelevantTerm, 1, 'CycLReifiableDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, highlyRelevantPredAssertion, 2, 'CycLAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, highlyRelevantAssertion, 1, 'CycLAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, genMassNoun, 1, 'CycLReifiableDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, genlRules, 2, 'CycLRuleAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, genlRules, 1, 'CycLRuleAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, genKeyword, 2, 'SubLKeyword', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, genKeyword, 1, 'CycLReifiableDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, genFormat, 2, 'SubLString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, forwardNonTriggerLiteral, 1, 'CycLOpenSentence', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, formulaArity, 1, 'CycLFormula', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, forAll, 2, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, forAll, 2, 'CycLSentence-Assertible', 'LogicalTruthMt', vStrDef).
assertedTinyKB(argQuotedIsa, forAll, 1, ftVar, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, forAll, 1, ftVar, 'LogicalTruthMt', vStrDef).
assertedTinyKB(argQuotedIsa, expansionDefn, 2, 'CycLNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, expansion, 2, 'CycLExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, expansion, 2, 'CycLExpression', 'UniversalVocabularyImplementationMt', vStrDef).
assertedTinyKB(argQuotedIsa, exceptWhen, 2, 'CycLAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, exceptWhen, 1, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, exceptFor, 2, 'CycLAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, exceptFor, 1, 'CycLReifiableDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, except, 1, 'CycLAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, exampleAssertions, 2, 'CycLAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, exampleAssertions, 1, 'CycLReifiableDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, exactlyAssertedSentence, 1, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, evaluationDefn, 2, 'CycLNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, equiv, 2, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, equiv, 2, 'CycLSentence-Assertible', 'BaseKB', vStrDef).
assertedTinyKB(argQuotedIsa, equiv, 1, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, equiv, 1, 'CycLSentence-Assertible', 'BaseKB', vStrDef).
assertedTinyKB(argQuotedIsa, ephemeralTerm, 1, 'CycLReifiableDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, defnSufficient, 2, 'CycLNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, defnNecessary, 2, 'CycLNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, defnIff, 2, 'CycLNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, definingMt, 1, 'CycLReifiableDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, cycTransformationProofRule, 2, 'CycLRuleAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, cycProblemStoreTerms, 2, 'CycLClosedDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, cycProblemQueryTerms, 2, 'CycLClosedDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, cycProblemQuerySentence, 2, 'CycLSentence-Askable', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, constraint, 1, 'CycLAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, constantName, 2, 'SubLString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, constantName, 1, 'CycLConstant', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, constantID, 1, 'CycLConstant', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, constantGUID, 1, 'CycLConstant', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, consistent, 1, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, comment, 2, 'SubLString', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(argQuotedIsa, comment, 1, 'CycLIndexedTerm', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(argQuotedIsa, collectionExpansion, 2, 'CycLExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, collectionExpansion, 2, 'CycLExpression', 'UniversalVocabularyImplementationMt', vStrDef).
assertedTinyKB(argQuotedIsa, assertionUtility, 1, 'CycLAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, assertionDirection, 1, 'CycLAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, assertedTermSentences, 2, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, assertedTermSentences, 1, 'CycLTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, assertedSentence, 1, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, arity, 2, 'SubLNonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, arity, 2, 'SubLNonNegativeInteger', 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(argQuotedIsa, argSometimesIsa, 2, 'SubLPositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, argIsa, 2, 'SubLPositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, argIsa, 2, 'SubLPositiveInteger', 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(argQuotedIsa, argAndRestIsa, 2, 'SubLPositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, argAndRestIsa, 2, 'SubLPositiveInteger', 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(argQuotedIsa, and, 1, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, afterRemoving, 2, 'CycLNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, afterAdding, 2, 'CycLNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, admittedSentence, 1, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, admittedNAT, 1, 'CycLNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, abnormal, 2, 'CycLAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, 'UncanonicalizerAssertionFn', 1, 'CycLNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, 'TLVariableFn', 2, 'SubLString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, 'TLAssertionFn', 2, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, 'TheSetOf', 2, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, 'TheSetOf', 1, ftVar, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, 'TheCollectionOf', 2, 'CycLSentence-Askable', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, 'TheCollectionOf', 1, ftVar, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, 'SubLQuoteFn', 1, 'SubLSExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, 'SkolemFunctionFn', 3, 'SubLSymbol', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, 'SkolemFunctionFn', 2, ftVar, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, 'SkolemFunctionFn', 1, 'SubLList', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, 'SkolemFuncNFn', 3, 'SubLSymbol', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, 'SkolemFuncNFn', 2, ftVar, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, 'SkolemFuncNFn', 1, 'SubLList', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, 'Quote', 1, 'CycLTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, 'Quote', 1, 'CycLTerm', 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(argQuotedIsa, 'QuasiQuote', 1, 'CycLTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, 'QuasiQuote', 1, 'CycLTerm', 'LogicalTruthImplementationMt', vStrMon).
assertedTinyKB(argQuotedIsa, 'prettyString-Canonical', 2, 'SubLString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, 'Kappa', 2, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, 'Kappa', 1, 'SubLList', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, 'ist-Asserted', 2, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, 'FormulaArityFn', 1, 'CycLFormula', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, 'FormulaArgSetFn', 1, 'CycLFormula', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, 'FormulaArgListFn', 1, 'CycLFormula', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, 'FormulaArgFn', 2, 'CycLFormula', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, 'ExpandSubLFn', 2, 'SubLSExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, 'ExpandSubLFn', 1, 'SubLList', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, 'EvaluateSubLFn', 1, 'CycLNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, 'EscapeQuote', 1, 'CycLTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argQuotedIsa, 'EscapeQuote', 1, 'CycLTerm', 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(argQuotedIsa, 'assertionUtility-1', 1, 'CycLAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, unitMultiplicationFactor, 3, 'RealNumber', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, unitMultiplicationFactor, 3, 'NonNegativeScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, unitMultiplicationFactor, 2, 'UnitOfMeasure', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, unitMultiplicationFactor, 1, 'UnitOfMeasure', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, trueSubL, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, trueRule, 1, 'RuleTemplate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, transitiveViaArgInverse, 3, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, transitiveViaArgInverse, 2, 'TransitiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, transitiveViaArgInverse, 1, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, transitiveViaArg, 3, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, transitiveViaArg, 2, 'TransitiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, transitiveViaArg, 1, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, thereExistExactly, 1, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, thereExistAtMost, 1, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, thereExistAtLeast, 1, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, termOfUnit, 2, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, termOfUnit, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, termExternalIDString, 2, 'HLExternalIDString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, termExternalIDString, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, termDependsOn, 2, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, termDependsOn, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, termChosen, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, synonymousExternalConcept, 3, 'CharacterString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, synonymousExternalConcept, 2, 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, synonymousExternalConcept, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, substring, 2, 'CharacterString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, substring, 1, 'CharacterString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, subsetOf, 2, 'SetOrCollection', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, subsetOf, 1, 'SetOrCollection', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, skolemizeForward, 1, 'ReifiableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, skolem, 1, 'SkolemFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, singleEntryFormatInArgs, 2, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, singleEntryFormatInArgs, 1, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, siblingDisjointExceptions, 2, 'SetOrCollection', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, siblingDisjointExceptions, 2, 'SetOrCollection', 'BaseKB', vStrDef).
assertedTinyKB(argIsa, siblingDisjointExceptions, 1, 'SetOrCollection', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, siblingDisjointExceptions, 1, 'SetOrCollection', 'BaseKB', vStrDef).
assertedTinyKB(argIsa, sharedNotes, 2, 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, sharedNotes, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, sentenceTruth, 2, 'TruthValue', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, sentenceEquiv, 2, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, sentenceEquiv, 2, 'Thing', 'BaseKB', vStrDef).
assertedTinyKB(argIsa, sentenceEquiv, 2, 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, sentenceEquiv, 2, 'Individual', 'BaseKB', vStrDef).
assertedTinyKB(argIsa, sentenceEquiv, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, sentenceEquiv, 1, 'Thing', 'BaseKB', vStrDef).
assertedTinyKB(argIsa, sentenceEquiv, 1, 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, sentenceEquiv, 1, 'Individual', 'BaseKB', vStrDef).
assertedTinyKB(argIsa, sentenceDesignationArgnum, 2, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, sentenceDesignationArgnum, 1, 'MicrotheoryDesignatingRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, scopingArg, 2, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, scopingArg, 1, 'ScopingRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, salientAssertions, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, ruleTemplateDirection, 2, 'CycLAssertionDirection', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, ruleTemplateDirection, 1, 'RuleTemplate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, ruleAfterRemoving, 2, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, ruleAfterRemoving, 1, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, ruleAfterAdding, 2, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, ruleAfterAdding, 1, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, rewriteOf, 2, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, rewriteOf, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, resultQuotedIsa, 2, 'SubLExpressionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, resultQuotedIsa, 1, tFunction, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, resultIsaArgIsa, 2, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, resultIsaArgIsa, 1, tFunction, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, resultIsaArg, 2, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, resultIsaArg, 1, tFunction, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, resultIsa, 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, resultIsa, 2, tCol, 'LogicalTruthMt', vStrDef).
assertedTinyKB(argIsa, resultIsa, 2, tCol, 'BaseKB', vStrDef).
assertedTinyKB(argIsa, resultIsa, 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, resultIsa, 1, tRelation, 'BaseKB', vStrMon).
assertedTinyKB(argIsa, resultIsa, 1, tFunction, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, resultGenlArg, 2, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, resultGenlArg, 1, 'CollectionDenotingFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, resultGenl, 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, resultGenl, 2, tCol, 'BaseKB', vStrDef).
assertedTinyKB(argIsa, resultGenl, 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, resultGenl, 1, tRelation, 'BaseKB', vStrMon).
assertedTinyKB(argIsa, resultGenl, 1, 'CollectionDenotingFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, requiredArg3Pred, 2, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, requiredArg3Pred, 1, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, requiredArg2Pred, 2, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, requiredArg2Pred, 1, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, requiredArg1Pred, 2, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, requiredArg1Pred, 1, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationMemberInstance, 3, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationMemberInstance, 2, 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationMemberInstance, 1, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationInstanceMember, 3, 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationInstanceMember, 2, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationInstanceMember, 1, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationInstanceExists, 3, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationInstanceExists, 2, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationInstanceExists, 1, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationInstanceAll, 3, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationInstanceAll, 2, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationInstanceAll, 1, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationExpansion, 1, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationExistsMinAll, 4, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationExistsMinAll, 3, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationExistsMinAll, 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationExistsMinAll, 1, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationExistsMaxAll, 4, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationExistsMaxAll, 3, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationExistsMaxAll, 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationExistsMaxAll, 1, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationExistsInstance, 3, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationExistsInstance, 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationExistsInstance, 1, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationExistsCountAll, 4, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationExistsCountAll, 3, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationExistsCountAll, 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationExistsCountAll, 1, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationExistsAll, 3, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationExistsAll, 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationExistsAll, 1, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationAllInstance, 3, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationAllInstance, 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationAllInstance, 1, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationAllExistsMin, 4, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationAllExistsMin, 3, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationAllExistsMin, 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationAllExistsMin, 1, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationAllExistsMax, 4, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationAllExistsMax, 3, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationAllExistsMax, 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationAllExistsMax, 1, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationAllExistsCount, 4, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationAllExistsCount, 3, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationAllExistsCount, 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationAllExistsCount, 1, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationAllExists, 3, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationAllExists, 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationAllExists, 1, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationAll, 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, relationAll, 1, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, reformulatorRuleProperties, 1, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, reformulatorRule, 2, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, reformulatorRule, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, reformulatorEquals, 2, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, reformulatorEquals, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, reformulationPrecondition, 2, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, reformulationPrecondition, 2, 'Thing', 'UniversalVocabularyImplementationMt', vStrDef).
assertedTinyKB(argIsa, reformulationPrecondition, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, reformulationDirectionInMode, 2, 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, reformulationDirectionInMode, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, ratioOfTo, 3, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, ratioOfTo, 2, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, ratioOfTo, 1, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, quotedIsa, 2, 'SubLExpressionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, quotedIsa, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, quotedDefnSufficient, 2, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, quotedDefnSufficient, 1, 'SubLExpressionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, quotedDefnNecessary, 2, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, quotedDefnNecessary, 1, 'SubLExpressionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, quotedDefnIff, 2, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, quotedDefnIff, 1, 'SubLExpressionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, quotedArgument, 2, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, quotedArgument, 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, quantitySubsumes, 2, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, quantitySubsumes, 1, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, quantityIntersects, 2, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, quantityIntersects, 1, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, prettyString, 2, 'CharacterString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, prettyString, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, preservesGenlsInArg, 2, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, preservesGenlsInArg, 1, 'CollectionDenotingFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, predicateConventionMt, 2, 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, predicateConventionMt, 1, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, pragmaticallyNormal, 1, 'List', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(argIsa, pointQuantValue, 2, 'ScalarPointValue', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, pointQuantValue, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, pointQuantValue, 1, 'ScalarPointValue', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, performSubL, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, overlappingExternalConcept, 3, 'CharacterString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, overlappingExternalConcept, 2, 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, operatorFormulas, 2, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, operatorFormulas, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, operatorFormulas, 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, openEntryFormatInArgs, 2, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, openEntryFormatInArgs, 1, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, opaqueArgument, 2, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, opaqueArgument, 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, omitArgIsa, 2, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, omitArgIsa, 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, oldConstantName, 2, 'CharacterString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, oldConstantName, 2, 'CharacterString', 'BookkeepingMt', vStrDef).
assertedTinyKB(argIsa, oldConstantName, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, oldConstantName, 1, 'Thing', 'BookkeepingMt', vStrDef).
assertedTinyKB(argIsa, numericallyEquals, 2, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, numericallyEquals, 2, 'ScalarInterval', 'BaseKB', vStrDef).
assertedTinyKB(argIsa, numericallyEquals, 1, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, numericallyEquals, 1, 'ScalarInterval', 'BaseKB', vStrDef).
assertedTinyKB(argIsa, nthSmallestElement, 4, 'UnaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, nthSmallestElement, 3, 'SetOrCollection', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, nthSmallestElement, 2, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, nthSmallestElement, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, nthLargestElement, 4, 'UnaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, nthLargestElement, 3, 'SetOrCollection', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, nthLargestElement, 2, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, nthLargestElement, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, notAssertibleMt, 1, 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, notAssertibleCollection, 1, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, notAssertible, 1, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, nonAbducibleWithValueInArg, 3, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, nonAbducibleWithValueInArg, 2, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, nonAbducibleWithValueInArg, 1, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, negationPreds, 2, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, negationPreds, 1, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, negationMt, 2, 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, negationMt, 1, 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, negationInverse, 2, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, negationInverse, 1, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, nearestIsa, 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, nearestIsa, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, nearestGenls, 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, nearestGenls, 1, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, nearestGenlPreds, 2, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, nearestGenlPreds, 1, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, nearestGenlMt, 2, 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, nearestGenlMt, 1, 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, nearestDifferentIsa, 3, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, nearestDifferentIsa, 2, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, nearestDifferentIsa, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, nearestDifferentGenls, 3, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, nearestDifferentGenls, 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, nearestDifferentGenls, 1, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, nearestCommonSpecs, 3, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, nearestCommonSpecs, 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, nearestCommonSpecs, 1, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, nearestCommonIsa, 3, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, nearestCommonIsa, 2, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, nearestCommonIsa, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, nearestCommonGenls, 3, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, nearestCommonGenls, 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, nearestCommonGenls, 1, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, nearestCommonGenlMt, 3, 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, nearestCommonGenlMt, 2, 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, nearestCommonGenlMt, 1, 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, natFunction, 2, 'ReifiableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, natFunction, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, natArgumentsEqual, 2, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, natArgumentsEqual, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, natArgument, 3, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, natArgument, 2, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, natArgument, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, myCreator, 2, 'Cyclist', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, myCreator, 2, 'Cyclist', 'BookkeepingMt', vStrDef).
assertedTinyKB(argIsa, myCreator, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, myCreator, 1, 'Thing', 'BookkeepingMt', vStrDef).
assertedTinyKB(argIsa, myCreationTime, 2, 'Integer', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, myCreationTime, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, myCreationTime, 1, 'Thing', 'BookkeepingMt', vStrDef).
assertedTinyKB(argIsa, myCreationSecond, 2, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, myCreationSecond, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, myCreationSecond, 1, 'Thing', 'BookkeepingMt', vStrDef).
assertedTinyKB(argIsa, myCreationPurpose, 2, 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, myCreationPurpose, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, myCreationPurpose, 1, 'Thing', 'BookkeepingMt', vStrDef).
assertedTinyKB(argIsa, multiplicationUnits, 3, 'UnitOfMeasure', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, multiplicationUnits, 2, 'UnitOfMeasure', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, multiplicationUnits, 1, 'UnitOfMeasure', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, mtVisible, 1, 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, minQuantValue, 2, 'ScalarPointValue', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, minQuantValue, 1, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, minimizeExtent, 1, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, microtheoryDesignationArgnum, 2, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, microtheoryDesignationArgnum, 1, 'MicrotheoryDesignatingRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, meetsPragmaticRequirement, 1, 'List', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(argIsa, means, 2, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, means, 1, 'SubLSExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, maxQuantValue, 2, 'ScalarPointValue', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, maxQuantValue, 1, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, ist, 1, 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, ist, 1, 'Microtheory', 'LogicalTruthMt', vStrDef).
assertedTinyKB(argIsa, isa, 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, isa, 2, tCol, 'LogicalTruthMt', vStrDef).
assertedTinyKB(argIsa, isa, 2, tCol, 'BaseKB', vStrDef).
assertedTinyKB(argIsa, isa, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, isa, 1, 'Thing', 'LogicalTruthMt', vStrDef).
assertedTinyKB(argIsa, isa, 1, 'Thing', 'BaseKB', vStrDef).
assertedTinyKB(argIsa, irrelevantTerm, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, irrelevantPredAssertion, 1, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, irrelevantMt, 1, 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, interArgResultIsaReln, 5, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, interArgResultIsaReln, 4, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, interArgResultIsaReln, 3, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, interArgResultIsaReln, 2, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, interArgResultIsaReln, 1, tFunction, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, interArgResultIsa, 4, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, interArgResultIsa, 3, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, interArgResultIsa, 2, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, interArgResultIsa, 1, tFunction, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, interArgResultGenlReln, 5, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, interArgResultGenlReln, 4, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, interArgResultGenlReln, 3, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, interArgResultGenlReln, 2, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, interArgResultGenlReln, 1, tFunction, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, interArgResultGenl, 4, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, interArgResultGenl, 3, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, interArgResultGenl, 2, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, interArgResultGenl, 1, tFunction, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, interArgIsa, 5, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, interArgIsa, 4, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, interArgIsa, 3, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, interArgIsa, 2, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, interArgIsa, 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, interArgDifferent, 3, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, interArgDifferent, 2, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, interArgDifferent, 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, integerBetween, 3, 'Integer', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, integerBetween, 2, 'Integer', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, integerBetween, 1, 'Integer', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, instanceElementType, 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, instanceElementType, 1, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, indexicalReferent, 2, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, indexicalReferent, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, independentArg, 2, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, independentArg, 1, 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, independentArg, 1, 'ArgConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, hypotheticalTerm, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, holdsIn, 1, 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, hlPrototypicalInstance, 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, hlPrototypicalInstance, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, highlyRelevantTerm, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, highlyRelevantPredAssertion, 1, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, highlyRelevantMt, 1, 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, greaterThanOrEqualTo, 2, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, greaterThanOrEqualTo, 2, 'ScalarInterval', 'BaseKB', vStrDef).
assertedTinyKB(argIsa, greaterThanOrEqualTo, 1, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, greaterThanOrEqualTo, 1, 'ScalarInterval', 'BaseKB', vStrDef).
assertedTinyKB(argIsa, greaterThan, 2, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, greaterThan, 2, 'ScalarInterval', 'BaseKB', vStrDef).
assertedTinyKB(argIsa, greaterThan, 1, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, greaterThan, 1, 'ScalarInterval', 'BaseKB', vStrDef).
assertedTinyKB(argIsa, genMassNoun, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, genls, 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, genls, 2, tCol, 'LogicalTruthMt', vStrDef).
assertedTinyKB(argIsa, genls, 2, tCol, 'BaseKB', vStrDef).
assertedTinyKB(argIsa, genls, 1, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, genls, 1, tCol, 'LogicalTruthMt', vStrDef).
assertedTinyKB(argIsa, genls, 1, tCol, 'BaseKB', vStrDef).
assertedTinyKB(argIsa, genlPreds, 2, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, genlPreds, 2, tPred, 'BaseKB', vStrDef).
assertedTinyKB(argIsa, genlPreds, 1, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, genlPreds, 1, tPred, 'BaseKB', vStrDef).
assertedTinyKB(argIsa, genlMt, 2, 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, genlMt, 2, 'Microtheory', 'LogicalTruthMt', vStrDef).
assertedTinyKB(argIsa, genlMt, 2, 'Microtheory', 'BaseKB', vStrDef).
assertedTinyKB(argIsa, genlMt, 1, 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, genlMt, 1, 'Microtheory', 'LogicalTruthMt', vStrDef).
assertedTinyKB(argIsa, genlMt, 1, 'Microtheory', 'BaseKB', vStrDef).
assertedTinyKB(argIsa, genlInverse, 2, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, genlInverse, 1, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, genlCanonicalizerDirectives, 2, 'CanonicalizerDirective', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, genlCanonicalizerDirectives, 1, 'CanonicalizerDirective', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, genKeyword, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, genFormat, 3, 'List', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, genFormat, 2, 'CharacterString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, genFormat, 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, formulaArity, 2, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, formulaArity, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, followingValue, 2, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, followingValue, 1, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, fanOutArg, 2, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, fanOutArg, 1, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, extentCardinality, 2, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, extentCardinality, 1, 'SetOrCollection', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, extConceptOverlapsColAndReln, 4, 'CharacterString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, extConceptOverlapsColAndReln, 3, 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, extConceptOverlapsColAndReln, 2, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, extConceptOverlapsColAndReln, 1, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, expresses, 2, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, expresses, 1, 'CycLSentence', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, expansionDefn, 2, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, expansionDefn, 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, expansion, 2, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, expansion, 2, 'Thing', 'UniversalVocabularyImplementationMt', vStrDef).
assertedTinyKB(argIsa, expansion, 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, exceptMt, 1, 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, exceptFor, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, exampleAssertions, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, evaluationResultQuotedIsa, 2, 'SubLExpressionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, evaluationResultQuotedIsa, 1, 'EvaluatableRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, evaluationDefn, 2, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, evaluationDefn, 1, 'EvaluatableRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, evaluateImmediately, 1, 'EvaluatableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, evaluateAtEL, 1, 'EvaluatableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, evaluate, 2, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, evaluate, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, equalSymbols, 2, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, equalSymbols, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, equals, 2, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, equals, 2, 'Thing', 'LogicalTruthMt', vStrDef).
assertedTinyKB(argIsa, equals, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, equals, 1, 'Thing', 'LogicalTruthMt', vStrDef).
assertedTinyKB(argIsa, ephemeralTerm, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, elInverse, 2, 'ELRelation-OneWay', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, elInverse, 2, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, elInverse, 1, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, elementOf, 2, 'SetOrCollection', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, elementOf, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, distributesOutOfArg, 3, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, distributesOutOfArg, 2, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, distributesOutOfArg, 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, disjointWith, 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, disjointWith, 2, tCol, 'LogicalTruthMt', vStrDef).
assertedTinyKB(argIsa, disjointWith, 1, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, disjointWith, 1, tCol, 'LogicalTruthMt', vStrDef).
assertedTinyKB(argIsa, different, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, denotes, 2, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, denotes, 1, 'CycLDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, defnSufficient, 2, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, defnSufficient, 1, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, defnNecessary, 2, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, defnNecessary, 1, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, defnIff, 2, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, defnIff, 1, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, defnIff, 1, tCol, 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(argIsa, definingMt, 2, 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, definingMt, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, defaultReformulatorModePrecedence, 1, 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, defaultReformulationDirectionInModeForPred, 3, 'ReformulatorDirectivePredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, defaultReformulationDirectionInModeForPred, 2, 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, defaultReformulationDirectionInModeForPred, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, decontextualizedPredicate, 1, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, decontextualizedCollection, 1, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, cycTransformationProofRule, 1, 'CycTransformationProof', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, cycTransformationProofBindings, 2, 'List', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, cycTransformationProofBindings, 1, 'CycTransformationProof', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, cycTacticID, 3, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, cycTacticID, 2, 'CycProblem', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, cycTacticID, 1, 'CycTactic', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, cycProofID, 3, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, cycProofID, 2, 'CycProblemStore', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, cycProofID, 1, 'CycProof', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, cycProblemStoreTerms, 2, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, cycProblemStoreTerms, 1, 'CycProblem', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, cycProblemStoreProofs, 2, 'CycProof', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, cycProblemStoreProofs, 1, 'CycProblemStore', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, cycProblemStoreProofCount, 2, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, cycProblemStoreProofCount, 1, 'CycProblemStore', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, cycProblemStoreProblems, 2, 'CycProblem', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, cycProblemStoreProblems, 1, 'CycProblemStore', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, cycProblemStoreProblemCount, 2, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, cycProblemStoreProblemCount, 1, 'CycProblemStore', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, cycProblemStoreLinks, 2, 'CycProblemLink', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, cycProblemStoreLinks, 1, 'CycProblemStore', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, cycProblemStoreLinkCount, 2, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, cycProblemStoreLinkCount, 1, 'CycProblemStore', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, cycProblemStoreInferences, 2, 'CycInference', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, cycProblemStoreInferences, 1, 'CycProblemStore', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, cycProblemStoreInferenceCount, 2, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, cycProblemStoreInferenceCount, 1, 'CycProblemStore', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, cycProblemStoreID, 2, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, cycProblemStoreID, 1, 'CycProblemStore', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, cycProblemQueryTerms, 2, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, cycProblemQueryTerms, 1, 'CycProblem', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, cycProblemQuerySentence, 1, 'CycProblem', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, cycProblemProvabilityStatus, 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, cycProblemProvabilityStatus, 1, 'CycProblem', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, cycProblemLinkID, 3, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, cycProblemLinkID, 2, 'CycProblemStore', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, cycProblemLinkID, 1, 'CycProblemLink', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, cycProblemID, 3, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, cycProblemID, 2, 'CycProblemStore', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, cycProblemID, 1, 'CycProblem', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, cycProblemDependentLinks, 2, 'CycProblemLink', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, cycProblemDependentLinks, 1, 'CycProblem', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, cycProblemArgumentLinks, 2, 'CycProblemLink', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, cycProblemArgumentLinks, 1, 'CycProblem', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, cycInferenceRelevantProblems, 2, 'CycProblem', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, cycInferenceRelevantProblems, 1, 'CycInference', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, cycInferenceAnswerLink, 2, 'CycProblemLink-AnswerLink', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, cycInferenceAnswerLink, 1, 'CycInference', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, constrainsArg, 2, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, constrainsArg, 1, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, constantName, 2, 'CharacterString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, constantName, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, constantID, 2, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, constantID, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, constantGUID, 2, 'SubLString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, constantGUID, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, conceptuallyRelated, 2, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, conceptuallyRelated, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, completelyEnumerableCollection, 1, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, completelyDecidableCollection, 1, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, completeExtentEnumerableViaBackchain, 1, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, completeExtentEnumerableForValueInArg, 3, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, completeExtentEnumerableForValueInArg, 2, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, completeExtentEnumerableForValueInArg, 1, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, completeExtentEnumerableForArg, 2, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, completeExtentEnumerableForArg, 1, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, completeExtentEnumerable, 1, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, completeExtentDecidableForValueInArg, 3, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, completeExtentDecidableForValueInArg, 2, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, completeExtentDecidableForValueInArg, 1, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, completeExtentDecidable, 1, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, completeExtentAssertedForValueInArg, 3, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, completeExtentAssertedForValueInArg, 2, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, completeExtentAssertedForValueInArg, 1, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, completeExtentAsserted, 1, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, commutativeInArgsAndRest, 2, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, commutativeInArgsAndRest, 1, 'PartiallyCommutativeRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, commutativeInArgs, 3, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, commutativeInArgs, 2, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, commutativeInArgs, 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, comment, 2, 'CharacterString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, comment, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, collectionIsaBackchainRequired, 1, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, collectionIsaBackchainEncouraged, 1, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, collectionGenlsBackchainRequired, 1, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, collectionGenlsBackchainEncouraged, 1, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, collectionExpansion, 2, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, collectionExpansion, 2, 'Thing', 'UniversalVocabularyImplementationMt', vStrDef).
assertedTinyKB(argIsa, collectionExpansion, 1, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, collectionConventionMt, 2, 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, collectionConventionMt, 1, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, collectionCompletelyEnumerableViaBackchain, 1, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, collectionBackchainRequired, 1, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, collectionBackchainEncouraged, 1, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, coExtensional, 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, coExtensional, 1, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, canonicalizerDirectiveForArgAndRest, 3, 'CanonicalizerDirective', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, canonicalizerDirectiveForArgAndRest, 2, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, canonicalizerDirectiveForArgAndRest, 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, canonicalizerDirectiveForArg, 3, 'CanonicalizerDirective', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, canonicalizerDirectiveForArg, 2, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, canonicalizerDirectiveForArg, 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, canonicalizerDirectiveForAllArgs, 2, 'CanonicalizerDirective', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, canonicalizerDirectiveForAllArgs, 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, backchainRequired, 1, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, backchainForbiddenWhenUnboundInArg, 2, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, backchainForbiddenWhenUnboundInArg, 1, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, backchainForbidden, 1, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, assertionUtility, 2, 'RealNumber', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, assertionDirection, 2, 'CycLAssertionDirection', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, assertedTermSentences, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, assertedPredicateArg, 3, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, assertedPredicateArg, 2, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, assertedPredicateArg, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arityMin, 2, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arityMin, 1, 'VariableArityRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arityMax, 2, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arityMax, 1, 'VariableArityRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arity, 2, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arity, 2, 'NonNegativeInteger', 'LogicalTruthMt', vStrDef).
assertedTinyKB(argIsa, arity, 2, 'Integer', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arity, 1, 'FixedArityRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arity, 1, 'FixedArityRelation', 'LogicalTruthMt', vStrDef).
assertedTinyKB(argIsa, argsQuotedIsa, 2, 'SubLExpressionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, argsQuotedIsa, 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, argSometimesIsa, 3, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, argSometimesIsa, 2, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, argSometimesIsa, 2, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, argSometimesIsa, 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, argsIsa, 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, argsIsa, 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, argsGenl, 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, argsGenl, 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, argQuotedIsa, 3, 'SubLExpressionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, argQuotedIsa, 2, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, argQuotedIsa, 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, argIsa, 3, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, argIsa, 3, tCol, 'LogicalTruthMt', vStrDef).
assertedTinyKB(argIsa, argIsa, 2, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, argIsa, 2, 'PositiveInteger', 'LogicalTruthMt', vStrDef).
assertedTinyKB(argIsa, argIsa, 2, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, argIsa, 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, argIsa, 1, tRelation, 'LogicalTruthMt', vStrDef).
assertedTinyKB(argIsa, argAndRestQuotedIsa, 3, 'SubLExpressionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, argAndRestQuotedIsa, 2, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, argAndRestQuotedIsa, 1, 'VariableArityRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, argAndRestIsa, 3, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, argAndRestIsa, 3, tCol, 'LogicalTruthMt', vStrDef).
assertedTinyKB(argIsa, argAndRestIsa, 2, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, argAndRestIsa, 2, 'PositiveInteger', 'LogicalTruthMt', vStrDef).
assertedTinyKB(argIsa, argAndRestIsa, 2, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, argAndRestIsa, 1, 'VariableArityRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, argAndRestIsa, 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, argAndRestIsa, 1, tRelation, 'LogicalTruthMt', vStrDef).
assertedTinyKB(argIsa, argAndRestGenl, 3, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, argAndRestGenl, 2, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, argAndRestGenl, 1, 'VariableArityRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg6SometimesIsa, 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg6SometimesIsa, 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg6QuotedIsa, 2, 'SubLExpressionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg6QuotedIsa, 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg6Isa, 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg6Isa, 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg6Genl, 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg6Genl, 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg6Format, 2, 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg6Format, 1, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg5SometimesIsa, 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg5SometimesIsa, 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg5QuotedIsa, 2, 'SubLExpressionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg5QuotedIsa, 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg5Isa, 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg5Isa, 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg5Genl, 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg5Genl, 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg5Format, 2, 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg5Format, 1, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg4SometimesIsa, 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg4SometimesIsa, 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg4QuotedIsa, 2, 'SubLExpressionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg4QuotedIsa, 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg4Isa, 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg4Isa, 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg4Genl, 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg4Genl, 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg4Format, 2, 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg4Format, 1, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg3SometimesIsa, 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg3SometimesIsa, 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg3QuotedIsa, 2, 'SubLExpressionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg3QuotedIsa, 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg3Isa, 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg3Isa, 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg3Genl, 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg3Genl, 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg3Format, 2, 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg3Format, 1, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg2SometimesIsa, 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg2SometimesIsa, 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg2QuotedIsa, 2, 'SubLExpressionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg2QuotedIsa, 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg2Isa, 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg2Isa, 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg2Genl, 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg2Genl, 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg2Format, 2, 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg2Format, 1, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg1SometimesIsa, 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg1SometimesIsa, 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg1QuotedIsa, 2, 'SubLExpressionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg1QuotedIsa, 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg1Isa, 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg1Isa, 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg1Genl, 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg1Genl, 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg1Format, 2, 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, arg1Format, 1, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, afterRemoving, 2, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, afterRemoving, 1, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, afterRemoving, 1, tPred, 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(argIsa, afterAdding, 2, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, afterAdding, 1, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, afterAdding, 1, tPred, 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(argIsa, admittedNAT, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, admittedArgument, 3, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, admittedArgument, 2, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, admittedArgument, 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, admittedAllArgument, 3, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, admittedAllArgument, 2, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, admittedAllArgument, 1, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, abnormal, 1, 'List', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'Unity', 1, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'UnitProductFn', 2, 'UnitOfMeasure', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'UnitProductFn', 1, 'UnitOfMeasure', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'UncanonicalizerAssertionFn', 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'TLVariableFn', 2, 'CharacterString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'TLVariableFn', 1, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'TLReifiedNatFn', 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'TLAssertionFn', 1, 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'TimesFn', 1, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'TheSet', 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'TheList', 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'substring-CaseInsensitive', 2, 'CharacterString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'substring-CaseInsensitive', 1, 'CharacterString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'SkolemFuncNFn', 4, 'NonNegativeScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'RoundUpFn', 1, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'RoundDownFn', 1, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'RoundClosestFn', 1, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'RelationInstanceExistsFn', 3, tCol, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(argIsa, 'RelationInstanceExistsFn', 2, 'Thing', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(argIsa, 'RelationInstanceExistsFn', 1, 'BinaryPredicate', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(argIsa, 'RelationExistsInstanceFn', 3, 'Thing', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(argIsa, 'RelationExistsInstanceFn', 2, tCol, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(argIsa, 'RelationExistsInstanceFn', 1, 'BinaryPredicate', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(argIsa, 'RelationExistsAllFn', 4, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'RelationExistsAllFn', 3, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'RelationExistsAllFn', 2, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'RelationExistsAllFn', 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'RelationAllExistsFn', 4, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'RelationAllExistsFn', 3, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'RelationAllExistsFn', 2, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'RelationAllExistsFn', 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'QuotientFn', 2, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'QuotientFn', 1, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'Quote', 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'QuasiQuote', 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'QuantityConversionFn', 2, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'QuantityConversionFn', 1, 'UnitOfMeasure', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'prettyString-Canonical', 2, 'CharacterString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'prettyString-Canonical', 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'PlusFn', 1, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'PlusAll', 2, 'UnaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'PlusAll', 2, 'UnaryFunction', 'BaseKB', vStrDef).
assertedTinyKB(argIsa, 'PlusAll', 2, 'EvaluatableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'PlusAll', 1, 'SetOrCollection', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'PlusAll', 1, 'SetOrCollection', 'BaseKB', vStrDef).
assertedTinyKB(argIsa, 'PerFn', 2, 'UnitOfMeasure', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'PerFn', 1, 'UnitOfMeasure', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'Percent', 1, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'MtUnionFn', 1, 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'MtTimeWithGranularityDimFn', 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'MtTimeWithGranularityDimFn', 1, 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'MtTimeDimFn', 1, 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'MtSpace', 1, 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'ModuloFn', 2, 'ScalarPointValue', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'ModuloFn', 1, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'MinRangeFn', 1, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'Minimum', 2, 'UnaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'Minimum', 2, 'UnaryFunction', 'BaseKB', vStrDef).
assertedTinyKB(argIsa, 'Minimum', 1, 'SetOrCollection', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'Minimum', 1, 'SetOrCollection', 'BaseKB', vStrDef).
assertedTinyKB(argIsa, 'MeaningInSystemFn', 2, 'CharacterString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'MeaningInSystemFn', 1, 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'MaxRangeFn', 1, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'Maximum', 2, 'UnaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'Maximum', 2, 'UnaryFunction', 'BaseKB', vStrDef).
assertedTinyKB(argIsa, 'Maximum', 1, 'SetOrCollection', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'Maximum', 1, 'SetOrCollection', 'BaseKB', vStrDef).
assertedTinyKB(argIsa, 'LogFn', 1, 'RealNumber', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'LogFn', 1, 'NonNegativeScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'larkc-hasUri', 2, 'CharacterString', 'BaseKB', vStrDef).
assertedTinyKB(argIsa, 'larkc-hasUri', 1, 'larkc-Plugin', 'BaseKB', vStrDef).
assertedTinyKB(argIsa, 'larkc-hasScalability', 2, 'CharacterString', 'BaseKB', vStrDef).
assertedTinyKB(argIsa, 'larkc-hasScalability', 1, 'larkc-Scalability', 'BaseKB', vStrDef).
assertedTinyKB(argIsa, 'larkc-hasEndpoint', 2, 'CharacterString', 'BaseKB', vStrDef).
assertedTinyKB(argIsa, 'larkc-hasEndpoint', 1, 'larkc-Plugin', 'BaseKB', vStrDef).
assertedTinyKB(argIsa, 'larkc-hasCostPerInvocation', 2, 'larkc-euro', 'BaseKB', vStrDef).
assertedTinyKB(argIsa, 'larkc-hasCostPerInvocation', 1, 'larkc-Cost', 'BaseKB', vStrDef).
assertedTinyKB(argIsa, 'ist-Asserted', 1, 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'IntervalMinFn', 1, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'IntervalMaxFn', 1, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa5-4', 3, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa5-4', 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa5-4', 1, 'QuintaryRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa5-3', 3, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa5-3', 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa5-3', 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa5-3', 1, 'QuintaryRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa5-2', 3, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa5-2', 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa5-2', 1, 'QuintaryRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa5-1', 3, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa5-1', 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa5-1', 1, 'QuintaryRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa4-5', 3, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa4-5', 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa4-5', 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa4-3', 3, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa4-3', 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa4-3', 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa4-2', 3, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa4-2', 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa4-2', 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa4-1', 3, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa4-1', 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa4-1', 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa3-5', 3, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa3-5', 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa3-5', 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa3-4', 3, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa3-4', 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa3-4', 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa3-2', 3, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa3-2', 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa3-2', 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa3-1', 3, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa3-1', 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa3-1', 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa2-5', 3, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa2-5', 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa2-5', 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa2-4', 3, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa2-4', 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa2-4', 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa2-3', 3, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa2-3', 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa2-3', 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa2-1', 3, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa2-1', 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa2-1', 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa1-5', 3, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa1-5', 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa1-5', 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa1-4', 3, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa1-4', 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa1-4', 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa1-3', 3, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa1-3', 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa1-3', 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa1-2', 3, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa1-2', 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgIsa1-2', 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgGenl1-2', 3, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgGenl1-2', 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgGenl1-2', 1, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgFormat1-2', 3, 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgFormat1-2', 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'interArgFormat1-2', 1, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'genls-SpecDenotesGenlInstances', 2, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'genls-SpecDenotesGenlInstances', 1, 'SubLExpressionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'genls-GenlDenotesSpecInstances', 2, 'SubLExpressionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'genls-GenlDenotesSpecInstances', 1, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'FunctionToArg', 2, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'FunctionToArg', 1, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'FormulaArityFn', 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'FormulaArgSetFn', 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'FormulaArgListFn', 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'FormulaArgFn', 2, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'FormulaArgFn', 1, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'FOL-TermFn', 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'FOL-PredicateFn', 2, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'FOL-PredicateFn', 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'FOL-FunctionFn', 2, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'FOL-FunctionFn', 1, tFunction, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'ExpFn', 1, 'ScalarPointValue', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'EvaluateSubLFn', 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'EscapeQuote', 1, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'equalStrings-CaseInsensitive', 2, 'CharacterString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'equalStrings-CaseInsensitive', 1, 'CharacterString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'DifferenceFn', 2, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'DifferenceFn', 1, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'DateEncodeStringFn', 2, 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'DateEncodeStringFn', 1, 'CharacterString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'DateDecodeStringFn', 2, 'CharacterString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'DateDecodeStringFn', 1, 'CharacterString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'CycTacticFn', 2, 'CycTactic', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'CycTacticFn', 1, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'CycProofFn', 2, 'CycProblemStore', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'CycProofFn', 1, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'CycProblemStoreFn', 1, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'CycProblemLinkFn', 2, 'CycProblemStore', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'CycProblemLinkFn', 1, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'CycProblemFn', 2, 'CycProblemStore', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'CycProblemFn', 1, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'CycInferenceFn', 2, 'CycProblemStore', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'CycInferenceFn', 1, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'CollectionRuleTemplateFn', 1, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'Average', 2, 'UnaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'Average', 2, 'UnaryFunction', 'BaseKB', vStrDef).
assertedTinyKB(argIsa, 'Average', 1, 'SetOrCollection', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'Average', 1, 'SetOrCollection', 'BaseKB', vStrDef).
assertedTinyKB(argIsa, 'assertionUtility-1', 2, 'RealNumber', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argIsa, 'AbsoluteValueFn', 1, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(argAndRestQuotedIsa, or, 1, 'CycLSentence-Assertible', 'LogicalTruthMt', vStrMon).
assertedTinyKB(argAndRestQuotedIsa, and, 1, 'CycLSentence-Assertible', 'LogicalTruthMt', vStrMon).
assertedTinyKB(argAndRestIsa, commutativeInArgsAndRest, 2, 'PositiveInteger', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(argAndRestIsa, commutativeInArgs, 2, 'PositiveInteger', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg6Format, different, 'SetTheFormat', 'BaseKB', vStrDef).
assertedTinyKB(arg5Isa, interArgResultIsaReln, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg5Isa, interArgResultGenlReln, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg5Isa, interArgIsa, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg5Genl, interArgIsa, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg5Format, interArgResultIsaReln, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg5Format, interArgResultGenlReln, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg5Format, interArgIsa, 'SetTheFormat', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg5Format, different, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg4Isa, relationExistsMinAll, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg4Isa, relationExistsMaxAll, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg4Isa, relationExistsCountAll, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg4Isa, relationAllExistsMin, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg4Isa, relationAllExistsMax, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg4Isa, relationAllExistsCount, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg4Isa, nthSmallestElement, 'UnaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg4Isa, nthLargestElement, 'UnaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg4Isa, interArgResultIsaReln, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg4Isa, interArgResultIsa, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg4Isa, interArgResultGenlReln, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg4Isa, interArgResultGenl, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg4Isa, interArgIsa, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg4Isa, extConceptOverlapsColAndReln, 'CharacterString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg4Isa, 'SkolemFuncNFn', 'NonNegativeScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg4Isa, 'RelationExistsAllFn', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg4Isa, 'RelationAllExistsFn', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg4Genl, interArgResultIsa, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg4Genl, interArgResultGenl, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg4Genl, 'RelationExistsAllFn', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg4Genl, 'RelationAllExistsFn', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg4Format, relationExistsMinAll, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg4Format, relationExistsMaxAll, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg4Format, relationExistsCountAll, singleEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg4Format, relationAllExistsMin, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg4Format, relationAllExistsMax, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg4Format, relationAllExistsCount, singleEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg4Format, nthSmallestElement, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg4Format, interArgResultIsaReln, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg4Format, interArgResultIsa, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg4Format, interArgResultGenlReln, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg4Format, interArgResultGenl, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg4Format, interArgIsa, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg4Format, extConceptOverlapsColAndReln, 'SingleEntry', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg4Format, different, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3QuotedIsa, thereExistExactly, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3QuotedIsa, thereExistAtMost, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3QuotedIsa, thereExistAtLeast, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3QuotedIsa, reformulationPrecondition, 'CycLAtomicAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3QuotedIsa, reformulationDirectionInMode, 'CycLAtomicAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3QuotedIsa, 'SkolemFunctionFn', 'SubLSymbol', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3QuotedIsa, 'SkolemFuncNFn', 'SubLSymbol', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, unitMultiplicationFactor, 'RealNumber', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, unitMultiplicationFactor, 'NonNegativeScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, transitiveViaArgInverse, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, transitiveViaArg, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, synonymousExternalConcept, 'CharacterString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, relationMemberInstance, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, relationInstanceMember, 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, relationInstanceExists, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, relationInstanceAll, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, relationExistsMinAll, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, relationExistsMaxAll, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, relationExistsInstance, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, relationExistsCountAll, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, relationExistsAll, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, relationAllInstance, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, relationAllExistsMin, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, relationAllExistsMax, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, relationAllExistsCount, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, relationAllExists, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, ratioOfTo, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, overlappingExternalConcept, 'CharacterString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, nthSmallestElement, 'SetOrCollection', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, nthLargestElement, 'SetOrCollection', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, nonAbducibleWithValueInArg, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, nearestDifferentIsa, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, nearestDifferentGenls, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, nearestCommonSpecs, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, nearestCommonIsa, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, nearestCommonGenls, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, nearestCommonGenlMt, 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, natArgument, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, multiplicationUnits, 'UnitOfMeasure', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, interArgResultIsaReln, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, interArgResultIsa, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, interArgResultGenlReln, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, interArgResultGenl, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, interArgIsa, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, interArgDifferent, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, integerBetween, 'Integer', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, genFormat, 'List', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, extConceptOverlapsColAndReln, 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, distributesOutOfArg, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, defaultReformulationDirectionInModeForPred, 'ReformulatorDirectivePredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, cycTacticID, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, cycProofID, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, cycProblemLinkID, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, cycProblemID, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, completeExtentEnumerableForValueInArg, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, completeExtentDecidableForValueInArg, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, completeExtentDecidableForValueInArg, 'NonNegativeInteger', 'CoreCycLMt', vStrDef).
assertedTinyKB(arg3Isa, completeExtentAssertedForValueInArg, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, completeExtentAssertedForValueInArg, 'NonNegativeInteger', 'CoreCycLMt', vStrDef).
assertedTinyKB(arg3Isa, commutativeInArgs, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, canonicalizerDirectiveForArgAndRest, 'CanonicalizerDirective', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, canonicalizerDirectiveForArgAndRest, 'CanonicalizerDirective', 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(arg3Isa, canonicalizerDirectiveForArg, 'CanonicalizerDirective', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, canonicalizerDirectiveForArg, 'CanonicalizerDirective', 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(arg3Isa, assertedPredicateArg, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, argSometimesIsa, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, argQuotedIsa, 'SubLExpressionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, argIsa, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, argAndRestQuotedIsa, 'SubLExpressionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, argAndRestIsa, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, argAndRestGenl, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, admittedArgument, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, admittedAllArgument, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, 'RelationInstanceExistsFn', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, 'RelationExistsInstanceFn', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, 'RelationExistsAllFn', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, 'RelationAllExistsFn', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, 'interArgIsa5-4', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, 'interArgIsa5-3', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, 'interArgIsa5-2', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, 'interArgIsa5-1', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, 'interArgIsa4-5', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, 'interArgIsa4-3', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, 'interArgIsa4-2', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, 'interArgIsa4-1', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, 'interArgIsa3-5', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, 'interArgIsa3-4', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, 'interArgIsa3-2', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, 'interArgIsa3-1', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, 'interArgIsa2-5', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, 'interArgIsa2-4', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, 'interArgIsa2-3', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, 'interArgIsa2-1', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, 'interArgIsa1-5', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, 'interArgIsa1-4', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, 'interArgIsa1-3', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, 'interArgIsa1-2', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, 'interArgGenl1-2', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Isa, 'interArgFormat1-2', 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Genl, relationInstanceExists, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Genl, relationInstanceAll, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Genl, relationExistsMinAll, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Genl, relationExistsMaxAll, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Genl, relationExistsCountAll, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Genl, relationExistsAll, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Genl, relationAllExistsMin, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Genl, relationAllExistsMax, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Genl, relationAllExistsCount, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Genl, relationAllExists, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Genl, nearestDifferentIsa, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Genl, nearestDifferentGenls, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Genl, nearestCommonSpecs, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Genl, nearestCommonIsa, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Genl, nearestCommonGenls, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Genl, interArgResultIsa, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Genl, interArgResultGenl, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Genl, interArgIsa, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Genl, argSometimesIsa, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Genl, argQuotedIsa, 'SubLSExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Genl, argIsa, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Genl, argAndRestQuotedIsa, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Genl, argAndRestQuotedIsa, 'SubLSExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Genl, argAndRestIsa, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Genl, argAndRestGenl, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Genl, 'RelationInstanceExistsFn', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Genl, 'RelationExistsAllFn', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Genl, 'RelationAllExistsFn', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Genl, 'interArgIsa5-4', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Genl, 'interArgIsa5-3', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Genl, 'interArgIsa5-2', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Genl, 'interArgIsa5-1', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Genl, 'interArgIsa4-5', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Genl, 'interArgIsa4-3', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Genl, 'interArgIsa4-2', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Genl, 'interArgIsa4-1', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Genl, 'interArgIsa3-5', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Genl, 'interArgIsa3-4', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Genl, 'interArgIsa3-2', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Genl, 'interArgIsa3-1', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Genl, 'interArgIsa2-5', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Genl, 'interArgIsa2-4', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Genl, 'interArgIsa2-3', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Genl, 'interArgIsa2-1', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Genl, 'interArgIsa1-5', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Genl, 'interArgIsa1-4', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Genl, 'interArgIsa1-3', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Genl, 'interArgIsa1-2', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Format, unitMultiplicationFactor, singleEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Format, transitiveViaArgInverse, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg3Format, transitiveViaArg, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg3Format, synonymousExternalConcept, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg3Format, relationInstanceExists, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Format, relationInstanceAll, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg3Format, relationExistsMinAll, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Format, relationExistsMaxAll, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Format, relationExistsInstance, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg3Format, relationExistsCountAll, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Format, relationExistsAll, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg3Format, relationAllInstance, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg3Format, relationAllExistsMin, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Format, relationAllExistsMax, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Format, relationAllExistsCount, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Format, relationAllExists, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg3Format, overlappingExternalConcept, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg3Format, nthSmallestElement, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg3Format, natArgument, singleEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg3Format, multiplicationUnits, singleEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Format, interArgResultIsaReln, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Format, interArgResultIsa, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Format, interArgResultGenlReln, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Format, interArgResultGenl, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Format, interArgIsa, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Format, interArgDifferent, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Format, integerBetween, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg3Format, different, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Format, cycTacticID, singleEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Format, cycProofID, singleEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Format, cycProblemLinkID, singleEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Format, cycProblemID, singleEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Format, argSometimesIsa, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Format, argIsa, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Format, argAndRestIsa, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Format, argAndRestGenl, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Format, admittedArgument, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg3Format, admittedAllArgument, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Format, 'interArgIsa5-4', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Format, 'interArgIsa5-3', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Format, 'interArgIsa5-2', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Format, 'interArgIsa5-1', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Format, 'interArgIsa4-5', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Format, 'interArgIsa4-3', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Format, 'interArgIsa4-2', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Format, 'interArgIsa4-1', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Format, 'interArgIsa3-5', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Format, 'interArgIsa3-4', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Format, 'interArgIsa3-2', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Format, 'interArgIsa3-1', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Format, 'interArgIsa2-5', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Format, 'interArgIsa2-4', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Format, 'interArgIsa2-3', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Format, 'interArgIsa2-1', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Format, 'interArgIsa1-5', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Format, 'interArgIsa1-4', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Format, 'interArgIsa1-3', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg3Format, 'interArgIsa1-2', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, xor, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, xor, 'CycLSentence-Assertible', 'BaseKB', vStrDef).
assertedTinyKB(arg2QuotedIsa, trueRule, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, thereExists, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, thereExistExactly, ftVar, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, thereExistAtMost, ftVar, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, thereExistAtLeast, ftVar, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, termOfUnit, 'CycLReifiableNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, termOfUnit, 'CycLReifiableNonAtomicTerm', 'LogicalTruthImplementationMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, termDependsOn, 'CycLReifiableDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, sharedNotes, 'DocumentationConstant', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, sentenceImplies, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, sentenceEquiv, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, salientAssertions, 'CycLAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, ruleAfterRemoving, 'CycLNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, ruleAfterAdding, 'CycLNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, rewriteOf, 'CycLClosedDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, relationExpansion, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, reformulatorRuleProperties, 'CycLAtomicAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, reformulatorRule, 'CycLExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, reformulatorEquiv, 'CycLSentence', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, reformulatorEquals, 'CycLDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, quotedDefnSufficient, 'CycLNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, quotedDefnNecessary, 'CycLNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, quotedDefnIff, 'CycLNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, prettyString, 'SubLString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, pragmaticRequirement, 'CycLRuleAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, pragmaticallyNormal, 'CycLAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, operatorFormulas, 'CycLFormula', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, oldConstantName, 'SubLString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, oldConstantName, 'SubLString', 'BookkeepingMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, natArgumentsEqual, 'CycLReifiableNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, meetsPragmaticRequirement, 'CycLAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, ist, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, irrelevantPredAssertion, 'CycLAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, implies, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, implies, 'CycLSentence-Assertible', 'BaseKB', vStrDef).
assertedTinyKB(arg2QuotedIsa, holdsIn, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, highlyRelevantPredAssertion, 'CycLAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, genlRules, 'CycLRuleAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, genKeyword, 'SubLKeyword', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, genFormat, 'SubLString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, forAll, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, expansionDefn, 'CycLNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, expansion, 'CycLExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, expansion, 'CycLExpression', 'UniversalVocabularyImplementationMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, exceptWhen, 'CycLAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, exceptFor, 'CycLAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, exampleAssertions, 'CycLAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, evaluationDefn, 'CycLNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, equiv, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, equiv, 'CycLSentence-Assertible', 'BaseKB', vStrDef).
assertedTinyKB(arg2QuotedIsa, defnSufficient, 'CycLNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, defnNecessary, 'CycLNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, defnIff, 'CycLNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, cycTransformationProofRule, 'CycLRuleAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, cycProblemStoreTerms, 'CycLClosedDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, cycProblemQueryTerms, 'CycLClosedDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, cycProblemQuerySentence, 'CycLSentence-Askable', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, constantName, 'SubLString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, comment, 'SubLString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, collectionExpansion, 'CycLExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, collectionExpansion, 'CycLExpression', 'UniversalVocabularyImplementationMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, assertedTermSentences, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, arity, 'SubLNonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, argSometimesIsa, 'SubLPositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, argIsa, 'SubLPositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, argAndRestIsa, 'SubLPositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, afterRemoving, 'CycLNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, afterAdding, 'CycLNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, abnormal, 'CycLAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, 'TLVariableFn', 'SubLString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, 'TLAssertionFn', 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, 'TheSetOf', 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, 'TheCollectionOf', 'CycLSentence-Askable', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, 'SkolemFunctionFn', ftVar, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, 'SkolemFuncNFn', ftVar, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, 'prettyString-Canonical', 'SubLString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, 'Kappa', 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, 'ist-Asserted', 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, 'FormulaArgFn', 'CycLFormula', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2QuotedIsa, 'ExpandSubLFn', 'SubLSExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, unitMultiplicationFactor, 'UnitOfMeasure', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, transitiveViaArgInverse, 'TransitiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, transitiveViaArg, 'TransitiveBinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, termOfUnit, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, termExternalIDString, 'HLExternalIDString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, termDependsOn, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, synonymousExternalConcept, 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, substring, 'CharacterString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, subsetOf, 'SetOrCollection', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, singleEntryFormatInArgs, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, siblingDisjointExceptions, 'SetOrCollection', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, siblingDisjointExceptions, 'SetOrCollection', 'BaseKB', vStrDef).
assertedTinyKB(arg2Isa, sharedNotes, 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, sentenceTruth, 'TruthValue', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, sentenceEquiv, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, sentenceEquiv, 'Thing', 'BaseKB', vStrDef).
assertedTinyKB(arg2Isa, sentenceEquiv, 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, sentenceEquiv, 'Individual', 'BaseKB', vStrDef).
assertedTinyKB(arg2Isa, sentenceDesignationArgnum, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, scopingArg, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, ruleTemplateDirection, 'CycLAssertionDirection', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, ruleAfterRemoving, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, ruleAfterAdding, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, rewriteOf, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, resultQuotedIsa, 'SubLExpressionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, resultIsaArgIsa, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, resultIsaArg, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, resultIsa, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, resultIsa, tCol, 'BaseKB', vStrDef).
assertedTinyKB(arg2Isa, resultGenlArg, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, resultGenl, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, resultGenl, tCol, 'BaseKB', vStrDef).
assertedTinyKB(arg2Isa, requiredArg3Pred, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, requiredArg2Pred, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, requiredArg1Pred, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, relationMemberInstance, 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, relationInstanceMember, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, relationInstanceExists, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, relationInstanceAll, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, relationExistsMinAll, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, relationExistsMaxAll, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, relationExistsInstance, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, relationExistsCountAll, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, relationExistsAll, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, relationAllInstance, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, relationAllExistsMin, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, relationAllExistsMax, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, relationAllExistsCount, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, relationAllExists, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, relationAll, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, reformulatorRule, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, reformulatorEquals, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, reformulationPrecondition, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, reformulationPrecondition, 'Thing', 'UniversalVocabularyImplementationMt', vStrDef).
assertedTinyKB(arg2Isa, reformulationDirectionInMode, 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, ratioOfTo, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, quotedIsa, 'SubLExpressionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, quotedDefnSufficient, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, quotedDefnNecessary, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, quotedDefnIff, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, quotedArgument, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, quantitySubsumes, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, quantityIntersects, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, prettyString, 'CharacterString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, preservesGenlsInArg, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, predicateConventionMt, 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, pointQuantValue, 'ScalarPointValue', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, overlappingExternalConcept, 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, operatorFormulas, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, openEntryFormatInArgs, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, opaqueArgument, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, omitArgIsa, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, oldConstantName, 'CharacterString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, oldConstantName, 'CharacterString', 'BookkeepingMt', vStrDef).
assertedTinyKB(arg2Isa, numericallyEquals, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, numericallyEquals, 'ScalarInterval', 'BaseKB', vStrDef).
assertedTinyKB(arg2Isa, nthSmallestElement, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, nthLargestElement, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, nonAbducibleWithValueInArg, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, negationPreds, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, negationMt, 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, negationInverse, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, nearestIsa, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, nearestGenls, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, nearestGenlPreds, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, nearestGenlMt, 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, nearestDifferentIsa, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, nearestDifferentGenls, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, nearestCommonSpecs, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, nearestCommonIsa, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, nearestCommonGenls, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, nearestCommonGenlMt, 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, natFunction, 'ReifiableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, natArgumentsEqual, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, natArgument, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, myCreator, 'Cyclist', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, myCreator, 'Cyclist', 'BookkeepingMt', vStrDef).
assertedTinyKB(arg2Isa, myCreationTime, 'Integer', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, myCreationSecond, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, myCreationPurpose, 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, multiplicationUnits, 'UnitOfMeasure', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, minQuantValue, 'ScalarPointValue', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, microtheoryDesignationArgnum, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, means, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, maxQuantValue, 'ScalarPointValue', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, isa, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, isa, tCol, 'BaseKB', vStrDef).
assertedTinyKB(arg2Isa, interArgResultIsaReln, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, interArgResultIsa, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, interArgResultGenlReln, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, interArgResultGenl, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, interArgIsa, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, interArgDifferent, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, integerBetween, 'Integer', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, instanceElementType, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, indexicalReferent, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, independentArg, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, hlPrototypicalInstance, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, greaterThanOrEqualTo, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, greaterThanOrEqualTo, 'ScalarInterval', 'BaseKB', vStrDef).
assertedTinyKB(arg2Isa, greaterThan, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, greaterThan, 'ScalarInterval', 'BaseKB', vStrDef).
assertedTinyKB(arg2Isa, genls, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, genls, tCol, 'BaseKB', vStrDef).
assertedTinyKB(arg2Isa, genlPreds, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, genlPreds, tPred, 'BaseKB', vStrDef).
assertedTinyKB(arg2Isa, genlMt, 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, genlMt, 'Microtheory', 'BaseKB', vStrDef).
assertedTinyKB(arg2Isa, genlInverse, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, genlCanonicalizerDirectives, 'CanonicalizerDirective', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, genlCanonicalizerDirectives, 'CanonicalizerDirective', 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(arg2Isa, genFormat, 'CharacterString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, formulaArity, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, followingValue, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, fanOutArg, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, extentCardinality, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, extConceptOverlapsColAndReln, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, expresses, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, expansionDefn, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, expansion, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, expansion, 'Thing', 'UniversalVocabularyImplementationMt', vStrDef).
assertedTinyKB(arg2Isa, evaluationResultQuotedIsa, 'SubLExpressionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, evaluationDefn, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, evaluate, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, equalSymbols, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, equals, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, elInverse, 'ELRelation-OneWay', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, elInverse, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, elementOf, 'SetOrCollection', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, distributesOutOfArg, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, disjointWith, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, denotes, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, defnSufficient, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, defnNecessary, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, defnIff, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, definingMt, 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, defaultReformulationDirectionInModeForPred, 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, cycTransformationProofBindings, 'List', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, cycTacticID, 'CycProblem', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, cycProofID, 'CycProblemStore', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, cycProblemStoreTerms, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, cycProblemStoreProofs, 'CycProof', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, cycProblemStoreProofCount, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, cycProblemStoreProblems, 'CycProblem', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, cycProblemStoreProblemCount, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, cycProblemStoreLinks, 'CycProblemLink', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, cycProblemStoreLinkCount, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, cycProblemStoreInferences, 'CycInference', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, cycProblemStoreInferenceCount, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, cycProblemStoreID, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, cycProblemQueryTerms, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, cycProblemProvabilityStatus, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, cycProblemLinkID, 'CycProblemStore', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, cycProblemID, 'CycProblemStore', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, cycProblemDependentLinks, 'CycProblemLink', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, cycProblemArgumentLinks, 'CycProblemLink', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, cycInferenceRelevantProblems, 'CycProblem', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, cycInferenceAnswerLink, 'CycProblemLink-AnswerLink', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, constrainsArg, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, constantName, 'CharacterString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, constantID, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, constantGUID, 'SubLString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, conceptuallyRelated, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, completeExtentEnumerableForValueInArg, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, completeExtentEnumerableForArg, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, completeExtentEnumerableForArg, 'NonNegativeInteger', 'CoreCycLMt', vStrDef).
assertedTinyKB(arg2Isa, completeExtentDecidableForValueInArg, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, completeExtentDecidableForValueInArg, 'Thing', 'CoreCycLMt', vStrDef).
assertedTinyKB(arg2Isa, completeExtentAssertedForValueInArg, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, completeExtentAssertedForValueInArg, 'Thing', 'CoreCycLMt', vStrDef).
assertedTinyKB(arg2Isa, commutativeInArgsAndRest, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, commutativeInArgs, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, comment, 'CharacterString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, collectionExpansion, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, collectionExpansion, 'Thing', 'UniversalVocabularyImplementationMt', vStrDef).
assertedTinyKB(arg2Isa, collectionConventionMt, 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, coExtensional, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, canonicalizerDirectiveForArgAndRest, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, canonicalizerDirectiveForArgAndRest, 'PositiveInteger', 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(arg2Isa, canonicalizerDirectiveForArg, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, canonicalizerDirectiveForArg, 'PositiveInteger', 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(arg2Isa, canonicalizerDirectiveForAllArgs, 'CanonicalizerDirective', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, canonicalizerDirectiveForAllArgs, 'CanonicalizerDirective', 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(arg2Isa, backchainForbiddenWhenUnboundInArg, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, assertionUtility, 'RealNumber', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, assertionDirection, 'CycLAssertionDirection', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, assertedPredicateArg, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, arityMin, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, arityMax, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, arity, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, arity, 'Integer', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, argsQuotedIsa, 'SubLExpressionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, argSometimesIsa, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, argSometimesIsa, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, argsIsa, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, argsGenl, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, argQuotedIsa, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, argIsa, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, argIsa, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, argAndRestQuotedIsa, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, argAndRestIsa, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, argAndRestIsa, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, argAndRestGenl, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, arg6SometimesIsa, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, arg6QuotedIsa, 'SubLExpressionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, arg6Isa, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, arg6Genl, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, arg6Format, 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, arg5SometimesIsa, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, arg5QuotedIsa, 'SubLExpressionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, arg5Isa, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, arg5Genl, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, arg5Format, 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, arg4SometimesIsa, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, arg4QuotedIsa, 'SubLExpressionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, arg4Isa, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, arg4Genl, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, arg4Format, 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, arg3SometimesIsa, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, arg3QuotedIsa, 'SubLExpressionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, arg3Isa, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, arg3Genl, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, arg3Format, 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, arg2SometimesIsa, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, arg2QuotedIsa, 'SubLExpressionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, arg2Isa, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, arg2Genl, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, arg2Format, 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, arg1SometimesIsa, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, arg1QuotedIsa, 'SubLExpressionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, arg1Isa, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, arg1Genl, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, arg1Format, 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, afterRemoving, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, afterAdding, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, admittedArgument, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, admittedAllArgument, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'UnitProductFn', 'UnitOfMeasure', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'TLVariableFn', 'CharacterString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'substring-CaseInsensitive', 'CharacterString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'RelationInstanceExistsFn', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'RelationExistsInstanceFn', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'RelationExistsAllFn', 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'RelationAllExistsFn', 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'QuotientFn', 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'QuantityConversionFn', 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'prettyString-Canonical', 'CharacterString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'PlusAll', 'UnaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'PlusAll', 'UnaryFunction', 'BaseKB', vStrDef).
assertedTinyKB(arg2Isa, 'PlusAll', 'EvaluatableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'PerFn', 'UnitOfMeasure', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'MtTimeWithGranularityDimFn', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'ModuloFn', 'ScalarPointValue', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'Minimum', 'UnaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'Minimum', 'UnaryFunction', 'BaseKB', vStrDef).
assertedTinyKB(arg2Isa, 'MeaningInSystemFn', 'CharacterString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'Maximum', 'UnaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'Maximum', 'UnaryFunction', 'BaseKB', vStrDef).
assertedTinyKB(arg2Isa, 'larkc-hasUri', 'CharacterString', 'BaseKB', vStrDef).
assertedTinyKB(arg2Isa, 'larkc-hasScalability', 'CharacterString', 'BaseKB', vStrDef).
assertedTinyKB(arg2Isa, 'larkc-hasEndpoint', 'CharacterString', 'BaseKB', vStrDef).
assertedTinyKB(arg2Isa, 'larkc-hasCostPerInvocation', 'larkc-euro', 'BaseKB', vStrDef).
assertedTinyKB(arg2Isa, 'interArgIsa5-4', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'interArgIsa5-3', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'interArgIsa5-2', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'interArgIsa5-1', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'interArgIsa4-5', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'interArgIsa4-3', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'interArgIsa4-2', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'interArgIsa4-1', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'interArgIsa3-5', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'interArgIsa3-4', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'interArgIsa3-2', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'interArgIsa3-1', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'interArgIsa2-5', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'interArgIsa2-4', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'interArgIsa2-3', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'interArgIsa2-1', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'interArgIsa1-5', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'interArgIsa1-4', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'interArgIsa1-3', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'interArgIsa1-2', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'interArgGenl1-2', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'interArgFormat1-2', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'genls-SpecDenotesGenlInstances', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'genls-GenlDenotesSpecInstances', 'SubLExpressionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'FunctionToArg', tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'FormulaArgFn', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'FOL-PredicateFn', 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'FOL-FunctionFn', 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'equalStrings-CaseInsensitive', 'CharacterString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'DifferenceFn', 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'DateEncodeStringFn', 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'DateDecodeStringFn', 'CharacterString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'CycTacticFn', 'CycTactic', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'CycProofFn', 'CycProblemStore', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'CycProblemLinkFn', 'CycProblemStore', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'CycProblemFn', 'CycProblemStore', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'CycInferenceFn', 'CycProblemStore', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'Average', 'UnaryFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Isa, 'Average', 'UnaryFunction', 'BaseKB', vStrDef).
assertedTinyKB(arg2Isa, 'assertionUtility-1', 'RealNumber', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, siblingDisjointExceptions, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, resultQuotedIsa, 'SubLSExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, resultIsa, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, resultGenl, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, relationExistsMinAll, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, relationExistsMaxAll, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, relationExistsInstance, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, relationExistsCountAll, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, relationExistsAll, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, relationAllInstance, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, relationAllExistsMin, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, relationAllExistsMax, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, relationAllExistsCount, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, relationAllExists, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, relationAll, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, quotedIsa, 'SubLSExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, nearestIsa, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, nearestGenls, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, nearestDifferentGenls, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, nearestCommonSpecs, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, nearestCommonGenls, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, isa, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, instanceElementType, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, genls, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, evaluationResultQuotedIsa, 'SubLSExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, disjointWith, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, cycProblemProvabilityStatus, 'CycProvabilityStatus', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, coExtensional, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, argsQuotedIsa, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, argsQuotedIsa, 'SubLSExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, argsIsa, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, argsGenl, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, arg6SometimesIsa, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, arg6QuotedIsa, 'SubLSExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, arg6Isa, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, arg6Genl, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, arg5SometimesIsa, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, arg5QuotedIsa, 'SubLSExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, arg5Isa, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, arg5Genl, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, arg4SometimesIsa, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, arg4QuotedIsa, 'SubLSExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, arg4Isa, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, arg4Genl, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, arg3SometimesIsa, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, arg3QuotedIsa, 'SubLSExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, arg3Isa, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, arg3Genl, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, arg2SometimesIsa, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, arg2QuotedIsa, 'SubLSExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, arg2Isa, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, arg2Genl, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, arg1SometimesIsa, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, arg1QuotedIsa, 'SubLSExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, arg1Isa, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, arg1Genl, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, 'RelationExistsInstanceFn', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, 'larkc-pluginByDataConnectsTo', 'larkc-Plugin', 'BaseKB', vStrDef).
assertedTinyKB(arg2Genl, 'larkc-hasOutputType', 'larkc-Resource', 'BaseKB', vStrDef).
assertedTinyKB(arg2Genl, 'larkc-hasInputType', 'larkc-Resource', 'BaseKB', vStrDef).
assertedTinyKB(arg2Genl, 'interArgIsa5-4', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, 'interArgIsa5-3', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, 'interArgIsa5-2', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, 'interArgIsa5-1', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, 'interArgIsa4-5', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, 'interArgIsa4-3', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, 'interArgIsa4-2', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, 'interArgIsa4-1', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, 'interArgIsa3-5', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, 'interArgIsa3-4', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, 'interArgIsa3-2', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, 'interArgIsa3-1', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, 'interArgIsa2-5', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, 'interArgIsa2-4', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, 'interArgIsa2-3', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, 'interArgIsa2-1', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, 'interArgIsa1-5', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, 'interArgIsa1-4', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, 'interArgIsa1-3', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, 'interArgIsa1-2', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, 'interArgFormat1-2', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Genl, 'genls-GenlDenotesSpecInstances', 'SubLSExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, unitMultiplicationFactor, singleEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, transitiveViaArgInverse, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg2Format, transitiveViaArg, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg2Format, termOfUnit, 'SingleEntry', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, termExternalIDString, 'SingleEntry', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, synonymousExternalConcept, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg2Format, subsetOf, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, sharedNotes, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, sentenceTruth, singleEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, salientAssertions, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, ruleAfterRemoving, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, ruleAfterAdding, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, rewriteOf, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, resultQuotedIsa, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, resultIsaArgIsa, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg2Format, resultIsaArg, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, requiredArg2Pred, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, requiredArg1Pred, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, relationInstanceExists, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, relationInstanceAll, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg2Format, relationExpansion, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, relationExistsMinAll, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, relationExistsMaxAll, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, relationExistsInstance, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg2Format, relationExistsCountAll, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, relationExistsAll, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg2Format, relationAllInstance, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg2Format, relationAllExistsMin, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, relationAllExistsMax, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, relationAllExistsCount, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, relationAllExists, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg2Format, relationAll, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg2Format, prettyString, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, preservesGenlsInArg, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg2Format, predicateConventionMt, singleEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg2Format, pointQuantValue, singleEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, overlappingExternalConcept, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg2Format, operatorFormulas, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, opaqueArgument, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg2Format, numericallyEquals, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, nthSmallestElement, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg2Format, negationPreds, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, negationInverse, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, natFunction, singleEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg2Format, natArgument, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg2Format, myCreator, 'SingleEntry', 'BookkeepingMt', vStrMon).
assertedTinyKB(arg2Format, myCreationTime, 'SingleEntry', 'BookkeepingMt', vStrMon).
assertedTinyKB(arg2Format, myCreationSecond, 'SingleEntry', 'BookkeepingMt', vStrMon).
assertedTinyKB(arg2Format, myCreationPurpose, singleEntryFormatInArgs, 'BookkeepingMt', vStrDef).
assertedTinyKB(arg2Format, multiplicationUnits, singleEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, minQuantValue, singleEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, means, singleEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, maxQuantValue, singleEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, isa, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, interArgResultIsaReln, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, interArgResultIsa, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, interArgResultGenlReln, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, interArgResultGenl, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, interArgIsa, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, interArgDifferent, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, integerBetween, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg2Format, independentArg, 'SingleEntry', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, greaterThanOrEqualTo, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, greaterThan, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, genls, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, genlMt, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, genKeyword, 'SingleEntry', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, formulaArity, singleEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, followingValue, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, fanOutArg, singleEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg2Format, extentCardinality, 'SingleEntry', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, expresses, singleEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, expansionDefn, 'SingleEntry', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, expansion, singleEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, exampleAssertions, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, evaluationDefn, singleEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, elInverse, 'SingleEntry', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, elementOf, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, disjointWith, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, different, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, denotes, 'SingleEntry', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, defnSufficient, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, defnIff, 'SingleEntry', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, definingMt, 'SingleEntry', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, cycTransformationProofBindings, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, cycProblemStoreTerms, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, cycProblemStoreProofs, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, cycProblemStoreProofCount, singleEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, cycProblemStoreProblems, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, cycProblemStoreProblemCount, singleEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, cycProblemStoreLinks, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, cycProblemStoreLinkCount, singleEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, cycProblemStoreInferences, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, cycProblemStoreInferenceCount, singleEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, cycProblemStoreID, singleEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, cycProblemQueryTerms, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, cycProblemQuerySentence, singleEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, cycProblemProvabilityStatus, singleEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, cycProblemDependentLinks, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, cycProblemArgumentLinks, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, cycInferenceRelevantProblems, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, cycInferenceAnswerLink, singleEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, constrainsArg, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, constantName, singleEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, constantName, 'SingleEntry', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, constantID, 'SingleEntry', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, constantGUID, 'SingleEntry', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg2Format, conceptuallyRelated, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, commutativeInArgsAndRest, singleEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, comment, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, collectionConventionMt, singleEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg2Format, assertionDirection, 'SingleEntry', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, arityMin, 'SingleEntry', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, arityMax, 'SingleEntry', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, arity, 'SingleEntry', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, argSometimesIsa, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, argsIsa, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, argsGenl, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, argIsa, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, argAndRestIsa, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, argAndRestGenl, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, arg6SometimesIsa, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, arg6Isa, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, arg6Genl, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, arg5SometimesIsa, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, arg5Isa, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, arg5Genl, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, arg4SometimesIsa, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, arg4Isa, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, arg4Genl, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, arg3SometimesIsa, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, arg3Isa, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, arg3Genl, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, arg2SometimesIsa, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, arg2Isa, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, arg2Genl, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, arg1SometimesIsa, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, arg1Isa, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, arg1Genl, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, afterAdding, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, admittedArgument, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg2Format, admittedAllArgument, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, 'prettyString-Canonical', 'SingleEntry', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, 'interArgIsa5-4', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, 'interArgIsa5-3', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, 'interArgIsa5-2', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, 'interArgIsa5-1', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, 'interArgIsa4-5', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, 'interArgIsa4-3', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, 'interArgIsa4-2', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, 'interArgIsa4-1', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, 'interArgIsa3-5', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, 'interArgIsa3-4', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, 'interArgIsa3-2', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, 'interArgIsa3-1', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, 'interArgIsa2-5', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, 'interArgIsa2-4', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, 'interArgIsa2-3', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, 'interArgIsa2-1', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, 'interArgIsa1-5', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, 'interArgIsa1-4', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, 'interArgIsa1-3', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, 'interArgIsa1-2', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg2Format, 'interArgFormat1-2', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, xor, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, xor, 'CycLSentence-Assertible', 'BaseKB', vStrDef).
assertedTinyKB(arg1QuotedIsa, unknownSentence, 'CycLSentence', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, trueSubL, 'CycLNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, trueSentence, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, thereExists, ftVar, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, termOfUnit, 'CycLReifiableNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, termExternalIDString, 'CycLExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, termDependsOn, 'CycLReifiableDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, sharedNotes, 'CycLIndexedTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, sentenceImplies, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, sentenceEquiv, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, salientAssertions, 'CycLReifiableDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, rewriteOf, 'CycLReifiableDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, reformulatorRule, 'CycLExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, reformulatorEquiv, 'CycLSentence', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, reformulatorEquals, 'CycLDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, querySentence, 'CycLSentence', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, pragmaticRequirement, 'CycLSentence-Askable', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, pointQuantValue, 'CycLReifiableDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, performSubL, 'CycLNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, or, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, operatorFormulas, 'CycLClosedDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, oldConstantName, 'CycLConstant', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, oldConstantName, 'CycLConstant', 'BookkeepingMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, not, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, not, 'CycLSentence-Assertible', 'BaseKB', vStrDef).
assertedTinyKB(arg1QuotedIsa, natFunction, 'CycLReifiableNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, natArgumentsEqual, 'CycLReifiableNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, natArgument, 'CycLReifiableNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, myCreator, 'CycLReifiableDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, myCreator, 'CycLReifiableDenotationalTerm', 'BookkeepingMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, myCreationTime, 'CycLConstant', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, myCreationTime, 'CycLConstant', 'BookkeepingMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, myCreationSecond, 'CycLConstant', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, myCreationSecond, 'CycLConstant', 'BookkeepingMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, myCreationPurpose, 'CycLReifiableDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, myCreationPurpose, 'CycLReifiableDenotationalTerm', 'BookkeepingMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, minimize, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, knownSentence, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, knownAntecedentRule, 'CycLRuleAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, irrelevantTerm, 'CycLReifiableDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, irrelevantAssertion, 'CycLAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, indexicalReferent, 'IndeterminateTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, implies, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, implies, 'CycLSentence-Assertible', 'BaseKB', vStrDef).
assertedTinyKB(arg1QuotedIsa, hypotheticalTerm, 'CycLReifiableDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, hlPrototypicalInstance, 'HLPrototypicalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, hlPrototypicalInstance, 'CycLIndexedTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, highlyRelevantTerm, 'CycLReifiableDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, highlyRelevantAssertion, 'CycLAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, genMassNoun, 'CycLReifiableDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, genlRules, 'CycLRuleAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, genKeyword, 'CycLReifiableDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, forwardNonTriggerLiteral, 'CycLOpenSentence', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, formulaArity, 'CycLFormula', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, forAll, ftVar, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, exceptWhen, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, exceptFor, 'CycLReifiableDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, except, 'CycLAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, exampleAssertions, 'CycLReifiableDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, exactlyAssertedSentence, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, equiv, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, equiv, 'CycLSentence-Assertible', 'BaseKB', vStrDef).
assertedTinyKB(arg1QuotedIsa, ephemeralTerm, 'CycLReifiableDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, definingMt, 'CycLReifiableDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, constraint, 'CycLAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, constantName, 'CycLConstant', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, constantID, 'CycLConstant', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, constantGUID, 'CycLConstant', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, consistent, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, comment, 'CycLIndexedTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, assertionUtility, 'CycLAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, assertionDirection, 'CycLAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, assertedTermSentences, 'CycLTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, assertedSentence, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, and, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, admittedSentence, 'CycLSentence-Assertible', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, admittedNAT, 'CycLNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, 'UncanonicalizerAssertionFn', 'CycLNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, 'TheSetOf', ftVar, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, 'TheCollectionOf', ftVar, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, 'SubLQuoteFn', 'SubLSExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, 'SkolemFunctionFn', 'SubLList', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, 'SkolemFuncNFn', 'SubLList', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, 'Quote', 'CycLTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, 'QuasiQuote', 'CycLTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, 'Kappa', 'SubLList', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, 'FormulaArityFn', 'CycLFormula', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, 'FormulaArgSetFn', 'CycLFormula', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, 'FormulaArgListFn', 'CycLFormula', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, 'ExpandSubLFn', 'SubLList', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, 'EvaluateSubLFn', 'CycLNonAtomicTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, 'EscapeQuote', 'CycLTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1QuotedIsa, 'assertionUtility-1', 'CycLAssertion', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, unitMultiplicationFactor, 'UnitOfMeasure', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, trueSubL, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, trueRule, 'RuleTemplate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, transitiveViaArgInverse, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, transitiveViaArg, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, thereExistExactly, 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, thereExistAtMost, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, thereExistAtLeast, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, termOfUnit, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, termExternalIDString, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, termDependsOn, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, termChosen, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, synonymousExternalConcept, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, substring, 'CharacterString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, subsetOf, 'SetOrCollection', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, skolemizeForward, 'ReifiableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, skolem, 'SkolemFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, singleEntryFormatInArgs, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, siblingDisjointExceptions, 'SetOrCollection', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, siblingDisjointExceptions, 'SetOrCollection', 'BaseKB', vStrDef).
assertedTinyKB(arg1Isa, sharedNotes, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, sentenceEquiv, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, sentenceEquiv, 'Thing', 'BaseKB', vStrDef).
assertedTinyKB(arg1Isa, sentenceEquiv, 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, sentenceEquiv, 'Individual', 'BaseKB', vStrDef).
assertedTinyKB(arg1Isa, sentenceDesignationArgnum, 'MicrotheoryDesignatingRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, scopingArg, 'ScopingRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, salientAssertions, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, ruleTemplateDirection, 'RuleTemplate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, ruleAfterRemoving, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, ruleAfterRemoving, tPred, 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(arg1Isa, ruleAfterAdding, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, ruleAfterAdding, tPred, 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(arg1Isa, rewriteOf, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, resultQuotedIsa, tFunction, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, resultIsaArgIsa, tFunction, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, resultIsaArg, tFunction, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, resultIsa, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, resultIsa, tRelation, 'BaseKB', vStrDef).
assertedTinyKB(arg1Isa, resultIsa, tFunction, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, resultGenlArg, 'CollectionDenotingFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, resultGenl, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, resultGenl, tRelation, 'BaseKB', vStrDef).
assertedTinyKB(arg1Isa, resultGenl, 'CollectionDenotingFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, requiredArg3Pred, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, requiredArg2Pred, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, requiredArg1Pred, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, relationMemberInstance, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, relationInstanceMember, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, relationInstanceExists, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, relationInstanceAll, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, relationExpansion, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, relationExistsMinAll, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, relationExistsMaxAll, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, relationExistsInstance, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, relationExistsCountAll, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, relationExistsAll, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, relationAllInstance, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, relationAllExistsMin, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, relationAllExistsMax, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, relationAllExistsCount, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, relationAllExists, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, relationAll, 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, reformulatorRuleProperties, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, reformulatorRule, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, reformulatorEquals, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, reformulationPrecondition, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, reformulationDirectionInMode, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, ratioOfTo, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, quotedIsa, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, quotedDefnSufficient, 'SubLExpressionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, quotedDefnNecessary, 'SubLExpressionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, quotedDefnIff, 'SubLExpressionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, quotedArgument, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, quantitySubsumes, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, quantityIntersects, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, prettyString, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, preservesGenlsInArg, 'CollectionDenotingFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, predicateConventionMt, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, pragmaticallyNormal, 'List', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, pointQuantValue, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, pointQuantValue, 'ScalarPointValue', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, performSubL, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, operatorFormulas, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, operatorFormulas, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, openEntryFormatInArgs, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, opaqueArgument, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, omitArgIsa, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, oldConstantName, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, oldConstantName, 'Thing', 'BookkeepingMt', vStrDef).
assertedTinyKB(arg1Isa, numericallyEquals, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, numericallyEquals, 'ScalarInterval', 'BaseKB', vStrDef).
assertedTinyKB(arg1Isa, nthSmallestElement, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, nthLargestElement, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, notAssertibleMt, 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, notAssertibleCollection, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, notAssertible, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, nonAbducibleWithValueInArg, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, negationPreds, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, negationMt, 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, negationInverse, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, nearestIsa, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, nearestGenls, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, nearestGenlPreds, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, nearestGenlMt, 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, nearestDifferentIsa, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, nearestDifferentGenls, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, nearestCommonSpecs, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, nearestCommonIsa, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, nearestCommonGenls, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, nearestCommonGenlMt, 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, natFunction, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, natArgumentsEqual, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, natArgument, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, myCreator, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, myCreator, 'Thing', 'BookkeepingMt', vStrDef).
assertedTinyKB(arg1Isa, myCreationTime, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, myCreationTime, 'Thing', 'BookkeepingMt', vStrDef).
assertedTinyKB(arg1Isa, myCreationSecond, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, myCreationSecond, 'Thing', 'BookkeepingMt', vStrDef).
assertedTinyKB(arg1Isa, myCreationPurpose, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, myCreationPurpose, 'Thing', 'BookkeepingMt', vStrDef).
assertedTinyKB(arg1Isa, multiplicationUnits, 'UnitOfMeasure', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, mtVisible, 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, minQuantValue, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, minimizeExtent, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, microtheoryDesignationArgnum, 'MicrotheoryDesignatingRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, meetsPragmaticRequirement, 'List', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, means, 'SubLSExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, maxQuantValue, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, ist, 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, isa, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, isa, 'Thing', 'BaseKB', vStrDef).
assertedTinyKB(arg1Isa, irrelevantTerm, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, irrelevantPredAssertion, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, irrelevantMt, 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, interArgResultIsaReln, tFunction, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, interArgResultIsa, tFunction, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, interArgResultGenlReln, tFunction, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, interArgResultGenl, tFunction, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, interArgIsa, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, interArgDifferent, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, integerBetween, 'Integer', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, instanceElementType, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, indexicalReferent, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, independentArg, 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, independentArg, 'ArgConstraintPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, hypotheticalTerm, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, holdsIn, 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, hlPrototypicalInstance, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, highlyRelevantTerm, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, highlyRelevantPredAssertion, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, highlyRelevantMt, 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, greaterThanOrEqualTo, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, greaterThanOrEqualTo, 'ScalarInterval', 'BaseKB', vStrDef).
assertedTinyKB(arg1Isa, greaterThan, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, greaterThan, 'ScalarInterval', 'BaseKB', vStrDef).
assertedTinyKB(arg1Isa, genMassNoun, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, genls, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, genls, tCol, 'BaseKB', vStrDef).
assertedTinyKB(arg1Isa, genlPreds, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, genlPreds, tPred, 'BaseKB', vStrDef).
assertedTinyKB(arg1Isa, genlMt, 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, genlMt, 'Microtheory', 'BaseKB', vStrDef).
assertedTinyKB(arg1Isa, genlInverse, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, genlCanonicalizerDirectives, 'CanonicalizerDirective', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, genlCanonicalizerDirectives, 'CanonicalizerDirective', 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(arg1Isa, genKeyword, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, genFormat, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, formulaArity, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, followingValue, 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, fanOutArg, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, extentCardinality, 'SetOrCollection', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, extConceptOverlapsColAndReln, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, expresses, 'CycLSentence', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, expansionDefn, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, expansion, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, exceptMt, 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, exceptFor, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, exampleAssertions, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, evaluationResultQuotedIsa, 'EvaluatableRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, evaluationDefn, 'EvaluatableRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, evaluateImmediately, 'EvaluatableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, evaluateAtEL, 'EvaluatableFunction', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, evaluate, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, equalSymbols, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, equals, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, ephemeralTerm, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, elInverse, 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, elementOf, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, distributesOutOfArg, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, disjointWith, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, different, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, denotes, 'CycLDenotationalTerm', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, defnSufficient, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, defnNecessary, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, defnIff, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, definingMt, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, defaultReformulatorModePrecedence, 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, defaultReformulationDirectionInModeForPred, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, decontextualizedPredicate, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, decontextualizedCollection, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, cycTransformationProofRule, 'CycTransformationProof', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, cycTransformationProofBindings, 'CycTransformationProof', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, cycTacticID, 'CycTactic', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, cycProofID, 'CycProof', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, cycProblemStoreTerms, 'CycProblem', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, cycProblemStoreProofs, 'CycProblemStore', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, cycProblemStoreProofCount, 'CycProblemStore', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, cycProblemStoreProblems, 'CycProblemStore', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, cycProblemStoreProblemCount, 'CycProblemStore', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, cycProblemStoreLinks, 'CycProblemStore', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, cycProblemStoreLinkCount, 'CycProblemStore', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, cycProblemStoreInferences, 'CycProblemStore', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, cycProblemStoreInferenceCount, 'CycProblemStore', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, cycProblemStoreID, 'CycProblemStore', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, cycProblemQueryTerms, 'CycProblem', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, cycProblemQuerySentence, 'CycProblem', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, cycProblemProvabilityStatus, 'CycProblem', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, cycProblemLinkID, 'CycProblemLink', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, cycProblemID, 'CycProblem', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, cycProblemDependentLinks, 'CycProblem', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, cycProblemArgumentLinks, 'CycProblem', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, cycInferenceRelevantProblems, 'CycInference', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, cycInferenceAnswerLink, 'CycInference', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, constrainsArg, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, constantName, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, constantID, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, constantGUID, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, conceptuallyRelated, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, completelyEnumerableCollection, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, completelyDecidableCollection, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, completelyDecidableCollection, tCol, 'CoreCycLMt', vStrDef).
assertedTinyKB(arg1Isa, completeExtentEnumerableViaBackchain, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, completeExtentEnumerableForValueInArg, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, completeExtentEnumerableForArg, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, completeExtentEnumerableForArg, tPred, 'CoreCycLMt', vStrDef).
assertedTinyKB(arg1Isa, completeExtentEnumerable, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, completeExtentDecidableForValueInArg, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, completeExtentDecidableForValueInArg, tPred, 'CoreCycLMt', vStrDef).
assertedTinyKB(arg1Isa, completeExtentDecidable, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, completeExtentDecidable, tPred, 'CoreCycLMt', vStrDef).
assertedTinyKB(arg1Isa, completeExtentAssertedForValueInArg, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, completeExtentAssertedForValueInArg, tPred, 'CoreCycLMt', vStrDef).
assertedTinyKB(arg1Isa, completeExtentAsserted, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, completeExtentAsserted, tPred, 'CoreCycLMt', vStrDef).
assertedTinyKB(arg1Isa, commutativeInArgsAndRest, 'PartiallyCommutativeRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, commutativeInArgs, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, comment, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, collectionIsaBackchainRequired, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, collectionIsaBackchainEncouraged, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, collectionGenlsBackchainRequired, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, collectionGenlsBackchainEncouraged, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, collectionExpansion, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, collectionConventionMt, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, collectionCompletelyEnumerableViaBackchain, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, collectionBackchainRequired, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, collectionBackchainEncouraged, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, coExtensional, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, canonicalizerDirectiveForArgAndRest, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, canonicalizerDirectiveForArgAndRest, tRelation, 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(arg1Isa, canonicalizerDirectiveForArg, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, canonicalizerDirectiveForArg, tRelation, 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(arg1Isa, canonicalizerDirectiveForAllArgs, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, canonicalizerDirectiveForAllArgs, tRelation, 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(arg1Isa, backchainRequired, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, backchainForbiddenWhenUnboundInArg, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, backchainForbidden, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, assertedTermSentences, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, assertedPredicateArg, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, arityMin, 'VariableArityRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, arityMax, 'VariableArityRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, arity, 'FixedArityRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, argsQuotedIsa, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, argSometimesIsa, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, argsIsa, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, argsGenl, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, argQuotedIsa, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, argIsa, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, argAndRestQuotedIsa, 'VariableArityRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, argAndRestIsa, 'VariableArityRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, argAndRestIsa, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, argAndRestGenl, 'VariableArityRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, arg6SometimesIsa, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, arg6QuotedIsa, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, arg6Isa, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, arg6Genl, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, arg6Format, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, arg5SometimesIsa, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, arg5QuotedIsa, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, arg5Isa, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, arg5Genl, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, arg5Format, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, arg4SometimesIsa, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, arg4QuotedIsa, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, arg4Isa, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, arg4Genl, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, arg4Format, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, arg3SometimesIsa, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, arg3QuotedIsa, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, arg3Isa, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, arg3Genl, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, arg3Format, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, arg2SometimesIsa, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, arg2QuotedIsa, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, arg2Isa, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, arg2Genl, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, arg2Format, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, arg1SometimesIsa, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, arg1QuotedIsa, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, arg1Isa, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, arg1Genl, tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, arg1Format, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, afterRemoving, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, afterAdding, tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, admittedNAT, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, admittedArgument, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, admittedAllArgument, tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, abnormal, 'List', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'Unity', 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'UnitProductFn', 'UnitOfMeasure', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'UncanonicalizerAssertionFn', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'TLVariableFn', 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'TLReifiedNatFn', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'TLAssertionFn', 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'TimesFn', 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'TheSet', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'TheList', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'substring-CaseInsensitive', 'CharacterString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'RoundUpFn', 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'RoundDownFn', 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'RoundClosestFn', 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'RelationInstanceExistsFn', 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'RelationExistsInstanceFn', 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'RelationExistsAllFn', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'RelationAllExistsFn', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'QuotientFn', 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'Quote', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'QuasiQuote', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'QuantityConversionFn', 'UnitOfMeasure', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'prettyString-Canonical', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'PlusFn', 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'PlusAll', 'SetOrCollection', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'PlusAll', 'SetOrCollection', 'BaseKB', vStrDef).
assertedTinyKB(arg1Isa, 'PerFn', 'UnitOfMeasure', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'Percent', 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'MtUnionFn', 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'MtTimeWithGranularityDimFn', 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'MtTimeDimFn', 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'MtSpace', 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'ModuloFn', 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'MinRangeFn', 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'Minimum', 'SetOrCollection', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'Minimum', 'SetOrCollection', 'BaseKB', vStrDef).
assertedTinyKB(arg1Isa, 'MeaningInSystemFn', 'Individual', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'MaxRangeFn', 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'Maximum', 'SetOrCollection', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'Maximum', 'SetOrCollection', 'BaseKB', vStrDef).
assertedTinyKB(arg1Isa, 'LogFn', 'RealNumber', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'LogFn', 'NonNegativeScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'larkc-hasUri', 'larkc-Plugin', 'BaseKB', vStrDef).
assertedTinyKB(arg1Isa, 'larkc-hasScalability', 'larkc-Scalability', 'BaseKB', vStrDef).
assertedTinyKB(arg1Isa, 'larkc-hasEndpoint', 'larkc-Plugin', 'BaseKB', vStrDef).
assertedTinyKB(arg1Isa, 'larkc-hasCostPerInvocation', 'larkc-Cost', 'BaseKB', vStrDef).
assertedTinyKB(arg1Isa, 'ist-Asserted', 'Microtheory', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'IntervalMinFn', 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'IntervalMaxFn', 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'interArgIsa5-4', 'QuintaryRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'interArgIsa5-3', tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'interArgIsa5-3', 'QuintaryRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'interArgIsa5-2', 'QuintaryRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'interArgIsa5-1', 'QuintaryRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'interArgIsa4-5', tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'interArgIsa4-3', tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'interArgIsa4-2', tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'interArgIsa4-1', tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'interArgIsa3-5', tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'interArgIsa3-4', tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'interArgIsa3-2', tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'interArgIsa3-1', tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'interArgIsa2-5', tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'interArgIsa2-4', tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'interArgIsa2-3', tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'interArgIsa2-1', tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'interArgIsa1-5', tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'interArgIsa1-4', tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'interArgIsa1-3', tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'interArgIsa1-2', tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'interArgGenl1-2', tRelation, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'interArgFormat1-2', tPred, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'genls-SpecDenotesGenlInstances', 'SubLExpressionType', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'genls-GenlDenotesSpecInstances', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'FunctionToArg', 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'FormulaArityFn', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'FormulaArgSetFn', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'FormulaArgListFn', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'FormulaArgFn', 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'FOL-TermFn', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'FOL-PredicateFn', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'FOL-FunctionFn', tFunction, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'ExpFn', 'ScalarPointValue', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'EvaluateSubLFn', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'EscapeQuote', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'equalStrings-CaseInsensitive', 'CharacterString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'DifferenceFn', 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'DateEncodeStringFn', 'CharacterString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'DateDecodeStringFn', 'CharacterString', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'CycTacticFn', 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'CycProofFn', 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'CycProblemStoreFn', 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'CycProblemLinkFn', 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'CycProblemFn', 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'CycInferenceFn', 'NonNegativeInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'CollectionRuleTemplateFn', tCol, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'Average', 'SetOrCollection', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Isa, 'Average', 'SetOrCollection', 'BaseKB', vStrDef).
assertedTinyKB(arg1Isa, 'AbsoluteValueFn', 'ScalarInterval', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Genl, siblingDisjointExceptions, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Genl, requiredArg3Pred, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Genl, requiredArg2Pred, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Genl, requiredArg1Pred, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Genl, quotedDefnSufficient, 'SubLSExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Genl, quotedDefnNecessary, 'SubLSExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Genl, quotedDefnIff, 'SubLSExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Genl, notAssertibleCollection, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Genl, nearestGenls, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Genl, nearestDifferentGenls, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Genl, nearestCommonSpecs, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Genl, nearestCommonGenls, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Genl, instanceElementType, 'Set-Mathematical', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Genl, genls, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Genl, extConceptOverlapsColAndReln, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Genl, disjointWith, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Genl, defnSufficient, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Genl, defnNecessary, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Genl, defnIff, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Genl, decontextualizedCollection, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Genl, completelyEnumerableCollection, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Genl, completelyDecidableCollection, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Genl, collectionIsaBackchainRequired, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Genl, collectionIsaBackchainEncouraged, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Genl, collectionGenlsBackchainRequired, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Genl, collectionGenlsBackchainEncouraged, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Genl, collectionConventionMt, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Genl, collectionCompletelyEnumerableViaBackchain, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Genl, collectionBackchainRequired, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Genl, collectionBackchainEncouraged, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Genl, coExtensional, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Genl, admittedAllArgument, 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Genl, 'larkc-pluginByDataConnectsTo', 'larkc-Plugin', 'BaseKB', vStrDef).
assertedTinyKB(arg1Genl, 'larkc-hasOutputType', 'larkc-Plugin', 'BaseKB', vStrDef).
assertedTinyKB(arg1Genl, 'larkc-hasInputType', 'larkc-Plugin', 'BaseKB', vStrDef).
assertedTinyKB(arg1Genl, 'genls-SpecDenotesGenlInstances', 'SubLSExpression', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Genl, 'CollectionRuleTemplateFn', 'Thing', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, unitMultiplicationFactor, singleEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, transitiveViaArgInverse, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg1Format, transitiveViaArg, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg1Format, termOfUnit, singleEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, termOfUnit, 'SingleEntry', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, termExternalIDString, 'SingleEntry', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, synonymousExternalConcept, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg1Format, sharedNotes, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, salientAssertions, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, rewriteOf, singleEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, resultQuotedIsa, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, resultIsaArgIsa, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg1Format, resultIsaArg, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, resultIsa, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, resultGenl, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, requiredArg2Pred, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, requiredArg1Pred, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, relationInstanceExists, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, relationInstanceAll, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg1Format, relationExistsMinAll, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, relationExistsMaxAll, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, relationExistsInstance, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg1Format, relationExistsCountAll, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, relationExistsAll, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg1Format, relationAllInstance, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg1Format, relationAllExistsMin, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, relationAllExistsMax, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, relationAllExistsCount, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, relationAllExists, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg1Format, relationAll, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg1Format, quotedIsa, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, prettyString, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, preservesGenlsInArg, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg1Format, pointQuantValue, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, overlappingExternalConcept, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg1Format, operatorFormulas, singleEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, opaqueArgument, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg1Format, numericallyEquals, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, nthSmallestElement, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg1Format, negationPreds, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, negationInverse, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, natFunction, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg1Format, natArgument, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg1Format, myCreationTime, 'SetTheFormat', 'BookkeepingMt', vStrMon).
assertedTinyKB(arg1Format, myCreationPurpose, openEntryFormatInArgs, 'BookkeepingMt', vStrDef).
assertedTinyKB(arg1Format, multiplicationUnits, singleEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, minQuantValue, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, minimizeExtent, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, means, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, maxQuantValue, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, isa, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, interArgResultIsaReln, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, interArgResultIsa, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, interArgResultGenlReln, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, interArgResultGenl, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, interArgIsa, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, interArgDifferent, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, integerBetween, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg1Format, independentArg, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, greaterThanOrEqualTo, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, greaterThan, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, genls, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, genlMt, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, genKeyword, 'SingleEntry', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, followingValue, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, fanOutArg, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg1Format, expresses, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, evaluationResultQuotedIsa, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, evaluationDefn, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, elInverse, 'SingleEntry', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, elementOf, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, disjointWith, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, different, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, denotes, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, defnSufficient, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, defaultReformulationDirectionInModeForPred, 'SingleEntry', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, cycInferenceAnswerLink, singleEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, constrainsArg, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, constantName, singleEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, constantID, 'SingleEntry', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, constantGUID, singleEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg1Format, conceptuallyRelated, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, completelyEnumerableCollection, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, completelyDecidableCollection, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, completeExtentEnumerable, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, completeExtentDecidable, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, completeExtentAsserted, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, commutativeInArgsAndRest, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, comment, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, arityMin, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, arityMax, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, arity, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, argSometimesIsa, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, argsIsa, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, argsGenl, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, argIsa, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, argAndRestIsa, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, argAndRestGenl, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, arg6SometimesIsa, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, arg6Isa, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, arg6Genl, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, arg6Format, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, arg5SometimesIsa, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, arg5Isa, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, arg5Genl, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, arg5Format, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, arg4SometimesIsa, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, arg4Isa, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, arg4Genl, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, arg4Format, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, arg3SometimesIsa, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, arg3Isa, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, arg3Genl, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, arg3Format, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, arg2SometimesIsa, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, arg2Isa, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, arg2Genl, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, arg2Format, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, arg1SometimesIsa, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, arg1Isa, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, arg1Genl, 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, arg1Format, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, admittedArgument, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrMon).
assertedTinyKB(arg1Format, admittedAllArgument, openEntryFormatInArgs, 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, 'prettyString-Canonical', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, 'interArgIsa5-4', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, 'interArgIsa5-3', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, 'interArgIsa5-2', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, 'interArgIsa5-1', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, 'interArgIsa4-5', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, 'interArgIsa4-3', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, 'interArgIsa4-2', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, 'interArgIsa4-1', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, 'interArgIsa3-5', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, 'interArgIsa3-4', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, 'interArgIsa3-2', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, 'interArgIsa3-1', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, 'interArgIsa2-5', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, 'interArgIsa2-4', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, 'interArgIsa2-3', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, 'interArgIsa2-1', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, 'interArgIsa1-5', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, 'interArgIsa1-4', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, 'interArgIsa1-3', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, 'interArgIsa1-2', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(arg1Format, 'interArgFormat1-2', 'SetTheFormat', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(afterRemoving, unitMultiplicationFactor, 'SubLQuoteFn'('CLEAR-UNIT-MULTIPLICATION-FACTOR-CACHES'), 'UniversalVocabularyImplementationMt', vStrMon).
assertedTinyKB(afterRemoving, transitiveViaArgInverse, 'SubLQuoteFn'('REMOVE-TRANSITIVE-VIA-ARG-INVERSE'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, transitiveViaArgInverse, 'SubLQuoteFn'('CLEAR-CACHED-SOME-TVA-CHECKS'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, transitiveViaArg, 'SubLQuoteFn'('REMOVE-TRANSITIVE-VIA-ARG'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, transitiveViaArg, 'SubLQuoteFn'('CLEAR-CACHED-TVA-CHECKS'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, termOfUnit, 'SubLQuoteFn'('REMOVE-TERM-OF-UNIT'), 'LogicalTruthImplementationMt', vStrMon).
assertedTinyKB(afterRemoving, termDependsOn, 'SubLQuoteFn'('REMOVE-DEPENDENT-TERM'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, substring, 'SubLQuoteFn'('REMOVE-TVA-CACHE-VALUE'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, substring, 'SubLQuoteFn'('REMOVE-TVA-CACHE-KEY'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, skolem, 'SubLQuoteFn'('SKOLEM-AFTER-REMOVING'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(afterRemoving, ruleAfterRemoving, 'SubLQuoteFn'('DECACHE-RULE-AFTER-REMOVINGS'), 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(afterRemoving, ruleAfterAdding, 'SubLQuoteFn'('DECACHE-RULE-AFTER-ADDINGS'), 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(afterRemoving, rewriteOf, 'SubLQuoteFn'('DECACHE-SOME-SOURCE-REWRITE-OF-ASSERTIONS-SOMEWHERE'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, rewriteOf, 'SubLQuoteFn'('DECACHE-SOME-EQUALITY-ASSERTIONS-SOMEWHERE'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, rewriteOf, 'SubLQuoteFn'('CYC-REMOVE-REFORMULATION-ASSERTION'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, resultQuotedIsa, 'SubLQuoteFn'('REMOVE-SUF-QUOTED-FUNCTION'), 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(afterRemoving, resultIsa, 'SubLQuoteFn'('REMOVE-SUF-FUNCTION'), 'LogicalTruthImplementationMt', vStrMon).
assertedTinyKB(afterRemoving, relationExpansion, 'SubLQuoteFn'('REMOVE-GENERATION-ASSERTION'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(afterRemoving, reformulatorRuleProperties, 'SubLQuoteFn'('CYC-REMOVE-REFORMULATION-ASSERTION'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, reformulatorRule, 'SubLQuoteFn'('CYC-REMOVE-REFORMULATION-ASSERTION'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, reformulatorEquiv, 'SubLQuoteFn'('CYC-REMOVE-REFORMULATION-ASSERTION'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, reformulatorEquals, 'SubLQuoteFn'('CYC-REMOVE-REFORMULATION-ASSERTION'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, reformulationPrecondition, 'SubLQuoteFn'('CYC-REMOVE-REFORMULATION-ASSERTION'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, reformulationDirectionInMode, 'SubLQuoteFn'('CYC-REMOVE-REFORMULATION-ASSERTION'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, quotedIsa, 'SubLQuoteFn'('QUOTED-INSTANCEOF-AFTER-REMOVING'), 'LogicalTruthImplementationMt', vStrMon).
assertedTinyKB(afterRemoving, quotedDefnSufficient, 'SubLQuoteFn'('REMOVE-SUF-QUOTED-DEFN'), 'LogicalTruthImplementationMt', vStrMon).
assertedTinyKB(afterRemoving, quotedDefnNecessary, 'SubLQuoteFn'('REMOVE-NEC-QUOTED-DEFN'), 'LogicalTruthImplementationMt', vStrMon).
assertedTinyKB(afterRemoving, quotedDefnIff, 'SubLQuoteFn'('REMOVE-IFF-QUOTED-DEFN'), 'LogicalTruthImplementationMt', vStrMon).
assertedTinyKB(afterRemoving, prettyString, 'SubLQuoteFn'('REMOVE-SEMANTIC-ASSERTION'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, prettyString, 'SubLQuoteFn'('REMOVE-PROPER-NAME-PREDICATE'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, oldConstantName, 'SubLQuoteFn'('REMOVE-OLD-CONSTANT-NAME'), 'BaseKB', vStrMon).
assertedTinyKB(afterRemoving, negationPreds, 'SubLQuoteFn'('NEGATION-PREDICATE-AFTER-REMOVING'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, negationInverse, 'SubLQuoteFn'('REMOVE-NEGATION-INVERSE'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, nearestGenls, 'SubLQuoteFn'('REMOVE-TVA-CACHE-VALUE'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, natFunction, 'SubLQuoteFn'('REMOVE-DEPENDENT-TERM'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, knownAntecedentRule, 'SubLQuoteFn'('CYC-REMOVE-KNOWN-ANTECEDENT-RULE'), 'UniversalVocabularyImplementationMt', vStrMon).
assertedTinyKB(afterRemoving, isa, 'SubLQuoteFn'('INSTANCEOF-AFTER-REMOVING'), 'LogicalTruthImplementationMt', vStrMon).
assertedTinyKB(afterRemoving, isa, 'SubLQuoteFn'('CLEAR-ISA-DEPENDENT-CACHES'), 'LogicalTruthImplementationMt', vStrMon).
assertedTinyKB(afterRemoving, interArgIsa, 'SubLQuoteFn'('INTER-ARG-ISA-AFTER-REMOVING'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, indexicalReferent, 'SubLQuoteFn'('DECACHE-SOME-EQUALITY-ASSERTIONS-SOMEWHERE'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, hlPrototypicalInstance, 'SubLQuoteFn'('HL-PROTOTYPICAL-INSTANCE-AFTER-REMOVING'), 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(afterRemoving, highlyRelevantTerm, 'SubLQuoteFn'('CYC-REMOVE-RELEVANT-TERM'), 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(afterRemoving, genls, 'SubLQuoteFn'('REMOVE-TVA-CACHE-VALUE'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, genls, 'SubLQuoteFn'('PGIA-AFTER-REMOVING-GENLS'), 'LogicalTruthImplementationMt', vStrMon).
assertedTinyKB(afterRemoving, genls, 'SubLQuoteFn'('GENLS-AFTER-REMOVING'), 'LogicalTruthImplementationMt', vStrMon).
assertedTinyKB(afterRemoving, genls, 'SubLQuoteFn'('CLEAR-GENLS-DEPENDENT-CACHES'), 'LogicalTruthImplementationMt', vStrMon).
assertedTinyKB(afterRemoving, genlPreds, 'SubLQuoteFn'('REMOVE-GENL-PREDICATE'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, genlMt, 'SubLQuoteFn'('REMOVE-BASE-MT'), 'LogicalTruthImplementationMt', vStrMon).
assertedTinyKB(afterRemoving, genlMt, 'SubLQuoteFn'('CLEAR-MT-DEPENDENT-CACHES'), 'LogicalTruthImplementationMt', vStrMon).
assertedTinyKB(afterRemoving, genlInverse, 'SubLQuoteFn'('REMOVE-GENL-INVERSE'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, genKeyword, 'SubLQuoteFn'('REMOVE-GENERATION-ASSERTION'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(afterRemoving, genFormat, 'SubLQuoteFn'('REMOVE-GENERATION-ASSERTION'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(afterRemoving, expansion, 'SubLQuoteFn'('REMOVE-GEN-TEMPLATE-EXPANSION'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, expansion, 'SubLQuoteFn'('REMOVE-FROM-CONTRACTION-HT'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, expansion, 'SubLQuoteFn'('CYC-REMOVE-REFORMULATION-ASSERTION'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, except, 'SubLQuoteFn'('CYC-EXCEPT-REMOVED'), 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(afterRemoving, evaluationResultQuotedIsa, 'SubLQuoteFn'('REMOVE-SUF-QUOTED-FUNCTION'), 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(afterRemoving, evaluationDefn, 'SubLQuoteFn'('DECACHE-LISP-DEFUN'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, equalSymbols, 'SubLQuoteFn'('DECACHE-SOME-EQUALITY-ASSERTIONS-SOMEWHERE'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, equals, 'SubLQuoteFn'('DECACHE-SOME-EQUALITY-ASSERTIONS-SOMEWHERE'), 'LogicalTruthImplementationMt', vStrMon).
assertedTinyKB(afterRemoving, equals, 'SubLQuoteFn'('DECACHE-SOME-EQUALITY-ASSERTIONS-SOMEWHERE'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, disjointWith, 'SubLQuoteFn'('MDW-AFTER-REMOVING'), 'LogicalTruthImplementationMt', vStrMon).
assertedTinyKB(afterRemoving, defnSufficient, 'SubLQuoteFn'('REMOVE-SUF-DEFN'), 'BaseKB', vStrMon).
assertedTinyKB(afterRemoving, defnNecessary, 'SubLQuoteFn'('REMOVE-NEC-DEFN'), 'LogicalTruthImplementationMt', vStrMon).
assertedTinyKB(afterRemoving, defnIff, 'SubLQuoteFn'('REMOVE-IFF-DEFN'), 'LogicalTruthImplementationMt', vStrMon).
assertedTinyKB(afterRemoving, definingMt, 'SubLQuoteFn'('REMOVE-DEPENDENT-TERM'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, defaultReformulatorModePrecedence, 'SubLQuoteFn'('CYC-REMOVE-REFORMULATION-ASSERTION'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, defaultReformulationDirectionInModeForPred, 'SubLQuoteFn'('CYC-REMOVE-REFORMULATION-ASSERTION'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, coExtensional, 'SubLQuoteFn'('REMOVE-TVA-CACHE-VALUE'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, canonicalizerDirectiveForArgAndRest, 'SubLQuoteFn'('RECACHE-SOME-CANONICALIZER-DIRECTIVE-ASSERTIONS-SOMEWHERE'), 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(afterRemoving, canonicalizerDirectiveForArg, 'SubLQuoteFn'('RECACHE-SOME-CANONICALIZER-DIRECTIVE-ASSERTIONS-SOMEWHERE'), 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(afterRemoving, canonicalizerDirectiveForAllArgs, 'SubLQuoteFn'('RECACHE-SOME-CANONICALIZER-DIRECTIVE-ASSERTIONS-SOMEWHERE'), 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(afterRemoving, arityMin, 'SubLQuoteFn'('REMOVE-MAX-ARITY'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, arityMin, 'SubLQuoteFn'('REMOVE-ARITY-MIN'), 'LogicalTruthImplementationMt', vStrMon).
assertedTinyKB(afterRemoving, arityMax, 'SubLQuoteFn'('REMOVE-MAX-ARITY'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, arityMax, 'SubLQuoteFn'('REMOVE-ARITY-MAX'), 'LogicalTruthImplementationMt', vStrMon).
assertedTinyKB(afterRemoving, arity, 'SubLQuoteFn'('REMOVE-ARITY'), 'LogicalTruthImplementationMt', vStrMon).
assertedTinyKB(afterRemoving, arg6Isa, 'SubLQuoteFn'('CYC-REMOVE-FROM-ARG-TYPE-CACHE'), 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(afterRemoving, arg5Isa, 'SubLQuoteFn'('CYC-REMOVE-FROM-ARG-TYPE-CACHE'), 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(afterRemoving, arg4Isa, 'SubLQuoteFn'('CYC-REMOVE-FROM-ARG-TYPE-CACHE'), 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(afterRemoving, arg3Isa, 'SubLQuoteFn'('CYC-REMOVE-FROM-ARG-TYPE-CACHE'), 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(afterRemoving, arg2Isa, 'SubLQuoteFn'('CYC-REMOVE-FROM-ARG-TYPE-CACHE'), 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(afterRemoving, arg1Isa, 'SubLQuoteFn'('CYC-REMOVE-FROM-ARG-TYPE-CACHE'), 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(afterRemoving, afterRemoving, 'SubLQuoteFn'('DECACHE-AFTER-REMOVINGS'), 'LogicalTruthImplementationMt', vStrMon).
assertedTinyKB(afterRemoving, afterAdding, 'SubLQuoteFn'('DECACHE-AFTER-ADDINGS'), 'LogicalTruthImplementationMt', vStrMon).
assertedTinyKB(afterRemoving, 'prettyString-Canonical', 'SubLQuoteFn'('REMOVE-SEMANTIC-ASSERTION'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, 'prettyString-Canonical', 'SubLQuoteFn'('REMOVE-PROPER-NAME-PREDICATE'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, 'interArgIsa5-4', 'SubLQuoteFn'('INTER-ARG-ISA-AFTER-REMOVING'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, 'interArgIsa5-3', 'SubLQuoteFn'('INTER-ARG-ISA-AFTER-REMOVING'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, 'interArgIsa5-2', 'SubLQuoteFn'('INTER-ARG-ISA-AFTER-REMOVING'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, 'interArgIsa5-1', 'SubLQuoteFn'('INTER-ARG-ISA-AFTER-REMOVING'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, 'interArgIsa4-5', 'SubLQuoteFn'('INTER-ARG-ISA-AFTER-REMOVING'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, 'interArgIsa4-3', 'SubLQuoteFn'('INTER-ARG-ISA-AFTER-REMOVING'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, 'interArgIsa4-2', 'SubLQuoteFn'('INTER-ARG-ISA-AFTER-REMOVING'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, 'interArgIsa4-1', 'SubLQuoteFn'('INTER-ARG-ISA-AFTER-REMOVING'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, 'interArgIsa3-5', 'SubLQuoteFn'('INTER-ARG-ISA-AFTER-REMOVING'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, 'interArgIsa3-4', 'SubLQuoteFn'('INTER-ARG-ISA-AFTER-REMOVING'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, 'interArgIsa3-2', 'SubLQuoteFn'('INTER-ARG-ISA-AFTER-REMOVING'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, 'interArgIsa3-1', 'SubLQuoteFn'('INTER-ARG-ISA-AFTER-REMOVING'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, 'interArgIsa2-5', 'SubLQuoteFn'('INTER-ARG-ISA-AFTER-REMOVING'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, 'interArgIsa2-4', 'SubLQuoteFn'('INTER-ARG-ISA-AFTER-REMOVING'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, 'interArgIsa2-3', 'SubLQuoteFn'('INTER-ARG-ISA-AFTER-REMOVING'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, 'interArgIsa2-1', 'SubLQuoteFn'('INTER-ARG-ISA-AFTER-REMOVING'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, 'interArgIsa1-5', 'SubLQuoteFn'('INTER-ARG-ISA-AFTER-REMOVING'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, 'interArgIsa1-4', 'SubLQuoteFn'('INTER-ARG-ISA-AFTER-REMOVING'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, 'interArgIsa1-3', 'SubLQuoteFn'('INTER-ARG-ISA-AFTER-REMOVING'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, 'interArgIsa1-2', 'SubLQuoteFn'('INTER-ARG-ISA-AFTER-REMOVING'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, 'interArgFormat1-2', 'SubLQuoteFn'('INTER-ARG-FORMAT-AFTER-REMOVING'), 'BaseKB', vStrDef).
assertedTinyKB(afterRemoving, 'equalStrings-CaseInsensitive', 'SubLQuoteFn'('DECACHE-SOME-EQUALITY-ASSERTIONS-SOMEWHERE'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, unitMultiplicationFactor, 'SubLQuoteFn'('CLEAR-UNIT-MULTIPLICATION-FACTOR-CACHES'), 'UniversalVocabularyImplementationMt', vStrMon).
assertedTinyKB(afterAdding, trueRule, 'SubLQuoteFn'('ADD-TRUE-RULE'), 'BaseKB', vStrMon).
assertedTinyKB(afterAdding, transitiveViaArgInverse, 'SubLQuoteFn'('CLEAR-CACHED-SOME-TVA-CHECKS'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, transitiveViaArgInverse, 'SubLQuoteFn'('ADD-TRANSITIVE-VIA-ARG-INVERSE'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, transitiveViaArg, 'SubLQuoteFn'('CLEAR-CACHED-TVA-CHECKS'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, transitiveViaArg, 'SubLQuoteFn'('ADD-TRANSITIVE-VIA-ARG'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, termOfUnit, 'SubLQuoteFn'('ADD-TERM-OF-UNIT'), 'LogicalTruthImplementationMt', vStrMon).
assertedTinyKB(afterAdding, substring, 'SubLQuoteFn'('ADD-TVA-CACHE-VALUE'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, substring, 'SubLQuoteFn'('ADD-TVA-CACHE-KEY'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, ruleAfterRemoving, 'SubLQuoteFn'('DECACHE-RULE-AFTER-REMOVINGS'), 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(afterAdding, ruleAfterAdding, 'SubLQuoteFn'('DECACHE-RULE-AFTER-ADDINGS'), 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(afterAdding, rewriteOf, 'SubLQuoteFn'('REWRITE-OF-AFTER-ADDING'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, rewriteOf, 'SubLQuoteFn'('DECACHE-SOME-SOURCE-REWRITE-OF-ASSERTIONS-SOMEWHERE'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, rewriteOf, 'SubLQuoteFn'('DECACHE-SOME-EQUALITY-ASSERTIONS-SOMEWHERE'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, rewriteOf, 'SubLQuoteFn'('CYC-ADD-REFORMULATION-ASSERTION'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, resultQuotedIsa, 'SubLQuoteFn'('ADD-SUF-QUOTED-FUNCTION'), 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(afterAdding, resultIsa, 'SubLQuoteFn'('ADD-SUF-FUNCTION'), 'LogicalTruthImplementationMt', vStrMon).
assertedTinyKB(afterAdding, relationExpansion, 'SubLQuoteFn'('ADD-GENERATION-ASSERTION'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(afterAdding, reformulatorRuleProperties, 'SubLQuoteFn'('PROPAGATE-INVERSE-TO-ISA'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, reformulatorRuleProperties, 'SubLQuoteFn'('CYC-ADD-REFORMULATION-ASSERTION'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, reformulatorRule, 'SubLQuoteFn'('CYC-ADD-REFORMULATION-ASSERTION'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, reformulatorEquiv, 'SubLQuoteFn'('CYC-ADD-REFORMULATION-ASSERTION'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, reformulatorEquals, 'SubLQuoteFn'('CYC-ADD-REFORMULATION-ASSERTION'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, reformulationPrecondition, 'SubLQuoteFn'('CYC-ADD-REFORMULATION-ASSERTION'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, reformulationDirectionInMode, 'SubLQuoteFn'('CYC-ADD-REFORMULATION-ASSERTION'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, quotedIsa, 'SubLQuoteFn'('QUOTED-INSTANCEOF-AFTER-ADDING'), 'LogicalTruthImplementationMt', vStrMon).
assertedTinyKB(afterAdding, quotedDefnSufficient, 'SubLQuoteFn'('ADD-SUF-QUOTED-DEFN'), 'LogicalTruthImplementationMt', vStrMon).
assertedTinyKB(afterAdding, quotedDefnNecessary, 'SubLQuoteFn'('ADD-NEC-QUOTED-DEFN'), 'LogicalTruthImplementationMt', vStrMon).
assertedTinyKB(afterAdding, quotedDefnIff, 'SubLQuoteFn'('ADD-IFF-QUOTED-DEFN'), 'LogicalTruthImplementationMt', vStrMon).
assertedTinyKB(afterAdding, prettyString, 'SubLQuoteFn'('ADD-SEMANTIC-ASSERTION'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, prettyString, 'SubLQuoteFn'('ADD-PROPER-NAME-PREDICATE'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, preservesGenlsInArg, 'SubLQuoteFn'('PGIA-AFTER-ADDING-PGIA'), 'BaseKB', vStrMon).
assertedTinyKB(afterAdding, oldConstantName, 'SubLQuoteFn'('ADD-OLD-CONSTANT-NAME'), 'BaseKB', vStrMon).
assertedTinyKB(afterAdding, negationPreds, 'SubLQuoteFn'('NEGATION-PREDICATE-AFTER-ADDING'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, negationInverse, 'SubLQuoteFn'('ADD-NEGATION-INVERSE'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, nearestIsa, 'SubLQuoteFn'('PROPAGATE-TO-ISA'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, nearestGenls, 'SubLQuoteFn'('PROPAGATE-TO-GENLS'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, nearestGenls, 'SubLQuoteFn'('ADD-TVA-CACHE-VALUE'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, nearestGenlPreds, 'SubLQuoteFn'('PROPAGATE-TO-GENLPREDS'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, nearestGenlMt, 'SubLQuoteFn'('PROPAGATE-TO-GENLMT'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, knownAntecedentRule, 'SubLQuoteFn'('CYC-ADD-KNOWN-ANTECEDENT-RULE'), 'UniversalVocabularyImplementationMt', vStrMon).
assertedTinyKB(afterAdding, ist, 'SubLQuoteFn'('ADD-IST'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, isa, 'SubLQuoteFn'('PGIA-AFTER-ADDING-ISA'), 'LogicalTruthImplementationMt', vStrMon).
assertedTinyKB(afterAdding, isa, 'SubLQuoteFn'('INSTANCEOF-AFTER-ADDING'), 'LogicalTruthImplementationMt', vStrMon).
assertedTinyKB(afterAdding, isa, 'SubLQuoteFn'('CLEAR-ISA-DEPENDENT-CACHES'), 'LogicalTruthImplementationMt', vStrMon).
assertedTinyKB(afterAdding, irrelevantTerm, 'SubLQuoteFn'('CYC-REMOVE-IRRELEVANT-TERM'), 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(afterAdding, irrelevantTerm, 'SubLQuoteFn'('CYC-ADD-IRRELEVANT-TERM'), 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(afterAdding, interArgIsa, 'SubLQuoteFn'('INTER-ARG-ISA-AFTER-ADDING'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, indexicalReferent, 'SubLQuoteFn'('DECACHE-SOME-EQUALITY-ASSERTIONS-SOMEWHERE'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, hlPrototypicalInstance, 'SubLQuoteFn'('HL-PROTOTYPICAL-INSTANCE-AFTER-ADDING'), 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(afterAdding, highlyRelevantTerm, 'SubLQuoteFn'('CYC-ADD-RELEVANT-TERM'), 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(afterAdding, genls, 'SubLQuoteFn'('GENLS-AFTER-ADDING'), 'LogicalTruthImplementationMt', vStrMon).
assertedTinyKB(afterAdding, genls, 'SubLQuoteFn'('CLEAR-GENLS-DEPENDENT-CACHES'), 'LogicalTruthImplementationMt', vStrMon).
assertedTinyKB(afterAdding, genls, 'SubLQuoteFn'('ADD-TVA-CACHE-VALUE'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, genlPreds, 'SubLQuoteFn'('ADD-GENL-PREDICATE'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, genlMt, 'SubLQuoteFn'('CLEAR-MT-DEPENDENT-CACHES'), 'LogicalTruthImplementationMt', vStrMon).
assertedTinyKB(afterAdding, genlMt, 'SubLQuoteFn'('ADD-BASE-MT'), 'LogicalTruthImplementationMt', vStrMon).
assertedTinyKB(afterAdding, genlInverse, 'SubLQuoteFn'('ADD-GENL-INVERSE'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, genKeyword, 'SubLQuoteFn'('ADD-GENERATION-ASSERTION'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(afterAdding, genKeyword, 'SubLQuoteFn'('ADD-GEN-KEYWORD'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, genFormat, 'SubLQuoteFn'('ADD-GENERATION-ASSERTION'), 'UniversalVocabularyMt', vStrDef).
assertedTinyKB(afterAdding, expansion, 'SubLQuoteFn'('CYC-ADD-REFORMULATION-ASSERTION'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, expansion, 'SubLQuoteFn'('ADD-TO-CONTRACTION-HT'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, expansion, 'SubLQuoteFn'('ADD-GEN-TEMPLATE-EXPANSION'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, except, 'SubLQuoteFn'('CYC-EXCEPT-ADDED'), 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(afterAdding, evaluationResultQuotedIsa, 'SubLQuoteFn'('ADD-SUF-QUOTED-FUNCTION'), 'CoreCycLImplementationMt', vStrMon).
assertedTinyKB(afterAdding, evaluationDefn, 'SubLQuoteFn'('DECACHE-LISP-DEFUN'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, equalSymbols, 'SubLQuoteFn'('DECACHE-SOME-EQUALITY-ASSERTIONS-SOMEWHERE'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, equals, 'SubLQuoteFn'('DECACHE-SOME-EQUALITY-ASSERTIONS-SOMEWHERE'), 'LogicalTruthImplementationMt', vStrMon).
assertedTinyKB(afterAdding, equals, 'SubLQuoteFn'('DECACHE-SOME-EQUALITY-ASSERTIONS-SOMEWHERE'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, elInverse, 'SubLQuoteFn'('PROPAGATE-TO-GENLINVERSE'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, elInverse, 'SubLQuoteFn'('PROPAGATE-INVERSE-TO-GENLINVERSE'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, elementOf, 'SubLQuoteFn'('CYC-ADD-ELEMENT-OF'), 'BaseKB', vStrMon).
assertedTinyKB(afterAdding, disjointWith, 'SubLQuoteFn'('MDW-AFTER-ADDING'), 'LogicalTruthImplementationMt', vStrMon).
assertedTinyKB(afterAdding, defnSufficient, 'SubLQuoteFn'('ADD-SUF-DEFN'), 'BaseKB', vStrMon).
assertedTinyKB(afterAdding, defnNecessary, 'SubLQuoteFn'('ADD-NEC-DEFN'), 'LogicalTruthImplementationMt', vStrMon).
assertedTinyKB(afterAdding, defnIff, 'SubLQuoteFn'('ADD-IFF-DEFN'), 'LogicalTruthImplementationMt', vStrMon).
assertedTinyKB(afterAdding, defaultReformulatorModePrecedence, 'SubLQuoteFn'('CYC-ADD-REFORMULATION-ASSERTION'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, defaultReformulationDirectionInModeForPred, 'SubLQuoteFn'('CYC-ADD-REFORMULATION-ASSERTION'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, coExtensional, 'SubLQuoteFn'('PROPAGATE-TO-GENLS'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, coExtensional, 'SubLQuoteFn'('PROPAGATE-INVERSE-TO-GENLS'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, coExtensional, 'SubLQuoteFn'('ADD-TVA-CACHE-VALUE'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, canonicalizerDirectiveForArgAndRest, 'SubLQuoteFn'('RECACHE-SOME-CANONICALIZER-DIRECTIVE-ASSERTIONS-SOMEWHERE'), 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(afterAdding, canonicalizerDirectiveForArg, 'SubLQuoteFn'('RECACHE-SOME-CANONICALIZER-DIRECTIVE-ASSERTIONS-SOMEWHERE'), 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(afterAdding, canonicalizerDirectiveForAllArgs, 'SubLQuoteFn'('RECACHE-SOME-CANONICALIZER-DIRECTIVE-ASSERTIONS-SOMEWHERE'), 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(afterAdding, arityMin, 'SubLQuoteFn'('ADD-MAX-ARITY'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, arityMin, 'SubLQuoteFn'('ADD-ARITY-MIN'), 'LogicalTruthImplementationMt', vStrMon).
assertedTinyKB(afterAdding, arityMax, 'SubLQuoteFn'('ADD-MAX-ARITY'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, arityMax, 'SubLQuoteFn'('ADD-ARITY-MAX'), 'LogicalTruthImplementationMt', vStrMon).
assertedTinyKB(afterAdding, arity, 'SubLQuoteFn'('ADD-ARITY'), 'LogicalTruthImplementationMt', vStrMon).
assertedTinyKB(afterAdding, arg6Isa, 'SubLQuoteFn'('CYC-ADD-TO-ARG-TYPE-CACHE'), 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(afterAdding, arg5Isa, 'SubLQuoteFn'('CYC-ADD-TO-ARG-TYPE-CACHE'), 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(afterAdding, arg4Isa, 'SubLQuoteFn'('CYC-ADD-TO-ARG-TYPE-CACHE'), 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(afterAdding, arg3Isa, 'SubLQuoteFn'('CYC-ADD-TO-ARG-TYPE-CACHE'), 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(afterAdding, arg2Isa, 'SubLQuoteFn'('CYC-ADD-TO-ARG-TYPE-CACHE'), 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(afterAdding, arg1Isa, 'SubLQuoteFn'('CYC-ADD-TO-ARG-TYPE-CACHE'), 'CoreCycLImplementationMt', vStrDef).
assertedTinyKB(afterAdding, afterRemoving, 'SubLQuoteFn'('DECACHE-AFTER-REMOVINGS'), 'LogicalTruthImplementationMt', vStrMon).
assertedTinyKB(afterAdding, afterAdding, 'SubLQuoteFn'('DECACHE-AFTER-ADDINGS'), 'LogicalTruthImplementationMt', vStrMon).
assertedTinyKB(afterAdding, 'prettyString-Canonical', 'SubLQuoteFn'('ADD-SEMANTIC-ASSERTION'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, 'prettyString-Canonical', 'SubLQuoteFn'('ADD-PROPER-NAME-PREDICATE'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, 'interArgIsa5-4', 'SubLQuoteFn'('INTER-ARG-ISA-AFTER-ADDING'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, 'interArgIsa5-3', 'SubLQuoteFn'('INTER-ARG-ISA-AFTER-ADDING'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, 'interArgIsa5-2', 'SubLQuoteFn'('INTER-ARG-ISA-AFTER-ADDING'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, 'interArgIsa5-1', 'SubLQuoteFn'('INTER-ARG-ISA-AFTER-ADDING'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, 'interArgIsa4-5', 'SubLQuoteFn'('INTER-ARG-ISA-AFTER-ADDING'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, 'interArgIsa4-3', 'SubLQuoteFn'('INTER-ARG-ISA-AFTER-ADDING'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, 'interArgIsa4-2', 'SubLQuoteFn'('INTER-ARG-ISA-AFTER-ADDING'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, 'interArgIsa4-1', 'SubLQuoteFn'('INTER-ARG-ISA-AFTER-ADDING'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, 'interArgIsa3-5', 'SubLQuoteFn'('INTER-ARG-ISA-AFTER-ADDING'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, 'interArgIsa3-4', 'SubLQuoteFn'('INTER-ARG-ISA-AFTER-ADDING'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, 'interArgIsa3-2', 'SubLQuoteFn'('INTER-ARG-ISA-AFTER-ADDING'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, 'interArgIsa3-1', 'SubLQuoteFn'('INTER-ARG-ISA-AFTER-ADDING'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, 'interArgIsa2-5', 'SubLQuoteFn'('INTER-ARG-ISA-AFTER-ADDING'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, 'interArgIsa2-4', 'SubLQuoteFn'('INTER-ARG-ISA-AFTER-ADDING'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, 'interArgIsa2-3', 'SubLQuoteFn'('INTER-ARG-ISA-AFTER-ADDING'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, 'interArgIsa2-1', 'SubLQuoteFn'('INTER-ARG-ISA-AFTER-ADDING'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, 'interArgIsa1-5', 'SubLQuoteFn'('INTER-ARG-ISA-AFTER-ADDING'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, 'interArgIsa1-4', 'SubLQuoteFn'('INTER-ARG-ISA-AFTER-ADDING'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, 'interArgIsa1-3', 'SubLQuoteFn'('INTER-ARG-ISA-AFTER-ADDING'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, 'interArgIsa1-2', 'SubLQuoteFn'('INTER-ARG-ISA-AFTER-ADDING'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, 'interArgFormat1-2', 'SubLQuoteFn'('INTER-ARG-FORMAT-AFTER-ADDING'), 'BaseKB', vStrDef).
assertedTinyKB(afterAdding, 'equalStrings-CaseInsensitive', 'SubLQuoteFn'('DECACHE-SOME-EQUALITY-ASSERTIONS-SOMEWHERE'), 'BaseKB', vStrDef).
assertedTinyKB('larkc-pluginByDataConnectsTo', 'larkc-GateTransformer', 'larkc-CycSelecter', 'BaseKB', vStrDef).
assertedTinyKB('larkc-pluginByDataConnectsTo', 'larkc-GateTransformer', 'larkc-CycReasoner', 'BaseKB', vStrDef).
assertedTinyKB('larkc-pluginByDataConnectsTo', 'larkc-CycSelecter', 'larkc-CycSelecter', 'BaseKB', vStrDef).
assertedTinyKB('larkc-pluginByDataConnectsTo', 'larkc-CycSelecter', 'larkc-CycReasoner', 'BaseKB', vStrDef).
assertedTinyKB('larkc-pluginByDataConnectsTo', 'larkc-ArticleIdentifier', 'larkc-GateTransformer', 'BaseKB', vStrDef).
assertedTinyKB('larkc-hasOutputType', 'larkc-GateTransformer', 'larkc-RdfGraph', 'BaseKB', vStrDef).
assertedTinyKB('larkc-hasOutputType', 'larkc-CycSelecter', 'larkc-RdfGraph', 'BaseKB', vStrDef).
assertedTinyKB('larkc-hasOutputType', 'larkc-CycReasoner', 'larkc-VariableBinding', 'BaseKB', vStrDef).
assertedTinyKB('larkc-hasOutputType', 'larkc-ArticleIdentifier', 'larkc-NaturalLanguageDocument', 'BaseKB', vStrDef).
assertedTinyKB('larkc-hasInputType', 'larkc-GateTransformer', 'larkc-NaturalLanguageDocument', 'BaseKB', vStrDef).
assertedTinyKB('larkc-hasInputType', 'larkc-CycSelecter', 'larkc-SetOfStatements', 'BaseKB', vStrDef).
assertedTinyKB('larkc-hasInputType', 'larkc-CycReasoner', 'larkc-SetOfStatements', 'BaseKB', vStrDef).
assertedTinyKB('larkc-hasInputType', 'larkc-ArticleIdentifier', 'larkc-SPARQLQuery', 'BaseKB', vStrDef).
assertedTinyKB('interArgIsa2-1', negationPreds, 'VariableArityRelation', 'VariableArityRelation', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB('interArgIsa2-1', negationPreds, 'UnaryPredicate', 'UnaryPredicate', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB('interArgIsa2-1', negationPreds, 'TernaryPredicate', 'TernaryPredicate', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB('interArgIsa2-1', negationPreds, 'QuintaryPredicate', 'QuintaryPredicate', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB('interArgIsa2-1', negationPreds, 'QuaternaryPredicate', 'QuaternaryPredicate', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB('interArgIsa2-1', negationPreds, 'BinaryPredicate', 'BinaryPredicate', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB('interArgIsa2-1', genls, 'SubLExpressionType', 'SubLExpressionType', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB('interArgIsa2-1', genlPreds, 'UnaryPredicate', 'UnaryPredicate', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB('interArgIsa2-1', genlPreds, 'TernaryPredicate', 'TernaryPredicate', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB('interArgIsa2-1', genlPreds, 'QuintaryPredicate', 'QuintaryPredicate', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB('interArgIsa2-1', genlPreds, 'QuaternaryPredicate', 'QuaternaryPredicate', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB('interArgIsa2-1', genlPreds, 'FixedArityRelation', 'FixedArityRelation', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB('interArgIsa2-1', genlPreds, 'BinaryPredicate', 'BinaryPredicate', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB('interArgIsa1-2', negationPreds, 'VariableArityRelation', 'VariableArityRelation', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB('interArgIsa1-2', negationPreds, 'UnaryPredicate', 'UnaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB('interArgIsa1-2', negationPreds, 'TernaryPredicate', 'TernaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB('interArgIsa1-2', negationPreds, 'QuintaryPredicate', 'QuintaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB('interArgIsa1-2', negationPreds, 'QuaternaryPredicate', 'QuaternaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB('interArgIsa1-2', negationPreds, 'BinaryPredicate', 'BinaryPredicate', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB('interArgIsa1-2', genlPreds, 'VariableArityRelation', 'VariableArityRelation', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB('interArgIsa1-2', arity, tPred, 'PositiveInteger', 'UniversalVocabularyMt', vStrDef).
assertedTinyKB('genls-SpecDenotesGenlInstances', 'TheTerm', 'Thing', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB('genls-SpecDenotesGenlInstances', 'SubLString', 'CharacterString', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB('genls-SpecDenotesGenlInstances', 'SubLPositiveInteger', 'PositiveInteger', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB('genls-SpecDenotesGenlInstances', 'SubLPositiveInteger', 'NonNegativeInteger', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB('genls-SpecDenotesGenlInstances', 'SubLNonNegativeInteger', 'NonNegativeInteger', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB('genls-SpecDenotesGenlInstances', 'SubLNonNegativeInteger', 'Integer', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB('genls-SpecDenotesGenlInstances', 'SubLInteger', 'Integer', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB('genls-SpecDenotesGenlInstances', 'HLPrototypicalTerm', 'Thing', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB('genls-SpecDenotesGenlInstances', 'DocumentationPredicate', tPred, 'CoreCycLMt', vStrMon).
assertedTinyKB('genls-SpecDenotesGenlInstances', 'CycLTerm', 'Thing', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB('genls-SpecDenotesGenlInstances', 'CycLRepresentedTerm', 'Thing', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB('genls-SpecDenotesGenlInstances', 'CycLReifiedDenotationalTerm', 'Thing', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB('genls-SpecDenotesGenlInstances', 'CycLReifiableNonAtomicTerm', 'Thing', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB('genls-SpecDenotesGenlInstances', 'CycLReifiableDenotationalTerm', 'Thing', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB('genls-SpecDenotesGenlInstances', 'CycLNonAtomicTerm', 'Thing', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB('genls-SpecDenotesGenlInstances', 'CycLNonAtomicReifiedTerm', 'Thing', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB('genls-SpecDenotesGenlInstances', 'CycLIndexedTerm', 'Thing', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB('genls-SpecDenotesGenlInstances', 'CycLFormula', 'Thing', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB('genls-SpecDenotesGenlInstances', 'CycLExpression', 'Thing', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB('genls-SpecDenotesGenlInstances', 'CycLDenotationalTerm-Assertible', 'Thing', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB('genls-SpecDenotesGenlInstances', 'CycLDenotationalTerm', 'Thing', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB('genls-SpecDenotesGenlInstances', 'CycLConstant', 'Thing', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB('genls-SpecDenotesGenlInstances', 'CycLClosedNonAtomicTerm', 'Thing', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB('genls-SpecDenotesGenlInstances', 'CycLClosedExpression', 'Thing', 'UniversalVocabularyMt', vStrMon).
assertedTinyKB('genls-SpecDenotesGenlInstances', 'CycLClosedDenotationalTerm', 'Thing', 'UniversalVocabularyMt', vStrMon).


end_of_file.

% ===================================================================
% File 'cyc.pl'
% Purpose: Lower-level connection based utilities for interfacing to CYC from SWI-Prolog
% Maintainer: Douglas Miles
% Contact: $Author: dmiles $@users.sourceforge.net ;
% Version: 'cyc.pl' 1.0.0
% Revision:  $Revision: 1.7 $
% Revised At:   $Date: 2002/07/11 21:57:28 $
% ===================================================================

:-swi_module(cyc,[
	 cycInit/0,
         op(700,xfx,'=^..'),
         '=^..'/2,
	 getCycConnection/4,
	 finishCycConnection/3,
	 converse/1,
	 converse/2,
	 %evalSubL/2,
	 evalSubL/3,
	 converseRaw/2,
	 cycInfo/0,
         toCycVar/3,
         toCycVar/2,
	 formatCyc/3,
	 toCycApiExpression/2,
	 toCycApiExpression/3,
         %transparent isCycConstantGuess/1,
	 cycQuery/1,
	 cycQuery/2,
	 cycQuery/6,
	 cycQuery/8,
	 toMarkUp/4,
	 cycAssert/1,
	 cycAssert/2,
	 cycRetract/1,
	 %is_string/1,
	 balanceBinding/2,
	 cycRetract/2,
	 cycRetractAll/1,
	 cycRetractAll/2,
	 %transparent isDebug/0,
	 makeConstant/1,
	 ensureMt/1,
	 isCycConstant/1,
	 readCycL/2,
	 %%user: termCyclify/2,
         %constant/4,
	 idGen/1,
	 %subst/4,
	 isCycOption/1,
	 isCycOption/2,
	 % unnumbervars/2,
	 % transparent defaultAssertMt/1,
         mtForCycL/2,
         assertIfNew/1,
	 getMtForPred/2,
	 % isRegisterCycPred/3,
	 registerCycPred/1,
	 setCycOption/2,
	 setCycOption/1,
	 unsetCycOption/1,
	 getWordTokens/2,
	 registerCycPred/2,
	 registerCycPred/3,
         getSurfaceFromChars/3,
         getSurface/2,
         getSurface/3,

         lisp_read/1,
         lisp_read/3,
         lisp_read_codes/2,
         lisp_read_fully/2,

	 assertThrough/1,
         cycSync/0,
         cycSyncThread/0,
         cycAssertBuffer/1,
         cycAssertBuffer/2,
	 assertThrough/2,
	 assertThrough/2,
	 assertThrough/2,
	 writel/1,
	 writel/2,
	 % atomSplit/2,
	 list_to_conj/2,
	 testCYC/0,

         /*
         flush_output_safe/1,

         %processRequestHook/1,

         loadLispFile/1,
           	 
         badConstant/1,
         quoteAtomString/2,
         unquoteAtom/2,
         termCyclifyAtom/2,
*/

	 createCycServer/1,
	 xmlPrologServer/1,
	 read_line_with_nl/3,
	 decodeRequest/2,
	 invokePrologCommandRDF/6,
	 serviceAcceptedClientSocketAtThread/2,

	 servantProcessCreate/1,
	 servantProcessCreate/3,
	 servantProcessCreate/4,
	 servantProcessCreate/5,
	 isCycProcess/2,
	 isCycProcess/5,
	 createProcessedGoal/1,
	 servantProcessSelfClean/0,
	 showCycStatisticsHTML/0,
	 cleanOldProcesses/0,
	 showCycProcessHTML/0,

         

         guessConstant/2,

         readUntil/3,
         readCycLTermChars/3,
         readCycLTermChars/2,
         atom_to_number/2,


         logOnFailure/1,

         writeHTMLStdHeader/1,
         writeHTMLStdFooter/0,
	 
         debugFmt/1,
	 debugFmt/2,
	 debugFmtFast/1,

         writeObject/2,
	 writeObject/3,
	 writeObject_conj/2,
         loadCycL/1,
         cycCacheToDo/1,
         cycCache/1,
         cycQueryV/2,

      writeFmtFlushed/1,
      writeFmtFlushed/2,
      writeFmtFlushed/3,
      % trim/2,
      pterm_to_sterm/2
      %canTrace/0, 
      %ctrace/0,
      %isConsole/0

	 ]).
:-module_transparent(user:nart/3).


:-dynamic(constant/4).
:-multifile(constant/4).

cyc:cyc_magic.

current_file(FileBase,Dir):-current_stream(File,read,_Stream),atom(File),is_absolute_file_name(File),
   file_directory_name(File,Dir),file_base_name(File,FilePart),once(FileBase=FilePart;file_name_extension(FileBase,_Ext,FilePart)).

asserta_if_new(A):-retract(A),fail.
asserta_if_new(A):-asserta(A),!.

:-current_file(F,Dir),writeq(current_file(F,Dir)),nl,!,
   asserta_if_new(user:library_directory(Dir)),
   asserta_if_new(user:file_search_path(cyc_api, Dir)),
   asserta_if_new(user:file_search_path(('.'), Dir)),!,
   asserta_if_new(cyc_magic_dir(Dir)),!.

addStagedDirs:-
  cyc_magic_dir(Dir),expand_file_name('./stage*',X),member(A,X),absolute_file_name(A,[relative_to(Dir)],O),asserta_if_new(user:library_directory(O)),!.
addStagedDirs.


:-dynamic(withoutCyc).
withoutCyc:-fail.

:-dynamic(canTrace/0).
canTrace.

%isConsole :- telling(user).
isConsole :- current_output(X),!,stream_property(X,alias(user_output)).

willTrace:-not(isConsole),!,fail.
willTrace:-canTrace.
hideTrace:-
   trace(cyc:hideTrace/0, -all),
   trace(willTrace/0, -all),
   trace(canTrace/0, -all),
   trace(ctrace/0, -all),
   trace(system:throw/1, +all),
   trace(system:print_message/2, +all),
   trace(user:message_hook/3 , +all),
   trace(system:message_to_string/2, +all).

ctrace:-willTrace->trace;notrace.
:-hideTrace.

withoutCyc(_,[]):-fail.

:-use_module(library(system)).
:-use_module(library(shlib)).
:-use_module(library(listing)).
:-use_module(library(sgml)).
%:-use_module(library(rdf)).
:- use_module(library(socket)).
:- use_module(library(readutil)).

%Load the TCP Library
%:-use_module(library('http/http_open')).
:-use_module(library('http/http_client')).
%:-use_module(library('http/http_header')).
%:-use_module(library('http/thread_httpd')).

%:- use_module(library(unix)).
:- use_module(library(shell)).
:- use_module(library(shlib)).
:- use_module(library(url)).
:- use_module(library(quintus)).
:- use_module(library(qsave)).

%:- use_module((javart)).

:- style_check(-singleton).
:- style_check(-discontiguous).
% :- style_check(-atom).
% :- style_check(-string).
/*
dynamic_transparent([]):-!.
dynamic_transparent([X]):-dynamic_transparent(X),!.
dynamic_transparent([X|Xs]):-!,dynamic_transparent(X),dynamic_transparent(Xs),!.
dynamic_transparent(M:F/A):-!, module_transparent(M:F/A),dynamic(M:F/A).
dynamic_transparent(F/A):-!,multi_transparent(user:F/A).
dynamic_transparent(X):-functor(X,F,A),dynamic_transparent(F/A),!.

multi_transparent([]):-!.
multi_transparent([X]):-multi_transparent(X),!.
multi_transparent([X|Xs]):-!,multi_transparent(X),multi_transparent(Xs),!.
multi_transparent(M:F/A):-!, module_transparent(M:F/A),dynamic(M:F/A),multifile(M:F/A).
multi_transparent(F/A):-!,multi_transparent(user:F/A).
multi_transparent(X):-functor(X,F,A),multi_transparent(F/A),!.
*/   
:-multi_transparent(holds/1).
:-multi_transparent(holds/2).
:-multi_transparent(holds/3).
:-multi_transparent(holds/4).
:-multi_transparent(holds/5).
:-multi_transparent(holds/6).
:-multi_transparent(holds/7).
:-multi_transparent(holds/8).



:-dynamic(double_quotes_was/1).
:-current_prolog_flag(double_quotes,X),asserta(double_quotes_was(X)).

%:- set_prolog_flag(optimise,true).
%:- set_prolog_flag(file_name_variables,false).
%:- set_prolog_flag(agc_margin,0).
%:- set_prolog_flag(trace_gc,false).
%:-set_prolog_flag(character_escapes,true).
%:-set_prolog_flag(double_quotes,string).
%:-set_prolog_flag(report_error,true).
%:-set_prolog_flag(verbose,normal).
:-set_prolog_flag(double_quotes,codes).
:-set_prolog_flag(float_format,'%.12g').
% :-set_prolog_flag(gc,false).
:-dynamic_transparent(cycConnectionAvalable/5).
:-dynamic_transparent(cycConnectionUsed/5).
:-dynamic_transparent(cycMutex/2).
:-dynamic_transparent(cycChatMode/1).
:-dynamic_transparent(termCyclify/2).



loadLispFile(Filename):-
   open(Filename,read,Stream),
   loadLispStream(Stream,doLispLine).

loadLispStream(Stream,Callback):-
   repeat,
   % %readUntil(10,Stream,Get),
   lisp_read(Stream,_String,Get),
   doSexpLine(Callback,Get),
   at_end_of_stream(Stream).
   
doSexpLine(Callback,Get):-
  once(getSurfaceFromTokens(Get,Surf,Vars)),
   call(Callback,Surf,Vars). 


s2p(X,Y,Feat):-s2p(nothingExtra,X,Y,Feat).
nothingExtra(X,Y,Z):-fail.

s2p(Extra,X,Y,Feat):-call(Extra,X,Y,Feat),!.
s2p(Extra,X,X,[]):- (var(X);number(X);is_string(X)),!.
s2p(Extra,svar(X,Name),X,[Name=X]):-atom_concat(':',_,Name),!.
s2p(Extra,svar(X,Name),Name,[Name=X])-!.
s2p(Extra,var(X,Name),X,[Name=X]):-!.
s2p(Extra,[H|T],R,Features):-!,s2Pred(Extra,H,T,R,Features),!.
s2p(Extra,C,R,Features):-compound(C),C=..[H|T],s2Pred(Extra,H,T,R,Features),!.
s2p(Extra,Atom,X,[Atom=X]):-atom(Atom),atom_concat(':',_,Atom),hash_term(Atom,Hash),X='$VAR'(Hash),!.
s2p(Extra,Atom,[Atom],[]):-atom(Atom),atom_concat('SKF',_,Atom),!.
%s2p(Extra,Atom,[X],[Atom=X]):-atom(Atom),atom_concat('SKF',_,Atom),hash_term(Atom,Hash),X='$VAR'(Hash),!.
s2p(Extra,X,X,[]):-!.


s2Pred(Extra,H,T,R,Features):-atom(H),isFn(H),!,s2List(Extra,T,TT,Features),R=[H|TT],!.
s2Pred(Extra,H,T,R,Features):-atom(H),isKeyword(H),!,s2List(Extra,T,TT,Features),R=[H|TT],!.
%s2Pred(Extra,H,T,R,Features):-is_list(H),s2List(Extra,H,HH,F1),!,s2List(Extra,T,TT,F2),R=[HH|TT],!,append(F1,F2,Features).
%s2Pred(Extra,H,T,R,Features):-isFn(H),!,s2List(Extra,T,TT,Features),R=[H|TT],!.
%s2Pred(Extra,H,T,R,Features):-isKeyword(H),!,s2List(Extra,T,TT,Features),R=[H|TT],!.
%s2Pred(Extra,H,T,R,Features):-s2List(Extra,T,TT,Features),R=..[H|TT],!.
s2Pred(Extra,H,T,R,Features):-s2p(Extra,H,HH,F1),s2List(Extra,T,TT,F2),append(F1,F2,Features),!, 
                                             s2Pred(Extra,H,T,HH,TT,R,Features).

s2Pred(Extra,H,T,HH,TT,R,Features):- atom(HH),proper_list(TT),not(isFn(HH)),!,R=..[H|TT],!.
s2Pred(Extra,H,T,HH,TT,R,Features):- R=[HH|TT].

s2List(Extra,X,X,[]):- (var(X);number(X);string(X);X==[]),!.
%s2List(Extra,X,X,[]):- atom(X),!.
s2List(Extra,[H|T],[HH|TT],Features):-s2p(Extra,H,HH,F1),s2List(Extra,T,TT,F2),append(F1,F2,Features),!.
s2List(Extra,X,Y,Features):-s2p(Extra,X,Y,Features),!.


isKeyword(X):-atom_prefix(X,':').

isFn(X):-isKeyword(X),!.
isFn(X):-name(X,[Cap|_]),char_type(Cap,upper),!.
isFn(X):-atom_concat(_,'Fn',X),!.
/*
implied with uppercheck
isFn(X):-atom_concat('The',_,X).  
isFn(X):-atom_concat('SKF',_,X).
isFn(X):-atom_concat('MT',_,X).
*/


balanceBindingS2P(X,Z):-balanceBindingS2P(X,Z,_Feats).

balanceBindingS2P(X,Z,Feats):-
      balanceBinding(X,Y),
      unnumbervars(Y,UN),
      s2p(UN,Z,Feats),!.

:-dynamic(cyc:dbCache/2).
doLispLine([P|Surf],Vars):-toUppercase(P,UP),not(UP==P),!,doLispLine([UP|Surf],Vars).
doLispLine(['CYC-ASSERT',quote(STUFF),quote(WHERE)|_],Vars):-!,doLispLine(['CYC-ASSERT',quote(STUFF),(WHERE)|_],Vars).
doLispLine(['CYC-ASSERT',quote(STUFF),(WHERE)|_],Vars):-
         balanceBindingS2P(STUFF,Prolog),
         balanceBindingS2P(WHERE,Mt),
         writeq(Mt:Prolog),nl,
         cycAssertBuffer(Prolog,Mt),!.
         %assertIfNew(cyc:dbCache(Prolog,Mt)),!.
         %writel(ist(WHERE,Prolog):Vars),nl,!.
doLispLine(Surf,Vars):-
      writeq(user_error,Surf:Vars),
      nl(user_error).


cycBaseJavaClass('org.cyc.prolog.JavaRt').


% =====================================
% Utitity
% =====================================


%assertIfNew(CX):-not(ground(CX)),!,throw(assertIfNew(CX)).
assertIfNew(CX):-catch(CX,_,fail),!.
assertIfNew(CX):-asserta(CX),!.

catchIgnore(CX):-ignore(catch(CX,_,true)).

% =====================================
% Database
% =====================================
:-dynamic(cycCacheToDo/1).
:-dynamic(cycCache/1).

                    

cycAssertBuffer(Out,Mt):-cycAssertBuffer(Mt:Out).
cycAssertBuffer(_:end_fo_file):-!.
cycAssertBuffer(forward(Out)):-!,cycAssertBuffer((Out)).
cycAssertBuffer(Out):-not(Out=_:_),!,mtForCycL(Out,MT),!,cycAssertBuffer(MT:Out).
cycAssertBuffer(Out):-cycCacheToDo(Out),!.
cycAssertBuffer(Out):-cycCache(Out),!.
cycAssertBuffer(U):-unusedCycL(U),!.
%cycAssertBuffer(Mt:Out):-coerceCyc(Out,CycL)
cycAssertBuffer(Out):-debugFmt('% cycAssertion ~w ~n',[Out]),assertIfNew(cycCacheToDo(Out)),!.
unusedCycL(_:end_fo_file).
%unusedCycL(_:comment(_,_)).
%unusedCycL(_:isa(A,'Property')):-nonvar(A),!.

cycSync:-user:cycCacheToDo(Out),cycSync(Out),fail.
cycSync:-!.%%d3Info.

cycSync(_:end_fo_file):-!.
cycSync(U):-unusedCycL(U),!.
cycSync(Out):-cycCache(Out),!,ignore(retract(cycCacheToDo(Out))).
cycSync(Out):-Out= MT : Assert,!,catch((myCycAssert(MT : Assert),ignore(assertIfNew(cycCache(Out))),ignore(retract(cycCacheToDo(Out)))),E,debugFmt('% % % % % % % ~q',[E])),!.
cycSync(Out):-mtForCycL(Out,Mt),!,cycSync(Mt:Out).

% ===================================================================
%  Predicates need and Assertion Mt
% ===================================================================


mtForCycL(isa(_,tCol),'UniversalVocabularyMt').
mtForCycL(isa(_,'Microtheory'),'UniversalVocabularyMt').
mtForCycL(isa(_,tPred),'UniversalVocabularyMt').
mtForCycL(arity(_,_),'UniversalVocabularyMt').
mtForCycL(Out,Mt):-predOfCycL(Out,Pred),!,getMtForPred(Pred,Mt).

predOfCycL(SENT,Y):-member(OP,[forward,and,':',or,implies,not]),SENT=..[OP|LIST],!,member(A,LIST),predOfCycL(A,Y),!.
predOfCycL(CX,Y):-functor(CX,Y,_).


% :-dynamic_transparent(mtForPred/2).

getMtForPred(X,Y):-mtForPred(X,Y),!.
getMtForPred(genlMt,'BaseKB').
getMtForPred(CycL,Mt):-nonvar(CycL),functor(CycL,Pred,_),isRegisterCycPred(Mt,Pred,_),!.
getMtForPred(CycL,Mt):-defaultAssertMt(Mt).


% ===================================================================
% Cyc Option Switches
%
%  setCycOption(Var,Value) - sets an option first removing the prevoius value
%
%  isCycOption(Var,Value). - tests for option
%
% ===================================================================

setCycOption([]):-!.
setCycOption([H|T]):-!,
      setCycOption(H),!,
      setCycOption(T),!.
setCycOption(Var=_):-var(Var),!.
setCycOption(_=Var):-var(Var),!.
setCycOption((N=V)):-nonvar(N),!,setCycOption_thread(N,V),!.
setCycOption(N):-atomic(N),!,setCycOption_thread(N,true).
	
setCycOption(Name,Value):-setCycOption_thread(Name,Value).
setCycOption_thread(Name,Value):-
	((thread_self(Process),
	retractall('$CycOption'(Process,Name,_)),
	asserta('$CycOption'(Process,Name,Value)),!)).


unsetCycOption(Name=Value):-nonvar(Name),
	unsetCycOption_thread(Name,Value).
unsetCycOption(Name):-nonvar(Name),
	unsetCycOption_thread(Name,_).
unsetCycOption(Name):-(retractall('$CycOption'(_Process,Name,_Value))).


unsetCycOption_thread(Name):-
	unsetCycOption_thread(Name,_Value).

unsetCycOption_thread(Name,Value):-
	thread_self(Process),
	retractall('$CycOption'(Process,Name,Value)).
	
getCycOption_nearest_thread(Name,Value):-
	getCycOption_thread(Name,Value),!.
getCycOption_nearest_thread(Name,Value):-
      '$CycOption'(_,Name,Value),!.
getCycOption_nearest_thread(_Name,_Value):-!.


'WRITEL'(F):-writel(F).

isCycOption(Name):-isCycOption(Name,true).
isCycOption(Name):-isCycOption(Name,on).
isCycOption(Name):-isCycOption(Name,yes).
isCycOption(Name=Value):-isCycOption(Name,Value).

isCycOption(Name,Value):-getCycOption_thread(Name,Value).


getCycOption_thread(Name,Value):-
	((thread_self(Process),
	('$CycOption'(Process,Name,Value);'$CycOption'(_,Name,Value)))),!.

getCycOption(Name=Value):-nonvar(Name),!,ensureCycOption(Name,_,Value).
getCycOption(Name=Default,Value):-nonvar(Name),!,ensureCycOption(Name,Default,Value).
getCycOption(Name,Value):-nonvar(Name),!,ensureCycOption(Name,_,Value).


ensureCycOption(Name=Default,Value):-
	ensureCycOption(Name,Default,Value),!.
	
ensureCycOption(Name,_Default,Value):-
	getCycOption_thread(Name,Value),!.

ensureCycOption(Name,Default,Default):-
	setCycOption_thread(Name,Default),!.

ensureCycOption(Name,_Default,Value):-nonvar(Name),!,   
	setCycOption_thread(Name,Value),!.

ensureCycOption(_Name,Default,Default).

setCycOption(Name,Value):-setCycOption_thread(Name,Value).


setCycOptionDefaults:-
             (unsetCycOption(_)),
             setCycOption(makeConstant='on'),
             setCycOption(opt_callback='sendNote'),
             setCycOption(cb_consultation='off'),
             setCycOption(opt_debug='true'),
             setCycOption(cb_error='off'),
             setCycOption(cb_result_each='off'),

% User Agent Defaults for 
             setCycOption(opt_cxt_request='BaseKB'),
             setCycOption(opt_ctx_assert='BaseKB'),
             setCycOption(opt_tracking_number='generate'),
             setCycOption(opt_agent='ua_parse'),
             setCycOption(opt_precompiled='off'),
             getCycOption(opt_theory,Context),setCycOption(opt_theory=Context),
             setCycOption(opt_notation='cycl'),
             setCycOption(opt_timeout=2),
             setCycOption(opt_readonly='off'),
             setCycOption(opt_debug='false'),
             setCycOption(opt_compiler='Byrd'),
             setCycOption(opt_language = 'pnx_nf'),

%Request Limits
             setCycOption(opt_answers_min=1),
             setCycOption(opt_answers_max=999), %TODO Default
             setCycOption(opt_backchains_max=5),
             setCycOption(opt_deductions_max=100),
             setCycOption(opt_backchains_max_neg=5),
             setCycOption(opt_deductions_max_neg=20),
             setCycOption(opt_forwardchains_max=1000),
             setCycOption(opt_max_breath=1000), %TODO Default

%Request Contexts
             setCycOption(opt_explore_related_contexts='off'),
             setCycOption(opt_save_justifications='off'),
             setCycOption(opt_deductions_assert='on'),
             setCycOption(opt_truth_maintence='on'),
             setCycOption(opt_forward_assertions='on'),
             setCycOption(opt_deduce_domains='on'),
             setCycOption(opt_notice_not_say=off),


%Request Pobibility
             setCycOption(opt_certainty_max=1),
             setCycOption(opt_certainty_min=1),
             setCycOption(opt_certainty=1),
             setCycOption(opt_resource_commit='on').

% ===================================================================
% Cyc initialization - call cycInit. once and this fiule will be loaded if not already
% ===================================================================
cycInit.

:-dynamic_transparent('$CycOption'/3).

:-((setCycOptionDefaults)).

:-(( %at_initialization
    setCycOption(cycServer,'10.1.1.104':36001),
      setCycOption(cycCoServer,'10.10.10.198':3679),
      setCycOption(cycServer,'10.10.10.198':13701),
      %setCycOption(cycCFasl,'10.10.10.198':3615),
     setCycOption(cycServer,'10.10.10.193':3601),
     setCycOption(cycServer,'10.10.10.198':3601),
     setCycOption(cycServer,'logicmoo.ath.cx':3601),
      setCycOption(query(backchains),3),
      setCycOption(query(number),nil),
      setCycOption(query(time),20), %max ten seconds maybe?
      setCycOption(query(depth),nil),
   !)).
      
:-((
      setCycOption(defaultAssertOptions,[':DIRECTION', ':FORWARD', ':STRENGTH', vStrMon]),
      setCycOption(':DIRECTION', ':FORWARD'),
      setCycOption(':STRENGTH', vStrMon),
      setCycOption(hookCycPredicates,true),
      setCycOption(makeConstants,true),
   !)).


% ===================================================================
% Connecter to Cyc TCP Server
% ===================================================================

getCycConnection3(SocketId,OutStream,InStream):- 
      ignore(once(isCycOption(cycServer,Server))),
      getCycConnection(Server,SocketId,OutStream,InStream).

%  Reuse an Available connection
getCycConnection(Server,SocketId,OutStream,InStream):- fail,
      thread_self(Thread),
      ignore((var(Server),throw(no_server(getCycConnection(Server,SocketId,OutStream,InStream))))),
      once(nonvar(SocketId);nonvar(OutStream);nonvar(InStream)),
      once(cyc:cycConnectionAvalable(Thread,Server,SocketId,OutStream,InStream);cyc:cycConnectionUsed(Thread,Server,SocketId,OutStream,InStream)),!.

%  Reuse an Available connection
getCycConnection(Server,SocketId,OutStream,InStream):-
      thread_self(Thread),
      retract(cyc:cycConnectionAvalable(Thread,Server,SocketId,OutStream,InStream)),
      ignore(system:retractall(cyc:cycConnectionUsed(Thread,Server,SocketId,OutStream,InStream))),
      assertz(cyc:cycConnectionUsed(Thread,Server,SocketId,OutStream,InStream)),!.

%  Or Create a new Available connection
getCycConnection(Server,SocketId,OutStream,InStream):-
      tcp_socket(SocketId),
      tcp_connect(SocketId,Server),
      tcp_open_socket(SocketId, InStream, OutStream),!,
      thread_self(Thread),
      debugFmt('Thread ~w Connected to Cyc TCP Server {~w,~w}\n',[Thread,InStream,OutStream]),
      thread_at_exit(finishCycConnectionThread(Thread)),
      assertz(cyc:cycConnectionUsed(Thread,Server,SocketId,OutStream,InStream)),!.

finishCycConnectionThread(Thread):-
      ignore((
       system:retract(cyc:cycConnectionAvalable(Thread,Server,SocketId,OutStream,InStream)),ignore(catch(tcp_close_socket(SocketId),_,true)),fail)),
      ignore((
       system:retract(cyc:cycConnectionUsed(Thread,Server,SocketId,OutStream,InStream)),ignore(catch(tcp_close_socket(SocketId),_,true)),fail)),!.
      

finishCycConnection(SocketId,OutStream,InStream):-
      thread_self(Thread),
      ignore(system:retractall(cyc:cycConnectionUsed(Thread,Server,SocketId,OutStream,InStream))),
      ignore(system:retractall(cyc:cycConnectionAvalable(Thread,Server,SocketId,OutStream,InStream))),
      asserta(cyc:cycConnectionAvalable(Thread,Server,SocketId,OutStream,InStream)),!.
      
% ===================================================================
% cycInfo. - Prints Cyc Usage info to current output 
% ===================================================================
cycInfo:- % will add more 
   listing(cycConnectionAvalable),
   listing(cycConnectionUsed),
%   listing(user:isCycConstantMade),
  % listing('$CycOption'),
   number_of_clauses(cycCache(_)),
   number_of_clauses(cycCacheToDo(_)).

loadCycL(File):-
      see(File),
      repeat,
      read(Term),
      cycAssertBuffer(Term),
      Term=end_of_file,
      seen,cycSync.


cycSyncThread:-
         createProcessedGoal(cycSyncThreadCode),
         debugFmt(createProcessedGoal(cycSyncThreadCode)).

cycSyncThreadCode:-repeat,once((cycSync,sleep(5))),fail.

cycDatabase(CX):-nonvar(CX),cycCacheToDo(CX).
cycDatabase(CX):-nonvar(CX),cycCacheToDo(_:CX).
cycDatabase(CX):-nonvar(CX),cycCache(CX).
cycDatabase(CX):-nonvar(CX),cycCache(_:CX).

cycCache(_:end_of_file).


number_of_clauses(P):-number_of_clauses(P,Y),functor(P,F,A),debugFmt('% number_of_clauses(~q/~q)->~q~n',[F,A,Y]).
number_of_clauses(P,Y):-predicate_property(P, number_of_clauses(Y)),!.
number_of_clauses(P,0).

% ===================================================================
% Invoke SubL
% converseRaw(+Send[,-Receive]).
% 
% ?- converseRaw('(find-constant "Dog")').
% Dog
%
% ===================================================================

converse(Send):-
      converseRaw(Send,Receive),
      debugFmt('% recv> ~s~n',[Receive]).

converse(Send,Receive):-
      converseRaw(Send,ReceiveCodes),
      atom_codes(Receive,ReceiveCodes).

converseRaw(Send,Receive):-withoutCyc,!,ctrace,withoutCyc(Send,Receive).

converseRaw(Send,Receive):-
      getCycConnection3(SocketId,OutStream,InStream),
      streamClear(InStream),
      writel(OutStream,Send),
      readSubL(InStream,Get),!,
      finishCycConnection(SocketId,OutStream,InStream),!,
      checkSubLError(InStream,Send,Get,Receive),!.

checkSubLError(InStream,Send,[53,48,48,_|Info],Info):-!, %Error "500 "
      atom_codes(ErrorMsg,Info),%true,
%      streamClear(InStream),
      throw(cyc_error(ErrorMsg,Send)).
checkSubLError(InStream,_,[50,48,48,_|Info],Trim):-!, % "200 "
      %true,
      trim(Info,Trim).
checkSubLError(InStream,Send,Info,Info).

evalSubL(Send,Surface:Vars):-evalSubL(Send,Surface,Vars).

evalSubL(Send,Surface,Vars):-
     converseRaw(Send,Receive),!,
     getSurfaceFromChars(Receive,Surface,Vars).

% ===================================================================
% Lowlevel printng
% ===================================================================
writeFmtFlushed(X,Y,Z):-catch((format(X,Y,Z),flush_output_safe(X)),_,true).
writeFmtFlushed(X,Y):-catch((format(X,Y),flush_output),_,true).
writeFmtFlushed(X):- once((atom(X) -> catch((format(X,[]),flush_output),_,true) ; writeFmtFlushed('~q~n',[X]))).

writel(Lisp):-writel(user_output,Lisp).

writel(OutStream,Send):-     
      writel(OutStream,Send,_Vars).

writel(OutStream,N,Vars):-N==[],!,writeFmtFlushed(OutStream,'NIL~n',[]).
writel(OutStream,Send,Vars):-     
%      (var(Send) ->
 %        throw(cyc_error('Unbound SubL message',Send));
         is_string(Send) ->
	    formatCyc(OutStream,'~s~n',[Send]);
	      % atom(Send) -> formatCyc(OutStream,'~w~n',[Send]);
      	       toCycApiExpression(Send,Vars,STerm),formatCyc(OutStream,'~w~n',[STerm]).
%	       throw(cyc_error('SubL message type not supported',Send)),


formatCyc(OutStream,Format,Args):-
      writeFmtFlushed(OutStream,Format,Args),
      debugFmt(Format,Args),
      flush_output_safe(OutStream),!.

readSubL(InStream,[G,E,T,Space|Response]):-
      get_code(InStream,G),
      get_code(InStream,E),
      get_code(InStream,T),
      get_code(InStream,Space),
      readCycLTermChars(InStream,Response),!.



% ===================================================================
% Lowlevel getSurface/lisp_read
% ===================================================================

getSurface(Surf,Vars):-getSurface(user_input,Surf,Vars).
getSurface(InStream,Surf,Vars):-
    readCycLTermChars(InStream,Response),
    getSurfaceFromChars(Response,Surf,Vars).

getSurface(Response):- readCycLTermChars(user_input,Response).


:-dynamic(saved_stream_buffer/2).
find_stream_buffer(I,B):-saved_stream_buffer(I,B),!.
find_stream_buffer(I,[]):-!. %%throw(nobuffer(I)).
set_stream_buffer(I,B):-retractall(saved_stream_buffer(I,_)),asserta(saved_stream_buffer(I,B)).

read_codes_one_at_a_time(Stream,NewBuffer):-
      set_stream_buffer(Stream,[]),
      repeat,
      read_line_to_codes_one_at_a_time_util(Stream,NewBuffer).

read_line_to_codes_one_at_a_time_util(Stream,_):-
      find_stream_buffer(Stream,NewBuffer),
      NewBuffer = [Code|Buffer],char_type(Code,space),
      set_stream_buffer(Stream,Buffer),fail.

%%debugFmt('~n NewBuffer codes: ~s~n',[NewBuffer]),
read_line_to_codes_one_at_a_time_util(Stream,NewBuffer):-
      find_stream_buffer(Stream,Buffer),
      get_code_no_eof(Stream,Code),
      append(Buffer, [Code], NewBuffer),
      set_stream_buffer(Stream,NewBuffer),
      charGoodForInput(Stream,Code),!.

:-flag(inbracket,_,0).

charGoodForInput(_Stream,''):-!,fail.
charGoodForInput(_Stream,C):-code_type(C,end_of_line),!.
charGoodForInput(_Stream,C):-flag(inbracket,N,N),charGoodForInput1(_Stream, N,C).
charGoodForInput1(_Stream,N,40):- flag(inbracket,N,N+1),!, fail.
charGoodForInput1(_Stream,N,41):- flag(inbracket,N,N-1), !, N < 2.
charGoodForInput1(_Stream,N,C):- N > 0,!,fail.
charGoodForInput1(_Stream,N,C):-code_type(C,space),!.


/*
 lisp_read_codes("() ",Sexp)
 lisp_read_codes("1 ",Sexp)
 lisp_read_codes("a1 ",Sexp)
 lisp_read_codes("( a )",S)
 lisp_read_codes("( a ) ",S)
 lisp_read_codes("(a )",S)
 
 */

% "fully" means at least one whitespace character was there
lisp_read_fully(String,SexpO):-lisp_read_fully(user_input,String,SexpO).
lisp_read_fully(InStream,String,SexpO):- phrase_codes(read_sexp_fully0(Sexp), String, []),!,
   set_stream_buffer(InStream,[]),!,processEachReadResult(InStream,Sexp,SexpO).
lisp_read_fully(InStream,String,SexpO):- %trace,
    phrase_codes(read_sexp_fully0(Sexp), String, More),set_stream_buffer(InStream,More),
    reportLeftInBuffer(InStream),!,
    processEachReadResult(InStream,Sexp,SexpO). 

%processEachReadResult(InStream,whitespace(String),SexpO):-!,whitespace(String)=SexpO.
processEachReadResult(InStream,iterateEach(List),SexpO):-!,member(E,List),processEachReadResult(InStream,E,SexpO).
processEachReadResult(InStream,read_from_string(String),SexpO):-!,lisp_read_fully(InStream,String,SexpO).
%processEachReadResult(InStream,reader_error(Error,String),_SexpO):-!,throw(reader_error(Error,String)).
processEachReadResult(InStream,SexpO,SexpO).

lisp_read_codes(String,Sexp):-phrase_codes(sexp0(Sexp), String),!.

lisp_read(Sexp) :- current_input(I),lisp_read(I,_,Sexp),!.
lisp_read(InStream,String,Sexp) :-         
        repeat,
        read_line_to_codes_one_at_a_time_util(InStream,String),        
        lisp_read_fully(InStream,String,Sexp).

reportLeftInBuffer(I):- saved_stream_buffer(I,F),F \== [], debugFmt('~n reportLeftInBuffer: "~s" ~n',[F]),!.
reportLeftInBuffer(_):- !.

phrase_codes(DCG,LEFT):-phrase_codes(DCG,LEFT,[]).
phrase_codes(A,[C|ODES],REST):-number(C),!,phrase(A,[C|ODES],REST).
phrase_codes(A,[C|ODES],REST):-atom(C),atom_length(C,1),char_code(C,NumberCode),number(NumberCode),!,atom_to_chars(Atom,[C|ODES]),!,phrase_codes(A,Atom,REST).
phrase_codes(A,String,REST):-string(String),string_to_list(String,Codes),!,phrase(A,Codes,REST).
phrase_codes(A,String,REST):-atom(String),atom_codes(String,Codes),!,phrase(A,Codes,REST).


spanStarted0(string,"\"") --> "\"".
spanStarted0(pipequoted,"|#") --> "#|".
spanStarted0(pipequoted,endOfLine) --> ";".

endOfLine --> [13,10].
endOfLine --> [10].
endOfLine --> [13].
endOfLine --> trimOffOneAndAllWhiteSpaces,!,endOfLine.



allCharsAsString(Chars,Codes,[]):-string_to_list(Chars,Codes).

% "fully" means at least one whitespace character was there
read_sexp_fully0(whitepace(Chars)) --> dcgBothC(endOfLine,allCharsAsString(Chars)),!.
read_sexp_fully0(iterateEach([whitepace(Chars),S])) --> dcgBothC(trimOffOneAndAllWhiteSpaces,allCharsAsString(Chars)),!,read_sexp_fully0(S).
read_sexp_fully0(S) --> sexp0(S), !.
read_sexp_fully0(iterateEach([Error,read_from_string(Next)])) 
  --> {member(Chars,[re(",",'unmatched close parenthesis'),re(")",'Comma not inside a backquote.')])},
      syntaxError(Chars,Error),!,
      allCharsAsString(Next).
read_sexp_fully0(iterateEach(Ns)) --> /*{!,trace},*/ listReader0(iterateEach,noMoreChars,alwaysFail,spaces0,Ns).

syntaxError(re(Chars,Error),reader_error(Error,String)) --> Chars,{string_to_list(String,Chars)}.

alwaysFail(_,_):-fail.
noMoreChars(What,[]):-What==[].

peekChar(Peek,SMORE,SMORE) :- phrase(Peek,SMORE,_).
peekContainsChar(Peek,SMORE,SMORE) :- append(Left,Right,SMORE), phrase(Peek,Right,_).


sexp0(S) --> trimOffOneAndAllWhiteSpaces,!,sexp0(S).
sexp0(S) --> sexp1(S), allowWhiteSpaces.

sexp1(quoted(S)) --> "'",!,sexp0(S).
sexp1(back_quoted(S)) --> "`",!,sexp0(S).
sexp1(comma_at_quoted(S)) --> ",@",!,sexp0(S).
sexp1(comma_quoted(S)) --> ",",!,sexp0(S).
sexp1(S) --> peekChar("("),!,list0(S).
sexp1(S) --> atom0(S).


list0(NsTyped) --> listSpan(Type,Ending,Dotted,LegalSeps),!,spaces0, listReader0(Type,Ending,Dotted,LegalSeps,Ns),{NsTyped= Ns /*..[Type,Ns]*/ ,!}.


trimOffOneAndAllWhiteSpaces --> "(",{!,fail}.
trimOffOneAndAllWhiteSpaces --> ")",{!,fail}.
trimOffOneAndAllWhiteSpaces --> oneSpace,!, spaces0.

listReader0(Type,Ending,Dotted,LegalSeps,Ns) --> trimOffOneAndAllWhiteSpaces,!,listReader0(Type,Ending,Dotted,LegalSeps,Ns).
listReader0(Type,Ending,Dotted,LegalSeps,[]) --> Ending, !.
listReader0(Type,Ending,Dotted,LegalSeps, N) --> Dotted,!, sexp0(N),!, Ending.
listReader0(Type,Ending,Dotted,LegalSeps,[N|Ns]) --> sexp0(N),!,listReader0(Type,Ending,Dotted,LegalSeps,Ns).


consElementSep-->spaces0.
listSpan(cons,")",".",consElementSep) --> "(".

allowWhiteSpaces --> endOfLine,!.
allowWhiteSpaces --> oneSpace,!,allowWhiteSpaces.
allowWhiteSpaces --> [].

oneSpace --> [X],{ X<33 }.% %, !, code_type(X,space),! }.

spaces0 --> oneSpace,!,spaces0.
spaces0 --> [].

atom0(S) --> "(",{!,fail}.
atom0(A) --> atom1(A).

atom1(A) --> spanStarted0(Type,EndChars),{!}, charsUpTo(S,EndChars), {A=..[Type,S]}.
atom1(A) --> char0(A).
atom1(A) --> number0(A).
%%atom1(A) --> {getTypeHintFromChar_hash(InStream,Chars,HashType)},Chars,symbolChars(Named),{A=..[HashType,Named]}.
atom1(A) --> symbol0(A).


number0(N) --> float0(N),!.
number0('/'(N,D)) --> integer0(N),"/",number0(D).
number0(N) --> integer0(N).

symbol0('#$'(S)) --> "#$",{!},symbolChars(S).

symbol0(nullPk(S)) --> "#:",{!},symbol1(S).
symbol0(S) --> ":",{!},symbol1(SC),{atom_concat(':',SC,S)}.
symbol0(S) --> symbol1(SC),{atom_concat('',SC,S)}.

% no upcase
symbol1(S) --> "|",{!}, charsUpTo(S,"|").
symbol1(S) --> symbolChars(S), { upcase_atom(S,S)}.
% symbol1('#$'(S)) --> symbolChars(S).
symbol1(S) --> symbolChars(S).
% symbol1(U) --> symbolChars(S), { upcase_atom(S,U)}.

char0(char(S))-->"#\\",char1(S).
char0(reader_error(char,C))-->"#\\",[C].
char1(S)--> ")",{!,string_to_list(S,")")}.
char1(S)--> "\\",{!,string_to_list(S,"\\")}.
char1(S)--> symbolChars(S),{!}.
char1(S)--> [C],{!,string_to_list(S,[C])}.


symbolChars(S) --> validSymbolChars([C|Cs]), {  string_to_list(S,[C|Cs]) }.



validSymbolChars([])--> dcgNoConsumeStartsC(invalidSymbolChar),!.
validSymbolChars([C|Cs])--> validSymbolChar(C),!,validSymbolChars(Cs).
validSymbolChars([])-->[].

validSymbolChar(C) --> dcgBothC(char0ExceptFor(C,[graph],[white]),dcgNotC(invalidSymbolChar)).
invalidSymbolChar --> meetsCharConstraitDCG([white,paren(_),quote|":,)"]).
meetsCharConstraitDCG(Include) -->  [C], {(( meetsCharConstrait(C,Include)))}.


dcgNotC(DCG2,S,E) :- not(phrase(DCG2,S,E)).
dcgBothC(DCG1,DCG2,S,R) :- append(L,R,S),phrase(DCG1,L,[]),once(phrase(DCG2,L,[])).
dcgNoConsumeStartsC(DCG,SE,SE):-phrase(DCG,SE,_).


escapedChar(C)-->[92,C]. % ,{trace}.

meetsCharConstrait(C,[]):-! /*,trace*/,  fail.
meetsCharConstrait(C,List):- member(LType,List),(LType==C ;( code_type(C,Type), LType=Type)),!.

char0ExceptFor(C,Include,Exclude) --> escapedChar(C),{!,not(member(escape, Exclude))}.
char0ExceptFor(C,Include,Exclude) --> [C], {notrace(( meetsCharConstrait(C,Include) , not(meetsCharConstrait(C,Exclude)) ))}.

chars0ExceptFor([C|Cs],Include,Exclude) --> escapedChar(C),{!,not(member(escape, Exclude))},chars0ExceptFor(Cs,Include,Exclude).
chars0ExceptFor([C|Cs],Include,Exclude) --> char0ExceptFor(C,Include,Exclude), chars0ExceptFor(Cs,Include,Exclude),!.
chars0ExceptFor([],_Include,_ExceptFor) --> [].

charsUpTo(Cs0,Except) --> charsUpTo0(Cs,Except),{string_to_list(Cs0,Cs)}.
charsUpTo0([C|Cs],Except) --> escapedChar(C), !, charsUpTo0(Cs,Except).
charsUpTo0([],Except) --> Except,{!}.
charsUpTo0([C|Cs],Except) --> [C], {!}, charsUpTo0(Cs,Except).


integer0(I) -->
        digit0(D0),
        digits0(D),!,
        noMoreSymbol,
        { number_chars(I, [D0|D]) }.



noMoreSymbol --> noMoreChars.
noMoreSymbol --> peekChar(noMoreSymbol1).
noMoreSymbol1 --> oneSpace.
noMoreSymbol1 --> invalidSymbolChar.

float0(I) -->
        digits0([D0|D0s]),
        ".",
        digits0([D1|D1s]),
        { append([D0|D0s],[46,D1|D1s],CODES),  number_codes(I, CODES) }.

digits0([D|T]) --> digit0(D), !, digits0(T).
digits0([]) --> [].

digit0(D) --> [D], { code_type(D, digit) }.


% ===================================================================
% Lowlevel readCycLTermChars
% ===================================================================
readCycLTermChars(InStream,Response):-
  readCycLTermChars(InStream,Response,_ResponseType).

readCycLTermChars(InStream,Response,ResponseType):-
   debugOnFailure(readCycLTermChars(InStream,[],[sexp],Response,ResponseType)),!.
   % (validLisp(Response)-> (!) ;(readMoreChars(Chars))).

subType(_Type,_ExpectedType).

:-set_prolog_flag(double_quotes,codes).

getTypeHintFromChar(InStream,"\"",double_quotes).
getTypeHintFromChar(InStream,"\\",any_char).
getTypeHintFromChar(InStream,";",line_comment).
getTypeHintFromChar(InStream,[10],newline).
getTypeHintFromChar(InStream,[X],whitespace):- X < 33.
getTypeHintFromChar(InStream,"#",hash_reader).
getTypeHintFromChar(InStream,":",symbol(kw)).
getTypeHintFromChar(InStream,"|",symbol(quoted)).
getTypeHintFromChar(InStream,"#|",lisp_multiline_start).
getTypeHintFromChar(InStream,"|#",lisp_multiline_end).

getTypeHintFromChar(InStream,"#<",lisp_uglyobject).

getTypeHintFromChar(InStream,Chars,HashType):-getTypeHintFromChar_hash(InStream,Chars,HashType).

getTypeHintFromChar_hash(InStream,"#$",hash_dollar).
getTypeHintFromChar_hash(InStream,"#\\x",lisp_char_hex).
getTypeHintFromChar_hash(InStream,"#\\o",lisp_char_oct).
getTypeHintFromChar_hash(InStream,"#\\d",lisp_char_dec).
getTypeHintFromChar_hash(InStream,"#\\",lisp_char).


% "whitepace reader is first"
readCycLTermChars(InStream,Sofar,[whitespace|OuterType],Response,ResponseType):-
   peek_code(InStream,White),White<33,get_code(InStream,White),
   append(Sofar,[White],Sofar2), readCycLTermChars(InStream,Sofar2,[whitespace|OuterType],Response,ResponseType).

% "whitepace reader terminator"
readCycLTermChars(InStream,Sofar,[whitespace|OuterType],ResponseOut,ResponseType):-
   peek_code(InStream,White),White>32,ResponseType=whitespace,
   typedResponse(Sofar,ResponseType,ResponseOut).

% "keyword symbol"
readCycLTermChars(InStream,":",[sexp|OuterType],ResponseOut,SubSubResponseType):-
   skip(InStream,58),
   readCycLTermChars(InStream,[],[symbol(_)|OuterType],Response,SubSubResponseType),
   atom_concat(':',Response,ResponseOut),!.

% "| quoted symbol"
readCycLTermChars(InStream,"|",[sexp|OuterType],ResponseOut,ResponseType):-
   skip(InStream,192),
   ResponseType = symbol(quoted),
   readUntilUnless("|",[92,_],InStream,Codes),
   skip(InStream,192),
   typedResponse(Codes,ResponseType,ResponseOut).

% "#\\ character start"
readCycLTermChars(InStream,"\\#",[lisp_char|OuterType],Response,char(LispCharSubType)):-
   skip(InStream,92),peek_code(InStream,Start),
   getTypeHintFromChar(InStream,[35,92,Start],LispCharType),subType(LispCharType,OuterType),
   skip(InStream,Start),
   readCycLTermChars(InStream,[],[LispCharSubType|OuterType],Response,_Done).

% "lisp char above found no subtype"
readCycLTermChars(InStream,"\\#",[lisp_char|OuterType],char(Response),char(LispCharSubType)):-
   skip(InStream,92),peek_code(InStream,Start),
   readCycLTermChars(InStream,[Start],[symbol(_)|OuterType],Response,LispCharSubType).

% "# hashreader start"
readCycLTermChars(InStream,[35],[hash_reader|OuterType],Response,HashSubTypeSubType):-
   skip(InStream,35),peek_code(InStream,Start),
   getTypeHintFromChar(InStream,[35,Start],HashSubType),subType(HashSubType,OuterType),
   skip(InStream,Start),
   readCycLTermChars(InStream,[],[HashSubType|OuterType],Response,HashSubTypeSubType).

% "\" double quotes" 
readCycLTermChars(InStream,"\"",[sexp|OuterType],ResponseOut,ResponseType):-
   skip(InStream,34),
   ResponseType = lisp_string,
   readUntilUnless("\"",[92,_],InStream,Codes),
   skip(InStream,34),
   typedResponse(Codes,ResponseType,ResponseOut).

% "( cons reader"
readCycLTermChars(InStream,"(",[sexp|OuterType],cons(ResponseHead,ResponseTail),cons(ResponseTypeHead,ResponseTypeTail)):-
   skip(InStream,40),
   readCycLTermChars(InStream,"",[sexp|OuterType],ResponseHead,ResponseTypeHead),
   readCycLTermChars(InStream,"",[constail|OuterType],ResponseTail,ResponseTypeTail),!.

% ") cons tail"
readCycLTermChars(InStream,")",[constail|OuterType],[],constail):-
   skip(InStream,41),!.

% ". cons dot"
readCycLTermChars(InStream,".",[constail|OuterType],ResponseTail,ResponseTypeTail):-
   skip(InStream,46),
   readCycLTermChars(InStream,"",[constail|OuterType],ResponseTail,ResponseTypeTail),!.

% " cons next "
readCycLTermChars(InStream,[],[constail|OuterType],ResponseTail,ResponseTypeTail):-
   readCycLTermChars(InStream,[],[sexp,constail|OuterType],ResponseTail,ResponseTypeTail),!.

% "any sexpr"
readCycLTermChars(InStream,[],[sexp|OuterType],ResponseOut,ResponseType):-
   peek_code(InStream,Start),
   readCycLTermChars(InStream,[Start],[sexp|OuterType],ResponseOut,ResponseType),!,
   debugFmt('cyc>~s (~w)~n',[RepsonseOut,Type]).

% "number sexpr"
readCycLTermChars(InStream,[Start],[sexp|OuterType],ResponseOut,ResponseType):-code_type(Start,digit),
   readCycLTermChars(InStream,[Start],[number|OuterType],ResponseOut,ResponseType),!.

% "nonwhite sexpr"
readCycLTermChars(InStream,[Start],[sexp|OuterType],ResponseOut,ResponseType):-not(code_type(Start,white)),
   readCycLTermChars(InStream,[Start],[symbol(_)|OuterType],ResponseOut,ResponseType),!.


/*
% "nonwhite sexpr"
readCycLTermChars(InStream,[Start],[symbol(_)|OuterType],ResponseOut,ResponseType):-not(code_type(Start,white)),
   readCycLTermChars(InStream,[],[symbol(_)|OuterType],ResponseOut,ResponseType),!.

% "white sexpr"
readCycLTermChars(InStream,[Start],[NotWhite|OuterType],ResponseOut,ResponseType):-code_type(Start,white),NotWhite \= whitespace,
   readCycLTermChars(InStream,[Start],[NotWhite|OuterType],ResponseOut,ResponseType),!,
*/


typedResponse(Sofar,whitespace,ResponseOut):-string_to_list(ResponseOut,Sofar).
typedResponse(Sofar,lisp_string,ResponseOut):-string_to_list(ResponseOut,Sofar).
typedResponse(Sofar,number,ResponseOut):-number_codes(ResponseOut,Sofar).
typedResponse(Sofar,symbol,ResponseOut):-atom_codes(ResponseOut,Sofar).

/*
readCycLTermCharsUntil(34,InStream,Response,string):-!, % double quoted
   get_code(InStream,_),
   readUntil(34,InStream,Response),  
   streamClear(InStream).
*/

readCycLTermCharsUntil(34,InStream,Response,string):-!, % double quoted
   readCycL(InStream,[_|Response]),
   streamClear(InStream).


readCycLTermCharsUntil(35,InStream,Response,term):-!, % removed the 35 at head
  % get_code(InStream,_),
    readCycL(InStream,[_|Response]),
   %%readUntil(10,InStream,Response),
   streamClear(InStream).

readCycLTermCharsUntil(84,InStream,[],true):-!, % TRUE
   get_code(InStream,_), % T
   streamClear(InStream).

readCycLTermCharsUntil(78,InStream,[],nil):-!, % FALSE
   get_code(InStream,_), % N
   get_code(InStream,_), % I
   get_code(InStream,_), % L
   streamClear(InStream).

readCycLTermCharsUntil(40,InStream,Trim,cons):-!,
  % get_code(InStream,_),
   readCycL(InStream,[_|Trim]),
   streamClear(InStream).

readCycLTermCharsUntil(Char,InStream,Trim,atom):-!,
  % get_code(InStream,_),
   readCycL(InStream,[_|Trim]),
   streamClear(InStream).


streamClear(InStream) :- !. %  trace,!.
% needs better solution!  .01 seconds works but .001 seconds don't :(  meaning even .01 might in some circumstances be unreliable
streamClear(InStream) :- once(catch(wait_for_input([InStream], Inputs, 0.01),E,(trace,debugFmt(E)))),Inputs=[],!.
%streamClear(InStream) :-get_code(InStream, Was),((Was == -1) -> (true);(debugFmt('FoundMore ~c ~q ~n',[Was,Was]),streamClear(InStream))),!.
streamClear(InStream) :- get_code(InStream, _Was),( (_Was == -1) -> true ; streamClear(InStream)),!.

% ===================================================================
%  Read until
% ===================================================================
get_code_no_eof(InStream,NoEOFCode):- get_code(InStream,NoEOFCode), (NoEOFCode == -1 -> throw(cyc_error('eof on',InStream)) ; true).

readUntil(Char,InStream,Response):-readUntilUnless([Char],[92,_],InStream,Response).

readUntilUnless(Chars,Unless,InStream,Response):-
      peek_code(InStream,C),
      readUntilUnless([C],Chars,Unless,InStream,Response).

% must skip over unless
readUntilUnless([Prev|Prevs],Chars,Unless,InStream,Response):-append(_,Unless,[Prev|Prevs]),!,
   get_code_no_eof(InStream,_),
   peek_code(InStream,Next),
   append([Prev|Prevs],[Next],AllPrev),
   readUntilUnless(AllPrev,Chars,Unless,InStream,ResponseSub).

% Hit termination
readUntilUnless(Prevs,Chars,Unless,InStream,Response):-append(Response,Chars,Prevs),!.

% must consume
readUntilUnless([Prev|Prevs],Chars,Unless,InStream,Response):-
   get_code_no_eof(InStream,_),
   peek_code(InStream,Next),
   append([Prev|Prevs],[Next],AllPrev),
   readUntilUnless(AllPrev,Chars,Unless,InStream,ResponseSub).
   

      
% ===================================================================
%  conversion toCycApiExpression
% ===================================================================
toMarkUp(_,Term,Vars,Out):-
   toCycApiExpression(Term,Vars,Out),!.


toCycAtom(B,'#$different'):-member(B,[neq,dif,diff,(\=)]).
%toCycAtom(B,'QUOTE'):-member(B,[('\''),(quote),'QUOTE']).
toCycAtom(B,'()'):-member(B,[(nil),([]),'NIL']).
toCycAtom(B,' '):-member(B,[(holds),('#$holds')]).
toCycAtom(B,'#$or'):-member(B,[(;)]).
%toCycAtom(B,'#$and'):-member(B,[(,)]).
toCycAtom('=>','#$implies').
toCycAtom('<=>','#$equiv').
toCycAtom('=','#$equals').
toCycAtom('==','#$same').




escapeString(R,RS):- (string(R);is_list(R)) ,string_to_atom(R,A),atom_codes(A,Codes),escapeCodes([34,92],92,Codes,RS),!.

escapeCodes(Escaped,EscapeChar,[],[]):-!.
escapeCodes(Escaped,EscapeChar,[EscapeChar,Skip|Source],[EscapeChar,Skip|New]):-!,
   escapeCodes(Escaped,EscapeChar,Source,New),!.
escapeCodes(Escaped,EscapeChar,[Char|Source],[EscapeChar,Char|New]):-member(Char,Escaped),!,
   escapeCodes(Escaped,EscapeChar,Source,New),!.
escapeCodes(Escaped,EscapeChar,[Skipped|Source],[Skipped|New]):-
   escapeCodes(Escaped,EscapeChar,Source,New),!.

is_charlist([X]):-atom(X),not(number(X)),atom_length(X,1).
is_charlist([X|T]):-atom(X),not(number(X)),atom_length(X,1),is_charlist(T),!.

is_codelist([A]):-integer(A),!,A>8,A<129,!.
is_codelist([A|L]):-integer(A),!,A>8,A<129,is_codelist(L).

is_string(X):-atom(X),!,atom_length(X,L),L>1,atom_concat('"',_,X),atom_concat(_,'"',X),!.
is_string(X):-var(X),!,fail.
is_string(string(_)):-!.
is_string("").
is_string(X):-string(X),!.
is_string(L):-is_charlist(L),!.
is_string(L):-is_codelist(L),!.

:-dynamic(asserted/4).
:-dynamic(assertion/13).
:-dynamic(('/')/2).


decyclify(X,X):-var(X);number(X),!.
decyclify([],[]):-!.
decyclify([H|T],[HH|TT]):-!,decyclify(H,HH),decyclify(T,TT),!.
decyclify(X,P):-compound(X),not(isNonCompound(X)),X=..LIST,decyclify(LIST,DL),P=DL,!.
decyclify(X,X):-not(atom(X)),!.
decyclify(B,A):-atom_concat('#$',A,B),!.
decyclify(B,B):-!.

destringify(X,X):-var(X);number(X),!.
destringify(X,S):-is_string(X),stringToCodelist(X,CL),name(S,CL),!.
destringify([],[]):-!.
destringify([H|T],[HH|TT]):-!,destringify(H,HH),destringify(T,TT),!.
destringify(X,P):-compound(X),X=..LIST,destringify(LIST,DL),P=..DL,!.
destringify(X,X):-not(atom(X)),!.
destringify(B,A):-atom_concat('#$',A,B),!.
destringify(B,B):-!.

%stringToList(X,Y):-writeq(string_to_list(X,Y)),nl,fail.
stringToList(X,Y):-var(X),!,string_to_list(X,Y).
stringToList([],[]).
stringToList("",[]).
stringToList(X,Y):-atom(X),atom_codes(X,Codes),!,stringToList(Codes,Y),!.
stringToList(X,Y):-string(X),string_to_atom(X,M),!,stringToList(M,Y).
stringToList(X,Y):-string(X),!,string_to_list(X,Y).
stringToList(X,Y):-is_string(X),!,string_to_list(X,Y).
stringToList([X|XX],Y):-concat_atom([X|XX],' ',XXX),!,string_to_list(XXX,Y).
%prologPredToCyc(Predicate):-arity(PredicateHead)

stringToCodelist(S,CL):-stringToCodelist2(S,SL),!,escapeString(SL,CS),!,stringToList(CL,CS),!.

stringToCodelist2(string(S),Codes):-!,stringToCodelist2(S,Codes).
stringToCodelist2([],[]):-!.
stringToCodelist2([[]],[]):-!.
stringToCodelist2([''],[]):-!.
stringToCodelist2([X|T],[X|T]):-is_codelist([X|T]),!.
stringToCodelist2([X|T],Codes):-atom(X),is_charlist([X|T]),!,stringToList([X|T],Codes),!.
stringToCodelist2(String,Codes):-string(String),!,string_to_atom(String,Atom),atom_codes(Atom,Codes),!.
stringToCodelist2(Atom,Codes):-atom(Atom),atom_codes(Atom,Codes),!.
stringToCodelist2(A,Codes):-toCycApiExpression_l(A,_,L),atom_codes(L,Codes),!.
stringToCodelist2(Term,Codes):-sformat(Codes,'~q',[Term]),true.

toCycApiExpressionEach([],[]).
toCycApiExpressionEach([H|T],[HH|TT]):-toCycApiExpression(H,HH),toCycApiExpressionEach(T,TT),!.

toCycApiExpression(Prolog,CycLStr):-toCycApiExpression(Prolog,[],CycLStr),!.
toCycApiExpression(Prolog,Vars,Chars):-var(Prolog),!,toCycVar(Prolog,Vars,Chars),!.
toCycApiExpression('$VAR'(0),Vars,Chars):-!,sformat(Chars,'?A',[]).
toCycApiExpression('$VAR'(VAR),Vars,Chars):-!,sformat(Chars,'?~p',['$VAR'(VAR)]).
toCycApiExpression([],_,S):-sformat(S,'()',[]),!.
toCycApiExpression(B,Vars,A):-atom(B),toCycAtom(B,A),!.
toCycApiExpression(format(S,List),Vars,Out):-!,toCycApiExpressionEach(List,OList),sformat(Out,S,OList),!.
toCycApiExpression(Prolog,Vars,Prolog):- (atom(Prolog);number(Prolog)),!.
toCycApiExpression(string(Rep),Vars,SVar):-free_variables(Rep,[Var]),!,toCycApiExpression(Var,Vars,SVar),!.
toCycApiExpression(string(Rep),Vars,'""'):-Rep==[],!.
toCycApiExpression(string(Rep),Vars,'""'):-Rep==[''],!.
toCycApiExpression(string(Rep),Vars,Chars):-nonvar(Rep),stringToCodelist(Rep,Prolog),!,sformat(Chars,'"~s"',[Prolog]),!.
toCycApiExpression(Rep,Vars,Chars):-is_string(Rep),!,stringToCodelist(Rep,Prolog),sformat(Chars,'"~s"',[Prolog]),!.
toCycApiExpression(listofvars([]),Vars,'NIL'):-!. %listofvars
toCycApiExpression(listofvars([P|List]),Vars,Chars):-!,toCycApiExpression_l([P|List],Vars,Term),sformat(Chars,'\'(~w)',[Term]),!.
toCycApiExpression(nv(List),Vars,Chars):-!,toCycApiExpression_l(List,Vars,Chars),!.
toCycApiExpression(nart(List),Vars,Chars):-!,toCycApiExpression(List,Vars,Chars),!.
toCycApiExpression(svar(_,List),Vars,Chars):-!,toCycApiExpression(List,Vars,Chars),!.
toCycApiExpression(varslist(List),Vars,Chars):-!,toCycApiExpression_vars(List,Vars,Chars),!.
toCycApiExpression(varslist(List,Vars),_,Chars):-!,toCycApiExpression_vars(List,Vars,Chars),!.
toCycApiExpression(quote(List),Vars,Chars):-toCycApiExpression(List,Vars,Term),sformat(Chars,'\'~w',[Term]),!.
toCycApiExpression((PROLOG:VARS),Vars,Chars):-append(Vars,VARS,NewVars),toCycApiExpression(PROLOG,NewVars,Chars),!.
toCycApiExpression(Prolog,Vars,Chars):-compound(Prolog),Prolog=..[P|List],not(P='.'),!,toCycApiExpression([P|List],Vars,Chars),!.
toCycApiExpression([P,A,B],Vars,Chars):-P==(':-'),B==true,toCycApiExpression(A,Vars,Chars),!.
toCycApiExpression([P,A,B],Vars,Chars):-P==(':-'),toCycApiExpression(A,Vars,TA),toCycApiExpression(B,Vars,TB),
                  sformat(Chars,'(#$sentenceImplies ~w ~w)',[TB,TA]),!. % ? enables-Generic ?
toCycApiExpression([P,A,B],Vars,Chars):-P==(':-'),toCycApiExpression(A,Vars,TA),toCycApiExpression(B,Vars,TB),
                  sformat(Chars,'(#$enables-ThingProp ~w ~w)',[TB,TA]),!. % ? enables-Generic ?
toCycApiExpression([P|List],Vars,Chars):-
	       toCycApiExpression_l([P|List],Vars,Term),
	       sformat(Chars,'(~w)',[Term]),!.

toCycApiExpression_l(NIL,Vars,''):-NIL==[].
toCycApiExpression_l([A|Rest],Vars,Chars):- Rest==[],
      toCycApiExpression(A,Vars,Chars),!.
toCycApiExpression_l([A|Rest],Vars,Chars):- is_list(Rest),
      toCycApiExpression(A,Vars,Chars1),
      toCycApiExpression_l(Rest,Vars,Chars2),
      sformat(Chars,'~w ~w',[Chars1,Chars2]),!.
toCycApiExpression_l([A|Rest],Vars,Chars):-
      toCycApiExpression(A,Vars,Chars1),
      toCycApiExpression(Rest,Vars,Chars2),
      sformat(Chars,'~w . ~w',[Chars1,Chars2]),!.

toCycApiExpression_vars(List,Vars,''):-var(List),!.
toCycApiExpression_vars([Var],Vars,Chars):-!,
		  toCycApiExpression_var(Var,Vars,Chars).
toCycApiExpression_vars([Var|Rest],Vars,Chars):-
		  toCycApiExpression_var(Var,Vars,C1),
	       toCycApiExpression_vars(Rest,Vars,C2),
	       sformat(Chars,'~w , ~w',[C1,C2]).

toCycApiExpression_var(Var,Vars,Chars):-
	    Var=..[_,Name,Value],
            %toCycVar(Name,Vars,C1),	 
	    toCycApiExpression(Value,Vars,C2),!,
	    sformat(Chars,'?~w = ~w',[Name,C2]).
toCycApiExpression_var(Value,Vars,Chars):-
	       toCycApiExpression(Value,Vars,Chars).

	       



toCycVar(Var,Val):-toCycVar(Var,_,Val).

toCycVar(Var,[VV|_],NameQ):-nonvar(VV),VV=..[_,Name,VarRef],Var==VarRef,!,sformat(NameQ,'?~w',[Name]).
toCycVar(Var,[_|Rest],Name):-nonvar(Rest),toCycVar(Var,Rest,Name).
toCycVar(VAR,_,VarName):-
      term_to_atom(VAR,AVAR),
      atom_codes(AVAR,[95|CODES]),!,
      catch(sformat(VarName,'?~s',[CODES]),_,VarName='?HYP-VAR').


% ===================================================================
%  Debugging Cyc 
% ===================================================================
     
:-dynamic_transparent(isDebug).

% Uncomment this next line to see Cyc debug messages

isDebug.

isDebug(Call):- isDebug -> Call ; true.


% ===================================================================
%  Cyc Query Cache Control
% ===================================================================
:-dynamic_transparent(cyc:cachable_query/1).
:-dynamic_transparent(cyc:cached_query/2).

user:save_cached_query:-
   tell(saved_cached_queries),
   listing_cq,
   told.

cachable_query(isa(_,_)).
cachable_query(arity(_,_)).
cachable_query(assertTemplate(_X,_Y,_Z)).
% everything?
cachable_query(_).

listing_cq:-listing(cached_query),!.
listing_cq:-
   current_prolog_flag(toplevel_print_options,TLPO),
   (format(':-dynamic(saved_cached_queries/2).~n~n')),
   set_prolog_flag(toplevel_print_options,[quoted(true), portray(true), max_depth(0), attributes(portray),numbervars(false)]),
   listingWithnumberVars(cached_query/2),
   set_prolog_flag(toplevel_print_options,TLPO).

listingWithnumberVars(F/A):-
      functor(P,F,A),
      clause(P,Ant),
      (Ant==true -> (write_term(P,[quoted(true), portray(true), max_depth(0), attributes(portray),numbervars(false)]))
         ; (write_term(P,[quoted(true), portray(true), max_depth(0), attributes(portray),numbervars(false)]),
            write(':-'),
            (write_term(Ant,[quoted(true), portray(true), max_depth(0), attributes(portray),numbervars(false)])))),
      write('.'),nl,
      fail.
listingWithnumberVars(F/A).


:-exists_file(saved_cached_queries)->true;user:save_cached_query.

:-catch([saved_cached_queries],_,true).

% ===================================================================
%  Cyc Assert
% ===================================================================

myCycAssert(Mt:CycL):-cycAssert(Mt:CycL).

cycAssert(Mt:CycL):-!,cycAssert(CycL,Mt).
cycAssert(CycL):-
   getMtForPred(CycL,Mt),
   cycAssert(CycL,Mt).

cycAssert(arity(P,A),Mt):-cycAssertNow(isa(P,'FixedArityRelation'),Mt),cycAssertNow(arity(P,A),Mt).
cycAssert(objectFoundInLocation(P,A),Mt):-cycSpatial(P),cycSpatial(A),cycAssertNow(objectFoundInLocation(P,A),Mt).
cycAssert(adjacentTo(P,A),Mt):-cycSpatial(P),cycSpatial(A),cycAssertNow(adjacentTo(P,A),Mt).
cycAssert(pathControl(A,P),Mt):-cycIsa(P,'Path-Simple'),cycIsa(A,'PhysicalDevice'),cycAssertNow(pathControl(A,P),Mt).
cycAssert(pathBetween(P,A,B),Mt):-cycIsa(P,'Path-Simple'),cycSpatial(A),cycSpatial(B),cycAssertNow(pathBetween(P,A,B),Mt).
cycAssert('locatedAtPoint-Spatial'(A,B),Mt):-cycSpatial(A),cycAssertNow('locatedAtPoint-Spatial'(A,B),Mt).
%cycAssert(genlPreds(A,P),Mt):-cycIsa(P,tRelation),cycIsa(A,'PhysicalDevice'),cycAssertNow(pathControl(A,P),Mt).

cycAssert(genls(P,A),Mt):-cycCollection(P),cycCollection(A),cycAssertNow(genls(P,A),Mt).
cycAssert(CycL,Mt):-cycAssertNow(CycL,Mt).

cycSpatial(A):-cycIsa(A,'SpatialThing-Localized').
cycCollection(A):-cycIsa(A,tCol).
cycIsa(A,B):-cycAssertNow(isa(A,B),'doom:VocabularyMt').

cycAssertNow(CycL,Mt):-
      system:retractall(cyc:cached_query(_,_)),
      termCyclify(CycL,CycLified),
      termCyclify(Mt,Mtified),
      defaultAssertOptions(DefaultOptions), 
      toCycApiExpression('CYC-ASSERT'(quote(CycLified),quote(Mtified),quote(DefaultOptions)),API),
      converse(API),!.

defaultAssertOptions(Opts):-isCycOption(defaultAssertOptions,Opts).

:-dynamic_transparent(defaultAssertMt/1).
:-dynamic_transparent(everythingMt/1).

defaultAssertMt('doom:VocabularyMt').
everythingMt('EverythingPSC').

% ===================================================================
%  Cyc Unassert/Retract
% ===================================================================
cycRetract(CycL):-getMtForPred(CycL,Mt),cycRetract(CycL,Mt).
cycRetractAll(CycL):-getMtForPred(CycL,Mt),cycRetractAll(CycL,Mt).

cycRetract(CycL,Mt):-cycQuery(CycL,Mt),!,cycUnassert(CycL,Mt),!.

cycRetractAll(CycL,Mt):-cycQuery(CycL,Mt),cycUnassert(CycL,Mt),fail.
cycRetractAll(CycL,Mt):-!.

cycUnassert(CycL,Mt):-
      system:retractall(cyc:cached_query(_,_)),
      termCyclify(CycL,CycLified),
      termCyclify(Mt,Mtified),
      converse('CYC-UNASSERT'(quote(CycLified),Mtified)).


% ===================================================================
%  Cyc Query
% ===================================================================




cycQuery(CycL):-cycQuery(CycL,'InferencePSC').
cycQuery(CycL,Mt):-
	 queryParams(Backchain,Number,Time,Depth),
	 cycQuery(CycL,Mt,Backchain,Number,Time,Depth).

cycQuery(CycL,Mt,Backchain,Number,Time,Depth):-
      copy_term(CycL,Copy),
      safe_numbervars(Copy,'$VAR',0,_),!,
      cycQuery(Copy,CycL,Mt,Vars,Backchain,Number,Time,Depth).

cycQuery(Copy,CycL,Mt,Vars,Backchain,Number,Time,Depth):-
      cached_query(Copy,Results),!,
      member(CycL,Results).

%cachable?
cycQuery(Copy,CycL,Mt,Result,Backchain,Number,Time,Depth):-cachable_query(Copy),!,
      findall(CycL,cycQueryReal(CycL,Mt,Result,Backchain,Number,Time,Depth),Save),
      (Save=[] -> (true,asserta(cached_query(Copy,[]))); (ground(Save)->asserta(cached_query(Copy,Save));true)),!,
      member(CycL,Save).

% non cachable realtime
cycQuery(Copy,CycL,Mt,Vars,Backchain,Number,Time,Depth):-
      cycQueryReal(CycL,Mt,Vars,Backchain,Number,Time,Depth).

/*
	  (clet ((*cache-inference-results* t)
	    (*allow-forward-skolemization*t)  
	    (*compute-inference-results* nil)  
	    (*unique-inference-result-bindings* t) 
	    (*generate-readable-fi-results* t))
	    (without-wff-semantics
	       (ask-template '(?SEL1 ?SEL2)  '?Formula BaseKB 0 nil nil nll )) )
	       
*/
%queryParams(Backchain,Number,Time,Depth).
%queryParams(0,	nil,	nil,	nil). % default
%queryParams(1,	nil,	nil,	nil). % used here

:-set_prolog_flag(double_quotes,codes).

queryParams(Backchain,Number,Time,Depth):-
   ignore(isCycOption(query(backchains),Backchain)),
   ignore(isCycOption(query(number),Number)),
   ignore(isCycOption(query(time),Time)),
   ignore(isCycOption(query(depth),Depth)),!.

cycQueryV(Vars,CycL):-free_variables(Vars,Free),cyc:cycQueryReal(CycL,'EverythingPSC',Free,Backchains,Number,Time,Depth).

cycQueryReal(CycL,Mt,Vars,Backchain,Number,Time,Depth):-
         once((queryParams(Backchain,Number,Time,Depth),
         termCyclify(CycL,CycLified),
         termCyclify(Mt,Mtified),
         ignore(free_variables(CycLified,Vars)))),
      %  backchain number time depth
      sublTransaction(clet('((*cache-inference-results* t)(*compute-inference-results* t)(*unique-inference-result-bindings* t)(*generate-readable-fi-results* t))',
      'without-wff-semantics'('ask-template'(listofvars(Vars),quote(CycLified),quote(Mtified),Backchain,Number,Time,Depth))),Vars).


      %(progn (csetq *pq1* (Cyc-query '(#$doom:frameRelationAllExists #$genls ?X ?Y) #$doom:FrameRelatingMt)) T)
% (clet ((res (car *pq1* )))(csetq *pq1* (cdr *pq1*))res)
      
% ===================================================================
%  Generic Cyc Transactions
% ===================================================================
sublTransaction(SubL,Result):-withoutCyc,!,withoutCyc(SubL,Result).
sublTransaction(SubL,Result):-
      ignore(once(isCycOption(cycServer,Server))),
   sublTransaction(Server,SubL,Result).

sublTransaction(Server,SubL,Result):-
   once(getCycConnection(Server,SocketId,OutStream,InStream)),
   streamClear(InStream),
   once((gensym('pqsym',PQSYM1),ignore(concat_atom(['*',PQSYM1,'*'],PQSYM)))),
   writel(OutStream,progn(defvar(PQSYM,'NIL'),csetq(PQSYM,'REMOVE-DUPLICATES'(SubL,'#\'TREE-EQUAL')),length(PQSYM))),
   get_code(InStream,G),
   get_code(InStream,E),
   get_code(InStream,T),
   get_code(InStream,Space),
   call_cleanup(
      (getTransactionSize([G,E,T],OutStream,InStream,PQSYM,SubL,Size),transGetResults(Size,OutStream,InStream,PQSYM,Result)),_,
                  (releaseTransaction(PQSYM),finishCycConnection(SocketId,OutStream,InStream))).

getTransactionSize([53,48,48],OutStream,InStream,PQSYM,SubL,Size):-
      get_code(InStream,Quote),
      readUntil(34,InStream,Errors),
      debugFmt('~n% ~w> ~s~n',[PQSYM,Errors]),!,
      streamClear(InStream),
         string_to_atom(Errors,Error),   
         sformat(SCycL,'~q',[SubL]),
      releaseTransaction(PQSYM),
      finishCycConnection(SocketId,OutStream,InStream),
      throw(cyc_error(Error,SCycL)).

getTransactionSize([50,48,48],OutStream,InStream,PQSYM,SubL,Size):-
      readUntil(10,InStream,Sizess),
      debugFmt('~n% ~w> ~s~n',[PQSYM,Sizess]),
      once((trim(Sizess,Sizes),number_codes(Size,Sizes))).

releaseTransaction(PQSYM1):-converse(csetq(PQSYM1,nil)),!.

transGetResults(0,OutStream,InStream,PQSYM,Vars):-!,fail.  % no results
transGetResults(1,OutStream,InStream,PQSYM,Vars):-Vars==[],!. %TRUE with no variables
transGetResults(Size,OutStream,InStream,PQSYM,Vars):- fail,
         Size<15,% BUG: in the reader os temporalily always ussing this normally <100 is better
         sformat(Send,'(cons (car ~w)(cdr ~w))',[PQSYM,PQSYM]),
         once((writel(OutStream,Send), 
         get_code(InStream,G),
         get_code(InStream,E),
         get_code(InStream,T),
         get_code(InStream,Space),
         readUntil(10,InStream,Result),
         %releaseTransaction(Exit,PQSYM,SocketId,OutStream,InStream),
         debugFmt('~n~s~n',[Result]),
         getSurfaceFromChars(Result,Bindings,_))),!,
         %debugFmt('~q.~n',[Result]),true,
         member(VarSet,Bindings),syncCycLVars(VarSet,Vars).

transGetResults(Size,OutStream,InStream,PQSYM,Result):-
      sformat(Send,'(clet ((res (car ~w )))(csetq ~w (cdr ~w))res)',[PQSYM,PQSYM,PQSYM]),      
      repeat,
      once((writel(OutStream,Send), 
      get_code(InStream,G),
      get_code(InStream,E),
      get_code(InStream,T),
      get_code(InStream,Space),
      peek_code(InStream,PCode),

      %readUntil(10,InStream,ResultTrim),
      readCycLTermCharsUntil(PCode,InStream,ResultTrim,Type),
      debugFmt('~n~s~n',[[PCode|ResultTrim]]))),
      eachResult(PCode,InStream,Result,[PCode|ResultTrim],Cut),
              ((Cut==cut,!);(Cut==fail,!,fail);true).

eachResult(40,InStream,Vars,ResultTrim,more):-
      getSurfaceFromChars(ResultTrim,Results,_),%debugFmt(('~q.~n',[Result])),
      syncCycLVars(Results,Vars),!.
eachResult(78,InStream,Vars,Result,fail). % NIL
%eachResult(78,InStream,Vars,Result,cut). % True/NIL
eachResult(N,InStream,Vars,Result,more):-N=N.
eachResult(35,InStream,Vars,Result,fail). % No solutions 'locatedAt-Spatial' all
eachResult(73,InStream,Vars,Result,fail). % Depth limit exceeded
eachResult(41,InStream,Vars,Result,fail).  % The previous solution was the last

syncCycLVars(Binding,PBinding):- (var(Binding);var(PBinding)),!,once(balanceBinding(Binding,PBinding)).
syncCycLVars(_,[]).
syncCycLVars([Binding|T],[PBinding|VV]):-
      once(balanceBinding(Binding,PBinding)),
      syncCycLVars(T,VV),!.

% ===================================================================
%  SubL Transactions
% ===================================================================


getAllTermAssertions(Term,Result):-termCyclify(Term,CTerm), sublTransaction(mapcar('#\'assertion-el-formula','all-term-assertions'(CTerm)),Result).


%list_to_conj(X,Y):- balanceBinding(X,Y).
list_to_conj(X,Y):-nonvar(X),var(Y),!,list_to_conjs_lr(X,Y).
list_to_conj(X,Y):-list_to_conjs_rl(X,Y).
list_to_conjs_rl(List,(A,B)):-list_to_conjs_rl(A,AL),list_to_conjs_rl(B,BL),append(AL,BL,List).
list_to_conjs_rl(List,(A;B)):-list_to_conjs_rl(A,AL),list_to_conjs_rl(B,BL),append(AL,[or|BL],List).
list_to_conjs_lr([],true):-!.
list_to_conjs_lr([T],T):-!.
list_to_conjs_lr([H|T],(H,TT)):-!,list_to_conjs_lr(T,TT).
   


balanceBinding(Binding,Binding):- (var(Binding);number(Binding)),!.
balanceBinding(string(B),string(B)):-!.
balanceBinding(Binding,BindingP):-atom(Binding),atom_concat('#$',BindingP,Binding),!.
balanceBinding(nart(B),nart(BA)):-balanceBinding(B,BA),!.
balanceBinding(nart(B),(BA)):-!,balanceBinding(B,BA),!.
balanceBinding(string(B),List):-atomSplit(List,B),!.
balanceBinding(string(B),B):-!.
balanceBinding(string([]),""):-!.
balanceBinding(quote(B),BO):-!,balanceBinding(B,BO).
balanceBinding(['noparens','#','G',[GU|ID]],guid([GU|ID])):-!.
balanceBinding([A|L],Binding):-balanceBindingCons(A,L,Binding).
%balanceBinding(Binding,BindingO):-not(Binding=[_|_]),compound(Binding),Binding=..[A|L],balanceBindingCons(A,L,BindingO),!.
balanceBinding(Binding,Binding):-!.
 
balanceBindingCons(A,L,[A|L]):- (var(A);var(L);A=string(_);number(A)),!.
balanceBindingCons('and-also',L,Binding):-balanceBindingS(L,LO), list_to_conj(LO,Binding),!.
balanceBindingCons('eval',L,Binding):-balanceBindingS(L,LO), list_to_conj(LO,Binding),!.
balanceBindingCons('#$and-also',L,Binding):-balanceBindingS(L,LO), list_to_conj(LO,Binding),!.

balanceBindingCons(A,L,Binding):-
	 balanceBinding(A,AO),
         balanceBindingCons(A,AO,L,Binding).
balanceBindingCons(A,AO,L,Binding):-
         atom(AO),!,
	 balanceBindingS(L,LO),
	 Binding=..[AO|LO],!.
balanceBindingCons(A,AO,L,Binding):-
	 balanceBindingS(L,LO),
	 Binding=[AO|LO],!.

balanceBindingS(Binding,Binding):- (var(Binding);atom(Binding);number(Binding)),!.
balanceBindingS([],[]).
balanceBindingS([V,[L]|M],[LL|ML]):-V=='\'',balanceBindingS(L,LL),balanceBindingS(M,ML).
balanceBindingS([A|L],[AA|LL]):-balanceBinding(A,AA),balanceBindingS(L,LL).
   

% ===================================================================
%  Cyclification
%
%    termCyclify(Statement,Cyclified)
%     Makes sure that atoms in Statement are prefixed witbh '#$' when comunicationg with Cyc
%
%    termCyclify(Statement,Cyclified)
%     same as termCyclify/2 but adds the constant names with (CREATE-CONSTANT "~w")
%
% ===================================================================

atom_to_number(Value,Value):-number(Value),!.
atom_to_number(Atom,Value):-catch(atom_number(Atom,Value),_Error,fail),!.
atom_to_number(Atom,Value):-catch((atom_concat('.',_,Atom),atom_concat('0',Atom,Dec),atom_number(Dec,Value)),_Error,fail),!.

termCyclify(Same,Same):- (var(Same);number(Same);string(Same);Same='$VAR'(_)),!.
termCyclify(Var,Value):-var(Var),!,toCycVar(Var,Value).
termCyclify('','""'):-!.
termCyclify([],[]):-!.
termCyclify(string(Before),Before):-var(Before),!.
termCyclify(string(Before),string(Before)):-!.
termCyclify(quote(Before),quote(After)):-!,termCyclify(Before,After).
termCyclify(nart(LIST),(O)):-termCyclify(LIST,O),!.
termCyclify(c(Before),'find-or-create-constant'(string(Before))):-atom(Before),!.
termCyclify(nart(LIST),quote(O)):-termCyclify(LIST,O),!.
termCyclify(c(Before),Before).
termCyclify(':-'(A,B),CA):-B==true,termCyclify(A,CA).
termCyclify(':-'(A,B),['#$sentenceImplies',CB,CA]):-termCyclify(A,CA),termCyclify(B,CB),!.
%termCyclify([C],Term):-compound(C),!,termCyclify(C,Term).
termCyclify(P:C,Term):-ground(P:C),concat_atom([P,':',C],A),!,termCyclify(A,Term),!.
termCyclify(Before,After):-atom(Before),!,termCyclifyAtom(Before,After),!.
termCyclify([B|BL],[A|AL]):-!,termCyclify(B,A),termCyclify(BL,AL),!.
termCyclify(Before,After):- compound(Before),!, Before=..[B|BL],termCyclify(B,CB),termCyclify(BL,CBL),!,After=[CB|CBL].


termCyclifyAtom('','""').
termCyclifyAtom('?','"?"').
termCyclifyAtom(Const,CycL):-constant(Const,_,_,_),!,atom_concat('#$',Const,CycL).
termCyclifyAtom(Before,Before):-atom_length(Before,L),L<3,!.
termCyclifyAtom(Before,After):-
      atom(Before),
      sub_atom(Before,0,1,_,F),!,
      termCyclifyAtom3(F,Before,After),!.

termCyclifyAtom3('#',Before,Before).
termCyclifyAtom3('?',Before,Before).
termCyclifyAtom3(':',Before,Before).
termCyclifyAtom3('(',Before,Before).
termCyclifyAtom3('!',Before,After):-atom_concat('!',After,Before).
termCyclifyAtom3('"',Before,Before).
termCyclifyAtom3(_,Before,After):-atom_to_number(Before,After),!.
termCyclifyAtom3(_,Before,After):-badConstant(Before),quoteAtomString(Before,After).
termCyclifyAtom3(_,Before,After):-atom_concat('#$',Before,After),makeConstant(Before).      

badConstant(Atom):-member(Char,['/','*','"','.',',',' ','!','?','#','%']),concat_atom([S,T|UFF],Char,Atom),!.
quoteAtomString([34|T],Out):-name(Out,[34|T]),!.
quoteAtomString([H|T],Out):-!,append([34,H|T],[34],Quote),name(Out,Quote).
quoteAtomString(QU,QU):-concat_atom(['"'|_],QU),!.
quoteAtomString(UQ,QU):-concat_atom(['"',UQ,'"'],QU),!.

unquoteAtom(Atom,New):-concat_atom(LIST,'"',Atom),concat_atom(LIST,New),!.

% ============================================
% Make new CycConstant
% ============================================

:-dynamic_transparent(makeConstant/0).
:-dynamic_transparent(user:isCycConstantMade/1).
:-dynamic_transparent(isCycConstantNever/1).
:-dynamic_transparent(isCycConstantNever/2).
:-dynamic_transparent(isCycConstantGuess/1).
:-dynamic_transparent(isCycConstantGuess/2).


user:isCycConstantMade(isa).
user:isCycConstantMade(or).
user:isCycConstantMade(genls).
user:isCycConstantMade('UniversalVocabularyMt').
user:isCycConstantMade('BaseKB').
user:isCycConstantMade(tCol).
user:isCycConstantMade(tPred).
user:isCycConstantMade('Microtheory').
user:isCycConstantMade(X):-constant(X,_,_,_).

%user:isCycConstantMade(X):-nonvar(X),isCycConstantGuess(X).


isCycConstantGuess(X):-nonvar(X),isCycConstant(X).
isCycConstantGuess(X):-nonvar(X),isCycConstantNever(X),!,fail.
isCycConstantGuess(X):-nonvar(X),isCycConstantGuess(H,T),atom_concat(H,T,X).
isCycConstantGuess(X):-member(X,[and,or,isa,not]).
isCycConstantGuess(ist,_).
isCycConstantGuess(implies,_).
isCycConstantGuess(adjacentTo,_).
isCycConstantGuess(objectF,_).

isCycConstantGuess(_,'Genl').
isCycConstantGuess(_,'Genls').
isCycConstantGuess(_,'isa').
isCycConstantGuess(_,'Isa').
isCycConstantGuess(_,'Type').
isCycConstantGuess(_,tPred).
isCycConstantGuess(_,tRelation).
isCycConstantGuess(_,'Function').
isCycConstantGuess(_,tCol).
isCycConstantGuess(_,'Microtheory').
%isCycConstantGuess(_,'Mt').
isCycConstantGuess(object,_).
isCycConstantGuess(inverse,_).
isCycConstantGuess(located,_).


isCycConstantGuess('arg',_).
isCycConstantGuess('genl',_).

isCycConstantNever(X):-nonvar(X),isCycConstantNever(H,T),atom_concat(H,T,X).
isCycConstantNever('doom:',_).
isCycConstantNever(_,'1').
isCycConstantNever(_,'2').
isCycConstantNever(_,'3').
isCycConstantNever(_,'4').

:-dynamic_transparent(termCyclify/2).

isCycConstant(Const):-(var(Const);is_string(Const);number(Const)),!,fail.
isCycConstant(Const):-user:isCycConstantMade(Const),!.
isCycConstant(Const):-cyc:constant(Const,_,_,_),!.
isCycConstant(Const):-holds(isa,Const,_),!.
%isCycConstant(Const):-termCyclify(Const,_),!,fail.
isCycConstant(Const):-atom(Const),atom_concat('#$',X,Const),!,isCycConstant(X).
isCycConstant(Const):-sformat(S,'(find-constant "~w")',[Const]),converseRaw(S,R),!,R=[35|_],asserta(user:isCycConstantMade(Const)).


:-dynamic(aliasConstant/2).
aliasConstant(type_of,isa).
aliasConstant(friendly,friends).
guessConstant(Xs,Y):-string_to_atom(Xs,X),aliasConstant(X,Y),!.
guessConstant(X,Y):-guessConstantFind(X,Y).
%findall(Y,guessConstantFind(X,Y),YY),member(Y,YY).
guessConstantFind(Const,Const):-isCycConstantMade(Const),!.
%guessConstantFind(Const,Const):-atom(Const),atom_concat('#$',X,Const),!.
%guessConstantFind(X,Const):-isCycConstantMade(X),atom_concat('#$',X,Const),!.
guessConstantFind(Name,R):-evalSubL('find-constant'(string(Name)),RE,_),isTrue(RE),!,balanceBinding(RE,R).
%guessConstantFind(Name,R):-evalSubL('ps-harvest-nps'(string(Name)),RS,_),isTrue(RS),!,member([_|RE],RS),balanceBinding(RE,R).
guessConstantFind(Name,R):-cycQuery('termStrings'(R,string(Name))),isTrue(R),atom(R).
guessConstantFind(Name,R):-evalSubL('denotation-mapper'(string(Name)),RSR,_),isTrue(RSR),reverse(RSR,RS),!,member([_|RE],RSR),balanceBinding(RE,R).
guessConstantFind(Name,R):-evalSubL('ps-get-cycls-for-np'(string(Name)),RS,_),isTrue(RS),!,member(RE,RS),balanceBinding(RE,R).
%guessConstantFind(Name,R):-cycQuery('wordStrings'(W,string(Name))),isTrue(W),atom(W),cycQuery('denotationRelatedTo'(W,_,_,R)).
guessConstantFind(Name,R):-evalSubL('constant-apropos'(string(Name)),RSR,_),isTrue(RSR),reverse(RSR,RS),!,member(RE,RS),balanceBinding(RE,R).
%guessConstantFind(Name,R):-evalSubL('cyclify'(string([a,Name])),RS,_),isTrue(RS),!,member([_|RE],RS),balanceBinding(RE,R).

:-dynamic_transparent(makeConstant/0).
%makeConstant.

makeConstant(_Const):-not(isCycOption(makeConstant)),!.
%makeConstant(_Const):-!.
makeConstant(Const):-atom_concat('#$',New,Const),!,makeConstant(New).
makeConstant(Const):-
   (isCycConstant(Const)->true;
   (sformat(String,'(CREATE-CONSTANT "~w")',[Const]),
   debugOnFailure(converse(String)),
   asserta(user:isCycConstantMade(Const)))),!.

%makeConstant(_Const):-!.
killConstant(Const):-atom_concat('#$',New,Const),!,killConstant(New).
killConstant(Const):-
   sformat(String,'(FI-KILL (find-or-create-constant "~w"))',[Const]),
   debugOnFailure(converse(String)),
   retractall(user:isCycConstantMade(Const)),!.

% ============================================
% Make new Microtheory
% ============================================

ensureMt(Mt):-
   makeConstant(Mt),
   cycAssert('isa'(Mt,'Microtheory'),'BaseKB').

ensureGenlMt(Sub,Super):-ensureMt(Sub),ensureMt(Super),
   cycAssert('genlMt'(Sub,Super),'BaseKB').

% ============================================
% Get An English Paraphrase
% ============================================
genParaphrase(CycL,English):-
      termCyclify(CycL,CycLfied),
      catch(evalSubL('GENERATE-PHRASE'('QUOTE'(CycLfied)),REnglish,_), cyc_error(_,REnglish),true),
      (REnglish=string(English);English=REnglish),!.

% ============================================
% dynamic Default Microtheory
% ============================================

   %everythingMt(EverythingPSC),
 %  :-cycAssert('BaseKB':'#$genlMt'(Mt,'CourseOfAction-AnalysisMt')). % Puts the defaultAssertMt/1 into Cyc 


% ============================================
% Prolog to Cyc Predicate Mapping
%
%  the following will all do the same things:
%
% ?- registerCycPred('BaseKB':isa/2). 
% ?- registerCycPred('BaseKB':isa(_,_)). 
% ?- registerCycPred(isa(_,_),'BaseKB'). 
% ?- registerCycPred('BaseKB',isa,2). 
%
%  Will make calls 
% ?- isa(X,Y)
%  Query into BaseKB for (isa ?X ?Y) 
%
% ============================================
:-dynamic_transparent(isRegisterCycPred/3).

:-module_transparent(isRegisterCycPred/3).

% ?- registerCycPred('BaseKB':isa/2). 
registerCycPred(Mt:Pred/Arity):-!,
   registerCycPred(Mt,Pred,Arity).
% ?- registerCycPred('BaseKB':isa(_,_)). 
registerCycPred(Mt:Term):-
   functor(Term,Pred,Arity),
   registerCycPred(Mt,Pred,Arity).
registerCycPred(Term):-
   functor(Term,Pred,Arity),
   registerCycPred(Mt,Pred,Arity).
   


% ?- registerCycPred(isa(_,_),'BaseKB'). 
registerCycPred(Term,Mt):-
   functor(Term,Pred,Arity),
   registerCycPred(Mt,Pred,Arity).
   
% ?- registerCycPred('BaseKB',isa,2). 
registerCycPred(Mt,Pred,0):-!,registerCycPred(Mt,Pred,2).
registerCycPred(Mt,Pred,Arity):-isRegisterCycPred(Mt,Pred,Arity),!.
registerCycPred(Mt,Pred,Arity):-
      functor(Term,Pred,Arity),
      ignore(defaultAssertMt(Mt)),
      asserta(( user:Term :- cycQuery(Term,Mt))),
      %asserta(( Mt:Term :- cycQuery(Term,Mt))),
      assertz(isRegisterCycPred(Mt,Pred,Arity)),!.


% ============================================
% Assert Side Effect Prolog to Cyc Predicate Mapping
%
% ============================================

% user:exception(undefined_predicate, Pred ,retry):- isCycOption(hookCycPredicates,true),cycDefineOrFail(Pred).

cycDefineOrFail(Mod:Pred/Arity):-atom_concat('#$',_,Pred),
      cycDefineOrFail(Mod,Pred,Arity).
cycDefineOrFail(Pred/Arity):-atom_concat('#$',_,Pred),registerCycPred(Mod,Pred,Arity).

cycDefineOrFail(Mod,Pred,Arity):-
      atom_concat('#$',_,Mod),
      registerCycPred(Mod,Pred,Arity).
cycDefineOrFail(_,Pred,Arity):-
      registerCycPred(_,Pred,Arity).

% ============================================
% Assert Side Effect Prolog to Cyc Predicate Mapping
%
% ?- assert(isa('Fido','Dog')).
% Will assert (isa Fido Dog) into BaseKB
%
% ?- assert('DogsMt':isa('Fido','Dog')).
% Will assert (isa Fido Dog) into DogsMt
% ============================================
%'$toplevel':assert(X):-assertz(Term).

ifHookRedef(_):-!.
%ifHookRedef(C):-C,!.

:-ifHookRedef((redefine_system_predicate(system:assert(_)),assert((system:assert(Term):-nonvar(Term),assertThrough(Term))))).

assertThrough(Mt:CycL):-assertThrough(Mt,CycL).
assertThrough(CycL):-mtForCycL(CycL,Mt),assertThrough(Mt,CycL).

assertThrough(ToMt,CycL):-
      functor(CycL,Pred,Arity),
      (isRegisterCycPred(Mt,Pred,Arity);atom_concat('#$',_,Pred)),!,
      ignore(ToMt=Mt),cycAssert(CycL,ToMt),!.

assertThrough(ToMt,CycL):-
      (predicate_property(Mod:CycL,_);context_module(Mod);Mod=ToMt),!,
      ignore(Mod=ToMt),
      assertz(Mod:CycL),!.

% ============================================
% Retract (All) Side Effect Prolog to Cyc Predicate Mapping
%
% ?- retractall(isa('Fido','Dog')).
% Will retract (isa Fido Dog) from BaseKB
%
% ?- retractall('DogsMt':isa('Fido','Dog')).
% Will retract (isa Fido Dog) from DogsMt
% ============================================
:-ifHookRedef((redefine_system_predicate(retractall(_)),asserta((retractall(Term):-nonvar(Term),retractAllThrough(Term))))).

retractAllThrough(Mt:CycL):-
      retractAllThrough(Mt,CycL).

retractAllThrough(CycL):-
      retractAllThrough(Mt,CycL).

retractAllThrough(ToMt,CycL):-
      functor(CycL,Pred,Arity),
      isRegisterCycPred(Mt,Pred,Arity),!,
      ignore(ToMt=Mt),
      cycRetract(CycL,ToMt),!.

retractAllThrough(ToMt,CycL):-
      (predicate_property(Mod:CycL,_);context_module(Mod);Mod=ToMt),!,
      ignore(Mod=ToMt),
      system:retractall(Mod:CycL),!.
            
% ============================================
% Retract (First) Side Effect Prolog to Cyc Predicate Mapping
%
% ?- retractall(isa('Fido','Dog')).
% Will retract (isa Fido Dog) from BaseKB
%
% ?- retractall('DogsMt':isa('Fido','Dog')).
% Will retract (isa Fido Dog) from DogsMt
% ============================================
:-ifHookRedef((redefine_system_predicate(retract(_)),asserta((retract(Term):-nonvar(Term),retractOnceThrough(Term))))).

retractOnceThrough(Mt:CycL):-
      retractOnceThrough(Mt,CycL).

retractOnceThrough(CycL):-
      retractOnceThrough(Mt,CycL).

retractOnceThrough(ToMt,CycL):-
      functor(CycL,Pred,Arity),
      isRegisterCycPred(Mt,Pred,Arity),!,
      ignore(ToMt=Mt),
      cycRetract(CycL,ToMt),!.

retractOnceThrough(ToMt,CycL):-
      (predicate_property(Mod:CycL,_);context_module(Mod);Mod=ToMt),!,
      ignore(Mod=ToMt),
      system:retract(Mod:CycL),!.

% ============================================
% Register isa/genls (more for testing :)
% ============================================

% examples
%:-registerCycPred('BaseKB',isa,2).
%:-registerCycPred('BaseKB',genls,2).
%:-registerCycPred('BaseKB',genlMt,2).


% ============================================
% Testing 
% ============================================
      
testCYC:-!.

% ===================================================================

isSlot(Var):-var(Var),!.
isSlot('$VAR'(Var)):-number(Var).

isNonCompound(Var):-isSlot(Var),!.
isNonCompound(Var):-not(compound(Var)),!.
isNonCompound(svar(_,_)):-!.
isNonCompound(Var):-is_string(Var),!.
isNonCompound(string(Var)):-!.

% ===================================================================
% CycL Term Reader
% ===================================================================
:-dynamic reading_in_comment/0.
:-dynamic reading_in_string/0.
:-dynamic read_in_atom/0.

readCycL(CHARS):-readCycL(user_input,CHARS).

really_at_end_of_stream(Stream):-not(at_end_of_stream(Stream)),not_in_escape,!,fail.
really_at_end_of_stream(Stream):-catch(stream_property(file_name,_Atom),E,(trace,debugFmt(E))).
really_at_end_of_stream(Stream):- once(wait_for_input([Stream], Inputs,0.3)),Inputs=[].

%readCycL(Stream,[])  :-at_end_of_stream(Stream).     
readCycL(Stream,CHARS)  :-
		flag('bracket_depth',_,0),
		retractall(reading_in_comment),
		retractall(reading_in_string),!,
		readCycLChars_p0(Stream,CHARS),!. % ,trim(CHARS,Trim).

readCycLChars_p0(Stream,[]):- really_at_end_of_stream(Stream),!.
readCycLChars_p0(Stream,[Char|Chars]):-
        get_code(Stream,C),
	cyclReadStateChange(C),
	readCycLChars_p1(C,Char,Stream,Chars),!.
	
readCycLChars_p1(C,Char,Stream,[]):- isCycLTerminationStateChar(C,Char),!.
readCycLChars_p1(C,Char,Stream,[]):- really_at_end_of_stream(Stream),!.
readCycLChars_p1(C,Char,Stream,Chars):-cyclAsciiRemap(C,Char),
      flag('$prev_char',_,Char),
      readCycLChars_p0(Stream,Chars),!.

not_in_escape :- not(reading_in_comment),not(reading_in_string),not(read_in_atom),flag('bracket_depth',X,X),(X<1).

isCycLTerminationStateChar(10,32):-not_in_escape,!.
isCycLTerminationStateChar(13,32):-not_in_escape,!.
isCycLTerminationStateChar(41,41):-not_in_escape,!.
%isCycLTerminationStateChar(C,C):- debugFmt('Not terminal ~c ~q ~n',[C,C]),!,fail.

cyclReadStateChange(_):- reading_in_comment,!.
cyclReadStateChange(34):-flag('$prev_char',Char,Char),   % char 92 is "\"" and will escape a quote mark
      (Char=92 -> true;(retract(reading_in_string) ; assert(reading_in_string))),!.
cyclReadStateChange(_):- reading_in_string,!.
cyclReadStateChange(59):- assert(reading_in_comment),!.
cyclReadStateChange(40):-!,flag('bracket_depth',N,N + 1).
cyclReadStateChange(41):-!,flag('bracket_depth',N,N - 1).
cyclReadStateChange(_).

cyclAsciiRemap(X,32):- (not(number(X));X>128;X<32),!.
cyclAsciiRemap(X,X):-!.


% ===================================================================
% CycL Term Parser
% ===================================================================
/*===================================================================
% getSurfaceFromChars/3 does less consistancy checking then conv_to_sterm

Always a S-Expression: 'WFFOut' placing variables in 'VARSOut'

|?-getSurfaceFromChars("(isa a b)",Clause,Vars).
Clause = [isa,a,b]
Vars = _h70

| ?- getSurfaceFromChars("(isa a (b))",Clause,Vars).
Clause = [isa,a,[b]]
Vars = _h70

|?-getSurfaceFromChars("(list a b )",Clause,Vars)
Clause = [list,a,b]
Vars = _h70

| ?- getSurfaceFromChars("(genlMt A ?B)",Clause,Vars).
Clause = [genlMt,'A',_h998]
Vars = [=('B',_h998)|_h1101]

| ?- getSurfaceFromChars("(goals Iran  (not   (exists   (?CITIZEN)   (and    (citizens Iran ?CITIZEN)    (relationExistsInstance maleficiary ViolentAction ?CITIZEN)))))",Clause,Vars).

Clause = [goals,Iran,[not,[exists,[_h2866],[and,[citizens,Iran,_h2866],[relationExistsInstance,maleficiary,ViolentAction,_h2866]]]]]
Vars = [=(CITIZEN,_h2866)|_h3347]

| ?- getSurfaceFromChars("
(queryTemplate-Reln QuestionTemplate definitionalDisplaySentence 
       (NLPatternList 
           (NLPattern-Exact \"can you\") 
           (RequireOne 
               (NLPattern-Word Acquaint-TheWord Verb) 
               (NLPattern-Word Tell-TheWord Verb)) 
           (RequireOne 
               (NLPattern-Exact \"me with\") 
               (NLPattern-Exact \"me what\")) 
           (OptionalOne 
               (WordSequence \"the term\") \"a\" \"an\") 
           (NLPattern-Template NPTemplate :THING) 
           (OptionalOne \"is\") 
           (OptionalOne TemplateQuestionMarkMarker)) 
       (definitionalDisplaySentence :THING ?SENTENCE))",Clause,Vars).

| ?- getSurfaceFromChars("(#$STemplate #$bioForProposal-short (#$NLPatternList (#$NLPattern-Template #$NPTemplate :ARG1) (#$NLPattern-Exact \"short bio for use in proposals\") (#$NLPattern-Word #$Be-TheWord #$Verb) (#$NLPattern-Exact \"\\\"\") (#$NLPattern-Template #$NPTemplate :ARG2)) (#$bioForProposal-short :ARG1 :ARG2))",Clause,Vars).

// ==================================================================== */
getSurfaceFromChars(V,Term,Vars):-var(V),!,throw(error(getSurfaceFromChars/3,'Arguments are not sufficiently instantiated')).
getSurfaceFromChars([],[],VARS).
getSurfaceFromChars(C,TERM,VARS):-atom(C),atom_codes(C,Chars),!,getSurfaceFromChars(Chars,TERM,VARS).
getSurfaceFromChars(C,TERM,VARS):-string(C),stringToList(C,List),not(C=List),!,getSurfaceFromChars(List,TERM,VARS),!.
getSurfaceFromChars(Chars,TERM,VARS):-trim(Chars,CharsClean),catch(
         (once(getSurfaceFromCleanChars(CharsClean,TERMO,VARS)),TERM=TERMO),E,(TERM=[error,E],!,fail)).

getSurfaceFromCleanChars([],[end_of_file],_):-!.
getSurfaceFromCleanChars([41|_],[end_of_file],_):-!. %  ")"
getSurfaceFromCleanChars([59|Comment],[file_comment,Atom],VARS):-atom_codes(Atom,Comment),!. %  ";"
getSurfaceFromCleanChars(Chars,WFFOut,VARSOut):- 
               once(getWordTokens(Chars,WFFClean)),
               once(getSurfaceFromToks(WFFClean,WFFOut,VARSOut)),
	       retractall(numbered_var(_,_)).
getSurfaceFromCleanChars(Comment,[unk_comment,Atom],VARS):-atom_codes(Atom,Comment),!,
      writeq(getSurfaceFromCleanChars(Comment,[unk_comment,Atom],VARS)),nl,
      trace.
               
getSurfaceFromToks(WFFClean,WFFOut,VARSOut):-
               catch((
               (once(phrase(cycl(WFF),WFFClean))),
               collect_temp_vars(VARS),!,
               ((VARS=[],VARSOut=_,WFFOut=WFF);
                    (unnumbervars(VARS,LIST),
                     cyclVarNums(LIST,WFF,WFFOut,VARSOut2) ,
                     list_to_set(VARSOut2,VARSOut1),
                     open_list(VARSOut1,VARSOut)))),ERROR,(trace,WFFOut=[error_tok,ERROR,WFFClean])),!.

%getSurfaceFromToks(['('|WFFClean],WFFOut,VARSOut):-getSurfaceFromToks(WFFClean,WFFOut,VARSOut),!.
getSurfaceFromToks(WFFClean,OUT,VARSOut):- OUT=[unk_comment,WFFClean], debugFmt('getSurfaceFromToks: ~q ~n',[OUT]),sleep(2),!.


%===================================================================
% Removes Leading and Trailing whitespaces and non ANSI charsets.
%====================================================================
:-assert(show_this_hide(trim,2)).
:-set_prolog_flag(double_quotes,codes).

trim(S,Y):-flatten(S,S2),trim2(S2,Y).

trim2(S,Y):-
      ground(S),%true,
      stringToList(S,X),
      ltrim(X,R),lists:reverse(R,Rvs), 
      addSpaceBeforeSym(Rvs,Rv),      
      ltrim(Rv,RY),lists:reverse(RY,Y),!.
     
addSpaceBeforeSym([H|T],[H,32|T]):-member(H,"?.!"),!.
addSpaceBeforeSym(H,H).

:-set_prolog_flag(double_quotes,string).

ltrim([],[]):-!.
ltrim([32,32,32,32,32,32,32|String],Out) :-trim(String,Out),!.
ltrim([32,32,32,32,32|String],Out) :-trim(String,Out),!.
ltrim([32,32,32|String],Out) :- trim(String,Out),!.
ltrim([32,32|String],Out) :- trim(String,Out),!.
ltrim([P|X],Y):- (isWhitespace(P);not(number(P));P<33;P>128),trim(X,Y),!.
ltrim(X,X).


% ===================================================================
%  CycL String to DCG Converter
% Converts up to 13 forms
%     13 Terms long
%  
% =169 Parens Pairs 'locatedAt-Spatial' the First 2 levels  
% 
% ===================================================================


%?- getSurfaceFromChars("'(ls dfg)",S,V).
%S = quote([ls, dfg])
%V = _G465 

cycl(quote(WFF)) --> ['\''],{!},cycl(WFF).
%cycl(vector(LIST)) -->  ['#','('],{!},cycl_s(LIST),[')'].
cycl(LIST) -->  ['#','('],{!},cycl_s(LIST),[')'].
cycl(nart(LIST)) -->  ['#','<','('],{!},cycl_s(LIST),[')','>'].
cycl(LIST) -->  ['('],{!},cycl_s(LIST),[')'].
cycl(WFF) -->  atomic(WFF), { ! }.
cycl('?') --> ['?'].

atomic([]) --> ['NIL'].
atomic([]) --> ['nil'].
atomic(WFF) -->  variable(WFF).
atomic(_) --> [UQ|_], {member(UQ,['(',')','<','>','?','.','#']),!,fail}.
atomic(string(WFF)) -->  string(WFF).
atomic(WFF) -->  quantity(WFF).
atomic(WFF) -->  constant(WFF).
atomic(WFF) -->  symname(WFF).

cycl_s(T) -->  ['.'],{!},cycl(T).
cycl_s([A|L]) --> cycl(A),{!} , cycl_s(L).
cycl_s([]) --> [].

quantity(Number) -->  [Number] , {  number(Number),! } .

variable(VN)-->  ['??',A], { var_number(A,VN)   } . 
variable(VN)-->  ['??'], { var_gen(A),var_number(A,VN)   } .     %Anonymous
variable(VN)-->  ['?',A], { var_number(A,VN)   } . 

checkValidConstAtoms(UQ,R):-not(member(UQ,['(',')','<','>','?','.','#'])),
      once(is_list(UQ) -> (stringToList(RR,UQ),R=string(RR)) ; R=UQ),!.
      %once(user:isCycConstantMade(UQ) -> true; assert(user:isCycConstantMade(UQ))),

                                                %preconditionFor-Props
constant(Constant) -->  ['#$'],{!},symname(C1) , { atom_concat('#$',C1,Constant)}.
constant(Constant) -->  [':'],{!},symname(C1) , { atom_concat(':',C1,Constant)}.
constant(Constant) -->  [':|'],{!},symname(C1),['|'] , { concat_atom([':|','|'],C1,Constant)}.
constant(Constant) -->  [':|','|'],{!},symname(C1),['|','|'] , { concat_atom([':||','||'],C1,Constant)}.
constant(Constant) -->  ['*'],symname(C1),['*'] , { concat_atom(['*',C1,'*'],Constant) } .

string(AA) -->  [[U|Q]] , { stringToList(AA,[U|Q]),! } .
string(UQ) -->  [UQ] , { (string(UQ);is_string(UQ)),! } .

symname(Sym) -->  [Head,':',UQ] , { checkValidConstAtoms(Head,C1),checkValidConstAtoms(UQ,C2),!,concat_atom([C1,':',C2],Sym) } .
symname(Sym) -->  [UQ] , { checkValidConstAtoms(UQ,Sym),! } .

% Makes up sequencial Variable names for anonymous cycl getPrologVars
var_gen(Atom):-idGen(Number),number_codes(Number,Codes),atom_codes(Atom,[86,65,82|Codes]). % "VAR"

variables_list([list,A]) --> qual_var(A).
variables_list([list,A]) -->  ['('],qual_var(A),[')'],!.
variables_list([list,A,B]) -->  ['('],qual_var(A),qual_var(B),[')'],! .
variables_list([list,A|QV]) -->  ['('],qual_var(A),many_qual_var(QV),[')'],!.
many_qual_var([A]) -->  qual_var(A).
many_qual_var([A|T]) -->  qual_var(A),many_qual_var(T).

% Var/Quality pairs that Sowa''s ACE examples use

qual_var(VN) --> ['('],variable(VN),[')'].
qual_var(VN) --> variable(VN).
qual_var(VN) --> ['('],variable(VN),qual(_Quality),[')'].

qual(Q) --> constant(Q), { nonvar(Q) }.

% Construct arbitrary list of args
arbitrary([]) -->  [].
arbitrary(VN)-->  ['?',A], { var_number(A,VN)   } . 
arbitrary([Head]) -->  cycl(Head).
arbitrary([A|L]) --> cycl(A) , cycl_s(L).

%======================================================================
% CLSID Generation
% idGen(+Var)
% Creates a new unique number   TODO
%
% Example:
% | ?- idGen(X).
% X = 2234
%======================================================================
idGen(X):-flag(idGen,X,X+1).
     
var_number(A,'$VAR'(VN)):-numbered_var(A,'$VAR'(VN)),!.
var_number(A,'$VAR'(VN)):-flag(get_next_num,VN,VN+1),asserta(numbered_var(A,'$VAR'(VN))),!.

:-dynamic_transparent(numbered_var/2).

% This creates ISO Prolog getPrologVars w/in a CycL/STANDARD expression to be reconstrated as after parsing is complete 

cyclVarNums([],WFF,WFF,_):-!.

cyclVarNums(LIST,'$VAR'(NUM),VAR,[=(SYM,VAR)]):-numbered_var(SYM,'$VAR'(NUM)),
               member(=(SYM,VAR),LIST).

cyclVarNums(_,Atom,Atom,[]):-atomic(Atom).
cyclVarNums(LIST,Term,NewTerm,VARLIST):-Term=..[F|ARGS],cyclVarNums_list(LIST,ARGS,VARARGS,VARLIST),NewTerm=..[F|VARARGS].

cyclVarNums_list(_LIST,[],[],[]).
cyclVarNums_list(LIST,[A|RGS],[V|ARARGS],VARLIST):-
            cyclVarNums(LIST,A,V,VARS1),
            cyclVarNums_list(LIST,RGS,ARARGS,VARS2),
            append(VARS1,VARS2,VARLIST).


unnumbervars(STUFF,UN):-sformat(S,'~W',[STUFF,[quoted(true),character_escapes(true),module(user),numbervars(true),portray(false),double_quotes(true)]]),string_to_atom(S,Atom),atom_to_term(Atom,UN,_).

open_list(V,V):-var(V).
open_list(A,B):-append(A,_,B).

unnumbervars_nil(X,Y):-!,unnumbervars(X,Y).

collect_temp_vars(VARS):-!,(findall_nodups(=(Name,Number),numbered_var(Name,Number),VARS);VARS=[]).

%================================================================
% STRING TOKENIZATION                            
%================================================================
:-assert(show_this_hide(tokenize,2)).

:-set_prolog_flag(double_quotes,codes).

toCodeList(string(S),XS):-ground(S),toCodeList(S,XS),!.
toCodeList(S,XS):-string(S),!,string_to_atom(S,A),toCodeList(A,XS),!.
toCodeList(S,XS):-atom(S),atom_codes(S,C),trim(C,XS),!.
toCodeList(S,XS):-ground(S),stringToList(S,X),trim(X,XS),!.

%getWordTokens(M,['(',surf,')']):-nonvar(M),member(34,M),!.
getWordTokens(S,Y):-toCodeList(S,XS),once( tokenize3(XS,Y) ). %,debugFmt('~q.~n',[Y]).

isWhitespace(32).
isWhitespace(N):-N<33;N>128.

tokenize3([],[]).
tokenize3([White|T],O):-isWhitespace(White),!, tokenize3(T,O).
tokenize3([C|List],[Token|TList])  :- 
%  append(_,[C|List],CharList), not(isWhitespace(C)),
  get_token(C,List,Token,Rest),
  tokenize3(Rest,TList),!.


%  cyc-> "\""
get_token(34,List,Token,Rest):-
  get_chars_until(List,Lchars,Rest,34),!,
  atom_codes(Token,[34|Lchars]).
%  atom_codes(Token,Lchars).

%  cyc-> "?"
get_token(35,[36|List],Token,Rest):-not(List=[32|_]),
  get_chars_type(List,Lchars,Rest,Type),!,
  atom_codes(Token,[35, 36|Lchars]).
%  atom_codes(Token,Lchars).

%  cyc-> "#$"
get_token(35,[36|List],Token,Rest):-not(List=[32|_]),
  get_chars_type(List,Lchars,Rest,Type),!,
  atom_codes(Token,[35, 36|Lchars]).
%  atom_codes(Token,Lchars).

%  cyc-> ":"
get_token(58,List,Token,Rest)  :-not(List=[32|_]),
  get_chars_type(List,Lchars,Rest,Type),!,
  atom_codes(Token,[58|Lchars]).

%  cyc-> "~"
get_token(126,List,Token,Rest)  :-not(List=[32|_]),
  get_chars_type(List,Lchars,Rest,Type),!,
  atom_codes(Token,[126|Lchars]).

get_token(A,List,Token,Rest)  :- 
  get_chars_type([A|List],Lchars,Rest,Type),!,
  type_codes(Type,Lchars,Token),!.


get_token(A,List,Token,Rest)  :- 
  get_chars_type([A|List],Lchars,Rest,Type),!,
  type_codes(Type,Lchars,Token),!.


%  get_chars_until(In,Out,Rest,UntilChar).
get_chars_until([UNTIL|Rest],[UNTIL],Rest,UNTIL):-!.
get_chars_until([92,UNTIL|List],Lchars,Rest,UNTIL):-
   get_chars_until(List,[UNTIL|Lchars],Rest,UNTIL).
get_chars_until([Safe|List],[Safe|Lchars],Rest,UNTIL):-
   get_chars_until(List,Lchars,Rest,UNTIL).


type_codes(num,CODES,Num):-catch(number_codes(Num,CODES),_,fail),!.
type_codes(_,[34|Lchars],String):-!,
      reverse(Lchars,[_|Rchars]),
      reverse(Rchars,LcharsNoQuotes),ground(LcharsNoQuotes),stringToList(String,LcharsNoQuotes).
      %getWordTokens(LcharsNoQuotes,S),
      %stringToList(O,LcharsNoQuotes).
type_codes(_,Lchars,Token):-!,atom_codes(Token,Lchars).

get_chars_type(L,S,L1,sep)  :-  separator(L,S,L1),!.
get_chars_type([C|L],[C|Lc],L1,S)  :- 
  check_start(S,C),
  get_word_chars(S,L,Lc,L1).

get_word_chars(S,L,Lc,L1)  :- 
  check_end(S,L,Lc,L1).
get_word_chars(S,[C|L],[C|Lc],L1)  :- 
  legal_char(S,C),
  get_word_chars(S,L,Lc,L1).

legal_char(num,C)    :-  digit(C).
legal_char(quote,C)  :-  not(bracket(_,C,_)).
legal_char(symb,C)   :-  valid_char(C).

check_start(Name,S):-bracket(Name,S,_E).
check_start(num, C)   :- start_digit(C).
check_start(symb,C)   :- valid_char(C). %, 'not'(digit(C)).
check_start(string,34) :- !.
check_start(other,C) :- true.

check_end(_,[],[],[])  :-  !.
check_end(num, [C|L],[],[C|L])  :-  'not'(digit(C)),!.
check_end(Name,[E|L],[E],L)  :-  bracket(Name,S,E),!.
%check_end(symb,[C1,C2|L],[],[C1,C2|L])  :-  member([C1,C2],["Fn"]),!.
check_end(symb,[C|L],[],[C|L])  :-  'not'(valid_char(C)).

separator([C,D,E|L],[C,D,E],L)  :-member([C,D,E],["<=>","=:=","=\\=","\\==","@=<","@>=","=..","-->"]),!.
separator([C,D|L],[C,D],L)  :-member([C,D],["~a","=>",":-","\\+","->","\\=","==","@<","@>","=<",">=","#$","//","??"]),!. %,"Fn"
separator([C|L],[C],L)  :- member(C,"*,.()'[\\]`!';= < >^{}|?%$#/"),!.

valid_char(46):-!,fail.
valid_char(39):-!,fail.
valid_char(C)  :-  letter(C); digit(C); C = 95 ; C=45 ; C=58; C=39 .
letter(C)  :-   C=45 ; C=58 ; (97 =< C, C =< 122) ; (65 =< C, C =< 90) ; C = 95 ; C=63 ; C = 64.
start_digit(C)   :- member(C,"-01234567890").
digit(C)   :- member(C,"-_.01234567890+eE").

%get_word([C|T],C,T)  :-  member(C,":,.?&amp;%"),!. % ( : , . ?)
get_word([C|T],[C],T)  :- member(C,"=&amp;()`"),!. % (=)
get_word([C,C1|T],[C,C1],T)  :- member([C,C1],["??"]),!. %"Fn",
get_word([C|T],[C|W],T2)  :-  bracket(_,C,C1),!,get_chars(0,C1,T,W,T2).
get_word([C|T],[C|W],T2)  :-  valid_start(C),!, get_chars(1,32,T,W,T2).

get_chars(K,C1,[C|T],[C|W],T2)  :-  valid_char(K,C,C1),!,get_chars(K,C1,T,W,T2).
get_chars(0,C,[C|T],[],T)  :- bracket(_,C,_), !.
get_chars(0,C,[C|T],[C],T)  :-  (C = 41; C = 93),!. % ) or ]
get_chars(1,_C1,[C|T],[],[C|T])  :-  member(C, [10,13|"=,?"]).
%get_chars(2,_C1,[C,C2|T],[],[C,C2|T])  :-  member([C,C2], ["Fn"]).

valid_start(C)  :-  valid(C). %; C = 37.  % (%)
valid_start(35).
valid_char(K,C,C1)  :-  K = 0,!, C \= C1; K = 1, valid(C).

%bracket(quote,39,39).  % single quotes
bracket(quote,34,34).  % double quotes
%bracket(list,91,93).  % square brackets []
%bracket(quote,37,37).  % Literal Percent % 
%bracket(quote,35,35).  % Literal Percent ##

quote_found(0,B,B)  :-  member(B,[34]),!.
quote_found(Q,Q,0).

var_found(0,B,C)  :-  'not'(valid(B)),var_start(C).

var_start(C)  :-  (65 =< C,C =< 90);C = 95;C = 39.

valid(C)  :-   (65 =< C, C =< 90);    % A - Z
             (97 =< C, C =< 122);   % a - z
             (48 =< C, C =< 57);    % 0 - 9
             C = 95; C = 96; C = 39;C = 45;C = 58;C = 63.  % underscore; hyphen; colon; questionmark


/*===================================================================
Convert S-Expression originating from user to a Prolog Clause representing the surface level

Recursively creates a Prolog term based on the S-Expression to be done after compiler
                                                 
Examples:

| ?- sterm_to_pterm([a,b],Pterm).
Pterm = a(b)

| ?- sterm_to_pterm([a,[b]],Pterm).    %Note:  This is a special Case
Pterm = a(b)

| ?- sterm_to_pterm([holds,X,Y,Z],Pterm).    %This allows Hilog terms to be Converted
Pterm = _h76(_h90,_h104)                    

| ?- sterm_to_pterm([X,Y,Z],Pterm).   %But still works in normal places
Pterm = _h76(_h90,_h104)                    

| ?- sterm_to_pterm(['AssignmentFn',X,[Y,Z]],Pterm).                                
Pterm = 'AssignmentFn'(_h84,[_h102,_h116])
// ====================================================================*/

sterm_to_pterm(VAR,VAR):-isSlot(VAR),!.
sterm_to_pterm([VAR],VAR):-isSlot(VAR),!.
sterm_to_pterm([X],Y):-!,nonvar(X),sterm_to_pterm(X,Y).

sterm_to_pterm([S|TERM],PTERM):-isSlot(S),
            sterm_to_pterm_list(TERM,PLIST),            
            PTERM=..[holds,S|PLIST].

sterm_to_pterm([S|TERM],PTERM):-number(S),!,
            sterm_to_pterm_list([S|TERM],PTERM).            
	    
sterm_to_pterm([S|TERM],PTERM):-nonvar(S),atomic(S),!,
            sterm_to_pterm_list(TERM,PLIST),            
            PTERM=..[S|PLIST].

sterm_to_pterm([S|TERM],PTERM):-!,  atomic(S),
            sterm_to_pterm_list(TERM,PLIST),            
            PTERM=..[holds,S|PLIST].

sterm_to_pterm(VAR,VAR):-!.

sterm_to_pterm_list(VAR,VAR):-isSlot(VAR),!.
sterm_to_pterm_list([],[]):-!.
sterm_to_pterm_list([S|STERM],[P|PTERM]):-!,
              sterm_to_pterm(S,P),
              sterm_to_pterm_list(STERM,PTERM).
sterm_to_pterm_list(VAR,[VAR]).


atomSplit(Atom,WordsO):- atomSplit(Atom,WordsO,[' ','\'',';',',','"','`',':','?','!','.','\n','\t','\r','\\','*','%','(',')']),!.

atomSplit(Atom,WordsO,List):- atom(Atom), concat_atom(Words1,' ',Atom),!, atomSplit2(Words1,Words,List),!,Words=WordsO.
atomSplit(Atom,Words,[Space|List]):-var(Atom),ground(Words),!,concat_atom(Words,Space,AtomO),!,Atom=AtomO.


atomSplit2([],[],_List):-!.
atomSplit2([Mark|S],[Mark|Words],List):- member(Mark,List),!,atomSplit2(S,Words,List),!.
atomSplit2([W|S],[A,Mark|Words],List):- member(Mark,List),atom_concat(A,Mark,W),!,atomSplit2(S,Words,List).
atomSplit2([W|S],[Mark,A|Words],List):- member(Mark,List),atom_concat(Mark,A,W),!,atomSplit2(S,Words,List).
atomSplit2([Word|S],Words,List):- member(Space,List),concat_atom(Atoms,Space,Word),Atoms=[_,_|_],interleave(Atoms,Space,Left),
                  atomSplit2(S,Right,List),append(Left,Right,WordsM),!,atomSplit2(WordsM,Words,List),!.
atomSplit2([W|S],[W|Words],List):-atomSplit2(S,Words,List).

interleave([''],Space,[Space]):-!.
interleave([Atom],_Space,[Atom]):-!.
interleave([''|More],Space,[Space|Result]):-interleave(More,Space,Result),!.
interleave([Atom|More],Space,[Atom,Space|Result]):-interleave(More,Space,Result),!.

pterm_to_sterm(VAR,VAR):- \+ compound(VAR),!.
pterm_to_sterm([X|L],[Y|Ls]):- !,pterm_to_sterm(X,Y),pterm_to_sterm(L,Ls),!.
pterm_to_sterm(P,S):-P=..L, pterm_to_sterm(L,S).
:- op(700,xfx,'=^..').
P =^.. L :- pterm_to_sterm(P,L).

% ===================================================================
% Substitution based on ==
% ===================================================================

% Usage: subst(+Fml,+X,+Sk,?FmlSk)

subst(A,B,C,D):- 
      catch(notrace(nd_subst(A,B,C,D)),_,fail),!.
subst(A,B,C,A).

nd_subst(  Var, VarS,SUB,SUB ) :- Var==VarS,!.
nd_subst(  P, X,Sk, P1 ) :- functor(P,_,N),nd_subst1( X, Sk, P, N, P1 ).

nd_subst1( _,  _, P, 0, P  ).
nd_subst1( X, Sk, P, N, P1 ) :- N > 0, P =.. [F|Args], 
            nd_subst2( X, Sk, Args, ArgS ),
            nd_subst2( X, Sk, [F], [FS] ),  
            P1 =.. [FS|ArgS].

nd_subst2( _,  _, [], [] ).
nd_subst2( X, Sk, [A|As], [Sk|AS] ) :- X == A, !, nd_subst2( X, Sk, As, AS).
nd_subst2( X, Sk, [A|As], [A|AS]  ) :- var(A), !, nd_subst2( X, Sk, As, AS).
nd_subst2( X, Sk, [A|As], [Ap|AS] ) :- nd_subst( A,X,Sk,Ap ),nd_subst2( X, Sk, As, AS).
nd_subst2( X, Sk, L, L ).




weak_nd_subst(  Var, VarS,SUB,SUB ) :- Var=VarS,!.
weak_nd_subst(        P, X,Sk,        P1 ) :- functor(P,_,N),weak_nd_subst1( X, Sk, P, N, P1 ).

weak_nd_subst1( _,  _, P, 0, P  ).

weak_nd_subst1( X, Sk, P, N, P1 ) :- N > 0, P =.. [F|Args], weak_nd_subst2( X, Sk, Args, ArgS ),
            weak_nd_subst2( X, Sk, [F], [FS] ),
            P1 =.. [FS|ArgS].

weak_nd_subst2( _,  _, [], [] ).
weak_nd_subst2( X, Sk, [A|As], [Sk|AS] ) :- X = A, !, weak_nd_subst2( X, Sk, As, AS).
weak_nd_subst2( X, Sk, [A|As], [A|AS]  ) :- var(A), !, weak_nd_subst2( X, Sk, As, AS).
weak_nd_subst2( X, Sk, [A|As], [Ap|AS] ) :- weak_nd_subst( A,X,Sk,Ap ),weak_nd_subst2( X, Sk, As, AS).
weak_nd_subst2( X, Sk, L, L ).

% ===================================================================
% PURPOSE
% This File is the bootstrap SWI-Prolog listener to hanndle CYC API requests
% So first is loads the proper files and then starts up the system
% ===================================================================


% ===================================================================
% Prolog Dependant Code
% ===================================================================

    
/*
:-swi_module(system_dependant,
      [getCputime/1,
      safe_numbervars/1,
      unnumbervars/2,
      debugFmt/1,
      debugFmt/2,
      writeFmt/1,
      writeFmt/2,
      writeFmt/3,
      fmtString/2,
      fmtString/3,
      writeFmtFlushed/1,
      writeFmtFlushed/2,
      writeFmtFlushed/3,
      saveUserInput/0,
      writeSavedPrompt/0,
      if_prolog/2,
      callIfPlatformWin32/1,
      callIfPlatformUnix/1,
      at_initialization/1,
      thread_create/3,
      current_thread/2,
      thread_exit/1,
      thread_self/1,
      thread_at_exit/1,
      thread_signal/2,
      thread_join/2,
      prolog_notrace/1,
      prolog_statistics/0,
      main/1]).
      
*/      



% ========================================================================================
% Using getCputime/1 (in Cyc code) since Eclipse prolog (another port for Cyc)  chokes on getCputime/1
% ========================================================================================
getCputime(Start):-statistics(cputime,Start).
prolog_statistics:-statistics.
prolog_notrace(G):-notrace(G).

% ========================================================================================
% Threads 
% ========================================================================================
/*thread_create(Goal,Id,Options):-thread_create((Goal),Id,[Options]).
current_thread(Id,Status):-current_thread(Id,Status).
thread_exit(Goal):-thread_exit(Goal).
thread_self(Id):-thread_self(Id).
thread_at_exit(Goal):-thread_at_exit(Goal).
thread_signal(ID,Goal):-thread_signal(ID,Goal).
thread_join(Id,X):-thread_join(Id,X).
  */
% ========================================================================================
% Some prologs have a printf() type predicate.. so I made up fmtString/writeFmt in the Cyc code that calls the per-prolog mechaism
% in SWI it''s formzat/N and sformat/N
% ========================================================================================

/*
defined above
writeFmtFlushed(X,Y,Z):-catch((format(X,Y,Z),flush_output_safe(X)),_,true).
writeFmtFlushed(X,Y):-catch((format(X,Y),flush_output),_,true).
writeFmtFlushed(X):- once((atom(X) -> catch((format(X,[]),flush_output),_,true) ; writeFmtFlushed('~q~n',[X]))).
*/

writeFmt(X,Y,Z):-catch(format(X,Y,Z),_,true).
writeFmt(X,Y):-format(X,Y).
writeFmt(X):-format(X,[]).

fmtString(X,Y,Z):-sformat(X,Y,Z).
fmtString(Y,Z):-sformat(Y,Z).

/*
:-dynamic_multifile_exported(isConsoleOverwritten/0).
:-meta_predicate_transparent(isConsoleOverwritten/0).
saveUserInput:-retractall(isConsoleOverwritten),flush_output.
writeSavedPrompt:-not(isConsoleOverwritten),!.
writeSavedPrompt:-flush_output.
writeOverwritten:-isConsoleOverwritten,!.
writeOverwritten:-assert(isConsoleOverwritten).
*/

writeErrMsg(Out,E):- message_to_string(E,S),writeFmtFlushed(Out,'<cycml:error>~s</cycml:error>\n',[S]),!.
writeErrMsg(Out,E,Goal):- message_to_string(E,S),writeFmtFlushed(Out,'<cycml:error>goal "~q" ~s</cycml:error>\n',[Goal,S]),!.
writeFileToStream(Dest,Filename):-
        catch((
        open(Filename,'r',Input),
        repeat,
                get_code(Input,Char),
                put(Dest,Char),
        at_end_of_stream(Input),
        close(Input)),E,
        writeFmtFlushed('<cycml:error goal="~q">~w</cycml:error>\n',[writeFileToStream(Dest,Filename),E])).


% ========================================================================================
% safe_numbervars/1 (just simpler safe_numbervars.. will use a rand9ome start point so if a partially numbered getPrologVars wont get dup getPrologVars
% Each prolog has a specific way it could unnumber the result of a safe_numbervars
% ========================================================================================

safe_numbervars(X):-get_time(T),convert_time(T,A,B,C,D,E,F,G),!,safe_numbervars(X,'$VAR',G,_).
safe_numbervars(Copy,X,Z):-numbervars(Copy,X,Z,[attvar(bind)]).
safe_numbervars(Copy,_,X,Z):-numbervars(Copy,X,Z,[attvar(bind)]).
%unnumbervars(X,Y):-term_to_atom(X,A),atom_to_term(A,Y,_).

% ========================================================================================
% Ensure a Module is loaded
% ========================================================================================
moduleEnsureLoaded(X):-
        catch(ensure_loaded(X),_,(catch((atom_concat('mod/',X,Y),
        ensure_loaded(Y)),_,debugFmt(';; file find error ~q ~q',[X,E])))).

% ========================================================================================
% Platform specifics
% ========================================================================================
callIfPlatformWin32(G):-prolog_flag(windows,true),!,ignore(G).
callIfPlatformWin32(G):-!.

callIfPlatformUnix(G):-not(prolog_flag(windows,true)),!,ignore(G).
callIfPlatformUnix(G):-!.

/*
:- callIfPlatformWin32(set_prolog_flag(debug_on_error,true)).
:- callIfPlatformUnix(set_prolog_flag(debug_on_error,false)).
:- callIfPlatformUnix(set_prolog_flag(debug_on_error,true)).
*/

% ========================================================================================
% Prolog specific code choices
% ========================================================================================
if_prolog(swi,G):-call(G).  % Run B-Prolog Specifics
if_prolog(_,_):-!.  % Dont run SWI Specificd or others

% used like if_prolog(bp,do_bp_stuff),if_prolog(swi,do_swi_stuff) inline in Cyc code


%at_initialization(V):-at_initialization(V),!,logOnFailureIgnore(V).


%englishAsk(String):-!.

% ===========================================================
% SOCKET SERVER - Looks 'locatedAt-Spatial' first charicater of request and decides between:
%  Http, Native or Soap and replies accordingly
% ===========================================================
/*
:-swi_module(cyc_httpd,[
   createCycServer/1,
   xmlPrologServer/1,
   read_line_with_nl/3,
   decodeRequest/2,
   invokePrologCommandRDF/6,
   serviceAcceptedClientSocketAtThread/1]).
*/

% :-include(cyc_header).



% :-use_module(cyc_threads).
%  :-ensure_loaded(system_dependant).

:-dynamic_transparent(isKeepAlive/1).

:-dynamic_transparent(isServerCreated/1).
%startCycAPIServer:-isServerCreated,!.
startCycAPIServer:- createCycServer(4600),!.
createCycServer(BasePort) :-isServerCreated(BasePort),!.
createCycServer(BasePort) :-
         asserta(isServerCreated(BasePort)),
         AsciiPort1 is BasePort+1,
         AsciiPort2 is BasePort+2,
         CFASLPORT is BasePort+14,
         COSRVER is BasePort+79,
        servantProcessCreate(nokill,'Logicmoo/CYC HTTPD/CycL/XML/SOAP Server Socket',xmlPrologServer(AsciiPort1),_,[global(4000),local(4000),trail(4000),detatched(true)]),
        servantProcessCreate(nokill,'Prolog HTTPD Server Socket',xmlPrologServer(AsciiPort2),_,[global(4000),local(4000),trail(4000),detatched(true)]), %%global(4000),local(4000),trail(4000)
        %servantProcessCreate(nokill,'CFASL Server Socket',cfaslServer(CFASLPORT),_,[]),
        %servantProcessCreate(nokill,'COPROCESSOR Server Socket',coServer(COSRVER),_,[]),
        gethostname(Hostname),catch(tcp_host_to_address(Hostname,ip(A,B,C,D)),_,true),
        sformat(IP,'~a.~a.~a.~a',[A,B,C,D]),
        ignore(IP=Hostname),
        ensureCycCallsProlog(IP,AsciiPort1),!.

xmlPrologServer(Port):-
        tcp_socket(ServerSocket),
        catch(ignore(tcp_setopt(ServerSocket, reuseaddr)),_,true),
        at_halt(tcp_close_socket(ServerSocket)),
        attemptServerBind(ServerSocket, Port),
        tcp_listen(ServerSocket, 655),
        repeat,
          acceptClientsAtServerSocket(ServerSocket),
        fail.



attemptServerBind(ServerSocket, Port):-
        catch((tcp_bind(ServerSocket, Port),
        debugFmt('% CYC Prolog API server started on port ~w. \n',[Port])),
        error(E,_),
        debugFmt('% CYC Prolog API server not started on port ~w becasue: "~w"\n',[Port,E])).

acceptClientsAtServerSocket(ServerSocket):-
		tcp_open_socket(ServerSocket, AcceptFd, _),
                 tcp_accept(AcceptFd, ClientSocket, ip(A4,A3,A2,A1)),!,
                cleanOldProcesses,!,
                %setCycOption('$source_ip',ip(A4,A3,A2,A1)),
                getPrettyDateTime(DateTime),
                %setCycOption('$datetime',DateTime),
                sformat(Name,'Dispatcher for ~w.~w.~w.~w  started ~w ',[A4,A3,A2,A1,DateTime]),
         	debugFmt('~s',[Name]),!,
        servantProcessCreate(killable,Name,serviceAcceptedClientSocketAtThread([ip(A4,A3,A2,A1)],ClientSocket),_,[]),!. %global(12800),local(12800),trail(12800)

serviceAcceptedClientSocketAtThread(OClientInfo,ClientSocket):-
       tcp_open_socket(ClientSocket,In,Out),!,
       ClientInfo = ['io'(ClientSocket,In,Out)|OClientInfo],
        setCycOption('socket',ClientSocket),
%        setCycOption('$socket_in',In),
%        setCycOption('$socket_out',Out),!,
        %set_prolog_IO(In,Out,user_error),
        ignore(catch(serviceIO(ClientInfo,In,Out),E,debugFmt(E:serviceIO(ClientInfo,In,Out)))),
        flush_output,seen,told,
        ignore(catch(close(In,[force(true)]),_,true)),
	ignore(catch(close(Out,[force(true)]),_,true)),
	ignore(catch(tcp_close_socket(ClientSocket),_,true)),
	thread_exit(ClientInfo).      

getPrettyDateTime(String):-get_time(Time),convert_time(Time, String).


%my_peek_char(In,Char):-debugFmt(my_peek_char(In,Char)),peek_char(In,Char).

serviceIO(ClientInfo,In,Out):-
        peek_char(In,Char),!,
	debugFmt('~q',serviceIOBasedOnChar([firstChar(Char)|ClientInfo],Char,In,Out)),
        serviceIOBasedOnChar([firstChar(Char)|ClientInfo],Char,In,Out),!.

serviceIOBasedOnChar(ClientInfo,'G',In,Out):-!,serviceHttpRequest(ClientInfo,In,Out).
serviceIOBasedOnChar(ClientInfo,'P',In,Out):-!,serviceHttpRequest(ClientInfo,In,Out).

serviceIOBasedOnChar(ClientInfo,'<',In,Out):-!,
         serviceSoapRequest(In,Out).  % see cyc_soap.pl

serviceIOBasedOnChar(ClientInfo,'+',In,Out):-!,
            get0(In,Plus),serviceJavaApiRequest(In,Out).

serviceIOBasedOnChar(ClientInfo,end_of_file,In,Out):-!,throw(end_of_file(In,Out)).

serviceIOBasedOnChar(ClientInfo,'(',In,Out):-!,  
         serviceCycApiRequest(ClientInfo,In,Out).

serviceIOBasedOnChar(ClientInfo,SkipChar,In,Out):- char_type(SkipChar,space),!,
	debugFmt(serviceIOBasedOnChar(ClientInfo,SkipChar)),
        get_char(In,_),
        peek_char(In,Char),!,
	%debugFmt(serviceIOBasedOnChar(ClientInfo,Char,In,Out)),
        serviceIOBasedOnChar(ClientInfo,Char,In,Out),!.

serviceIOBasedOnChar(ClientInfo,ANY,In,Out):-!,serviceJavaApiRequest(In,Out).

% ===========================================================
% PROLOGD for CYC SERVICE
% ===========================================================

readLispStream(In,PrologGoal,ToplevelVars):-readCycL(In,Trim),getSurfaceFromChars(Trim,PrologGoal,ToplevelVars),!.


serviceCycApiRequest(ClientInfo,In,Out):-
   thread_self(Session),
   retractall(isKeepAlive(Session)),
   %asserta(isKeepAlive(Session)),
        tell(Out),
 %  repeat,
	 once((readLispStream(In,PrologGoal,ToplevelVars),debugFmt('remote API Call "~q" ~n',[PrologGoal]))),
	 ignore(once(catch(once(callCycApi(Out,PrologGoal,ToplevelVars)),E,(writeFmtFlushed(Out,'500 "~q"\n',[E]),writeFmtFlushed(user_error,'% sent cyc: 500 "~q"\n',[E]))))),
         !.
  %       not(isKeepAlive(Session)).



isCycAPIQuit([A]):-nonvar(A),!,isCycAPIQuit(A).
isCycAPIQuit('API-QUIT').
isCycAPIQuit('api-quit').
isCycAPIQuit('CLOSE-JAVA-API-SOCKET').
isCycAPIQuit('QUIT').
isCycTrue(APIQUIT):-isCycAPIQuit(APIQUIT).
isCycTrue('INITIALIZE-JAVA-API-PASSIVE-SOCKET').

      
'PRINT'(X):-writel(X).

'TEST':-format('"hi"').

cfaslRead(In,Object):-get_code(In,Type),cfaslRead(Type,In,Object).
% CFASL_P_8BIT_INT
cfaslCode('CFASL_P_8BIT_INT',0).
cfaslRead(0,In,Object):-get_code(I,Object).
% CFASL_N_8BIT_INT
cfaslCode('CFASL_N_8BIT_INT',1).
cfaslRead(1,In,Object):-get_code(I,O), Object is -1*O.
% CFASL_P_16BIT_INT
cfaslCode('CFASL_P_16BIT_INT',2).
cfaslRead(2,In,Object):-get_code(I,V1),get_code(I,V2),Object is (V1+V2*256).
% CFASL_N_16BIT_INT
cfaslCode('CFASL_N_16BIT_INT',3).
cfaslRead(3,In,Object):-get_code(I,V1),get_code(I,V2),Object is -1*(V1+V2*256).
% CFASL_P_24BIT_INT
cfaslCode('CFASL_P_24BIT_INT',4).
cfaslRead(4,In,Object):-get_code(I,V1),get_code(I,V2),get_code(I,V3),Object is (V1+V2*256+V3*256*256).
% CFASL_N_24BIT_INT
cfaslCode('CFASL_N_24BIT_INT',5).
cfaslRead(5,In,Object):-get_code(I,V1),get_code(I,V2),get_code(I,V3),Object is -1*(V1+V2*256+V3*256*256).
% CFASL_P_32BIT_INT
cfaslCode('CFASL_P_32BIT_INT',6).
cfaslRead(6,In,Object):-get_code(I,V1),get_code(I,V2),get_code(I,V3),get_code(I,V4),Object is (V1+V2*256+V3*256*256+V4*256*256*256).
% CFASL_N_32BIT_INT
cfaslCode('CFASL_N_32BIT_INT',7).
cfaslRead(7,In,Object):-get_code(I,V1),get_code(I,V2),get_code(I,V3),get_code(I,V4),Object is -1* (V1+V2*256+V3*256*256+V4*256*256*256).
%CFASL_P_FLOAT
cfaslCode('CFASL_P_FLOAT',8).
cfaslRead(8,In,Object):-cfaslRead(In,V1),cfaslRead(In,V2),Object is V1 * 2^V2.
%CFASL_N_FLOAT
cfaslCode('CFASL_N_FLOAT',9).
cfaslRead(9,In,Object):-cfaslRead(In,V1),cfaslRead(In,V2),Object is -1 * V1 * 2^V2.
%CFASL_P_BIGNUM
cfaslCode('CFASL_P_BIGNUM',23).
cfaslRead(23,In,Object):-cfaslRead(In,Len),readBignum(In,Len,0,Object).
readBignum(In,0,N,N):-!.
readBignum(In,Len,SoFar,All):-cfaslRead(In,Num),R is SoFar +Num * (256^Len),Len2 is Len-1,readBignum(In,Len2,R,All).
%CFASL_N_BIGNUM
cfaslCode('CFASL_N_BIGNUM',24).
cfaslRead(24,In,Object):-cfaslRead(In,Len),readBignum(In,Len,0,O),Object is -1 * O.
%CFASL_KEYWORD
cfaslCode('CFASL_KEYWORD',10).
cfaslRead(10,In,Object):-cfaslRead(In,String),string_to_atom(String,O),prependAtom(':',O,Output).
prependAtom(S,Output,Output):-atom_concat(S,_,Output),!.
prependAtom(S,O,Output):-atom_concat(S,O,Output),!.
%CFASL_SYMBOL
cfaslCode('CFASL_SYMBOL',11).
cfaslRead(11,In,Object):-cfaslRead(In,String),string_to_atom(String,Object).
%CFASL_NIL
cfaslCode('CFASL_NIL',12).
cfaslRead(12,In,[]).
%CFASL_LIST
cfaslCode('CFASL_LIST',13).
cfaslRead(13,In,List):-cfaslRead(In,Len),cfaslReadList(In,Len,[],List).
cfaslReadList(In,0,N,N):-!.
cfaslReadList(In,Len,N,List):-cfaslRead(In,O),append(N,[O],Mid),Len2 is Len-1,cfaslReadList(In,Len2,Mid,List).
%CFASL_CONS
cfaslCode('CFASL_DOTTED',17).
cfaslRead(30,In,Out):-cfaslRead(In,Len),cfaslReadList(In,Len,[],List),cfaslRead(In,Dot),append(List,Dot,Out).
%CFASL_VECTOR
cfaslCode('CFASL_VECTOR',14).
cfaslRead(14,In,v(List)):-cfaslRead(In,Len),cfaslReadList(In,Len,[],List).
%CFASL_STRING
cfaslCode('CFASL_STRING',15).
cfaslRead(15,In,List):-cfaslRead(In,Len),cfaslReadString(In,Len,[],List).
cfaslReadString(In,0,N,N):-!.
cfaslReadString(In,Len,N,List):-get_code(In,O),append(N,[O],Mid),Len2 is Len-1,cfaslReadString(In,Len2,Mid,List).
%CFASL_CHARACTER
cfaslCode('CFASL_CHARACTER',16).
cfaslRead(16,In,Char):-get_char(In,Char).
%CFASL_GUID
cfaslCode('CFASL_GUID',25).
cfaslRead(25,In,guid(Data)):-cfaslRead(In,Data).
%CFASL_UNICODE_STRING
cfaslCode('CFASL_UNICODE_STRING',53).
cfaslRead(53,In,List):-cfaslRead(In,Len),cfaslReadString(In,Len,[],List).
%CFASL_UNICODE_CHAR
cfaslCode('CFASL_UNICODE_CHAR',52).
cfaslRead(52,In,Char):-get_char(In,Char).
%CFASL_BYTE_VECTOR
cfaslCode('CFASL_BYTE_VECTOR',26).
cfaslRead(26,In,v(List)):-cfaslRead(In,Len),cfaslReadList(In,Len,[],List).
%CFASL_CONSTANT
cfaslCode('CFASL_CONSTANT',30).
cfaslRead(30,In,Const):-cfaslRead(In,Len),toConstant(Len,Const).
%CFASL_NART
cfaslCode('CFASL_NART',31).
cfaslRead(31,In,Const):-cfaslRead(In,Len),toNart(Len,Const).
%CFASL_ASSERTION
cfaslCode('CFASL_ASSERTION',33).
cfaslRead(33,In,ist(Mt,Form)):-cfaslRead(In,Form),cfaslRead(In,Mt).
%CFASL_VARIABLE
cfaslCode('CFASL_VARIABLE',40).
cfaslRead(40,In,'$VAR'(Form)):-cfaslRead(In,Form).
%CFASL_EXTERNALIZATION
cfaslCode('CFASL_EXTERNALIZATION',51).
cfaslRead(51,In,'QUOTE'(Form)):-cfaslRead(In,Form).
%CFASL_UNKNOWN
cfaslCode('CFASL_HASHTABLE',18).
cfaslCode('CFASL_BTREE_LOW_HIGH',19).
cfaslCode('CFASL_BTREE_LOW',10).
cfaslCode('CFASL_BTREE_HIGH',21).
cfaslCode('CFASL_BTREE_LEAF',22).
cfaslCode('CFASL_RESULT_SET_SLICE',27).
cfaslCode('CFASL_ASSERTION_SHELL',34).
cfaslCode('CFASL_ASSERTION_DEF',35).
cfaslCode('CFASL_SOURCE',36).
cfaslCode('CFASL_SOURCE_DEF',37).
cfaslCode('CFASL_AXIOM',38).
cfaslCode('CFASL_AXIOM_DEF',39).
cfaslCode('CFASL_INDEX',41).
cfaslCode('CFASL_SPECIAL_OBJECT',50).
cfaslCode('CFASL_DICTIONARY',64).
cfaslCode('CFASL_SERVER_DEATH',-1).
cfaslRead(Type,In,E):-cfaslCode(Name,Type),throw(Name).

cfaslServer(Port):-
        tcp_socket(ServerSocket),
        catch(ignore(tcp_setopt(ServerSocket, reuseaddr)),_,true),
        at_halt(tcp_close_socket(ServerSocket)),
        attemptServerBind(ServerSocket, Port),
        tcp_listen(ServerSocket, 655),
        repeat,
	       acceptCFaslClient(ServerSocket),
        fail.
acceptCFaslClient(ServerSocket):-
		tcp_open_socket(ServerSocket, AcceptFd, _),
                cleanOldProcesses,!,
		tcp_accept(AcceptFd, ClientSocket, ip(A4,A3,A2,A1)),!,
                getPrettyDateTime(DateTime),
                sformat(Name,'Dispatcher for CFASL ~w.~w.~w.~w  started ~w ',[A4,A3,A2,A1,DateTime]),
                servantProcessCreate(killable,Name,serviceCfaslClient(ClientSocket),_,[global(128000),local(12800),trail(12800),detatched(true)]),!. % 
serviceCfaslClient(ClientSocket):-
	tcp_open_socket(ClientSocket, In, Out),!,
        setCycOption('$socket_in',In),
        setCycOption('$socket_out',Out),!,
        servCFasl(In,Out),
        flush_output,
	catch(tcp_close_socket(ClientSocket),_,true),
	thread_exit(complete).

servCFasl(In,Out):-
   thread_self(Session),
   retractall(isKeepAlive(Session)),
   asserta(isKeepAlive(Session)),
   repeat,
      once((
	 once((cfaslRead(In,PrologGoal), 
	    %set_output(Out),set_input(In),
	 debugFmt('%CFASL API Call ~q~n',[PrologGoal]), !,
      callCycApi(PrologGoal,ToplevelVars,Result))),
         cfaslWrite(Out,Result),flush_output_safe(Out))),
       isCycAPIQuit(PrologGoal),!.
%catch(callCycApi(Out,PrologGoal,ToplevelVars),E,writeFmtFlushed(Out,'500 "~q"\n',[E])),
%flush_output_safe(Out))),
      	
% NUMBER
cfaslWrite(Out,O):-number(O),encodeNumber(O,E),cfaslWriteSeq(Out,E).
cfaslWriteSeq(Out,[]):-!.
cfaslWriteSeq(Out,[V|O]):-put(Out,V),cfaslWriteSeq(Out,O).
% STRING                                                                                                          //53
cfaslWrite(Out,S):-is_string(S),string_to_atom(S,A),atom_codes(A,C),length(C,L),put(Out,53),cfaslWrite(Out,L),cfaslWriteSeq(Out,C).
cfaslWrite(Out,S):-atom(S),atom_concat('"',_,S),unquoteAtom(S,New),atom_codes(New,C),cfaslWrite(Out,C).
% NIL
cfaslWrite(Out,[]):-put(Out,12).
cfaslWrite(Out,'NIL'):-put(Out,12).
% LIST
cfaslWrite(Out,[H|T]):-proper_list([H|T]),length([H|T],N),put(Out,13),cfaslWrite(Out,N),cfaslWriteList(Out,[H|T]).
cfaslWriteList(Out,[]):-!.
cfaslWriteList(Out,[H|T]):-cfaslWrite(Out,H),cfaslWriteList(Out,T).
% CONS
cfaslWrite(Out,[H|T]):-not(proper_list([H|T])),properPart([H|T],PP),length(PP,N),put(Out,17),cfaslWrite(Out,N),cfaslWriteList(Out,PP),improperPart([H|T],IP),cfaslWrite(Out,IP).
% HLVAR
cfaslWrite(Out,'$VAR'(N)):-put(Out,40),cfaslWrite(Out,N).
% ELVAR
cfaslWrite(Out,V):-var(V),term_to_atom(V,A),cfaslWrite(Out,A).
% CFASL_KEYWORD 
cfaslWrite(Out,V):-atom(V),atom_concat(':',N,V),put(Out,10),string_to_atom(S,N),cfaslWrite(Out,S).
%CFASL_SYMBOL
cfaslWrite(Out,V):-atom(V),atom_concat('_',N,V),atom_concat('?',N,VV),cfaslWrite(Out,VV).
cfaslWrite(Out,V):-atom(V),once(toUppercase(V,VU)),VU==V,put(Out,11),string_to_atom(S,N),cfaslWrite(Out,S).
%CONSTANT
cfaslWrite(Out,V):-atom(V),fromConstant(V,Guid),put(Out,30),cfaslWrite(Out,Guid),!.
%GUID
cfaslWrite(Out,guid(Data)):-put(Out,25),cfaslWrite(Out,Data).
%NART
cfaslWrite(Out,nart([H|T])):-put(Out,51),put(Out,31),cfaslWrite(Out,[H|T]).
cfaslWrite(Out,nart(Int)):-put(Out,31),cfaslWrite(Out,Int).
%ASSERTION
cfaslWrite(Out,ist(Mt,Assert)):-put(Out,51),put(Out,33),cfaslWrite(Out,Assert),cfaslWrite(Out,Mt).

%:-module_transparent(assertion/13).
%:-dynamic(assertion/13).
%:-multifile(assertion/13).

:-module_transparent(constant/4).
:-dynamic(constant/4).
%user:constant(A,B,C,D):-cyc:constant(A,B,C,D).

:-dynamic(constantGuid/2).
constantGuid(Const,ID):-cyc:constant(Const,_,ID,_).
fromConstant(Const,guid(BB)):-constantGuid(Const,Guid),!,atom_codes(Guid,BB).
fromConstant(Const,Id):-constantId(Const,Id),!.
fromConstant(Const,BB):-sformat(S,'(constant-external-id (find-constant "~w"))',[Const]),evalSubL(S,X,_),balanceBinding(X,BB),
         BB=guid(String),string_to_atom(String,Atom),
         asserta(constantGuid(Const,Atom)).

:-dynamic(constantId/2).
constantId(Const,ID):-cyc:constant(Const,ID,_,_).
toConstant(Len,Const):-constantId(Const,Len),!.
toConstant(Len,Const):-integer(Len),sformat(S,'(find-constant-by-internal-id ~w)',[Len]),evalSubL(S,X,_),balanceBinding(X,BB),
         unhashConstant(BB,Const),
         asserta(constantId(Const,Len)),!.
toConstant(guid(Guid),Const):-!,toConstant(Guid,Const).
toConstant(Guid,Const):-is_string(Guid),!,string_to_atom(Guid,Atom),toConstant(Atom,Const).
toConstant(Guid,Const):-constantGuid(Const,Guid),!.
toConstant(Len,Const):-concat_atom([A,B|C],'-',Len),sformat(S,'(find-constant-by-external-id (string-to-guid "~w"))',[Len]),evalSubL(S,X,_),balanceBinding(X,BB),
         unhashConstant(BB,Const),
         asserta(constantGuid(Const,Len)),!.
toConstant(C,CU):-unhashConstant(C,CU).

isTrue(V):-var(V),!.
isTrue([]):-!,fail.
isTrue('NIL'):-!,fail.
isTrue('nil'):-!,fail.
isTrue('false'):-!,fail.
isTrue('fail'):-!,fail.
isTrue('no'):-!,fail.
isTrue(X:_):-!,isTrue(X).
isTrue(_).



:-module_transparent(user:nart/3).

nart(not,not,not).
toNart(Id,Nart):-nart(Id,_,Nart),!.
toNart(Id,Nart):-nart(_,Id,Nart),!.
toNart(nart(Nart),nart(Nart)):-!.
toNart(Nart,nart(Nart)).
 

unhashConstant(HConst,Const):-atom_concat('#$',Const,HConst),!.
unhashConstant(Const,Const).

properPart(T,[]):-not(T=[_|_]).
properPart([H|T],[H|CDR]):-properPart(T,CDR).
improperPart(T,T):-not(T=[_|_]).
improperPart([H|T],CDR):-improperPart(T,CDR).






isWhole(O,W):-number(O),W is round(O),atom_number(A2,W),atom_number(A1,O),(atom_concat(A2,'.0',A1);atom_concat(A2,A1)).

encodeIntNumber(Int,[NCode|Rest]):-Int<0, NInt is -1 * Int,encodeIntNumber(NInt,[Code|Rest]),NCode is Code+1,!.
encodeIntNumber(Int,[0,Int]):-Int<256.
encodeIntNumber(Int,[2,V1,V2]):-Int<65536,V1 is 255 /\ Int,V2 is ((255*256) /\ Int)>>8.
encodeIntNumber(Int,[4,V1,V2,V3]):-Int<16777216,V1 is 255 /\ Int,V2 is ((255*256) /\ Int)>>8,V3 is ((255*256) /\ Int)>>16.
encodeIntNumber(Int,[6,V1,V2,V3,V4]):-Int<4294967296, V1 is 255 /\ Int,V2 is ((255*256) /\ Int)>>8 ,V3 is ((255*256*256) /\ Int)>>16,V4 is ((255*256*256*256) /\ Int)>>24.
encodeIntNumber(Int,[23|VAL]):-V1 is 255 /\ Int,Int2 is (Int - V1)>>8, encodeIntNumber(Int2,1,REST,Len),encodeIntNumber(Len,LE),append(LE,[V1|REST],VAL).
encodeIntNumber(Int,N,[],N):-Int<1,!.
encodeIntNumber(Int,N,[V1|All],O):-V1 is 255 /\ Int, NN is N+1, IntN is (Int-V1)>>8,encodeIntNumber(IntN,NN,All,O).


%CFASL_P_BIGNUM
%cfaslRead(23
encodeNumber(N,E):-integer(N),!,encodeIntNumber(N,E).
encodeNumber(N,E):-encodeRNumber(N,E).
encodeRNumber(Int,[NCode|Rest]):-Int<0, NInt is -1.0 * Int,encodeRNumber(NInt,[Code|Rest]),NCode is Code+1,!.
%encodeRNumber(N,[8|RESAT]):-isWhole(N,W),!,encodeIntNumber(W,IE),append(IE,[0,0],RESAT).
encodeRNumber(N,[8|STUFF]):-encodeRNumber(N,0,W,RR),encodeIntNumber(W,IE),encodeIntNumber(RR,RE),append(IE,RE,STUFF).

encodeRNumber(N,R,W,R):-isWhole(N,W),!.
encodeRNumber(N,R,NNN,RRR):-NN is N*2,RR is R-1,encodeRNumber(NN,RR,NNN,RRR).


   
%callCycApi(Out,[string("prologProcForCycPred-pos-proc"), ['#$prologCycPred2', 1, _G5354]], [var0=_G5354|_G5514], _G5523).
callCycApi(Out,[string(Predstring), Call],ToplevelVars):- string_to_atom(Predstring,Atom),concat_atom([H|T],'-',Atom),!,
      cycPredCall([H|T],Call,Result),!,
      writel(Out,Result,ToplevelVars),!.
         
callCycApi(Out,PrologGoal,ToplevelVars):-cycGoal(PrologGoal,ToplevelVars,Result),writel(Out,Result,ToplevelVars),!.





:-dynamic(evalSubLCache/2).


%passAlong([H|T],Y):-X=..[H|T],!,passAlong(X,Y).
%passAlong(X,Y):-evalSubLCache(X,Y),!.
passAlong(X,Y):-toCycApiExpression(X,CycLX),evalSubL(CycLX,Y,Vars),asserta(evalSubLCache(X,Y)).


notraceTry(Goal):-notrace(ignore(catch(Goal,E,debugFmt(Goal-E)))).


cycGoal(X,Y,Z):-debugFmt('?- ~q.~n',[cycGoal(X,Y,Z)]),fail.
cycGoal([],Vars,[]):-!.
%cycGoal(['END-OF-FILE'|_],_,'NIL'):-!.
cycGoal(['END-OF-FILE'|_],_,'NIL'):-!.
%cycGoal([APIQUIT|_],_,'T'):-isCycTrue(APIQUIT),!.
%writecycGoal(['CONSTANT-INFO-FROM-GUID-STRINGS'|
%cycGoal(['CYC-QUERY',PrologGoal,MT|OPTS],ToplevelVars,Result):-sterm_to_pterm(PrologGoal,PTERM), findall(ToplevelVars,PTERM,Result),!.
%cycGoal(X,Vars,Lisp):- debugFmt(passIn(X)),passAlong(X,Y),toCycApiExpression(Y,Vars,Lisp),debugFmt('\n% Pass back->'),debugFmt(Lisp),!.

cycGoal(['PEVAL', string(EVAL)], _G94, Result):-
      catch((atom_to_term(EVAL,PTERM,ToplevelVars),catch(predicate_property(PTERM,_),_,fail),!,
          debugFmt('?- ~q.~n',[PTERM]),
         catch(findall(ToplevelVars,PTERM,Result),E,Result=[E]),
         debugFmt('-> ~q.~n',[ToplevelVars:Result])),E,Result=[E]),!.


cycGoal(PrologGoal,ToplevelVars,Result):-once(sterm_to_pterm(PrologGoal,PTERM)),catch(predicate_property(PTERM,_),_,fail),!,
          debugFmt('?- ~q.~n',[PTERM]),
         findall(ToplevelVars,PTERM,Result),!,
          debugFmt('-> ~q.~n',[ToplevelVars:Result]),!.
          
%cycGoal([F|A],ToplevelVars,Result):-toUppercase([F|A],FU),not([F|A]==FU),!,cycUCaseGoal(FU,ToplevelVars,Result),!.
cycGoal(X,Y,Z):-functor(X,F,_),sformat(S,'"~q is not defined in the API"',[F]),throw(unknown(S,X)),!.

%cycGoal(['FIND-CONSTANT',STRING],ToplevelVars,Result):-string_to_atom(String,Atom),atom_concat('#$',Atom,Result).
%cycGoal(['DEFVAR',NAME,VALUE|_],ToplevelVars,NAME).


user:keepUpWithAssertions:-
      evalSubL('(assertion-count)',X:Var),
       flag('$cyc_assertion_pointer',_,X-100),
       crawlAssertionsBG.





crawlAssertions:- 
     flag('$cyc_assertion_pointer',_,0),crawlAssertionsBG,crawlAssertionsBG.
   
crawlAssertionsBG:-
createProcessedGoal((
      repeat,
      flag('$cyc_assertion_pointer',Current,Current+1),
      ignore(once(once(catch(cacheAssertionById(Current),_,(flag('$cyc_assertion_pointer',Down,Down-100),sleep(5),fail));flag('$cyc_assertion_pointer',Down,Down-100)))),
      fail)).


:- dynamic cycAssertionCache/6.
% :- index(cycAssertionCache(0,1,1,1,1,0)).
cacheAssertionById(Id):-cycAssertionCache(Id,Assertion,Mt,Strength,Direction,Vars),!.
cacheAssertionById(Id):-getAssertionById(Id,Assertion,Mt,Strength,Direction,Vars),
      asserta(cycAssertionCache(Id,Assertion,Mt,Strength,Direction,Vars)).


getAssertionById(Id,Assertion,Mt,Strength,Direction,Vars):-
      sformat(S,'(clet ((assrt (find-assertion-by-id ~w)))(list (assertion-id assrt) (assertion-formula assrt) (assertion-mt assrt) (assertion-el-formula assrt) (asserted-by assrt)(assertion-truth assrt) (asserted-when assrt)  (GET-ASSERTED-ARGUMENT  asrt) (assertion-direction assrt)  (assertion-strength assrt)))',[Id]),
      evalSubL(S,Surf),
      once(getAssertionById2(Surf,Assertion,Mt,Strength,Direction,Vars)).

getAssertionById2([[[[ist,Mt,[Assertion]]],Strength,Direction]]:Vars,NewAssertion,NewMt,Strength,Direction,GVars):-
         s2p(Assertion,NewAssertion,MoreVars),s2p(Mt,NewMt,MtVars),append(MoreVars,Vars,AllVars1),append(AllVars1,MtVars,AllVars),ssort(AllVars,GVars).
getAssertionById2(Surf:Vars,Surf,'NIL',Strength,Direction,Vars).

ssort(X,[]):-var(X),!.
ssort(X,Y):-sort(X,Y).


'API-QUIT':-'api-quit'.
'api-quit':-thread_self(Session),retractall(isKeepAlive(Session)),told.


listingToString(Pred,RS):-
      findall(':-'(Pred,X),clause(Pred,X),R1),
      termCyclify(R1,R2),
      toCycApiExpression(R2,_,R),escapeString(R,RS),!.


noCaseChange([],[]):-!.
noCaseChange(VAR,VAR):-var(VAR),!.
noCaseChange(MiXed):-atom(MiXed),atom_concat('#$',_,MiXed),!.
noCaseChange(c(VAR),c(VAR)):-!.

/*
         toUppercase/2,
         toLowercase/2,
         toPropercase/2,
         toCamelcase/2,

toUppercase(MiXed,MiXed):-noCaseChange(MiXed),!.
toUppercase(V,V2):-string(V),!,atom_codes(V,VC),toUppercase(VC,CVC),string_to_atom(V2,CVC),!.
toUppercase(95,45):-!.
toUppercase(I,O):-integer(I),!,to_upper(I,O).
toUppercase([A|L],[AO|LO]):-
   toUppercase(A,AO),!,
   toUppercase(L,LO),!.
toUppercase(MiXed,CASED):-atom(MiXed),upcase_atom(MiXed,CASED),!.
toUppercase(MiXed,CASED):-atom(MiXed),!,
   atom_codes(MiXed,Codes),
   toUppercase(Codes,UCodes),
   atom_codes(CASED,UCodes),!.
toUppercase(MiXed,CASED):-compound(MiXed),MiXed=..MList,toUppercase(MList,UList),!,CASED=..UList.
toUppercase(A,A).

toLowercase(MiXed,MiXed):-noCaseChange(MiXed),!.
toLowercase(V,V2):-string(V),!,atom_codes(V,VC),toLowercase(VC,CVC),string_to_atom(V2,CVC),!.
toLowercase(95,45):-!.
toLowercase(I,O):-integer(I),!,to_lower(I,O).
toLowercase([A|L],[AO|LO]):-
   toLowercase(A,AO),!,
   toLowercase(L,LO),!.
toLowercase(MiXed,CASED):-atom(MiXed),downcase_atom(MiXed,CASED),!.
toLowercase(MiXed,CASED):-atom(MiXed),!,
   atom_codes(MiXed,Codes),
   toLowercase(Codes,UCodes),
   atom_codes(CASED,UCodes),!.
toLowercase(MiXed,CASED):-compound(MiXed),MiXed=..MList,toLowercase(MList,UList),!,CASED=..UList.
toLowercase(A,A).


toPropercase(VAR,VAR):-var(VAR),!.
toPropercase([],[]):-!.
toPropercase([CX|Y],[D3|YY]):-!,toPropercase(CX,D3),toPropercase(Y,YY).
toPropercase(D3,DD3):-atom(D3),member(V,[' ','-','_',':','mt','doom','Mt','Doom']),concat_atom([L,I|ST],V,D3),toPropercase([L,I|ST],LIST2),toPropercase(V,VV),concat_atom(LIST2,VV,DD3).
toPropercase(CX,Y):-atom(CX),name(CX,[S|SS]),char_type(S,to_lower(NA)),name(NA,[N]),name(Y,[N|SS]),!.
toPropercase(MiXed,UPPER):-compound(MiXed),MiXed=..MList,toPropercase(MList,UList),!,UPPER=..UList.
toPropercase(A,A).


toCamelcase(VAR,VAR):-var(VAR),!.
toCamelcase([],[]):-!.
toCamelcase([CX|Y],[D3|YY]):-!,toCamelcase(CX,D3),toCamelcase(Y,YY).
toCamelcase(D3,DD3):-atom(D3),member(V,[' ','-','_',':','mt','doom','Mt','Doom']),concat_atom([L,I|ST],V,D3),toCamelcase([L,I|ST],LIST2),toCamelcase(V,VV),concat_atom(LIST2,VV,DD3).
toCamelcase(CX,Y):-atom(CX),name(CX,[S|SS]),char_type(S,to_upper(NA)),name(NA,[N]),name(Y,[N|SS]),!.
toCamelcase(MiXed,UPPER):-compound(MiXed),MiXed=..MList,toCamelcase(MList,UList),!,UPPER=..UList.
toCamelcase(A,A).

*/      
      

% ===========================================================
% PROLOGD for OpenCyc SERVICE
% ===========================================================

serviceCycApiRequest5(In,Out):-
       readCycL(In,Trim), 
       isDebug(format('"~s"~n',[Trim])),
       serviceCycApiRequestSubP(In,Trim,Out).
   
serviceCycApiRequestSubP(In,Trim,Out):-
       getSurfaceFromChars(Trim,[Result],ToplevelVars),!,
       balanceBinding(Result,PrologGoal),
        thread_self(Session),
        retractall(isKeepAlive(Session)),
        xmlClearTags,
       invokePrologCommand(Session,In,Out,PrologGoal,ToplevelVars,Returns).

serviceCycApiRequestSubP(Trim):-
       getSurfaceFromChars(Trim,[Result],ToplevelVars),!,
       balanceBinding(Result,PrologGoal),
	 ignore(catch(PrologGoal,_,true)).

% ===========================================================
% PROLOGD for Java SERVICE
% ===========================================================
serviceJavaApiRequest(In,Out):-
        thread_self(Session),
        retractall(isKeepAlive(Session)),
        xmlClearTags,
   %     writeFmt(Out,'<session:id goal="~q">\n',[Session]),
        flush_output,
        repeat,
               ignore((once(( catch(
                        read_term(In,PrologGoal,[variable_names(ToplevelVars),character_escapes(true),syntax_errors(error)]),
                        E,
                        writeErrMsg(Out,E)),
                invokePrologCommand(Session,In,Out,PrologGoal,ToplevelVars,Returns))))),
                notKeepAlive(Out,Session),!.

invokePrologCommand(Session,In,Out,PrologGoal,ToplevelVars,Returns):-
         writeFmt(Out,'<cycml:solutions goal="~q">\n',[PrologGoal:ToplevelVars]),var(PrologGoal),!.

invokePrologCommand(Session,In,Out,PrologGoal,ToplevelVars,Returns):-flush_output,
      set_output(Out),set_input(In),!,
      %   tell(Out),
	PrologGoal,
        inform_xml_vars(PrologGoal,ToplevelVars),
        flush_output,
        xmlExitTags,!.


% ===========================================================
% HTTPD SERVICE
% ===========================================================
%prologHTTPD(Port):-http_server(reply, [port(Port)]).

serviceHttpRequest(ClientInfo,In,Out):-!,
        setCycOption(client,html),
        readHTTP(In,Request),!,
        tell(Out),
        ignore(reply([clientinfo=ClientInfo|Request])),
        told.


reply(Request) :-
        debugFmt('REQUEST DATA: ~q',[Request]),
        setCycOption(client,html),!,
        %Set-Cookie: nameTest=valueTest
        writeFmtFlushed('HTTP/1.1 200 OK\nServer: LOGICMOO HTTPD\nContent-Type: text/html\n\n',[]),
        once(processRequest(Request)),!,
        flush_output,!.

% ===================================================================
% Semi-Prolog Dependant Code
% ===================================================================
sigma_ua(X):-processRequest(X).


:-module_transparent(user:processRequestHook/1).
:-dynamic(user:processRequestHook/1).
:-multifile(user:processRequestHook/1).

processRequest(X):-catch(user:processRequestHook(X),E,( debugFmt('processRequestHook: "~q" \n',[X:E]), fail)),!.

% =================================================
% SubL
% =================================================
:-dynamic(processRequestHook/1).
:-multifile(processRequestHook/1).
:-module_transparent(processRequestHook/1).

user:processRequestHook(ARGS):-member(file='subl.moo',ARGS),!,
      ignore(member(formula=W,ARGS)),
      ignore(W=''),
      writeHTMLStdHeader('SubL Interactor'),
      writeFmtFlushed('
      <form method="GET">
	<p><textarea rows="9" name="formula" cols="40">~w</textarea><br>
	<input type="submit" value="Call" name="submit">&nbsp;<input type="reset" value="Reset" name="resetButton"></p>
      </form>',[W]),
      writeHTMLStdFooter,!.
	
        
processRequest(X):-
        once((writeHTMLStdHeader(X),  
        once(showCycProcessHTML),
        % serviceSoapRequest(In,Out),
	writeHTMLStdFooter)),!.


readHTTP(In,DOPTS):-!,
      http_header:http_read_request(In,Request),!,
      getData(Request,Data),!,decodeRequestArguments(Data,DData),!,
     request_to_options(Request,Options),!,
      append(Options,DData,DOPTS),!.

%request_to_options(Request,Options),
request_to_options([],[]):-!.
request_to_options([R|Request],[O|Options]):-r2o(R,O),!,request_to_options(Request,Options),!.

r2o(path(R),file=V):-atom_concat('/',V,R),!.
r2o(R,N=V):-functor(R,N,1),R=..[_,V],!.
r2o(RO,RO).

getData(Request,Data):-member(method(post), Request),http_read_data(Request, Data, []),!.
getData(Request,Data):-member(search(Data), Request),!.
getData(Request,[]).


readHTTP(In,Request):-
        read_line_with_nl(In, Codes, []),
        append([71, 69, 84, _, _],Stuff,Codes), % "GET /"
        append(RequestCodes,[72,84,84,80|_],Stuff),
        atom_codes(RequestEncoded,RequestCodes),
        decodeRequest(RequestEncoded,Request).

readHTTP(In,Request):-
        read_line_with_nl(In, Codes, []),
        append([80, 79, 83, 84,_, _],Stuff,Codes), % "POST /"
        append(RequestCodes,[72,84,84,80|_],Stuff),
        atom_codes(RequestEncoded,RequestCodes),
        decodeRequest(RequestEncoded,Request).


read_line_with_nl(Fd, Codes, Tail) :-
        get_code(Fd, C0),
        read_line_with_nl(C0, Fd, Codes, Tail).
read_line_with_nl(end_of_file, _, Tail, Tail) :- !.
read_line_with_nl(-1, _, Tail, Tail) :- !.
read_line_with_nl(10, _, [10|Tail], Tail) :- !.
read_line_with_nl(C, Fd, [C|T], Tail) :-
        get_code(Fd, C2),
        read_line_with_nl(C2, Fd, T, Tail).

decodeRequest(RequestEncoded,[file=FileT]):-
      www_form_encode(RequestDecoded,RequestEncoded),
      concat_atom([File],'?',RequestDecoded),!,
      decodeRequestAtom(File,FileT).
decodeRequest(RequestEncoded,[file=FileT|ENCARGS]):-
      concat_atom([File|_],'?',RequestEncoded),
      atom_concat(File,'?',FilePart),
      atom_concat(FilePart,ARGS,RequestEncoded),
      concat_atom(ArgList,'&',ARGS),
      decodeRequestAtom(File,FileT),!,
      decodeRequestArguments(ArgList,ENCARGS),!.

decodeRequestArguments([],[]):-!.
decodeRequestArguments([ctx=Value|List],[ctx=CValue,theory=KValue|ARGS]):- concat_atom([KValue,CValue],':',Value),!,
          decodeRequestArguments(List,ARGS).
decodeRequestArguments([Arg|List],[DDName=DDValue|ARGS]):-
          split_nv(Arg,Name,Value),
          decodeRequestAtom(Name,DName),
          decodeRequestAtom(Value,DValue),!,
          decodeRequestArguments(List,ARGS),!,
          unatom(DName,DDName),
          unatom(DValue,DDValue),!.


refixArgs([],[]):-!.
refixArgs([A|RGS],[R|ARGS]):-
      refixArg(A,R),!,
      refixArgs(RGS,ARGS).
refixArg(A=B,AA=BB):-unatom(A,AA),unatom(B,BB).
refixArg(A,AA):-unatom(A,AA).

unatom(B,BB):-atom(B),catch(atom_to_term(B,BB,_),_,fail),ground(BB),!.
unatom(B,B).



%ctx=PrologMOO%3ASTRUCTURAL-ONTOLOGY&amp;

split_nv(Name=Value,Name,Value):-!.
split_nv(Arg,Name,Value):-concat_atom([Name,Value],'=',Arg),!.
split_nv(Arg,Arg,Arg).
                        

decodeRequestAtom(RequestEncoded,X):-www_form_encode(RequestDecoded,RequestEncoded),!,decodeRequestAtom2(RequestDecoded,X),!.
decodeRequestAtom2(A,A):-var(A),!.
decodeRequestAtom2(tn,tn):-!.
decodeRequestAtom2(N,N):-number(N),!.
decodeRequestAtom2(A=B,AA=BB):-decodeRequestAtom2(A,AA),decodeRequestAtom2(B,BB),!.
decodeRequestAtom2(A,T):-catch(atom_to_term(A,T,_),_,fail),number(T),!.
decodeRequestAtom2(A,T):-catch(atom_to_term(A,T,_),_,fail),not(var(T)),not(compound(T)),!.
decodeRequestAtom2(A,T):-atom(A),catch(atom_codes(A,[95|_]),_,fail),catch(atom_to_term(A,T,_),_,fail),!.
decodeRequestAtom2(Request,RequestT):-atom_concat(RequestT,' ',Request),!.
decodeRequestAtom2(Request,Request).


% ===========================================================
% NATIVE SERVICE
% ===========================================================

serviceNativeRequestAsRDF(_,In,Out):-
        writeFmt(Out,'<?xml version="1.0" encoding="ISO-8859-1"?>\n',[]),
        thread_self(Session),
        retractall(isKeepAlive(Session)),
        xmlClearTags,
        repeat,
                catch(
                        read_term(In,PrologGoal,[variable_names(ToplevelVars),character_escapes(true),syntax_errors(error)]),
                        E,
                        writeErrMsg(Out,E)),
                %debugFmt(PrologGoal:ToplevelVars),
                invokePrologCommandRDF(Session,In,Out,PrologGoal,ToplevelVars,Returns),
                notKeepAlive(Out,Session),!.

notKeepAlive(Out,Session):-isKeepAlive(Session),
        write(Out,
                'complete.\n'
                %'<cycml:keepalive/>\n'
                                ),flush_output_safe(Out),!,fail.
notKeepAlive(Out,Session):-flush_output_safe(Out).


keep_alive:-thread_self(Me),retractall(isKeepAlive(Me)),assert(isKeepAlive(Me)),writeFmtFlushed('<keepalive/>\n',[]).
goodbye:-thread_self(Me),retractall(isKeepAlive(Me)),writeFmt('<bye/>/n',[]).


invokePrologCommandRDF(Session,In,Out,PrologGoal,ToplevelVars,Returns):-var(PrologGoal),!.

invokePrologCommandRDF(Session,In,Out,PrologGoal,ToplevelVars,Returns):-
        term_to_atom(Session,Atom),concat_atom(['$answers_for_session',Atom],AnswersFlag),
        writeFmt(Out,'<cycml:solutions goal="~q">\n',[PrologGoal]),
        flag(AnswersFlag,_,0),
        set_output(Out),set_input(In),!,
        getCputime(Start),
        callNondeterministicPrologCommandRDF(Session,AnswersFlag,In,Out,PrologGoal,ToplevelVars),
        xmlExitTags,
        getCputime(End),
        flag(AnswersFlag,Returns,Returns),
%       (Returns > 0 ->
%               writeFmt(Out,'<cycml:yes/>\n',[]) ;
%               writeFmt(Out,'<cycml:no/>\n',[])),!,
        Elapsed is End -Start,
        writeFmt(Out,'</cycml:solutions answers="~w" cputime="~g">\n',[Returns,Elapsed]),!.

callNondeterministicPrologCommandRDF(Session,AnswersFlag,In,Out,PrologGoal,ToplevelVars):-
        ground(PrologGoal),!,
        catch(
                (PrologGoal,
                 flag(AnswersFlag,Answers,Answers+1),
                 writePrologToplevelVarsXML(Out,PrologGoal,AnswersFlag,ToplevelVars)
                 ),
           Err,writeErrMsg(Out,Err,PrologGoal)),!.

callNondeterministicPrologCommandRDF(Session,AnswersFlag,In,Out,PrologGoal,ToplevelVars):-
        catch(
                (PrologGoal,
                 flag(AnswersFlag,Answers,Answers+1),
                 writePrologToplevelVarsXML(Out,PrologGoal,AnswersFlag,ToplevelVars),
                 fail),
           Err,writeErrMsg(Out,Err,PrologGoal)),!.
callNondeterministicPrologCommandRDF(Session,AnswersFlag,In,Out,PrologGoal,ToplevelVars):-!.


writePrologToplevelVarsXML(Out,PrologGoal,AnswersFlag,ToplevelVars):-
         flag(AnswersFlag,Answers,Answers),
        writeFmt(Out,'<cycml:result solution="~w">\n',[Answers]),
        writePrologToplevelVarsXML2(Out,ToplevelVars),
        writeFmt(Out,'</cycml:result>\n',[]),!.

writePrologToplevelVarsXML2(Out,[]):-!.
writePrologToplevelVarsXML2(Out,[Term|REST]):-!,Term=..[_,N,V],
         writeFmtFlushed(Out,'       <cycml:p>~w = ~q</cycml:p>\n',[N,V]),
         writePrologToplevelVarsXML2(Out,REST),!.


writeFmt(A,B,C):-!.
writeFmt(A,B):-!.

writeFmt(A,B,C):-
        writeFmtFlushed(A,B,C).
writeFmt(A,B):-
        writeFmtFlushed(A,B).


throwCyc(Module,Type,Details):-
        current_prolog_flag(debug_on_error, DebugOnError),
        set_prolog_flag(debug_on_error, false),!,
        throw(cycException(Module,Type,Details,DebugOnError)),
        ifInteractive(debugFmt('Post throwCyc')),!.

ifInteractive(X):-X.


% ===========================================================
% NATIVE SOAPD SERVER FOR SWI-PROLOG
% ===========================================================

			    
%:-swi_module(cyc_soap,[]).

% :-include('cyc_header.pl').

:-dynamic_transparent(xmlCurrentOpenTags/2).

serviceSoapRequest(In,Out):-
      debugFmt('SOAP Request'),
        catch(read_do_soap(stream(In),Out),E,
        writeFmt(Out,'<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n<error>~w</error>\n',[E])),
        flush_output_safe(Out).


read_do_soap(Source):-
        open(Source,read,Stream),
        read_do_soap(Stream,user_output).

read_do_soap(Source,Out):-
       thread_self(Self),
        write(Out,'<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n'),
       % writeFmt(Out,'<?xml version="1.0" encoding="ISO-8859-1"?>\n<answer thread="~w">\n',[Self]),
        flush_output_safe(Out),
        load_structure(Source,RDF,[]),
        structure_to_options(RDF,Options),
%       writeFmt(user_error,'structure="~q"\noptions="~q"\n',[RDF,Options]),
        flush_output_safe(user_error),
        processRequest([client=soap|Options]).
        %writeFmt(Out,'</answer>\n',[]).


% request
structure_to_options([element(request, Options, [Atom])],[submit=ask,sf=Atom|Options]):-!.

% assert
structure_to_options([element(assert, Options, [Atom])],[submit=assert,sf=Atom|Options]):-!.
structure_to_options([element(asssertion, Options, [Atom])],[submit=assert,sf=Atom|Options]):-!.
structure_to_options([element(assertion, Options, [Atom])],[submit=assert,sf=Atom|Options]):-!.

% get inner
structure_to_options([element(Ptag, ['xmlns:cyc'=Server], Inner)],[opt_server=Server,opt_outter=Ptag|Out]):-!,
        structure_to_options(Inner,Out).


writeFmtServer(A,B):-format(A,B),flush.
writeFmtServer(O,A,B):-format(A,B),flush_output_safe(O).

xmlOpenTag(Name):-thread_self(Self),asserta(xmlCurrentOpenTags(Self,A)),writeFmtServer('<~w>',[Name]),!.
xmlOpenTagW(Out,Name,Text):-thread_self(Self),asserta(xmlCurrentOpenTags(Self,A)),writeFmtServer(Out,'~w',[Text]),!.

xmlCloseTag(Name):-thread_self(Self),ignore(retract(xmlCurrentOpenTags(Self,A))),writeFmtServer('</~w>',[Name]),!.
xmlCloseTagW(Name,Text):-thread_self(Self),ignore(retract(xmlCurrentOpenTags(Self,A))),writeFmtServer('~w',[Text]),!.
xmlCloseTagW(Out,Name,Text):-thread_self(Self),ignore(retract(xmlCurrentOpenTags(Self,A))),writeFmtServer(Out,'~w',[Text]),!.

xmlClearTags:-thread_self(Self),retractall(xmlCurrentOpenTags(Self,A)).

xmlExitTags:-thread_self(Self),retract(xmlCurrentOpenTags(Self,A)),writeFmtServer('</~w>',[Name]),fail.
xmlExitTags.


% ===========================================================
% Insert
% ===========================================================

parse_cyc_soap(Options):-memberchk(submit=assert,Options),!,
        getCycOption(opt_ctx_assert='BaseKB',Ctx),
        getCycOption(opt_theory='doom:DataMt',Context),
        getCycOption(sf=surf,Assertion),
        atom_codes(Assertion,Assertion_Chars),
        getCycOption(user='Web',User),
        getCycOption(interp='cycl',Interp),
        logOnFailure(getCycOption(tn=_,EXTID)),
        %sendNote(user,'Assert',formula(NEWFORM),'Ok.'). %,logOnFailure(saveCycCache)
        logOnFailure(getCleanCharsWhitespaceProper(Assertion_Chars,Show)),!,
        xml_assert(Show,Ctx,Context,User).

xml_assert(Show,Ctx,Context,User):-
        getSurfaceFromChars(Show,STERM,Vars),
        toCycApiExpression(STERM,NEWFORM),
        xml_assert(Show,NEWFORM,Vars,Ctx,Context,User).

xml_assert(Show,Ctx,Context,User):-!,
        writeFmt('<assertionResponse accepted="false">\nUnable to parse: "~s"\n</assertionResponse>\n',[Show]).

xml_assert(Show,NEWFORM,Vars,Ctx,Context,User):-
        logOnFailure(getTruthCheckResults(tell,[untrusted],surface,NEWFORM,Ctx,STN,Context,Vars,Maintainer,Result)),
        (Result=accept(_) ->
                        (
                        once(invokeInsert([trusted,canonicalize,to_mem],surface,NEWFORM,Ctx,EXTID,Context,Vars,User)),
                        write('<assertionResponse accepted="true">\nOk.\n</assertionResponse>\n')
                        )
                        ;
                        (
                        Result=notice(FormatStr,Args),
                        write('<assertionResponse accepted="false">\n'),
                        writeFmt(FormatStr,Args),
                        write('\n</assertionResponse>\n')
                        )
        ),!.

xml_assert(Show,NEWFORM,Vars,Ctx,Context,User):-!.


% ===========================================================
% Ask a Request
% ===========================================================
parse_cyc_soap(Options):-memberchk(submit=ask,Options),!,make,
        %write('<!DOCTYPE cyc:ask SYSTEM "/opt/tomcat-4.0/webapps/cyc-1.4b1/dtd/java_prolog.dtd">\n'),
        write('<cycml:ask xmlns:cycml="http://localhost">\n'),
        getCycOption(opt_ctx_request='BaseKB',Ctx),
        getCycOption(opt_theory='doom:DataMt',Context),
        getCycOption(sf=surf,Askion),
        atom_codes(Askion,Askion_Chars),
        getCycOption(user='Web',User),
        getCycOption(interp='cycl',Interp),
         logOnFailure(getCleanCharsWhitespaceProper(Askion_Chars,Show)),!,
         logOnFailure(getSurfaceFromChars(Show,STERM,Vars)),!,
         logOnFailure(toCycApiExpression(STERM,NEWFORM)),!,
              logOnFailure(once(( NEWFORM=comment(_) ->
                     (writeFmt('<cycml:error>Syntax Error: Unmatched parentheses in "~s"</cycml:error>\n',[Show]),!,FORM=_) ;(!,
                     logOnFailure(invokeRequest_xml(NEWFORM,ChaseVars,Ctx,TrackingAtom,Context,User,Vars,CPU))
                     )))),
        write('</cycml:ask>\n').

:-dynamic_transparent(invokeRequestToBuffer(NEWFORM,ChaseVars,Ctx,TrackingAtom,Context,User,Vars,CPU)).

invokeRequest_xml(NEWFORM,ChaseVars,Ctx,TrackingAtom,Context,User,Vars,CPU):-
        invokeRequestToBuffer(NEWFORM,ChaseVars,Ctx,TrackingAtom,Context,User,Vars,CPU),
        final_answer(Logic:How),
        invoke_final_answer(Logic,How,CPU).

invoke_final_answer(possible,How,CPU):-!,
        writeFmt('<requestResponse yesno="~w" numBindings="0" seconds="~w"/>\n',[How,CPU]).

invoke_final_answer(Logic,How,CPU):-
        writeFmt('<requestResponse yesno="~w" numBindings="~w" seconds="~w">\n<bindings>\n',[Logic,How,CPU]),
        cite_xml_buffered_answers,
        write('</bindings>\n</requestResponse>\n').


cite_xml_buffered_answers:-
        retract(requestBuffer_db(UResultsSoFar,Result,Explaination,Status)),
        once(inform_xml_agent(UResultsSoFar,Result,Explaination,Status)),fail.

% Call to write Summary
/*
cite_xml_buffered_answers:-
        final_answer(Logic:How),
        debugFmt(final_answer(Logic:How)),
        inform_xml_agent(How, ['Summary'=Logic|_G14093],final_answer(Logic:How),final_answer(Logic:How) ).
*/
cite_xml_buffered_answers:-!.

:-dynamic_transparent(cycassertgaffast/4).

cycassertgaffast(P,X,Y,Mt):-
   termCyclify(P,CP),
   termCyclify(X,CX),
   termCyclify(Y,CY),
   termCyclify(Mt,CMT),
   evalSubL('cyc-assert'(quote([CP,CX,CY]),quote(CMT)),_),!.
      

removalPredicateCodedInProlog(Pred,Prolog).

prologEval(X,Y):-Y is X + 111.
prologEval(X,Y):-Y is X + 211.

/*
:-use_module(library(odbc)).  
:-odbc_debug(5).
*/

:-dynamic(ensureCycCallsProlog/2).

ensureCycCallsProlog(Host,Port):-withoutCyc,!.
ensureCycCallsProlog(Host,Port):-
   sformat(SFormat,'(progn (define callprologpred (outval) (clet ((*retval* nil)(*stream* (OPEN-TCP-STREAM *prolog-host* *prolog-port*)))
   (prin1 outval *stream*)(force-output *stream*)(terpri *stream*)(force-output *stream*)(csetq *retval* (read *stream*))
   (close *stream*)(ret *retval*))) (defvar *prolog-host* "~w")(csetq *prolog-host* "~w")(defvar *prolog-port* ~w)(csetq *prolog-port* ~w))',[Host,Host,Port,Port]),
   evalSubL(SFormat,_,_),

   asserta((ensureCycCallsProlog(_,Port):-!)),!.
      
                                    
%odbc_current_table(CON, Table, Facet).


numberArgs(_,[]):-!.
numberArgs(N,[A|Args]):-ignore(N=A),NN is N+1,numberArgs(NN,Args),!.


cycPredCall([Pred, neg, Proc], Stuff, Stuff):-ground(Stuff),!,cycPredCall([Pred, pos, Proc], Stuff,R),!,R=[].
cycPredCall([Pred, pos, proc], [P|Args],[[P|Args]]):-!,numberArgs(0,Args),!.
 
cycPredCall(X,Y,[]):-attach_console,true,debugFmt(cycPredCall(X,Y)),!.
cycPredCall([Prolog,pos|_],[CycPred|CallArgs],Result):-is_list(CallArgs),Call=..[Prolog|CallArgs],!,findall([CycPred|CallArgs],catch(Call,_,fail),Result).
cycPredCall([Prolog,neg|_],[CycPred|CallArgs],[]):-!.
cycPredCall(Predstring,Call,[Call]):-!.

prologProcForCycPred(X,X).
  

dsnForDB('AdventureWorks','AdventureWorks').
connectionForDB(DB,CON):-odbc_current_connection(CON,database_name(DB)),!.
connectionForDB(DB,CON):-dsnForDB(DB,DSN),odbc_connect(DSN, CON,[ /*user('Administrator'),%password(Password),%alias(wordnet),*/open(once)]),!.

databaseForSource('AdventureWorksSource','AdventureWorks').
tableForSource('AdventureWorksSource',addressInfo,'Person.Address').
predicatesOfSource('AdventureWorksSource',addressInfo).

selectAll(Predicate,ROWS):-
   predicatesOfSource(Source,Predicate),
   tableForSource(Source,Predicate,Table),
   databaseForSource(Source,DB),
   connectionForDB(DB,CON),
   queryOfPredicate(Predicate,Query),
   odbc_query(CON,Query,ROWS).

queryOfPredicate(addressInfo,'SELECT * FROM Person.Address').

%rowInfo


insert_child(Child, Mother, Father, Affected) :- 
        odbc_query(parents,'INSERT INTO parents (name,mother,father) VALUES ("mary", "christine", "bob")',affected(Affected)).


% defineRemovalPred(prologEval,prologEval). 
defineRemovalPred(Predname,Prologname):-
   evalSubL('find-or-create-constant'(string(Predname)),_),
   termCyclify(Predname,CPredname),
   cycassertgaffast(isa,CPredname,'VariableArityRelation','UniversalVocabularyMt'),!,
   cycassertgaffast(comment,CPredname,string(['Defined via the defineRemovalPred',CPredname,'->',Prologname]),'UniversalVocabularyMt'),
   cycassertgaffast(isa,CPredname,'RemovalModuleSupportedPredicate-Specific','CycAPIMt'),
  % cycassertgaffast(arity,CPredname,2,'UniversalVocabularyMt'),!,
   atom_concat(':removal-',Predname,RemovalPrefix),
   atom_concat(RemovalPrefix,'-pos',RemovalPos),
   atom_concat(RemovalPrefix,'-neg',RemovalNeg),
   atom_concat(Prologname,'-pos-proc',RemovalPosProc),
   atom_concat(Prologname,'-neg-proc',RemovalNegProc),
   evalSubL('inference-removal-module'(RemovalPos,quote(
   [':sense',':pos',':predicate',% ':module-subtype' , ':kb',          
   CPredname,':cost-expression',0,':completeness',':complete',':input-verify-pattern',':anything',
   ':output-generate-pattern',[':call',RemovalPosProc,':input']])),_),
   evalSubL('inference-removal-module'(RemovalNeg,quote(
   [':sense',':neg',':predicate',     %  ':module-subtype' , ':kb',
   CPredname,':cost-expression',0,':completeness',':complete',':input-verify-pattern',':anything',
   ':output-generate-pattern',[':call',RemovalNegProc,':input']])),_),
   evalSubL('register-solely-specific-removal-module-predicate'(CPredname),_),!,
   evalSubL('define'(RemovalPosProc,['value'],ret(callprologpred(list(string(RemovalPosProc),'value')))),_),!,
   evalSubL('define'(RemovalNegProc,['value'],ret(callprologpred(list(string(RemovalNegProc),'value')))),_),!.


  /*
  
(define callprologpred (values) (print values) (ret NIL))
(define callprologpred (values) (print values) (ret (list '(1 2))))



(inference-removal-module :removal-gameNear-unbound-unbound
 '(:sense :pos 
	:predicate #$doom:gameNear 
   	:cost-expression 0 :completeness :complete 
	:input-extract-pattern (:template (#$doom:gameNear (:bind value-1) (:bind value-2)) ((:value value-1) (:value value-2)))
	:input-verify-pattern :anything
	:output-generate-pattern (:call removal-gameNear-pos-uu :input)
	:output-construct-pattern  (#$doom:gameNear (:call first :input) (:call second :input))))
(inference-removal-module :removal-gameNear-bound-bound 
'( :sense :pos 
	:predicate #$doom:gameNear 
	:check t 
	:required-pattern (#$doom:gameNear :fully-bound :fully-bound)
	:cost-expression 0 :completeness :complete
	:input-extract-pattern (:template (#$doom:gameNear (:bind value-1) (:bind value-2)) ((:value value-1) (:value value-2)))
	:input-verify-pattern :anything
	:output-check-pattern (:call removal-gameNear-pos-bb (:tuple (value-1 value-2) ((:value value-1) (:value value-2))))))


(define removal-gameNear-pos-bu (value) (clet ((*newvalue* value)) (csetq *newvalue* (GAME-EVAL (list "gameNear-pbu" value))) (ret  *newvalue* )))
(define removal-gameNear-pos-ub (value) (clet ((*newvalue* value)) (csetq *newvalue* (GAME-EVAL (list "gameNear-pub" value))) (ret  *newvalue* )))
(define removal-gameNear-pos-bb (vvs) (clet ((*newvalue* vvs)) (csetq *newvalue* (GAME-EVAL (list "gameNear-pbb" vvs))) (ret  *newvalue* )))
(define removal-gameNear-pos-uu (vvs) (clet ((*newvalue* vvs)) (csetq *newvalue* (GAME-EVAL (list "gameNear-puu" vvs))) (ret  *newvalue* )))
(register-solely-specific-removal-module-predicate #$doom:gameNear)
                                     */
    /*
(tableName TABLE STRING) 
isSKSI(prologSKSIConnect,'TheList'(
prologSKSIConnect(DataSrc,Result):-
       cycQueryOnce(tableName(DataSrc,TablName),
     cycQueryOnce(usernameForAccount(DataSrc,Username)),
     cycQueryOnce(passwordForAccount(DataSrc,Password)),
                */


% ===========================================================
% Send to debugger
% ===========================================================
inform_xml_agent(UResultsSoFar,Result,InExplaination,Status):-
        debugFmt(inform_xml_agent(UResultsSoFar,Result,InExplaination,Status)),fail.

% ===========================================================
% Hide certain returns
% ===========================================================
inform_xml_agent(-1,Result,Explaination,Status).

inform_xml_agent(0, ['Result'=none|A], 'Unproven', done(possible:searchfailed)).
inform_xml_agent(_, ['Result'=true|A], found(_), done(true:_)).
inform_xml_agent(_, ['Summary'=_|_G5892], _, _).

% ===========================================================
% Write Answers
% ===========================================================
:-dynamic_transparent(length_explaination/2).

inform_xml_agent(UResultsSoFar,Result,InExplaination,Status):-
        writeFmt('<binding>\n',[]),
        inform_xml_vars(Result,Vars),
        length_explaination(InExplaination,InLength),
        findall(Length-Explaination,
                (retract(inform_xml_agent_buffer_db(_,Result,Explaination,_)),
                 length_explaination(Explaination,Length)
                 ),KeyList),
        keysort([(InLength-InExplaination)|KeyList],[(_-ChoiceExplaination)|_]),
        inform_xml_explaination(InLength,ChoiceExplaination,Result),
        writeFmt('</binding>\n',[]).

inform_xml_vars(Result,Vars):-
        length_var(Result,NumVar),
        writeFmt('<variables numVars="~w">\n',[NumVar]),
        inform_each_variable(Result,Vars),
        writeFmt('</variables>\n',[]).

length_var([],0).
length_var([A|'$VAR'(_)],1).
length_var([A|L],N):-
          length_var(L,NN),
          N is NN +1.

inform_each_variable([],Vars).
inform_each_variable('$VAR'(_),Vars).
inform_each_variable([NV|Rest],Vars):-
        inform_nv(NV,Vars),
        inform_each_variable(Rest,Vars).


inform_nv('$VAR'(_),Vars).
inform_nv(Name=Value,Vars):-
        toMarkUp(cycl,Name,Vars,OName),
        toMarkUp(cycl,Value,Vars,OValue),
        writeFmt('<var varName="~w" value="~w"/>\n',[OName,OValue]).


inform_xml_explaination(InLength,ChoiceExplaination,Result):-
        writeFmt('<explaination numSteps="~w">',[InLength]),
        flag(explaination_linenumber,_,0),
        writeObject_explaination(ChoiceExplaination,Result),
        writeFmt('</explaination>\n').

writeObject_explaination(deduced,_).
writeObject_explaination('$VAR'(_),_).
writeObject_explaination(explaination(Choice1) ,Result):-!,
        writeObject_explaination(Choice1,Result),!.
writeObject_explaination(Choice1 * Choice2 ,Result):-!,
        writeObject_explaination(Choice1,Result), !,
        writeObject_explaination(Choice2,Result),!.
writeObject_explaination(Choice1,Result):-!,
             write('<explainationStep isRule="true">\n<originalRule>\n'),
             toMarkUp(html,Choice1,Result,Out),!,
             ignore(write_escaped(Out)),
             write('\n</originalRule>\n</explainationStep>\n').

write_escaped([O|T]):-!,
        write_e_codes([O|T]),!.
write_escaped(Out):-atom(Out),!,
        atom_codes(Out,Codes),!,write_escaped(Codes),!.
write_escaped(String):- !,
        string_to_atom(String,Atom),
         atom_codes(Atom,Codes),!,
        write_e_codes(Codes),!.

write_e_codes([]):-!.
write_e_codes([E|Cs]):-!,
        write_e(E),!,
        write_e_codes(Cs),!.
write_e(34):-write('&amp;qt;'),!.
write_e(60):-write('&amp;lt;'),!.
write_e(62):-write('&amp;gt;'),!.
write_e(C):-put_code(C),!.


% ===================================================================
% writeIfOption(class(input),message(input),respoinse(output))
% generic call interface that was hooked into the belief engine with "ua_set_agent_callback(console_post)"
%This is not a predicate the useragent calls, but one that is called by the belief module to communicate  a question to the useragent or inform it of something.  
% The useragent decides if it can answer the a question and if not itself may ask a human user that is using it.
% There is three arguments to the my_callback predicate: Class, Message and Response
%
% Whenever the belief engine calls 'my_callback' only the first two arguments (Class,Message) are bound to supply information relevant to a Server invoked request.
%
% Class is a programmer defined message catagory  
% The Class is inteded to contain user defined message names that are sent as a callback function that is sent to the user's module consultation 
% Is is the type of Message catagory for the user agent.. A list of these are in TABLE 1.1 in <http://10.10.10.198/cyc_interface_advanced.html>
% (Class is always a ground Term)
%
% Message is a prolog term in the writeFmt defined by it's Class
% Each Class has a one known Message writeFmt shown in the table.   
% Message sometimes is ground term. 
%
%
% Response has normally has 2 response single_bindings: continue or abort
% This response is sent back to the belief_engine.
% If the belief_engine didn''t receive 'abort', then it moves to the next stage in the command.
% 
% ===================================================================

			  /*      				   
:-swi_module(cyc_generation,
	 [ 
	 debugFmt/1,
	 debugFmt/2,
	 debugFmtFast/1,
	 logOnFailureIgnore/1,
	 setCycOptionExplicitWriteSettings/0,
	 setCycOptionImplicitWriteSettings/0,
	 sendNote/1,
	 sendNote/4,
	 writeFailureLog/2,
	 debugOnFailure/2,
	 writeObject/2,
	 writeObject/3,
	 writeObject_conj/2]).
					 */

% :-include('cyc_header.pl').

% :-use_module(cyc_globalisms).

% ==========================================================
%  Sending Notes
% ==========================================================
 

logOnFailureIgnore(X):-ignore(logOnFailure(X)),!.

writeModePush(_Push):-!.
writeModePop(_Pop):-!.

%debugFmt([-1]).
%debugFmt([[-1]]).
%debugFmt(T):- isCycOption(opt_debug=false),!.
debugFmt(Stuff):-!,debugFmt('% ~q~n',[Stuff]).
debugFmt(T):-!,
	((
	if_prolog(swi,
		(prolog_current_frame(Frame),
		prolog_frame_attribute(Frame,level,Depth),!,
		Depth2 = (Depth-25))),
	writeFmt(';;',[T]),!,
	indent_e(Depth2),!,
	writeFmt('~q\n',[T]))),!.

indent_e(X):- catch((X < 2),_,true),write(' '),!.
indent_e(X):-XX is X -1,!,write(' '), indent_e(XX).

%debugFmt(C,T):- isCycOption(opt_debug=false),!.
debugFmt(_,F):-F==[-1];F==[[-1]].
debugFmt(F,A):-
        nl(user_error),
        writeFmtFlushed(user_error,F,A),
        nl(user_error),
        flush_output_safe(user_error),!.

debugFmt(C,T):-!,
	((
	writeFmt('<font size=+1 color=~w>',[C]),
	debugFmt(T),
        writeFmt('</font>',[]))),!.

dumpstack_argument(T):-isCycOption(opt_debug=false),!.  
	
dumpstack_argument(Frame):-
	write(frame=Frame),write(' '),
	dumpstack_argument(1,Frame).

dumpstack_argument(1,Frame):-!,
	prolog_frame_attribute(Frame,goal,Goal),!,
	write(goal=Goal),write('\n').
	
dumpstack_argument(N,Frame):-
	prolog_frame_attribute(Frame,argument(N),O),!,
	write(N=O),write(' '),
	NN is N +1,
	dumpstack_argument(NN,Frame).
	
dumpstack_argument(N,Frame):-!,write('\n').
	
:-dynamic_transparent(mods/1).

write_response_begin:-!.
write_response_end:-!.
/*
:-swi_export((	 logOnFailureIgnore/1,
	 sendNote/1,
	 sendNote/4,
	 writeFailureLog/2)).

sendNote(X):-var(X),!.
sendNote(X):-mods(X),!.
sendNote(X):-!,assert(mods(X)).
sendNote(X).			 

sendNote(To,From,Subj,Message):-sendNote(To,From,Subj,Message,_).

sendNote(To,From,Subj,Message,Vars):-
	not(not((safe_numbervars((To,From,Subj,Message,Vars)),
	%debugFmt(sendNote(To,From,Subj,Message,Vars)),
	catch(sendNote_1(To,From,Subj,Message,Vars),E,
	writeFmt('send note ~w ~w \n <HR>',[E,sendNote(To,From,Subj,Message,Vars)]))))).


sendNote_1(To,From,Subj,surf,Vars):-!.
sendNote_1(To,From,[],surf,Vars):-!.
sendNote_1(To,From,[],end_of_file,Vars):-!.
sendNote_1(doug,From,_,_,Vars):-!.
sendNote_1(extreme_debug,From,_,_,Vars):-!.
sendNote_1(debug,'Belief',_,_,Vars):-!.

%sendNote_1(canonicalizer,From,Subj,Message,Vars):-!.


sendNote_1(canonicalizer,From,Subj,Message,Vars):-
            toMarkUp(cycl,From,Vars,SFrom),
            toMarkUp(cycl,nv(Subj),Vars,SS),
            toMarkUp(cycl,nv(Message),Vars,SA),
            writeFmt('<font color=red>canonicalizer</font>: ~w "~w" (from ~w). \n',[SA,SS,SFrom]),!.
*/
/*

sendNote_1(debug,From,Subj,Message,Vars):- %isCycOption(disp_notes_nonuser=on),!,
            toMarkUp(cycl,From,Vars,SFrom),
            toMarkUp(cycl,Subj,Vars,SS),
            toMarkUp(cycl,Message,Vars,SA),
            writeFmt('% debug: ~w "~w" (from ~w). \n',[SA,SS,SFrom]).
sendNote_1(debug,From,Subj,Message,Vars):-!.
*/

            /*

/*
sendNote_1(To,From,Subj,Message,Vars):- isCycOption(client=consultation),  !, 
            toMarkUp(cycl,To,Vars,STo),
            toMarkUp(cycl,From,Vars,SFrom),
            toMarkUp(cycl,nv(Subj),Vars,S),
            toMarkUp(cycl,nv(Message),Vars,A),
            fmtString(Output,'~w (~w from ~w) ',[A,S,SFrom]),
	    sayn(Output),!.

sendNote_1(To,From,'Rejected',Message,Vars):- isCycOption(client=automata),  !.

sendNote_1(To,From,Subj,Message,Vars):- isCycOption(client=automata),  !, 
            toMarkUp(cycl,To,Vars,STo),
            toMarkUp(cycl,From,Vars,SFrom),
            toMarkUp(cycl,nv(Subj),Vars,S),
            toMarkUp(cycl,nv(Message),Vars,A),
            writeFmt(user_error,'% ~w (~w from ~w) ',[A,S,SFrom]).

sendNote_1(To,From,Subj,Message,Vars):- isCycOption(client=html),  !, %  In Html
            toMarkUp(cycl,To,Vars,STo),
            toMarkUp(cycl,From,Vars,SFrom),
            toMarkUp(cycl,nv(Subj),Vars,S),
            toMarkUp(html,nv(Message),Vars,A),
            writeFmt('<hr><B>To=<font color=green>~w</font> From=<font color=green>~w</font> Subj=<font color=green>~w</font></B><BR>~w\n',[To,From,S,A]),!.

sendNote_1(To,From,Subj,Message,Vars):- isCycOption(client=console),!, % In CYC
            toMarkUp(cycl,To,Vars,STo),
            toMarkUp(cycl,From,Vars,SFrom),
            toMarkUp(cycl,nv(Subj),Vars,SS),
            toMarkUp(cycl,nv(Message),Vars,SA),
            writeFmt(user_error,'; ~w: ~w "~w" (from ~w). \n',[STo,SA,SS,SFrom]),!.
  
sendNote_1(To,From,Subj,Message,Vars):-  % In CYC
            toMarkUp(cycl,To,Vars,STo),
            toMarkUp(cycl,From,Vars,SFrom),
            toMarkUp(cycl,nv(Subj),Vars,SS),
            toMarkUp(cycl,nv(Message),Vars,SA),
            writeFmt(user_error,'; ~w: ~w "~w" (from ~w). \n',[STo,SA,SS,SFrom]),!.

sendNote(To,From,Subj,Message,Vars):-!.
                                                                       */

logOnFailure(assert(X,Y)):- catch(assert(X,Y),_,Y=0),!.
logOnFailure(assert(X)):- catch(assert(X),_,true),!.
logOnFailure(assert(X)):- catch(assert(X),_,true),!.
%logOnFailure(X):-catch(X,E,true),!.
logOnFailure(X):-catch(X,E,(writeFailureLog(E,X),!,catch((true,X),_,fail))),!.
logOnFailure(X):- writeFailureLog('Predicate Failed',X),!.
*/

debugFmtFast(X):-writeq(X),nl.

flush_output_safe(X):-catch(flush_output(X),_,true),!.
flush_output_safe(X).

writeFailureLog(E,X):-
		writeFmt(user_error,'\n% error:  ~q ~q\n',[E,X]),flush_output_safe(user_error),!,
		%,true.
		writeFmt('\n;; error:  ~q ~q\n',[E,X]),!,flush_output. %,writeFmtFlushed([E,X]).

/*
:-swi_export((	 debugOnFailure/2,
	 debugOnFailure/1,
         debugOnError/1)).

debugOnFailure(assert(X,Y)):- catch(assert(X,Y),_,Y=0),!.
debugOnFailure(assert(X)):- catch(assert(X),_,true),!.
debugOnFailure(assert(X)):- catch(assert(X),_,true),!.
debugOnFailure(X):-catch(X,E,(writeFailureLog(E,X),fail)).
debugOnFailure(X):-ctrace,call(X).

debugOnFailure(arg_domains,CALL):-!,logOnFailure(CALL),!.
debugOnFailure(Module,CALL):-debugOnFailure(Module:CALL),!.


debugOnError((X,Y)):-!,debugOnError(X),debugOnError(Y).
debugOnError((X;Y)):-!,(debugOnError(X);debugOnError(Y)).
debugOnError(call(X)):-!,debugOnError(X).
debugOnError(X):-catch(X,E,(writeFailureLog(E,X),ctrace,call(X))).
*/

noDebug(CALL):-CALL.
	


%unknown(Old, autoload).

% ================================================================
%   Serialize Objects to XML
% ================================================================


%%writeObject(OBJ,Vars):-!. %,writeq(OBJ),!.
%writeObject(OBJ,Vars):-!,catch(writeq(OBJ),_,true),nl,!.

writeObject(quiet,Term,Vars):-!.

writeObject(Verbose,Term,Vars):-writeObject(Term,Vars).

		
writeObject(OBJ,Vars):- isCycOption(client=html),!,
		((toMarkUp(html,OBJ,Vars,Chars),write(Chars))),!.
		
writeObject(OBJ,Vars):- isCycOption(client=atomata),!,
		((toMarkUp(cycl,OBJ,Vars,Chars),write(Chars))),!.

writeObject(OBJ,Vars):- isCycOption(client=console),!,
		((toMarkUp(cycl,OBJ,Vars,Chars),write(Chars))),!.

writeObject(OBJ,Vars):- !,
		((toMarkUp(cycl,OBJ,Vars,Chars),write(Chars))),!.


writeObject_conj(A,Vars):-isSlot(A),!,
	writeObject(A,Vars).

writeObject_conj(and(A,true),Vars):-!,
	writeObject_conj(A,Vars).

writeObject_conj(and(true,A),Vars):-!,
	writeObject_conj(A,Vars).

writeObject_conj(and(A,B),Vars):-!,
	writeObject_conj(A,Vars),
	writeObject_conj('\n\n Also \n\n ',Vars),
	writeObject_conj(B,Vars).

writeObject_conj(Output,Vars):-
	%write(Output),nl.
	writeObject(Output,Vars).


:-dynamic_transparent(resolve_skolem/2).
:-dynamic_transparent(final_answer/1).

ignoreOnce(X):-ignore(once(X)).

writeIfOption(C,P):-ignoreOnce(writeCycEvent(C,P,_)).
writeIfOption(C,M,Vars):-ignoreOnce(writeCycEvent(C,M,Vars)).


write_val(Any,Vars):- isCycOption(client=html)
      -> write_val_xml(Any,Vars) ;
      (toMarkUp(cycl,Any,Vars,Chars),write(Chars),nl).
%      write_sterm(Any,Vars).
      
write_val_xml(Any,Vars):-
      toMarkUp(leml,Any,Vars,Chars),write(Chars),nl.
                                        /*

:-dynamic_transparent(telling_file).               

writeCycEvent(_,_,_):-isCycOption(disp_hide_all=true),!.
writeCycEvent(_,_,_):-telling_file,!.
writeCycEvent(Class,_,_):-isCycOption(Class=false),!.
writeCycEvent(Class,_,_):-isCycOption(disp_explicit=true),not(isCycOption(_Class=true)),!.

writeCycEvent(request_start,Note,Vars):-!,
         (isCycOption(client=html) -> 
          (writeFmt('<Answer>\n'),le_push('Answer'));
          true).

writeCycEvent(request_end,(Result,Normal,Elapsed,Num,Bindings),Vars):-!, 
                  (isCycOption(client=html) -> 
                     ((    
                       (toMarkUp(leml,note('user',logicEngine,Result,(Result,Normal,Elapsed,Num,Bindings)),Vars,Chars),once((var(Chars);write(Chars)))),
                       writeFmt('<Summary result="~w" solutions="~d" bindings="~d" cpu="~f"/>\n</Answer>\n',[Result,Num,Bindings,Elapsed]),
                       le_pull('Answer')
                     ));
                       writeFmt('\n%%  ~w solutions="~d" bindings="~d" cpu="~f"\n',[Result,Num,Bindings,Elapsed])).

writeCycEvent(Class,Message,Vars):-not(isCycOption(client=html)),!, toMarkUp(cycl,[Class,Message],Vars,Chars),write(Chars),nl.
writeCycEvent(Class,Message,Vars):-isCycOption(client=html),!, event_to_chars(leml,Class,_Message,Vars,Chars),write(Chars),nl.
writeCycEvent(cb_consultation, assertion([PredicateI|ConsultTemplate],_Context_atom,_SN), continue):- 
               agentConsultation(_Context_atom,[PredicateI|ConsultTemplate], _ListOfGafsAsserted).
writeCycEvent(_,_,_):-!.

                                                         */
/*
Where the parameters are some string syntax or other straightforward data
structure and we've used I to signify a parameter that is used by the
function and O to signify a parameter that is returned by the
function.  If that were forall it had, we think that is sufficient for
the bulk of interactions.  Everything else is helpful but not strictly
essential.  Because of that, we believe that it is possible to run
our system with just the above commands after startup.

   We have shown a number of features implemented such as

  - explaination trees
  - belief execution time and search controls
  - compilation
  - consultation mode

The expanded API is
*/          
%=================================================================
%  CONSULTATION MANAGEMENT DIRECTIVES
%=================================================================

/*
where the xxxNative versions take the disp_modification WFSform and the other
versions take STANDARD.  Consultation mode has a cycl default interface too:
*/



/* ; where the list is of arguments
missing that is requested from the user.  The default is to ask for
any and forall arguments that are missing

%TODO

ua_consultationModeEvery() ; ask the user for as many inputs as he's willing

to give
etc. ; other modes...

A further expansion to handle communication with a user agent external to
Prolog would add a message sent to a socket that process is listening to.
and a message string sent from Prolog to the user agent to request user input

"userInputRequest predicateName<cr>"

Where <cr> indicates a carriage return or some other suitable delimiter.

*/


% User Agent
:-dynamic_transparent('$CycOption'/3).
:-dynamic_transparent(saved_note/4).
:-dynamic_transparent(act_mem/3).


% ===========================================================
% THREAD SERVICE
% ===========================================================

% imports these models from SWI-Prolog
% thread_create(Goal,Id,Options)
% current_thread(Id,Status)
% thread_at_exit(Goal)
% thread_self(Id)
% thread_at_exit(Id,Goal)
% thread_join(Id,_)

/*
:-swi_module(cyc_threads,
      [ 
      	 servantProcessCreate/1,
	 servantProcessCreate/3,
	 servantProcessCreate/4,
	 servantProcessCreate/5,
	 isCycProcess/2,
	 isCycProcess/5,
	 createProcessedGoal/1,
	 servantProcessSelfClean/0,
	 showCycStatisticsHTML/0,
	 cleanOldProcesses/0,
	 showCycProcessHTML/0]).
  */
% :-include('cyc_header.pl').

:-dynamic_transparent(isCycProcess/5).


createProcessedGoal(Goal):-
      servantProcessCreate((thread_at_exit((
	 (thread_self(Id),thread_exit(i_am_done(Id))))),Goal),Id,[]).


servantProcessCreate(Perms,Name,Goal,Id,Options):-
        thread_create((thread_at_exit(servantProcessSelfClean),Goal),Id,Options),
        asserta(isCycProcess(Perms,Name,Goal,Id,Options)).

servantProcessCreate(Name,Goal,Id,Options):-
        thread_create((thread_at_exit(servantProcessSelfClean),Goal),Id,Options),
        asserta(isCycProcess(killable,Name,Goal,Id,Options)).

servantProcessCreate(Goal,Id,Options):-
        thread_create((thread_at_exit(servantProcessSelfClean),Goal),Id,Options),
        asserta(isCycProcess(killable,thread(Id),Goal,Id,Options)).

servantProcessCreate(Goal):-servantProcessCreate(Goal,_Id,[]),!. %%global(2800),local(2800),trail(2800)

isCycProcess(ID,Goal):-
        isCycProcess(_,_,Goal,ID,_).

debugProcess(T):-
	thread_signal(T, (attach_console, true)).


servantProcessSelfClean:-
      thread_self(Id),
      retractall(isCycProcess(_Perms,_Name,_Goal,Id,_Options)).




showCycStatisticsHTML:-
   writeFmt('<pre>'),prolog_statistics,
   threads,
   writeFmt('<br>'),
   writeFmt('</pre>').

showCycProcessHTML:-
        once(showCycStatisticsHTML),
        writeFmt('<hr><table border=1 width=80%><th>Id</th><th>Name</th><th>Status</th><th>Actions</th><th>Options</th><th>Goals</th>',[]),
        ignore((current_thread(Id,Status),
        isCycProcess(Perms,Name,Goal,Id,Options),
        once(writeCycProcessesHTML(Perms,Name,Goal,Id,Options,Status)),
        fail)),writeFmt('</table>',[]),!.


writeCycProcessesHTML(nokill,Name,Goal,Id,Options,Status):-
        writeFmt('<tr><td>~w</td><td><nobr>~w</td><td>~w</td><td>nokill</a></td><td>~w</td><td>~w</td><tr>\n ',[Id,Name,Status,Options,Goal]),!.

writeCycProcessesHTML(Perms,Name,Goal,Id,Options,Status):-
        writeFmt('<tr><td>~w</td><td><nobr>~w</td><td>~w</td><td><A href="controlpanel.jsp?killable=~w">Kill</a></td><td>~w</td><td>~w</td><tr>\n ',[Id,Name,Status,Id,Options,Goal]),!.

cleanOldProcesses:-
        saveUserInput,
        current_thread(Id,Status),
        handleProcessStatus(Id,Status),fail.
cleanOldProcesses:-writeSavedPrompt,!.
cleanOldProcesses:-!.

handleProcessStatus(Id,running):-!. %Normal
handleProcessStatus(Id,exited(complete)):-!,thread_join(Id,_),!.
handleProcessStatus(Id,true):-!, debugFmt('% Process ~w complete.\n',[Id]),!,thread_join(Id,_),!.
handleProcessStatus(Id,exception(Error)):-!, debugFmt('% Process ~w exited with exceptions: ~q \n',[Id,Error]),!. %,thread_join(Id,_),!.
handleProcessStatus(Id,O):-!, debugFmt('% Process ~w exited "~q". \n',[Id,O]),!,thread_join(Id,_),!.

mutex_call(Goal,Id):-
                        mutex_create(Id),
                        mutex_lock(Id),!,
                        with_mutex(Id,Goal),!,
                        mutex_unlock_all.



%:-defaultAssertMt(Mt),!,ensureMt(Mt),cycAssert('BaseKB':'#$genlMt'(Mt,'InferencePSC')). % Puts the defaultAssertMt/1 into Cyc 
%:-defaultAssertMt(Mt),ensureMt(Mt).




% ===========================================================
% HTML
% ===========================================================

writeHTMLStdHeader(Title):-
   writeFmtFlushed('
   <html>
   <head>
   <meta http-equiv="Content-Language" content="en-us">
   <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
   <meta name="Keywords" content="PROLOG Artificial Intelligence Ontology AI MOO DARPA Douglas Miles">
   <meta name="Description" content="PROLOG Artificial Intelligence Ontology AI DARPA MOO">
   <title>MOO Engine - ~w</title>
   </head>
   <body>
          <a href="browse.moo">Browse</a> 
	    <a href="english.moo">English</a>
	    <a href="cycl.moo">CycL</a>
	    <a href="subl.moo">SubLisp</a>
	    <a href="daml.moo">Daml</a>
	    <a href="wn.moo">WordNet</a>
	    <a href="cycml.moo">CycML</a>
	    <a href="prolog.moo">Prolog</a>
	    <a href="settings.moo">Settings</a>
	    <a href="system.moo">System</a>
	    <a href="help.moo">Help</a>
	  <br><font size=+1>Create/Edit</font>
	   <a href="predicate.moo">Predicate</a>
	   <a href="function.moo">Function</a>
	   <a href="collection.moo">Collection</a>
	   <a href="microtheory.moo">Microtheory</a>
	  <font size=+1>Tests</font>
	   <a href="inference_tests.moo">Inference</a><br>
       <br><font size=+1 color=green><b>~w</b></font><br>
   ',[Title,Title]).

writeHTMLStdFooter:-
   writeFmtFlushed('
   </body>
   </html>',[X]).



 
clauseForVirtual(Predicate/Arity,Head):-functor(Head,Predicate,Arity),!.
clauseForVirtual(Predicate,Predicate).
clauseForVirtual(Predicate,Call):-not(atom(Predicate)),!.
clauseForVirtual(Term,asserted(Data,Mt,Vars,List)):-asserted(Data,Mt,Vars,List),once(memberchk(Term,List)).
clauseForVirtual(Predicate,Call):-Call=..[Predicate,_].
clauseForVirtual(Predicate,Call):-Call=..[Predicate,_,_].
clauseForVirtual(Predicate,Call):-Call=..[Predicate,_,_,_].
clauseForVirtual(Predicate,Call):-Call=..[Predicate,_,_,_,_].

getClauseDB(saved(Data,Mt,Vars,List),saved(Data,Mt,Vars,List)):-!.
getClauseDB(Head,imported_from(X,Head)):-predicate_property(Head,imported_from(X)).
getClauseDB(Head,implimentedInCode(Head)):-real_builtin_predicate(Head),!.
getClauseDB(Head,implimentedInCode(Head)):-predicate_property(Head,foreign),!.
getClauseDB(Head,entails(VirtualClauses,Head)):-clause(Head,VirtualClauses).


htmlListing(Predicate):-
      writeFmtFlushed('<pre>'),
      clauseForVirtual(Predicate,Head),
      getClauseDB(Head,VirtualClauses),
      writeHtml(VirtualClauses),fail.

htmlListing(Predicate):-
      make,
      writeFmtFlushed('~nEnd of Clauses with ~w</pre>',[Predicate]),!.

writeHtml(linkEach([])):-!.
writeHtml(linkEach([H|T])):-writeHtml(linkFor(H)),
      writeHtml(nl),writeHtml(linkEach(T)).
writeHtml(nl):-format('<br>').

writeHtml(linkFor(H)):-
	 my_www_form_encode(H,E),
	 writeFmtFlushed('<A href="browse.moo?find=~w">~w</A>',[E,H]).
%writeHtml((H:-T)):-!,writeHtml(prologEntails(T,H)).      
writeHtml(Clauses):-
        flag(indent,_,0),
      numbervars(Clauses,0,_),%true,
      toCycApiExpression(html(Clauses),[],O),!,
      writeFmtFlushed('~w~n',[O]).

my_www_form_encode(X,Y):-www_form_encode(X,Y).


writeHyperLink(NameFmt,NameArgs,UrlFmt,UlrArgs):-
      writeFmtFlushed('<a href="'),writeFmtFlushed(UrlFmt,UlrArgs),
      writeFmtFlushed('">'),writeFmtFlushed(NameFmt,NameArgs),writeFmtFlushed('</a>'),!.

writeCheckbox(Name,Text,Default):-
      getCycOption(Name=Default,Value),
      valueToCheckMark(Value,OnOff,More),
      writeFmtFlushed('<label for="~w"><input id="~w" type="checkbox" name="~w" value="~w" ~w>~w</label>',[Name,Name,Name,OnOff,More,Text]).

writeSpaces(N):-not(number(N)),!.
writeSpaces(N):-N<1,!.
writeSpaces(N):-format('&nbsp;'),NN is N-1,writeSpaces(NN),!.


valueToCheckMark(Value,'ON','CHECKED'):-memberchk(Value,['ON',yes,true,'TT','T','True','Yes']).
valueToCheckMark(Value,'OFF',' ').

:-set_prolog_flag(double_quotes,string).


%  ======================================
%  lisp_reade_term(Lisp)
%  ======================================
% :-set_prolog_flag(double_quotes,codes).


:-retract(double_quotes_was(X)),set_prolog_flag(double_quotes,X).


% ===================================================================
% Lowlevel readCycLTermChars
% ===================================================================
%%getSurfaceFromTokens(GET,TERM,VARS):-!.

%getSurfaceFromTokens(GET,SURF,VARS):-debugOnFailure(s2p(surfFromTokens,GET,SURF,VARS)),!.
getSurfaceFromTokens(GET,token(GET),_VARS):-!.


end_of_file.

:- decl_mpred((
'abbreviationString-PN'/2, 
'countryName-LongForm'/2, 
'countryName-ShortForm'/2, 
abbreviationForLexicalWord/3, 
adjSemTrans/4, 
compoundString/4, 
denotation/4, 
formerName/2,
denotationRelatedTo/4, 
genFormat/3, 
genPhrase/4, 
headMedialString/5, 
initialismString/2, 
multiWordString/4, 
nameStrings/2, 
nounPrep/3, 
partOfSpeech/3, 
preferredGenUnit/3, 
preferredNameString/2, 
prepCollocation/3, 
scientificName/2, 
verbSemTrans/4, 
infinitive/4, 
'termStrings-GuessedFromName'/2)).

:- registerCycPredPlus2([
'abbreviationForCompoundString'/6,
'abbreviationForLexicalWord'/5,
'abbreviationForMultiWordString'/6,
'abbreviationForString'/4,
'abbreviationString-PN'/4,
'abnormal'/4,
'acronymString'/4,
'actionExpressesFeelingToward'/5,
'actionViolatesObligation'/4,
'adjacentTo'/4,
'adjSemTrans'/6,
'adjSemTrans-Restricted'/7,
'adjSemTransTemplate'/5,
'affiliatedWith'/4,
'affixRuleArity'/4,
'affixRuleCategorialConstraint'/4,
'affixRuleTypeMorphemePosition'/5,
'affixSemantics'/4,
'agentive-Mass'/4,
'agentive-Pl'/4,
'agentive-Sg'/4,
'agentiveNounSemTrans'/6,
'agreeingAgents'/4,
'algorithmStartStep'/4,
'allies'/4,
'alternateRouteFromThrough'/6,
'altitudeAnglePredicate'/4,
'analogousFeelings'/4,
'anatomicalParts'/4,
'areaOfRegion'/4,
'arg1Format'/4,
'arg1Genl'/4,
'arg1Isa'/4,
'arg2Format'/4,
'arg2Genl'/4,
'arg2Isa'/4,
'arg3Format'/4,
'arg3Genl'/4,
'arg3Isa'/4,
'arg4Format'/4,
'arg4Genl'/4,
'arg4Isa'/4,
'arg5Format'/4,
'arg5Genl'/4,
'arg5Isa'/4,
'arg6Format'/4,
'arg6Isa'/4,
'argAdmittanceTestedDuringTransitiveViaInference'/6,
'argAndRestIsa'/5,
'argQuotedIsa'/5,
'argGenl'/5,
'argIsa'/5,
'argsIsa'/4,
'arity'/4,
'arityMax'/4,
'arityMin'/4,
'assertionTimeOfMicrotheory'/4,
'assertTemplate-Reln'/6,
'azimuthAnglePredicate'/4,
'backchainForbidden'/3,
'backchainRequired'/3,
'barLevelOfPhraseType'/4,
'baseForm'/4,
'basicSpeechPartPred'/4,
'behaviorCapable'/5,
'beliefs'/4,
'beneficiary'/4,
'betweenCyc'/5,
'bogusSpeechPart'/3,
'bordersOn'/4,
'budgetExpenditureFractionOfGDP'/6,
'budgetExpenditures'/6,
'canBop'/4,
'capitalCity'/4,
'cardinality'/4,
'casualtyCount'/4,
'causes-PropProp'/4,
'causes-SitProp'/4,
'chiefPorts'/4,
'citizens'/4,
'coExtensional'/4,
'collectionBackchainEncouraged'/3,
'collectionIntersection'/4,
'collectionUnion'/4,
'comment'/4,
'commutativeInArgs'/5,
'commutativeInArgsAndRest'/4,
'comparativeAdverb'/4,
'comparativeDegree'/4,
'completeCollectionExtent'/3,
'completeExtentKnown'/3,
'compoundSemTrans'/7,
'compoundString'/6,
'compoundStringDenotesArgInReln'/7,
'compoundVerbSemTrans'/6,
'conceptuallyRelated'/4,
'conditionalProbability'/5,
'conditionalProbabilitySet'/5,
'considersAsEnemy'/4,
'constrainsArg'/4,
'consumptionAmountDuring'/6,
'consumptionCapacityDuring'/6,
'containsInformation'/4,
'contiguousAfter'/4,
'contradictoryPreds'/4,
'contraryFeelings'/4,
'contrastedFeelings'/4,
'controls'/4,
'correspondingPreds-Capability'/4,
'countryCodeDigraph'/4,
'countryName-LocalLongForm'/4,
'countryName-LocalShortForm'/4,
'countryName-LongForm'/4,
'countryName-ShortForm'/4,
'covering'/4,
'currencyOf'/4,
'currentAccountBalanceDuring'/5,
'customers'/4,
'cyclistNotes'/4,
'damages'/4,
'dateOfEvent'/4,
'deathToll'/5,
'decontextualizedCollection'/3,
'decontextualizedCollectionConventionMt'/4,
'decontextualizedPredicate'/3,
'decontextualizedPredicateConventionMt'/4,
'decreasesCausally'/5,
'defaultCorrespondingRoles'/4,
'defaultReformulationDirectionInModeForPred'/5,
'defenseBudgetExpenditures'/4,
'definingMt'/4,
'definingTimeUnit'/4,
'defnIff'/4,
'defnSufficient'/4,
'deliberateActors'/4,
'denotation'/6,
'denotationPlaceholder'/6,
'denotationRelatedTo'/6,
'denotatumArg'/4,
'denotesArgInReln'/6,
'derivationalAffixBasePOS'/4,
'derivationalAffixResultPOS'/4,
'derivedProbability'/4,
'derivedProbability-Range'/4,
'derivedUsingPrefix'/4,
'derivedUsingSuffix'/4,
'desires'/4,
'determinerAgreement'/4,
'deviceUsed'/4,
'different'/4,
'directingAgent'/4,
'disjointWith'/4,
'distanceAboveSeaLevel'/4,
'distanceBetween'/5,
'domainAssumptions'/4,
'doneBy'/4,
'driverActor'/4,
'duration'/4,
'eastOf'/4,
'elInverse'/4,
'emptiesInto'/4,
'endingDate'/4,
'endingPoint'/4,
'endsAfterEndingOf'/4,
'enforcingAgent'/4,
'englishGloss'/4,
'equals'/4,
'etymologicalVariantOfSuffix'/5,
'evaluate'/4,
'evaluationDefn'/4,
'eventOccursAt'/4,
'exceptFor'/4,
'exceptWhen'/4,
'exchangeRateDuring'/6,
'exchangeRateDuring-Market'/6,
'exchangeRateDuring-Official'/6,
'executableProgramName'/4,
'expansion'/4,
'expansionAxiom'/4,
'expansionDefn'/4,
'expertRegarding'/4,
'exportAmountDuring'/6,
'exportCapacityDuring'/6,
'exportDestinationFractionDuring'/6,
'exportRate'/5,
'exportRateThrough'/6,
'exportRevenueFractionDuring'/6,
'exports'/4,
'exportsThrough'/5,
'exportThroughAmountDuring'/7,
'extent'/4,
'facets-Generic'/4,
'facets-Partition'/4,
'facets-Strict'/4,
'fanOutArg'/4,
'fertilityRate'/4,
'firstPersonSg-Present'/4,
'firstSubEvents'/4,
'flowCapacity'/4,
'followingIntervalType'/4,
'followingValue'/4,
'formalityOfWS'/6,
'formalityOfWS-New'/4,
'formationAuthorizedBy'/4,
'formedByConfluenceOf'/4,
'formerName'/4,
'frequencyOfActionType'/6,
'functionalInArgs'/4,
'functionCommutesWith'/4,
'functionCorrespondingPredicate'/5,
'functionCorrespondingPredicate-Canonical'/5,
'functionCorrespondingPredicate-Generic'/5,
'genCodeSupport'/3,
'generalSemantics'/4,
'generateArgWithOutsideScope'/4,
'generateQuantOverArg'/5,
'genExpansion'/4,
'genFormat'/5,
'genFormat-ArgFixed'/7,
'genFormat-NP'/5,
'genFormat-Precise'/5,
'genKeyword'/4,
'genlAttributes'/4,
'genlFuncs'/4,
'genlInverse'/4,
'genlMt'/4,
'genlMt-Vocabulary'/4,
'genlPreds'/4,
'genls'/4,
'genMassNoun'/3,
'genNatTerm-ArgLast'/5,
'genNatTerm-compoundString'/7,
'genNatTerm-multiWordString'/7,
'genPhrase'/6,
'genPreferredKeyword'/4,
'genQuestion'/6,
'genStringAssertion'/4,
'genStringAssertion-Old'/3,
'genStringAssertion-Precise'/4,
'genTemplate'/4,
'genTemplate-Constrained'/5,
'genWithGloss'/3,
'geographicalSubRegions'/4,
'geopoliticalSubdivision'/4,
'givesSupportToAgent'/5,
'goalCategoryForAgent'/5,
'goals'/4,
'governmentType'/4,
'granuleOfStuff'/4,
'greaterThanOrEqualTo'/4,
'grossDomesticProduct'/5,
'grossDomesticProduct-Nominal'/5,
'grossDomesticProduct-Slot'/4,
'grossNationalProduct'/5,
'groupCardinality'/4,
'groupMembers'/4,
'groupMemberType'/4,
'hasAgents'/4,
'hasBeliefSystems'/4,
'hasClimateType'/4,
'hasHeadquartersInCountry'/4,
'hasLeaders'/4,
'hasMembers'/4,
'hasOwnershipIn'/4,
'hasSequentialProgramSteps'/5,
'hasStatusWithAgent'/5,
'headMedialString'/7,
'headsPhraseOfType'/4,
'holdsIn'/4,
'hyphenString'/6,
'implies'/4,
'importAmountDuring'/6,
'importanceOfThingInSet'/5,
'importCapacityDuring'/6,
'importExpenditureFractionDuring'/6,
'importFromAmountDuring'/7,
'importFromThroughAmountDuring'/8,
'importOriginFractionDuring'/6,
'importRate'/5,
'importRateFrom'/6,
'imports'/4,
'importsFrom'/5,
'importsThrough'/5,
'importThroughAmountDuring'/7,
'increasesCausally'/5,
'independentArg'/4,
'industryFacilities'/4,
'industryFractionOfGDP'/6,
'industryProduces'/4,
'infinitive'/4,
'inflationRateDuring'/5,
'infoTransferred'/4,
'inhabitantTypes'/4,
'initialismString'/4,
'initialParameterValue'/4,
'inputsDestroyed'/4,
'inReactionTo'/4,
'localityOfObject'/4,
'instanceElementType'/4,
'instancesDontNeedLexification'/3,
'instrument-Generic'/4,
'intangibleParts'/4,
'integerRange'/4,
'intendedBehaviorCapable'/5,
'interArg1ResultGenls'/5,
'interArg1ResultIsa'/5,
'interArg2ResultIsa'/5,
'interArgCardinality'/7,
'interArgDifferent'/5,
'interArgFormat1-1'/5,
'interArgFormat1-2'/5,
'interArgFormat2-2'/5,
'interArgGenl2-1'/5,
'interArgIsa1-2'/5,
'interArgIsa1-3'/5,
'interArgIsa2-1'/5,
'interArgIsa3-4'/5,
'interArgIsa4-5'/5,
'interArgReln'/6,
'interArgReln1-2'/4,
'interArgReln1-3'/4,
'interArgReln1-4'/4,
'interArgReln2-1'/4,
'interArgReln2-3'/4,
'interArgReln2-4'/4,
'interArgReln3-1'/4,
'interArgReln3-2'/4,
'interArgReln3-4'/4,
'interArgResultGenl'/6,
'interArgResultIsa'/6,
'interArgResultReln'/5,
'internationalMonetaryReservesDuring'/5,
'internationalOrg-MemberCountry'/4,
'interResultArgReln'/5,
'intersectsIntervalType'/4,
'intervalStartedBy'/4,
'inverseFunc'/4,
'isa'/4,
'jurisdictionRegion'/4,
'keClarifyingCollection'/3,
'keCommonQueryPredForInstances'/4,
'keConsiderationInverse'/4,
'keConsiderationPreds'/4,
'keGenlsConsiderationInverse'/4,
'keGenlsConsiderationPreds'/4,
'keGenlsStrongSuggestionPreds'/4,
'keGenlsWeakSuggestionInverse'/4,
'keGenlsWeakSuggestionPreds'/4,
'kePredArgStrongSuggestionPreds'/5,
'kePredArgWeakSuggestionPreds'/5,
'keRequirementPreds'/4,
'keStrongConsiderationInverse'/4,
'keStrongConsiderationPreds'/4,
'keStrongSuggestion'/4,
'keStrongSuggestionInverse'/4,
'keStrongSuggestionPreds'/4,
'keWeakSuggestionInverse'/4,
'keWeakSuggestionPreds'/4,
'knows'/4,
'laborForceDuring'/5,
'laborForceFractionDuring'/6,
'languageOfLexicon'/4,
'languagesSpokenHere'/4,
'laterThan'/4,
'latitude'/4,
'lengthOfObject'/4,
'lengthOfPathTypeInRegion'/5,
'lessLikelyThan-Prior'/4,
'lexicalWordTypeForLanguage'/4,
'lightVerb-TransitiveSemTrans'/5,
'linksOfCustomarySystem'/4,
'listSetMembers'/4,
'literacyRateForGroupInRegion'/5,
'longitude'/4,
'majorReligions'/4,
'maleficiary'/4,
'massNounSemTrans'/6,
'massNumber'/4,
'memberStatusInOrganization'/5,
'microtheoryDesignationArgnum'/4,
'minimize'/3,
'minimizeExtent'/3,
'modalInArg'/4,
'morphologicalComposition'/5,
'morphologicallyDerivedFrom'/4,
'mtInferenceFunction'/4,
'multiplicationUnits'/5,
'multiWordSemTrans'/7,
'multiWordString'/6,
'multiWordStringDenotesArgInReln'/7,
'nameOfAgent'/4,
'nameStrings'/4,
'nationalBudgetExpenditures'/4,
'nationalLanguage'/4,
'naturalResourcesInRegion'/4,
'ncRuleConstraint'/4,
'ncRuleLabel'/4,
'ncRuleTemplate'/4,
'near'/4,
'negationAttribute'/4,
'negationInverse'/4,
'negationPreds'/4,
'negativeVestedInterest'/4,
'nicknames'/4,
'nlPhraseTypeForTemplateCategory'/4,
'no-GenQuant'/4,
'nonCompositionalVerbSemTrans'/5,
'nonGradableAdjectiveForm'/4,
'nonThirdSg-Present'/4,
'northeastOf'/4,
'northOf'/4,
'northwestOf'/4,
% 'not'/3,
'notAssertible'/3,
'notAssertibleCollection'/3,
'notAssertibleMt'/3,
'nounPrep'/5,
'nounSemTrans'/6,
'nthLargestElement'/6,
'numInhabitants'/4,
'objectActedOn'/4,
'objectFoundInLocation'/4,
'obligatedAgent'/4,
'obligationParts'/4,
'occurrencesPerPeriod'/5,
'officialArmedForces'/4,
'oldConstantName'/4,
'opaqueArgument'/4,
'opponents'/4,
'opponentsInConflict'/5,
'oppositeAttributeValue'/4,
'oppositeDirection-Precise'/4,
'or'/4,
'overrides'/4,
'owns'/4,
'paraphraseCoercionAllowedFrom'/4,
'partitionedInto'/4,
'partOfSpeech'/5,
'pastTense-Universal'/4,
'pathBetween'/5,
'pathConnects'/5,
'pathFromToInSystem'/6,
'pathTerminus'/4,
'perfect'/4,
'performedBy'/4,
'performsInsAtLocation'/5,
'perpendicularVectors'/4,
'phoneticVariantOfPrefix'/5,
'phoneticVariantOfSuffix'/5,
'phraseTemplateArg'/4,
'physicalPartTypes'/4,
'placeName-ShortForm'/4,
'plural'/4,
'pluralVerb-Present'/4,
'pnMassNumber'/4,
'pnPlural'/4,
'pnSingular'/4,
'politenessOfWS'/6,
'populationDuring'/5,
'populationGrowthRate'/4,
'posBaseForms'/4,
'posForms'/4,
'posForTemplateCategory'/4,
'positiveVestedInterest'/4,
'posOfPhraseType'/4,
'posPredForTemplateCategory'/4,
'power-Military'/4,
'predicateForAction'/4,
'preferredGenUnit'/5,
'preferredNameString'/4,
'preferredTermStrings'/4,
'prefixString'/4,
'prepCollocation'/5,
'prepReln-Action'/6,
'prepReln-Object'/6,
'prepSemTrans'/6,
'presentParticiple'/4,
'presentTense-Universal'/4,
'preservesGenlsInArg'/4,
'prettyName'/4,
'primaryFunction'/5,
'priorProbability'/4,
'priorProbability-Range'/4,
'productionAmountDuring'/6,
'productionCapacity'/5,
'productionCapacityDuring'/6,
'productionQuotaDuring'/6,
'productionRateOfRegion'/5,
'productionValueOfIndustryDuring'/6,
'programAlgorithmInputs'/4,
'programAlgorithmInputs'/5,
'programAlgorithmInternals'/4,
'programAlgorithmOutputs'/4,
'programExpressionHasType'/4,
'programFunctionArity'/4,
'programFunctionIdentifier'/4,
'programFunctionOperator'/4,
'programIfConditionThenElse'/6,
'programObjectTypeRepresents'/4,
'programStrings'/4,
'programTypeStrings'/4,
'programWhileConditionDo'/5,
'properNounSemTrans'/6,
'psRuleArity'/4,
'psRuleCategory'/4,
'psRuleConstraint'/4,
'psRuleExample'/4,
'psRuleSemanticsFromDtr'/4,
'psRuleSemanticsHandler'/4,
'psRuleSyntacticHeadDtr'/4,
'psRuleTemplateBindings'/4,
'psRuleTemplateDtr'/4,
'purchaseFromFractionDuring'/7,
'purposeInEvent'/5,
'quotedArgument'/4,
'quotedCollection'/3,
'realGDPGrowthRateDuring'/5,
'realGNPGrowthRateDuring'/5,
'recipientOfInfo'/4,
'reformulationPrecondition'/5,
'reformulatorEquals'/4,
'reformulatorEquiv'/4,
'regionHasTransportMeans'/4,
'regionLacksTransportMeans'/4,
'regularAdverb'/4,
'regularDegree'/4,
'regularSuffix'/5,
'relatedArgPositions'/5,
'relationAll'/4,
'relationAllExists'/5,
'relationAllExistsCount'/6,
'relationAllExistsMany'/5,
'relationAllExistsMax'/6,
'relationAllExistsMin'/6,
'relationAllInstance'/5,
'relationExistsAll'/5,
'relationExistsAllMany'/5,
'relationExistsCountAll'/6,
'relationExistsInstance'/5,
'relationExistsMaxAll'/6,
'relationIndicators'/5,
'relationIndicators-Strong'/5,
'relationInstanceAll'/5,
'relationInstanceExists'/5,
'relationInstanceExistsCount'/6,
'relationInstanceExistsMany'/5,
'relationInstanceExistsMax'/6,
'relationInstanceExistsMin'/6,
'reliabilityOfMicrotheory'/4,
'requiredActorSlots'/4,
'requiredArg1Pred'/4,
'requiredArg2Pred'/4,
'residenceOfOrganization'/4,
'resultGenl'/4,
'resultGenlArg'/4,
'resultIsa'/4,
'resultIsaArg'/4,
'resultIsaArgIsa'/4,
'revenueFromProduct'/5,
'rewriteOf'/4,
'rolesForEventType'/4,
'saleToFractionDuring'/7,
'salientAssertions'/4,
'scientificName'/4,
'scopingArg'/4,
'secondPersonSg-Present'/4,
'sellsProductType'/4,
'semTransArg'/4,
'semTransPredForPOS'/4,
'senderOfInfo'/4,
'sentenceDesignationArgnum'/4,
'sharedNotes'/4,
'shortTimeIntervalAfter'/4,
'siblingDisjointExceptions'/4,
'singular'/4,
'skillRequired'/6,
'socialParticipants'/4,
'softwareParameterDomain'/4,
'softwareParameterHasType'/4,
'spatiallyIntersects'/4,
'spatiallyIntrinsicArg'/4,
'spatiallySubsumes'/4,
'speechPartPreds'/4,
'startingDate'/4,
'startingPoint'/4,
'startsAfterEndingOf'/4,
'startsAfterStartingOf'/4,
'startsDuring'/4,
'statementOfPurpose'/4,
'subBeliefSystem'/4,
'subcatFrame'/6,
'subcatFrameArity'/4,
'subcatFrameDependentConstraint'/5,
'subcatFrameDependentKeyword'/5,
'subcatFrameExample'/4,
'subcatFrameKeywords'/4,
'subEvents'/4,
'subEventType'/4,
'subEventTypes'/4,
'subGroups'/4,
'subIndustries'/4,
'subjectRoles'/4,
'subOrganizations'/4,
'subsumesIntervalType'/4,
'suffixString'/4,
'suffrageAge'/4,
'superlativeAdverb'/4,
'superlativeDegree'/4,
'superTaxons'/4,
'suppliedWithFrom'/5,
'supplyFromThroughAmountDuring'/8,
'supplyThroughAmountDuring'/7,
'surroundsHorizontally'/4,
'synonymousExternalConcept'/5,
'temporalBoundsContain'/4,
'temporallyCooriginating'/4,
'temporallyCoterminal'/4,
'temporallyIntrinsicArg'/4,
'temporallyStartedBy'/4,
'temporallySubsumes'/4,
'termDoesntNeedLexification'/3,
'termPOS-Strings'/5,
'termStrings'/4,
'termStrings-GuessedFromName'/4,
'territoriesControlled'/4,
'thereExistAtLeast'/5,
'thereExistExactly'/5,
'thereExists'/4,
'thirdPersonSg-Present'/4,
'timeIntervalBetween'/5,
'toBeReviewedBy'/4,
'topicOfIndividual'/4,
'topicOfInfoTransfer'/4,
'totalBudgetExpenditures'/5,
'totalReserves'/5,
'tradeBalanceDuring'/6,
'transitiveViaArg'/5,
'transitiveViaArgInverse'/5,
'transportedInTypes'/4,
'transportees'/4,
'transportFacilityFor'/4,
'trueRule'/4,
'colBehaviorCapable'/5,
'coldGenlInverse'/4,
'coldGenlPreds'/4,
'typeGenls'/4,
'colLevelVersionInArg'/7,
'unemploymentRateDuring'/5,
'uniquePartTypes'/4,
'unitExpansions'/4,
'unitMultiplicationFactor'/5,
'unitOfMeasurePrefixString'/4,
'useReformulationRuleForQuantifierProcessing'/3,
'variantOfSuffix'/4,
'verbPrep-Passive'/5,
'verbPrep-Transitive'/5,
'verbPrep-TransitiveTemplate'/5,
'verbSemTrans'/6,
'verbSemTransPartial'/6,
'verbSemTransTemplate'/5,
'victim'/4,
'widthOfObject'/4,
'wnAdjectiveParticiple'/6,
'wnAdjectivePertains'/6,
'wnAntonymous'/6,
'wnAttribute'/4,
'wnCauses'/4,
'wnEntailment'/4,
'wnFollowsInMeaning'/6,
'wnHypernym'/4,
'wnMemberMeronym'/4,
'wnPartMeronym'/4,
'wnS'/8,
'wnSimilarInMeaning'/4,
'wnSubstanceMeronym'/4,
'wnVerbsSimilarInMeaning'/4,
'wordInLanguage'/4,
'wornOn-TypeType'/4
]).




