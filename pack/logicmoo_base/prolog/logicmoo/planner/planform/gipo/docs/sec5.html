<html>
<head>
<title>The Object Centred Language Manual (Version1.2) - Development of an Hierarchical Domain Model</title>
</head>
<body bgcolor="#FFFFFF">
<a NAME="top">
<table width="100%"><tr>
<td align=left valign=top><td align=left valign=top><a href="sec4.html"><img SRC="prev.gif" ALT="prev" BORDER=0></a>
<a href="content.html"><img SRC="index.gif" ALT="content" BORDER=0> </a></td>
<td align=center><h2 align=center>The Object Centered Language Manual<br>
<b>OCL<font valign=bottom size=-1>h</font></b> - Version1.2</h2>
<td align=right><a href="http://helios.hud.ac.uk/planform/main.html">
<img src="planform_logo2.gif" height="30" width="140" border=0 alt="Planform Home"></a>
</td>
</tr></table>
<hr>

<h2 align=center>5. Development of an Hierarchical Domain Model</h2>

<h4><a name="Sec51">5.1. Sort Hierarchy</h4>

As a larger example, we will use a transport logistics model based on 
Translog <a href="ref.html">[4]</a>.
This is a nice example of a domain needing hierarchy and hierarchical operators.
A sort hierarchy for Translog is shown in Example 1, containing 4 
dynamic primitive sorts <i>truck, package, train, traincar</i> and 
hence 15 dynamic objects.
In <a href="http://helios.hud.ac.uk/planform/resource/translog_spec">here</a> we give a full specification of our 
Translog (although there
are a few differences to the examples below!).
 
<pre>
   sorts(physical-obj, [vehicle, package])
   sorts(vehicle, [railv,roadv])
   sorts(roadv, [truck])
   sorts(railv, [train, traincar])
   sorts(location, [city-location,city])
   sorts(city-location, [tcentre,not-tcentre])
   sorts(tcentre, [train-station])
   sorts(not-tcentre, [clocation,post-office])
   sorts(route, [road-route, rail-route])
   objects(train-station, [city1-ts1,city2-ts1,city3-ts1])
   objects(clocation, [city1-cl1,city1-cl2,city2-cl1,city3-cl1])
   objects(post-office, [post_1])
   objects(city, [city_1, city_2, city_3])
   objects(train,[train_1,train_2])
   objects(traincar,[traincar_1])
   objects(road-route, [road-route_1,road-route_2,road-route_3]) 
   objects(rail-route,[rail-route_2,rail-route_3,rail-route_4 ]) 
   objects(truck, [truck_1, truck_2, truck_3, truck_11, truck_22, truck_33]) 
   objects(package,[pk_1, pk_2, pk_3, pk_4, pk_5, pk_6])
</pre>

<h5 align=right>Example 1</h5>

Let the predicates that
describe a train be <code>at(train,location)</code>, <code>attached(train,traincar)</code>,
<code>unattached(train)</code>, <code>in-service(train)</code>, <code>available(train)</code>.
An example of an object description is:

<pre>
   (train,train_1,[at(train_1,city1-ts1), in-service(train_1), attached(train_1,traincar_1)])
</pre>

<h5 align=right>Example 2</h5>

Here the local closed world assumption tells us that, for example,
the train is not available, and it
is not attached to other traincars apart from <code>traincar_1</code>.
Example 3 is an object expression as it is satisfied by an least
one object description - that of Example 2.
In this case <code>train</code> is a subsort of <code>railv</code>,
<code>t = [train_1/T, city1-ts1/Y]</code> and
<code>in-city(city1-ts1,city1)</code> is consistent with the domain
model.

<pre>
   (railv,T,[at(T,Y),in-service(T),in-city(Y,city1)])
</pre>

<h5 align=right>Example 3</h5>

The substate in Example 2 has three hierarchical components -
<code>at</code>, relating to physical objects, <code>attached</code> relating to
rail vehicles, and <code>in-service</code>, relating specifically to trains.
Objects of sort <code>train</code> are described by
predicates through their primitive sort
but they also inherit the dynamic predicates from supersorts <code>railv</code>
 and <code>physical_obj</code>.

<pre>
   substate_classes(physical_obj, P, [ [at(P,L), is-of-sort(L,train-station) ])
   substate_classes(railv, V,  [ [unattached(V)] ,
            [attached(V,V1),is-of-sort(V1,traincar)] ])
   substate_classes(train, T, [ [out-of-service(T)], [in-service(T)], 
            [in-service(T),available(T)] ])
</pre>

<h5 align=right>Example 4: hierarchical substate specification for trains</h5>

Example 4 implicitly specifies the substates of the train.  If there
are <code>n</code> stations, <code>m</code> traincars, and <code>t</code> 
trains then this
implicitly defines all <code>t*(n*(m+1)*3)</code> substates.
Static predicates are used to capture the exact set required.

<h4><a name="Sec52">5.2. Special Rules Relating to Hierarchical Transitions</h4>

When object transitions appear in operators, 
predicates in the hierarchy of the substate specification
that are not mentioned in
the left hand side of the transition are assumed to persist when it
is applied. For example, the transition of package <code>P</code>

<pre>
   [waiting(P),certified(P)]<img src="rarrow.gif">[loaded(P,V),certified(P)]
</pre>

changes the class expression:

<pre>
    (package,pk_1,[at(pk_1,L),waiting(pk_1),certified(pk_1)]
</pre>

to:

<pre>
    (package,pk_1,[at(pk_1,L),loaded(pk_1,V),certified(pk_1)]
</pre>

when this transition is applied. Here <code>t = [pk_1/P]</code>,
and the predicate <code>at(pk_1,L)</code> persists as it is specified
at a higher level in package's hierarchy than the other predicates.

<h4><a name="Sec53">5.3. Compound and Method Operators</h4>

A <b>compound operator</b> <code>C</code> has components:

<pre>
   (Nm,Pre,Index, 
     [(Cons<font size=-2>1</font>,Temps<font size=-2>1</font>,Body<font size=-2>1</font>),
      ..., 
     (Cons<font size=-2>n</font>,Temps<font size=-2>n</font>,Body<font size=-2>n</font>)])
</pre>

<code>Nm</code> is the operator's name followed by its
parameters, and <code>Pre</code> is a set of
object expressions that must be true before <code>C</code>
(unlike the prevail in a primitive operator
objects in <code>Pre</code> may be affected by the operators in the
expansion of <code>C</code>).
<b>Index</b> is a set of necessary
state transitions (possibly null) similar to <b>Index</b> in the
primitive operator case.
The <code>(Cons<font size=-2>i</font>,Temps<font size=-2>i</font>,Body<font size=-2>i</font>)</code> are conditional expansions, where
<code>Cons<font size=-2>i</font></code> and <code>Temps<font size=-2>i</font></code> are static conditions on the
parameters in the operator, and temporal constraints on the nodes
in the <code>Body<font size=-2>i</font></code>, respectively.
If a <code>Cons<font size=-2>i</font></code> can be satisfied, the
compound operator can be expanded into the network
as specified in <code>Body<font size=-2>i</font></code> (the <code>Cons<font size=-2>i</font></code> need not be mutually
exclusive).
<code>Body<font size=-2>i</font></code> contains nodes in the
usual HTN fashion: a node is either
the name of a primitive operator, the name of a compound operator,
or an expression of the form `achieve-goal(<code>G</code>)', where <code>G</code> is
a class expression.

Compound operators can be split into  <code>n</code> <i>methods</i>
of the form
 <pre>
   (Nn,Pre,Index,Cons<font size=-2>i</font>,Temps<font size=-2>i</font>,Body<font size=-2>i</font>)
</pre>
 
The example shows 
a method for carrying a package from one location to
another within the same city.

<pre>
   method( carry-direct(P,O,D), [], 
           [ sc(package, P, [at(P,O),waiting(P),certified(P)]<img src="rarrow.gif"> 
                      [at(P,D),waiting(P),certified(P)])] 
           [is-of-sort(P,package), is-of-sort(V,truck), 
                       in-city(O,CY), in-city(D,CY) ],
           [before(1,2), before(2,3), before(3,4),before(4,5) ], 
           [comission(V,P), move(V,OL,O,R), 
                       load-package(P,V,O), move(V,O,D,R1),
                       unload-package(P,V,D) ]). 
</pre>
 
<h5 align=right>Example 5: a `carry-direct' method</h5>

An OCL<font valign=bottom size=-1>h</font> compound operator  has
no achievable conditions on intermediate nodes in its
body.
This is because constraints on the persistence of facts
(e.g. using a `between' constraint)
throughout a sequence of nodes in compound operator bodies
can be represented within the substate
specification of each sort, making the
constraints implicit as discussed in reference <a href="ref.html">[2]</a>. 

Whenever a method has been fully expanded to primitive operators,
the resulting plan must effect the transitions
given in the <b>Index</b>.
<code>C</code> may, however, change other objects
in ways conditional on its expansion into more detailed task
networks (such as the vehicle <code>V</code> in the
example above). The property that methods decompose into
networks that guarantee the transitions specified in a
method's index we have called
<b>transparency</b>. Some earlier work discussed the design and use of
a tool for checking the
transparency of a domain model <a href="ref.html">[2]</a>.

<hr>
<table width="100%"><tr><td align=left>
<a href="sec4.html"><img src="prev.gif" border=0 alt="prev"></a>
<a href="content.html"><img src="index.gif" border=0 alt="content"></a>
</td>
<td align=center><script language="JavaScript">
<!---//hide script from old browsers
    document.write( "Last updated "+ document.lastModified );
//end hiding contents --->
</script>
</td>

</tr>
</table>
</body>
</html>
