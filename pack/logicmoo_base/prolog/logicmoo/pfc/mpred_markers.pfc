

% catching of misinterpreations
(mpred_mark(pfcPosTrigger,_,F,A)/(fa_to_p(F,A,P), predicate_property(P,static)))
  ==> {trace_or_throw(warn(pfcPosTrigger,P,static))}.
(mpred_mark(pfcPosTrigger,_,F,A)/(fa_to_p(F,A,P), \+ predicate_property(P,_))) ==> {kb:dynamic(F/A)}.


(mpred_mark(pfcNegTrigger,_,F,A)/(fa_to_p(F,A,P), predicate_property(P,static)))
  ==> {dmsg(warn(pfcNegTrigger,P,static))}.
(mpred_mark(pfcNegTrigger,_,F,A)/(fa_to_p(F,A,P), \+ predicate_property(P,_))) ==> {kb:dynamic(F/A)}.


mpred_mark(pfcPosTrigger, S1, F, A)/ground(S1)==>hybrid_support(F,A).
mpred_mark(S1, S2, F, A)/ground(S1:S2)==>arity(F,A).
%mpred_mark(pfcPosTrigger, _, F, A)/(integer(A),functor(P,F,A)) ==> pfcTriggered(F/A),   afterAdding(F,lambda(P,mpred_enqueue(P,(m,m)))).
%mpred_mark(pfcNegTrigger, _, F, A)/(integer(A),functor(P,F,A)) ==> pfcTriggered(F/A), afterRemoving(F,lambda(P,mpred_enqueue(~P,(m,m)))).

/*
mpred_mark(pfcRHS,_,F,1)/(fail,atom(F),functor(Head,F,1), 
 \+ argsQuoted(F),
 \+ prologDynamic(F),
 \+ neg(tCol(F)),
 \+ specialFunctor(F),
 \+ predicate_property(Head,built_in))==>completelyAssertedCollection(F).
*/
% mpred_mark(Type,_,F,A)/(integer(A),A>1,F\==arity,Assert=..[Type,F])==>arity(F,A),Assert.

mpred_mark_C(G) ==> {mpred_mark_C(G)}.
mpred_mark_C(G) :-  map_literals(lambda(P,(get_functor(P,F,A),mpred_add([isa(F,pfcControlled),arity(F,A)]))),G).
mpred_mark(pfcRHS,_,F,A)/(atom(F),integer(A),F\==arity)==>tPred(F),arity(F,A),pfcControlled(F/A).



