/** <module>
% =============================================
% File 'mpred_builtin.pfc'
% Purpose: Agent Reactivity for SWI-Prolog
% Maintainer: Douglas Miles
% Contact: $Author: dmiles $@users.sourceforge.net ;
% Version: 'interface' 1.0.0
% Revision: $Revision: 1.9 $
% Revised At: $Date: 2002/06/27 14:13:20 $
% =============================================
%
%  PFC is a language extension for prolog.. there is so much that can be done in this language extension to Prolog
%
%
% props(Obj,[height(ObjHt)]) == t(height,Obj,ObjHt) == rdf(Obj,height,ObjHt) == t(height(Obj,ObjHt)).
% padd(Obj,[height(ObjHt)]) == prop_set(height,Obj,ObjHt,...) == ain(height(Obj,ObjHt))
% [pdel/pclr](Obj,[height(ObjHt)]) == [del/clr](height,Obj,ObjHt) == [del/clr]svo(Obj,height,ObjHt) == [del/clr](height(Obj,ObjHt))
% keraseall(AnyTerm).
%
%         ANTECEEDANT                                   CONSEQUENT
%
%         P = test nesc_true                         assert(P),retract(neg(P))
%       ~ P = test not_nesc_true                     disable(P), assert(neg(P)),retract(P)
%    neg(P) = test false/impossible                  make_impossible(P), assert(neg(P))
%   ~neg(P) = test possible (via not impossible)     enable(P),make_possible(P),retract(neg(P))
%  \+neg(P) = test impossiblity is unknown           remove_neg(P),retract(neg(P))
%     \+(P) = test naf(P)                            retract(P)
%
% Dec 13, 2035
% Douglas Miles
*/

:- op(500,fx,'~').
:- op(1050,xfx,('<-')).
:- op(1050,xfx,'<==>').
:- op(1050,xfx,('<-')).
:- op(1100,fx,('nesc')).
:- op(1150,xfx,('::::')).
:- op(500,fx,'~').
:- op(1050,xfx,'<==>').
:- op(1050,xfx,('<-')).
:- op(1200,fx,('=>')).
:- op(1200,fx,('==>')).
:- op(1100,fx,('nesc')).
:- op(1150,xfx,('::::')).
:- op(300,fx,'-').
:- op(600,yfx,'&').  
:- op(600,yfx,'v').
:- op(1075,xfx,'<-').
:- op(1075,xfx,'<=').
:- op(1070,xfx,'=>').
:- op(1070,xfx,'<=>').
:- op(1100,xfx,('<==>')).
:- op(1100,xfx,('==>')).
:- op(350,xfx,'xor').

:- kb_dynamic(mpred_default/1).

meta_argtypes(mpred_default(ftAssertable)).

((mpred_default(P ==> Q),
  {is_ftNonvar(P),mpred_literal_nv(Q),functor(Q,F,A), 
    once(
    (singleValuedInArg(F,N));                    % We have evidence already asserted
    (is_ftCompound(P),arg(N,Q,DEF),                   % Else we guess...
                  is_ftNonvar(DEF),\+arg(_,P,DEF));   %  find the first is_ftNonvar not in P
    (N=A,arg(N,Q,DEF),is_ftNonvar(DEF));              %  try arity if is_ftNonvar
    (arg(N,Q,DEF),is_ftNonvar(DEF));                  %  find the first is_ftNonvar
    (N=A)),                                      %  lastly, use the arity
    replace_arg(Q,N,NEW,R)}) 
         ==> (P, ~R/(NEW\==DEF), ~neg(Q) ==> Q)).


% here is an example which defines mpred_default facts and rules.  Will it work?
(mpred_default(P)/mpred_literal(P))  ==>  (~neg(P) ==> P).

% seem to need both these rule the second is so we have a on remove hook
(mpred_default((P ==> Q)/mpred_literal_nv(Q)) ==> (P,  ~neg(Q) ==> Q)).
(mpred_default((P ==> Q)/mpred_literal_nv(Q)) ==> (P,  ~Q, ~neg(Q) ==> Q)).

(mpred_default((P ==> Q))/mpred_literal_nv(Q)),{functor(Q,_,1)} ==> (P, ~neg(Q) ==> Q).

(mpred_default((P ==> Q))/(mpred_literal(P),\+ mpred_literal(Q))) ==> (P ==> mpred_default(Q)).

% should be done at the canonicalizer
%  (mpred_default(P)/mpred_each_literal(P,E))  ==>  mpred_default(E).

((mpred_default(P)/(mpred_literal(P),is_ftCompound(P),if_missing_mask(P,_,Q,Test)))  ==> ((~Q/(Test), ~neg(P)) ==> P)).

:- mpred_trace_exec.


:- if(lmconf:startup_option(datalog,sanity);lmconf:startup_option(clif,sanity)).

:- ensure_loaded('genls.pfc').

tCol(tFly).
tCol(tCanary).
tCol(tPenguin).

tCol(tBird).
:- mpred_test(dynamic(tBird/1)).
:- mpred_test(current_predicate(kb:tBird(_),dynamic)).

genls(tCanary,tBird).
genls(tPenguin,tBird).



% chilly is a penguin.
tPenguin(iChilly).

:-mpred_test((tBird(iChilly))).

:- prolog.

% tweety is a canary.
tCanary(iTweety).

:-mpred_test((tBird(iTweety))).


% birds fly by default.
(mpred_default(( tBird(X) ==> tFly(X)))).

:-mpred_test((isa(I,tFly),I=iChilly)).

:-mpred_test((tFly(iTweety))).
:-mpred_test((tFly(iChilly))).


% penguins do neg tFly.
tPenguin(X) ==> neg(tFly(X)).

:-mpred_test((\+ tFly(iChilly))).
:-mpred_test((neg(tFly(iChilly)))).



:- endif.

