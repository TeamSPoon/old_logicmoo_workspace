
%   File   : pfc
%   Author : Tim Finin, finin@umbc.edu
%   Updated: 10/11/87, ...
%   Purpose: consult system file for ensure
/*
:- shared_multifile    
        lmconf:hook_one_minute_timer_tick/0,
        lmconf:infoF/1,
        lmconf:mpred_hook_rescan_files/0,
        baseKB:resolveConflict/1,
        baseKB:resolverConflict_robot/1.
*/
/*
:-export((
          all_different_head_vals/1,all_different_head_vals_2/2,

mpred_run_resume/0,mpred_run_pause/0,

% old_ain_t/2,
% mpred_select/2,
add_reprop/2,
add_side_effect/2,
%mpred_ain/1,mpred_ain/2,
old_ain_actiontrace/2,
old_ain_db_to_head/2,
old_ain_fast/1,
old_ain_fast/2,
old_ain_fast_sp/2,
old_ain_fast_sp0/2,
old_ain_fast_timed/2,
ain_minfo/1,
mpred_retry/1,
ain_minfo/2,
ain_minfo_2/2,
old_ain_rule0/1,
old_ain_rule_if_rule/1,
old_ain_support/2,
old_ain_trigger/2,
old_ain_trigger_0/3,
old_ain_trigger_1/3,
old_ain_ts/2,
aina_i/2,            
ainz_i/2,
all_closed/1,
append_as_first_arg/3,
assert_eq_quitely/1,
mpred_assumption/1,
mpred_assumptions/2,
mpred_assumptions1/2,
attvar_op/2,
baseable/2,
baseable_list/2,
old_brake/1,
build_code_test/3,
build_consequent/3,
build_neg_test/4,
build_rhs/3,
old_build_rule/3,
build_trigger/4,
bwc/0,
call_prologsys/1,
call_with_bc_triggers/1,
check_context_module/0,
check_never_assert/1,
check_never_retract/1,
clause_asserted_local/1,
clause_or_call/2,
cnstrn/1,
cnstrn/2,
cnstrn0/2,
code_sentence_op/1,
compute_resolve/3,
compute_resolve/5,
correctify_support/2,
cwc/0,
defaultmpred_select/2,            
each_in_list/3,
erase_w_attvars/2,
exact_args/1,
f_to_mfa/4,
fa_to_p/3,
old_fc_eval_action/2,
old_fcnt/2,
old_fcnt0/2,
old_fcpt/2,
old_fcpt0/2,
fix_negations/2,
fixed_negations/2,
old_foreachl_do/2,
fwc/0,            
fwd_ok/1,
get_fa/3,
get_mpred_is_tracing/1,
get_next_fact/2,
get_source_ref/1,
get_source_ref1/1,
get_user_tbox/1,
get_why/4,
has_body_atom/2,
has_cl/1,
has_db_clauses/1,
has_functor/1,
if_missing_mask/3,
if_missing_mask/4,
is_action_body/1,
is_already_supported/3,
is_bc_body/1,
is_disabled_clause/1,
is_fc_body/1,
is_mpred_action/1,
is_relative/1,
is_reprop/1,
is_reprop_0/1,
is_resolved/1,
is_retract_first/1,
is_side_effect_disabled/0,
justification/2,
old_justifications/2,
lmconf:module_local_init/0,
%loop_check_nr/1,
make_uu_remove/1,
map_literals/2,
map_literals/3,
map_unless/4,
match_source_ref1/1,
maybeSupport/2,
meta_wrapper_rule/1,
mmsg/2,
mpred_ain/1,
mpred_ain/2,
mpred_aina/1,
mpred_ainz/1,
mpred_ainz/2,
mpred_axiom/1,
mpred_bc_only/1,
mpred_bc_only0/1,
mpred_bt_pt_combine/3,
mpred_call_0/1,
mpred_call_1/3,
mpred_call_only_facts/1,
mpred_call_only_facts/2,
mpred_call_with_no_triggers/1,
mpred_call_with_no_triggers_bound/1,
mpred_call_with_no_triggers_uncaugth/1,
mpred_child/2,
mpred_children/2,
mpred_clause/3,
mpred_clause_i/1,
mpred_clause_is_asserted/2,
mpred_clause_is_asserted_hb_nonunify/2,
mpred_cleanup/0,
mpred_cleanup/2,
mpred_cleanup_0/1,
mpred_compile_rhsTerm/3,
mpred_connective/1,
mpred_current/0,
mpred_current_db/1,
mpred_current_op_support/1,
mpred_database_item/1,
mpred_database_term/1,
mpred_db_type/2,
mpred_deep_support/2,
mpred_deep_support0/2,
mpred_define_bc_rule/3,
mpred_descendant/2,
mpred_descendant1/3,
mpred_descendants/2,
mpred_each_literal/2,
mpred_enqueue/2,
mpred_error/1,
mpred_error/2,
mpred_eval_lhs/2,
mpred_eval_lhs0/2,
mpred_eval_rhs1/3,
mpred_eval_rhs_0/3,
mpred_fact/1,
mpred_fact/2,
mpred_facts/1,
mpred_facts/2,
mpred_facts/3,
mpred_facts_and_universe/1,
mpred_facts_only/1,
mpred_file_expansion_0/2,
mpred_freeLastArg/2,
mpred_fwd/1,
mpred_fwd/2,
mpred_fwd1/2,
mpred_fwd2/2,
mpred_get_support/2,
mpred_get_support_neg/2,
mpred_get_support_one/2,
mpred_get_support_precanonical/2,
mpred_get_support_precanonical_plus_more/2,
mpred_get_support_via_clause_db/2,
mpred_get_support_via_sentence/2,
mpred_had_support/2,
mpred_halt/0,
mpred_halt/1,
mpred_halt/2,
mpred_hide_msg/1,
mpred_ignored/1,
mpred_init_i/2,
mpred_is_builtin/1,
mpred_is_minfo/1,
mpred_is_silient/0,
mpred_is_spying/2,
mpred_is_taut/1,
mpred_is_tautology/1,
mpred_is_tracing_exec/0,
mpred_literal/1,
mpred_literal_nv/1,
map_first_arg/2,
map_first_arg/2,
map_first_arg/3,
mpred_mark_as/4,
mpred_mark_as_ml/4,
mpred_mark_fa_as/6,
mpred_negated_literal/1,
mpred_negated_literal/2,
mpred_negation/2,
mpred_negation_w_neg/2,
mpred_nf/2,
mpred_nf1/2,
mpred_nf1_negation/2,
mpred_nf_negation/2,
mpred_nf_negations/2,
mpred_no_chaining/1,
mpred_no_spy/0,
mpred_no_spy/1,
mpred_no_spy/3,
mpred_no_spy_all/0,
mpred_no_trace/0,
mpred_no_trace_all/0,
mpred_no_warnings/0,
mpred_no_watch/0,
mpred_non_neg_literal/1,
mpred_notrace_exec/0,
mpred_pbody/5,
mpred_pbody_f/5,
mpred_pfc_file/0,
mpred_positive_literal/1,
mpred_post/2,
mpred_post1/2,
mpred_post1_sp_0/2,
mpred_post1_sp_1/2,
mpred_post_sp/2,
mpred_post_sp_zzz/2,
mpred_post_sp_zzzz/2,
mpred_prove_neg/1,
mpred_rem/1,
mpred_withdraw/1,
mpred_withdraw/2,
mpred_remove/1,
mpred_remove/1,
mpred_remove/2,
mpred_rem_actiontrace/2,
mpred_blast/1,
mpred_remove_file_support/1,
mpred_remove_old_version/1,
mpred_remove_supports/2,
mpred_remove_supports_quietly/1,
mpred_reset/0,
mpred_retract_db_type/1,
mpred_retract_db_type/2,
mpred_retract_or_warn_i/1,
mpred_retract_support_relations/2,
mpred_rewrap_h/2,
mpred_rule_hb/3,
mpred_rule_hb_0/3,
mpred_run/0,
mpred_scan_tms/1,
mpred_slow_search/0,
mpred_spy/1,
mpred_spy/2,
mpred_spy/3,
mpred_spy1/3,
mpred_spy_all/0,
mpred_step/0,
mpred_support_db_rem/3,
mpred_test/1,
mpred_tms_supported/2,
mpred_tms_supported/3,
mpred_tms_supported0/3,
mpred_trace/0,
mpred_trace/1,
mpred_trace/2,
mpred_trace_add/2,
mpred_trace_add_print/2,
mpred_trace_add_print_0/2,
mpred_trace_break/2,
mpred_trace_exec/0,
mpred_trace_msg/1,
mpred_trace_msg/2,
mpred_trace_rem/2,
mpred_undo/2,
mpred_undo_e/2,
mpred_undo_u/2,
mpred_unfwc/1,
mpred_unfwc1/1,
mpred_unfwc_check_triggers/2,
mpred_union/3,
mpred_unique_i/1,
mpred_unique_u/1,
mpred_untrace/0,
mpred_untrace/1,
mpred_update_literal/4,
mpred_user_fact/1,
mpred_warn/0,
mpred_warn/1,
mpred_warn/2,
mpred_warnings/0,
mpred_warnings/1,
mpred_watch/0,
mpred_wff/3,
mpred_wfflist/2,
mreq/1,
neg_in_code/1,
no_side_effects/1,
nmpred_warn/0,
nonfact_metawrapper/1,
not_cond/2,
pfc_add/1,
pfc_provide_storage_op/2,
pfcBC_Cache/1,
pfcBC_NoFacts/1,
pfcBC_NoFacts_TRY/1,
old_pfcl_do/1,
pfcVerifyMissing/3,
pfcVersion/1,
physical_side_effect/1,
pred_all/1,
pred_head/2,
pred_head_all/1,
pred_r0/1,
pred_t0/1,
pred_u0/1,
pred_u1/1,
pred_u2/1,
old_process_rule/3,
put_clause_ref/2,
record_se/0,
reduce_clause_from_fwd/2,
remove_if_unsupported/2,
remove_if_unsupported_verbose/3,
remove_selection/2,
repropagate/1,
repropagate_0/1,
repropagate_1/1,
repropagate_2/1,
repropagate_meta_wrapper_rule/1,
req/1,
rescan_pfc/0,
retract_eq_quitely/1,
retract_eq_quitely_f/1,
retract_i/1,
retract_t/1,
retract_u/1,
retractall_u/1,
retractall_u/1,
rewritten_metawrapper/1,
ruleBackward/2,
ruleBackward0/2,
run_nt/5,
select_next_fact/2,
set_prolog_stack_gb/1,
should_call_for_facts/1,
should_call_for_facts/3,
show_if_debug/1,
spft_precanonical/3,
sub_term_eq/2,
sub_term_v/2,
support_ok_via_clause_body/1,
support_ok_via_clause_body/3,
supporters_list/2,
to_addable_form/2,
to_addable_form_wte/3,
to_predicate_isas/2,
to_predicate_isas0/2,
to_predicate_isas_each/2,
trigger_supporters_list/2,
undoable/1,
update_single_valued_arg/2,
use_presently/0,
user_atom/1,
w_get_fa/3,
wac/0,
well_founded/2,
which_missing_argnum/2,
with_mpred_trace_exec/1,
with_no_mpred_trace_exec/1,
with_search_mode/2,
call_u/1,
without_running/1,
{}/1,
          wac/0)).
*/

/*
:- meta_predicate((

% baseKB:resolveConflict(0),baseKB:resolveConflict0(0),baseKB:resolverConflict_robot(0),
without_running(0),
call_u((*)),
with_search_mode(+,0),
with_no_mpred_trace_exec((*)),
with_mpred_trace_exec(0),
with_mpred_trace_exec((*)),
update_single_valued_arg(0,*),
update_single_valued_arg((*),*),
req((*)),
repropagate_meta_wrapper_rule(0),
repropagate_meta_wrapper_rule((*)),
repropagate_1(0),
repropagate_1((*)),
repropagate_0(0),
repropagate_0((*)),
pred_head(1,*),
physical_side_effect(0),
physical_side_effect((*)),
pfcBC_NoFacts(0),
pfcBC_NoFacts((*)),
pfcBC_Cache(0),
pfcBC_Cache((*)),
pfc_provide_storage_op(*,0),
pfc_provide_storage_op(*,(*)),
not_cond(*,0),
not_cond(*,(*)),
mpred_update_literal(*,*,0,*),
mpred_update_literal(*,*,(*),*),
mpred_tms_supported0(*,0,?),
mpred_tms_supported0(*,(*),?),
mpred_tms_supported(0,?),
mpred_tms_supported(*,0,?),
mpred_tms_supported(*,(*),?),
mpred_tms_supported((*),?),
mpred_test(*),
mpred_scan_tms(0),
mpred_scan_tms((*)),
mpred_retry(0),
mpred_remove_supports_quietly((*)),
mpred_prove_neg(0),
mpred_prove_neg((*)),
mpred_facts_only(0),
mpred_facts_only((*)),
mpred_facts_and_universe(0),
mpred_facts_and_universe((*)),
mpred_fact(*,(*)),
mpred_enqueue((*),?),
mpred_deep_support0(*,0),
mpred_deep_support0(*,(*)),
mpred_deep_support(*,0),
mpred_deep_support(*,(*)),
mpred_call_with_no_triggers_uncaugth((*)),
mpred_call_with_no_triggers(0),
mpred_call_with_no_triggers((*)),
mpred_call_only_facts(0),
mpred_call_only_facts(*,0),
mpred_call_only_facts(*,(*)),
mpred_call_only_facts((*)),
mpred_call_0(0),
mpred_call_0((*)),
mpred_bc_only(:),
mpred_bc_only((:)),
map_unless(1,:,*,*),
is_resolved(0),
is_resolved((*)),
cnstrn0(0,*),
cnstrn0((*),*),
cnstrn(?,0),
cnstrn(?,(*)),
cnstrn(0),
cnstrn((*)),
call_u(0),
call_u((*)),
call_prologsys(0),
attvar_op(1,*),
ain_minfo_2(1,*),
ain_minfo(1,*)
      )).
*/
/*
:- dynamic((
        mpred_hide_msg/1,
        mpred_is_spying/2,
        mpred_warnings/1,
        %mpred_select/2,
        mpred_is_tracing_exec/0,
        use_presently/0)).
*/
/*
:- module_transparent((check_context_module/0,clause_i/2,clause_i/3)).


:- shared_multifile(bt/3).
:- shared_multifile(nt/4).
:- shared_multifile(pk/4).
:- shared_multifile(pt/3).
:- shared_multifile(spft/5).
:- shared_multifile(tms/1).
:- shared_multifile(hs/1).
:- shared_multifile(qu/3).
:- shared_multifile(sm/1).
:- shared_multifile(mpred_do_and_undo_method/2).
*/
/*
:- shared_multifile(('==>')/1).
:- shared_multifile(('::::')/2).
:- shared_multifile(('<-')/2).
:- shared_multifile(('<==>')/2).
:- shared_multifile(('==>')/2).
:- shared_multifile(('~')/1).
:- shared_multifile(('nesc')/1).
:- shared_multifile((('~'))/1).
*/
/*
:- shared_multifile((mpred_action)/1).
   ((shared_multifile(baseKB:P/1)))).
:- shared_multifile(hs/2).
:- shared_multifile(pfcControlled/1).
:- shared_multifile(prologDynamic/2).
:- shared_multifile(prologSideEffects/1).
:- shared_multifile(prologSingleValued/1).
:- shared_multifile(singleValuedInArg/2).
:- shared_multifile(prologSideEffects/1).
*/
/*
%% loop_check_nr( ?CL) is semidet.
%
% Loop Check Nr.
%
loop_check_nr(CL):- loop_check(no_repeats(CL)).
*/


%% mpred_init_i( ?GeneralTerm, ?Default) is semidet.
%
% PFC Init For Internal Interface.
%
mpred_init_i(GeneralTerm,Default) :- ((
  clause_i(GeneralTerm,true) -> true ; assert_u(Default))).

%= tms is one of {none,local,cycles} and controles the tms alg.
lmconf:module_local_init:- must((mpred_init_i(tms(_), tms(cycles)))).

% Pfc Search strategy. sm(X) where X is one of {direct,depth,breadth}
lmconf:module_local_init:- mpred_init_i(sm(_), sm(direct)).

% aliases

/*
%% mpred_ain( ?G) is semidet.
%
% PFC Assert If New.
%
mpred_ain(G):-pfc_add(G).

%% mpred_ainz( ?G) is semidet.
%
% PFC Ainz.
%
mpred_ainz(G):-pfc_add(G).

%% mpred_aina( ?G) is semidet.
%
% PFC Aina.
%
mpred_aina(G):-pfc_add(G).


%% mpred_ain( ?G, ?S) is semidet.
%
% PFC Assert If New.
%
mpred_ain(G,S):- mpred_ain(G,S).

%% mpred_ainz( ?G, ?S) is semidet.
%
% PFC Ainz.
%
mpred_ainz(G,S):-mpred_ain(G,S).

%% mpred_aina( ?G, ?S) is semidet.
%
% PFC Aina.
%
mpred_aina(G,S):-mpred_ain(G,S).

%= mpred_ain/2 and mpred_post/2 are the main ways to assert_db new clauses into the
%= database and have forward reasoning done.

%= mpred_ain(P,S) asserts P into the user''s dataBase with support from S.

%% pfc_add( ?P) is semidet.
%
% Prolog Forward Chaining Add.
%
pfc_add(P) :- 
  old_ain_fast(P),mpred_run.


%% old_ain( ?P, ?S) is semidet.
%
% Assert If New.
%
old_ain(P,S) :- 
  old_ain_fast(P,S),mpred_run.



%% old_ain_fast( ?P0) is semidet.
%
% Assert If New Fast.
%
old_ain_fast('$si$':'$was_imported_kb_content$'(_, _)<-THIS):-is_ftNonvar(THIS),!.
old_ain_fast(P0):-
  must(get_source_ref(S)), old_ain_fast(P0,S).



%% old_ain_fast( ?P0, ?S) is semidet.
%
% Assert If New Fast.
%
old_ain_fast(nesc(P),S) :- nonvar(P),!,old_ain_fast(P,S).
old_ain_fast(P0,S):- gripe_time(23.6,old_ain_fast_timed(P0,S)).


%% old_ain_fast_timed( ?P0, ?S) is semidet.
%
% Assert If New Fast Timed.
%
old_ain_fast_timed(P0,S):- '$module'(user,user),'$set_source_module'(user,user),!,
  '$module'(WM,baseKB),'$set_source_module'(WS,baseKB),
   call_cleanup(old_ain_fast_timed(P0,S),('$module'(_,WM),'$set_source_module'(_,WS))).

old_ain_fast_timed(P000,S0):- check_context_module,
  unnumbervars(P000:S0,P00:S),
  strip_module(P00,_,P0),  
  must(to_addable_form_wte(assert,P0,P)),
      (is_list(P)
        ->must_maplist(old_ain_fast_sp(S),P);
       old_ain_fast_sp(S,P)).


% a really common example is people want unbound predicate backchaining .. that is to query the predicates witha  varaible where the predciate is 

%% old_ain_fast_sp( ?S, ?P0) is semidet.
%
% Assert If New Fast Sp.
%
old_ain_fast_sp(S,P0):- 
  strip_module(P0,_,P),
  ensure_vars_labled(P,P0),fully_expand(change(assert,add),P0,P1),old_ain_fast_sp0(S,P1).


% old_ain_fast_sp(S,P->Q) :-!,old_ain_fast_sp(S,P==>Q).

%% old_ain_fast_sp0( ?S, ?P) is semidet.
%
% Assert If New Fast Sp Primary Helper.
%
old_ain_fast_sp0(S,P) :-
   mpred_rule_hb(P,OutcomeO,_),!,
     loop_check_term(mpred_post_sp_zzz(S,P),
     aining(OutcomeO),
     (mpred_post_sp_zzz(S,P),mpred_trace_msg(looped_outcome((P))))),!.
%old_ain_fast_sp(_,_).
old_ain_fast_sp0(P,S) :- mpred_error("old_ain_fast(~p,~p) failed",[P,S]).
*/
/*
:-module_transparent(mpred_ain/1).
:-module_transparent(mpred_aina/1).
:-module_transparent(mpred_ainz/1).
:-module_transparent(logicmoo_util_database:mpred_ain/1).
:-module_transparent(logicmoo_util_database:aina/1).
:-module_transparent(logicmoo_util_database:ainz/1).
:-multifile(logicmoo_util_database:mpred_ain/1).
:-multifile(logicmoo_util_database:aina/1).
:-multifile(logicmoo_util_database:ainz/1).
:-asserta((logicmoo_util_database:ainz(G):- !, call_u(mpred_ainz(G)))).
:-asserta((logicmoo_util_database:mpred_ain(G):- !, call_u(mpred_ain(G)))).
:-asserta((logicmoo_util_database:aina(G):- !, call_u(mpred_aina(G)))).

mpred_ain(G):- !, call_u(mpred_ain(G)).
*/
/*
% mpred_post(+Ps,+S) tries to assert a fact or set of fact to the database.  For
% each fact (or the singelton) mpred_post1 is called. It always succeeds.


%% mpred_post( ?P, ?S) is semidet.
%
% PFC Post.
%
mpred_post([H|T],S) :-
  !,

/*
%% mpred_run is det.
%
% mpred_run computes the deductive closure of the current database.
% How this is done depends on the searching mode:
%    direct -  fc has already done the job.
%    depth or breadth - use the qu mechanism.
%
mpred_run :- repeat, \+ mpred_step, !.

%mpred_run_queued:- repeat,sleep(1.0),mpred_run,fail.
%:-thread_property(_,alias(mpred_running_queue))-> true ; thread_create(mpred_run_queued,_,[alias(mpred_running_queue)]).


% mpred_step removes one entry from the qu/3 and reasons from it.


%% mpred_step is semidet.
%
% PFC Step.
%
mpred_step :- t_l:mpred_run_paused,!,fail.
mpred_step :-
  % if hs(Signal) is true, reset it and fail, thereby stopping inferencing.
  hs(Signal),!,
  mpred_retract_db_type(hs(Signal)),
  !,
  mpred_warn("Stopping on signal ~p",[Signal]),
  fail.
mpred_step :-
  % draw immediate conclusions from the next fact to be considered.
  % fails iff the queue is empty.
  get_next_fact(P,S) -> old_pfcl_do(mpred_fwd(P,S)),!.


%% get_next_fact( ?P, ?WS) is semidet.
%
% Get Next Fact.
%
get_next_fact(P,WS) :-
  %identifies the nect fact to fc from and removes it from the queue.
  select_next_fact(P,WS),
  remove_selection(P,WS).


%% remove_selection( ?P, ?S) is semidet.
%
% Remove Selection.
%
remove_selection(P,S) :-
 get_user_tbox(TBOX),
  clause(qu(TBOX,P,S),B,Ref),must(B),erase(Ref),!.
remove_selection(P,S) :-
  old_brake(wdmsg("pfc:get_next_fact - selected fact not on Queue: ~p (~p)",
               [P,S])).


% select_next_fact(P) identifies the next fact to reason from.
% It tries the user defined predicate first and, failing that,
%  the mdefault mechanism.

%% select_next_fact( ?P, ?S) is semidet.
%
% Select Next Fact.
%
select_next_fact(P,S) :-
  req(mpred_select(P,S)),
  !.
select_next_fact(P,S) :-
  defaultmpred_select(P,S),
  !.

% the mdefault selection predicate takes the item at the froint of the queue.

%% defaultmpred_select( ?P, ?S) is semidet.
%
% Defaultmpred Select.
%
defaultmpred_select(P,S) :- get_user_tbox(TBOX),qu(TBOX,P,S),!.

:- shared_multifile(hs/1).

% mpred_halt stops the forward chaining.

%% mpred_halt is semidet.
%
% PFC Halt.
%
mpred_halt :-  mpred_halt("",[]).


%% mpred_halt( ?Format) is semidet.
%
% PFC Halt.
%
mpred_halt(Format) :- mpred_halt(Format,[]).


%% mpred_halt( ?Format, ?Args) is semidet.
%
% PFC Halt.
%
mpred_halt(Format,Args) :-
  sformat(S,Format,Args),
  !,
  in_cmt((wdmsg('-s',[S]))),
  (hs(Signal) ->
       mpred_warn("mpred_halt finds hs(Signal) already set to ~p",[Signal])
     ; assert_u(hs(S))).


%=
%=
%= predicates for manipulating triggers
%=

%% old_ain_trigger( ?TriggerBody, ?Support) is semidet.
%
% Assert If New Trigger.
%
old_ain_trigger(TriggerBody,Support) :- mpred_had_support(TriggerBody,Support),!,mpred_trace_msg('Had Support',TriggerBody).

% old_ain_trigger(Trig,Support) :-  !,copy_term(Trig,TriggerBody), old_ain_trigger_0(Trig,TriggerBody,Support).

old_ain_trigger(Trig,Support) :-
   copy_term_and_varnames(Trig,Int), 
   loop_check_term(old_ain_trigger_1(Int,Trig,Support),here,nop((dmsg(old_ain_trigger_1(Int,Trig,Support))))).

% old_ain_trigger(_Trig,TriggerBody,Support) :- mpred_had_support(TriggerBody,Support),!,mpred_trace_msg('Had Support',TriggerBody).


%% old_ain_trigger_1( ?Trig, ?Trigger, ?Support) is semidet.
%
% Assert If New trigger  Secondary Helper.
%
old_ain_trigger_1(Trig,Trigger,Support) :- 
   old_ain_support(Trigger,Support), 
   (mpred_clause_i(Trigger)-> true ; 
      ((
        mpred_trace_msg('Adding For Later',Trigger),
        old_ain_trigger_0(Trig,Trigger,Support)))),!.



%% old_ain_trigger_0( ?Trig, :TermX, ?Support) is semidet.
%
% Assert If New trigger  Primary Helper.
%
old_ain_trigger_0(Trig,pt(TBOX,Trigger,Body),Support) :- !,
  (clause_asserted_i(pt(TBOX,Trigger,Body)) -> trace_or_throw(never_happens(clause_asserted_i(pt(TBOX,Trigger,Body)))) ;   
     (( old_ain_ts(pt(TBOX,Trigger,Body),Support),
        (must(mpred_mark_as(Support,p,Trigger,pfcPosTrigger))),
        add_reprop(Trig,Trigger)))).

old_ain_trigger_0(Trig,pt(TBOX,_ABOX,Trigger,_Body),Support) :-!,
   mpred_mark_as(Support,p,Trigger,pfcPosTrigger),
   add_reprop(Trig,Trigger).

old_ain_trigger_0(_Trig,bt(TBOX,Trigger,Body),Support) :- 
 must((
   must(old_ain_ts(bt(TBOX,Trigger,Body),Support)),
      attvar_op(assertz_if_new,((Trigger:-mpred_bc_only(Trigger)))),!,
      import_to_user(Trigger),
      must(mpred_mark_as(Support,p,Trigger,pfcBcTrigger)),
     % WAS mpred_bt_pt_combine(Trigger,Body).
   mpred_bt_pt_combine(Trigger,Body,Support))),!.


old_ain_trigger_0(_Trig,bt(_ABOX,Trigger,Body),Support) :- !,
  import_to_user(Trigger),
  attvar_op(assertz_if_new,((Trigger:-mpred_bc_only(Trigger)))),!,
  must(mpred_mark_as(Support,p,Trigger,pfcBcTrigger)),
     % WAS mpred_bt_pt_combine(Trigger,Body).
  mpred_bt_pt_combine(Trigger,Body,Support).


old_ain_trigger_0(Trig,nt(TBOX,Trigger,Test,Body),Support) :- !,
 get_user_tbox(TBOX),
  (must(mpred_mark_as(Support,n,Trigger,pfcNegTrigger)),
         copy_term_and_varnames(Trigger,TriggerCopy),!,
         old_ain_ts(nt(TBOX,TriggerCopy,Test,Body),Support)),
  run_nt(TBOX,Trigger,TriggerCopy,Test,Body),
  nop(add_reprop(Trig, Trigger)).

old_ain_trigger_0(Trig,X,Support) :- mpred_warn("Unrecognized trigger to aintrigger: ~p for ~p",[old_ain_trigger(X,Support),Trig]).



%% run_nt( ?TBOX, ?Trigger, ?TriggerCopy, ?Test, ?Body) is semidet.
%
% Run Nt.
%
run_nt(TBOX,Trigger,TriggerCopy,Test,Body):-
   not_cond(old_ain_trigger,Test),
    (SupportLHS = ( \+ Trigger,  nt(TBOX,TriggerCopy,Test,Body))),
     mpred_eval_lhs(Body,SupportLHS).


%% mpred_bt_pt_combine( ?Head, ?Body, ?Support) is semidet.
%
% PFC Bt Predicate Type Combine.
%
mpred_bt_pt_combine(Head,Body,Support) :-
 get_user_tbox(TBOX),
  %= a backward trigger (bt) was just added with head and Body and support Support
  %= find any pt''s with unifying heads and assert the instantied bt body.
  lookup_u(pt(TBOX,Head,_PtBody)),
  mpred_eval_lhs(Body,Support),
  fail.
mpred_bt_pt_combine(_,_,_) :- !.




%=
%=
%= predicates for manipulating action traces.
%=


%% old_ain_actiontrace( ?Action, ?Support) is semidet.
%
% Assert If New Action Trace.
%
old_ain_actiontrace(Action,Support) :-
  % adds an action trace and it''s support.
  old_ain_support(mpred_action(Action),Support).


%% mpred_rem_actiontrace( ?VALUE1, :TermARG2) is semidet.
%
% PFC Remove/erase Action Trace.
%
mpred_rem_actiontrace(_,mpred_action(A)) :-
  mpred_do_and_undo_method(A,M),
  M,
  !.


%=
%= predicates to remove pfc facts, triggers, action traces, and queue items
%= from the database.
%=
%= was simply:  mpred_retract

%% mpred_retract_db_type( ?X) is semidet.
%
% PFC Retract Database Type.
%
mpred_retract_db_type(X) :-
  %= retract an arbitrary thing.
  mpred_db_type(X,Type),
  mpred_retract_db_type(Type,X),
  !.



%% mpred_retract_db_type( ?VALUE1, ?TBOX) is semidet.
%
% PFC Retract Database Type.
%
mpred_retract_db_type(_,qu(TBOX,P,S)) :-
  doall(retract_u(qu(TBOX,P,_))),
  ignore(mpred_unfwc(qu(TBOX,P,S))).


mpred_retract_db_type(fact,X) :-
  %= db old_ain_db_to_head(X,X2), retract(X2).
  retract_u(X),
  ignore(mpred_unfwc(X)).

mpred_retract_db_type(rule,X) :-
  %= db  old_ain_db_to_head(X,X2),  retract(X2).
  retract_u(X).

mpred_retract_db_type(trigger,X) :-
  retract_t(X)
    -> mpred_unfwc(X)
     ; mpred_warn("Trigger not found to mpred_retract_db_type: ~p",[X]).

mpred_retract_db_type(action,X) :- mpred_rem_actiontrace(mpred_retract_db_type,X).

*/

/* UNUSED TODAY
%= old_ain_db_type(X) adds item X to some database
%= was simply:  mpred_Add
old_ain_db_type(X) :-
  % what type of X do we have?
  mpred_db_type(X,Type),
  % call the appropriate predicate.
  old_ain_db_type(Type,X).

old_ain_db_type(fact,X) :-
  mpred_unique_u(X),
  import_to_user(X),
  must(assert_u(X)),!.
old_ain_db_type(rule,X) :-
  mpred_unique_i(X),
  assert_u(X),!.
old_ain_db_type(trigger,X) :-
  assert_t(X).
old_ain_db_type(action,_Action) :- !.
*/
/*
%% each_in_list(+P2,+HT,+S) semidet.
%
% Call P(E,S). each Element in the list.
%
each_in_list(P,[H|T],S) :-
  % mpred_withdraw 
  call(P,H,S),
  each_in_list(P,T,S).

%% mpred_withdraw( ?List) is semidet.
%
% mpred_withdraw/1 is the user''s interface - it withdraws user support for P.
%
mpred_withdraw(P) :-
  make_uu_remove(UU),
  mpred_withdraw(P,UU).


%% mpred_withdraw( ?P, ?S) is semidet.
%
% Removes support S from P and checks to see if P is still supported.
% If it is not, then the fact is retracted from the database and any support
% relationships it participated in removed.
%
mpred_withdraw(List,S) :-
  % iterate down the list of facts to be mpred_withdraw'ed.
  is_ftNonvar(List),
  List=[_|_],!,
  each_in_list(mpred_withdraw,List,S).
mpred_withdraw(pfclog(P),S) :- nonvar(P),ignore((mpred_withdraw(P,S))), retract_eq_quitely(P),fail.
mpred_withdraw(P,S) :- 
 call_u((copy_term_and_varnames(mpred_withdraw(P,S),Why),   
  mpred_support_db_rem(Why,P,S)
     -> (remove_if_unsupported(Why,P))
      ; mpred_warn("mpred_withdraw/2 Could not find support ~p to remove from fact ~p",
                [S,P]))).

%% mpred_remove( ?P) is semidet.
%
% Ensure it is unasserted
%
mpred_remove(P):- mpred_remove(P),mpred_unfwc(P).      
mpred_rem(P):- mpred_remove(P),mpred_unfwc(P).      


%% mpred_remove( ?P) is semidet.
%
% mpred_remove is like mpred_withdraw, but if P is still in the DB after removing the
% user''s support, it is retracted by more forceful means (e.g. remove).
%
mpred_remove(P) :- 
  % mpred_remove/1 is the user''s interface - it withdraws user support for P.
  make_uu_remove(UU),
  mpred_remove(P,UU).


%% mpred_remove( ?P, ?S) is semidet.
%
% mpred_remove is like mpred_withdraw, but if P is still in the DB after removing the
% S support, it is retracted by more forceful means (e.g. remove).
%
mpred_remove(List,S) :-
  % iterate down the list of facts to be mpred_withdraw'ed.
  is_ftNonvar(List),
  List=[_|_],!,
  each_in_list(mpred_remove,List,S).
mpred_remove(P,S) :- 
 call_u((
  mpred_withdraw(P,S),
  % used to say mpred_call_only_facts(Why,P) but that meant it was 
  % was no_repeats(( mpred_call_with_triggers(P);mpred_call_with_no_triggers(Why,P)))
  (( mpred_call_only_facts(mpred_remove,P) )  
     -> (mpred_blast(P))
      ; true))).

% prev way
% mpred_remove(P):-!,mpred_remove(P).
% new way

%% mpred_blast( ?F) is semidet.
%
% retracts fact F from the DB and removes any dependent facts
%
mpred_blast(F) :-
 call_u((
  show_if_debug(mpred_remove_supports(mpred_blast(F),F)),
  mpred_undo(mpred_blast(F),F))).

%% mpred_remove_supports( ?Why, ?F) is semidet.
%
% Will remove any remaining supports for fact F, complaining as it goes.
%
mpred_remove_supports(Why,F) :-
  mpred_support_db_rem(Why,F,S),
  (S=(z,z)->true;mpred_trace_msg("~p was supported by ~p",[F,S])),
  fail.
mpred_remove_supports(Why,F) :- fail,
  mpred_support_db_rem(Why,F,S),nonvar(S),
  (S=(z,z)->true;mpred_warn("WARN: ~p was still supported by ~p",[F,S])),
  fail.
mpred_remove_supports(_,_).


%% mpred_remove_supports_quietly( ?F) is semidet.
%
% Will remove any remaining supports for fact F, uncomplainingly
%
mpred_remove_supports_quietly(F) :-
  mpred_support_db_rem(mpred_remove_supports_quietly,F,_),
  fail.
mpred_remove_supports_quietly(_).

% mpred_undo(Why,X) undoes X.

%% mpred_undo( ?Why, :TermFact) is semidet.
%
% Undose any resulting deductions
%
mpred_undo(Why,mpred_action(A)) :-
  % undo an action by finding a method and successfully executing it.
  !,
  mpred_rem_actiontrace(Why,mpred_action(A)).

mpred_undo(Why,pk(TBOX,Key,Head,Body)) :-
  % undo a positive trigger.
  %
  !,
  (retract_i(pk(TBOX,Key,Head,Body))
    -> mpred_unfwc(pt(TBOX,Head,Body))
     ; mpred_warn("for ~p \nTrigger not found to retract pk= ~p: ~p",[Why,Key,pt(TBOX,Head,Body)])).

mpred_undo(Why,pt(TBOX,Head,Body)) :- 
  % undo a positive trigger.
  %
  !,
  (retract_i(pt(TBOX,Head,Body))
    -> mpred_unfwc(pt(TBOX,Head,Body))
     ; mpred_warn("for ~p:\nTrigger not found to retract: ~p",[Why,pt(TBOX,Head,Body)])).


mpred_undo(Why,bt(TBOX,Head,Body)) :- 
  % undo a backchaining trigger.
  %
  !,
  dtrace(attvar_op(retractall,(Head:-mpred_bc_only(Head)))),
  (retract_i(bt(TBOX,Head,Body))
    -> mpred_unfwc(bt(TBOX,Head,Body))
     ; mpred_warn("for ~p:\nTrigger not found to retract: ~p",[Why,bt(TBOX,Head,Body)])).


mpred_undo(Why,nt(TBOX,Head,Condition,Body)) :-
  % undo a negative trigger.
  !,
  (retract_i(nt(TBOX,Head,Condition,Body))
    -> true
     ; mpred_trace_msg("for ~p:\nTrigger not found to retract: ~p",[Why,nt(TBOX,Head,Condition,Body)])),
  mpred_unfwc(nt(TBOX,Head,Condition,Body)).

mpred_undo(Why,( \+ ~Fact)):- mpred_undo(Why, Fact),fail.
mpred_undo(Why,   ~(~Fact)):- mpred_undo(Why, Fact),fail.

mpred_undo(Why,Fact):- mpred_undo_u(Why,Fact)*->true;mpred_undo_e(Why,Fact).

%% mpred_undo_u( ?Why, ?Fact) is semidet.
%
% PFC Undo For User Code.
%
mpred_undo_u(Why,Fact) :-
  % undo a random fact, printing out the trace, if relevant.
  retract_u(Fact),
     must(mpred_trace_rem(Why,Fact)),
     mpred_unfwc1(Fact).


%% mpred_undo_e( ?Why, ?Fact) is semidet.
%
% PFC Undo E.
%
mpred_undo_e(Why,Fact) :- 
    % (Fact\= ~(_)->cnotrace(mpred_trace_msg("mpred_undo_e ; Fact not found in user db: ~p",[Fact]));true),
     (Fact\= ~(_)->mpred_trace_rem(Why,Fact);true),
     mpred_unfwc(Fact).

%% mpred_unfwc(+Fact) is semidet.
%
% mpred_unfwc(Fact) "un-forward-chains" from fact Fact.  That is, fact Fact has just
% been removed from the database, so remove all support relations it
% participates in and check the things that they support to see if they
% should stay in the database or should also be removed.
%
mpred_unfwc(UnFact) :-   
  strip_module(UnFact,_,Fact),
  mpred_retract_support_relations(why(mpred_unfwc(Fact)),Fact),
  mpred_unfwc1(Fact).
  


%% mpred_unfwc1( ?F) is semidet.
%
% PFC Unfwc Secondary Helper.
%
mpred_unfwc1(F) :-
  mpred_unfwc_check_triggers(_Sup,F),
  % is this really the right place for mpred_run<?
  mpred_run.


%% mpred_unfwc_check_triggers( ?Sup, ?Clause) is semidet.
%
% PFC Unfwc Check Triggers.
%
mpred_unfwc_check_triggers(_Sup,Clause) :- 
 strip_module(Clause,_,F),
  mpred_db_type(F,fact),
  copy_term_and_varnames(F,Fcopy),
  lookup_u(nt(TBOX,Fcopy,Condition,Action)),
  (not_cond(nt,Condition)),
  G = mpred_eval_lhs(Action,((\+F),nt(TBOX,F,Condition,Action))),
  loop_check(G,mpred_trace_msg(unfwc_caught_loop(G))),
  fail.
mpred_unfwc_check_triggers(_Sup,_).


%% mpred_retract_support_relations( ?Why, ?Fact) is semidet.
%
% PFC Retract Support Relations.
%
mpred_retract_support_relations(Why,Fact) :-
  mpred_db_type(Fact,Type),
  (Type=trigger -> mpred_support_db_rem(Why,P,(_,Fact)) ;
    % non trigger
    mpred_support_db_rem(Why,P,(Fact,_))),
  remove_if_unsupported(Why,P),
  fail.
mpred_retract_support_relations(_,_).

%= remove_if_unsupported(Why,+P) checks to see if P is supported and removes
%= it from the DB if it is not.

*/
/*
%% remove_if_unsupported_verbose( ?Why, ?TMS, ?P) is semidet.
%
% Remove If Unsupported While Being Descriptive.
%
remove_if_unsupported_verbose(Why,TMS,P) :- is_ftVar(P),!,trace_or_throw(warn(var_remove_if_unsupported_verbose(Why,TMS,P))).
remove_if_unsupported_verbose(Why,TMS,P) :- 
   (((mpred_tms_supported(TMS,P,How),How\=unknown(_)) -> mpred_trace_msg(v_still_supported(How,Why,TMS,P)) ; ( mpred_undo(Why,P)))).
   % mpred_run.
*/
  mpred_post1(H,S),
  mpred_post(T,S).
mpred_post([],_) :- !.
mpred_post(P,S) :-   
  mpred_post1(P,S).

% mpred_post1(+P,+S) tries to assert a fact to the database, and, if it succeeded,
% adds an entry to the pfc queue for subsequent forward chaining.
% It always succeeds.

%% mpred_post1( ?P0, ?S) is semidet.
%
% PFC Post Secondary Helper.
%
mpred_post1(mpred_ain(P0),S):- must(is_ftNonvar(P0)), !,mpred_ain(P0,S).
mpred_post1(P0,S):-
  to_addable_form_wte(assert,P0,P),
      (is_list(P)
        ->maplist(mpred_post_sp_zzz(S),P);
       mpred_post_sp_zzz(S,P)).


%% mpred_post_sp( ?S, ?P) is semidet.
%
% PFC Post Sp.
%
mpred_post_sp(S,P):- mpred_post_sp_zzz(S,P).



%% mpred_post_sp_zzz( ?S, ?P) is semidet.
%
% PFC Post Sp Zzz.
%
mpred_post_sp_zzz(S,P):- ground(S:P),!,mpred_post_sp_zzzz(S,P),!.
mpred_post_sp_zzz(S,P):- \+ is_main_thread,!,
   (hotrace(ensure_vars_labled(S:P,S0:P0))-> 
     mpred_post_sp_zzzz(S0,P0);mpred_post_sp_zzzz(S,P)),!.

mpred_post_sp_zzz(S,P):-  is_main_thread,!,
   (hotrace(ensure_vars_labled(S:P,S0:P0))-> 
     mpred_post_sp_zzzz(S0,P0);mpred_post_sp_zzzz(S,P)),!.

mpred_post_sp_zzz(S,P):- 
    hotrace(dcall_when(ensure_vars_labled,S:P,S0:P0)),!,
    mpred_post_sp_zzzz(S0,P0),!.

mpred_post_sp_zzz(S,P):-mpred_post_sp_zzzz(S,P),!.




%% mpred_post_sp_zzzz( ?S, ?P) is semidet.
%
% PFC Post Sp Zzzz.
%
mpred_post_sp_zzzz(S, Var):-is_ftVar(Var),!,trace_or_throw(var_mpred_post_sp_zzzz(S, Var)).
mpred_post_sp_zzzz(S,(P1,P2)) :- !,mpred_post_sp_zzzz(S,(P1)),mpred_post_sp_zzzz(S,(P2)).
mpred_post_sp_zzzz(S,[P1]) :- !,mpred_post_sp_zzzz(S,(P1)).
mpred_post_sp_zzzz(S,[P1|P2]) :- !,mpred_post_sp_zzzz(S,(P1)),mpred_post_sp_zzzz(S,(P2)).

mpred_post_sp_zzzz(S,NEG) :- fixed_negations(NEG,NEGO),!,mpred_post_sp_zzzz(S,NEGO).

mpred_post_sp_zzzz(S, \+ P) :- must(is_ftNonvar(P)),!, doall(mpred_remove(P,S)),!,mpred_undo((\+),P).
mpred_post_sp_zzzz(S, ~(P)) :- nonvar(P),doall(mpred_remove(P,S)),mpred_undo((\+),P),fail.

mpred_post_sp_zzzz(_S,P) :- once((notrace(mpred_is_tautology(P)),wdmsg(trace_or_throw(todo(error(mpred_is_tautology(P))))))),show_load_context,fail.

% only do loop check if it's already supported

mpred_post_sp_zzzz(S,P) :- is_ftCompound(P), arg(SV,P,V),is_relative(V),must((mpred_update_literal(P,SV,Q,R),mpred_post_sp_zzzz(S,R))),(Q=R->true;mpred_undo(update,Q)).
mpred_post_sp_zzzz(S,P) :- is_already_supported(P,S,_How),must(loop_check(mpred_post1_sp_0(S,P),mpred_post1_sp_1(S,P))),!. % ,mpred_enqueue(P,S).

mpred_post_sp_zzzz(S,~(P)) :-!, mpred_post1_sp_0(S,~(P)),!,assert_u(~(P)).

mpred_post_sp_zzzz(S,P) :- mpred_post1_sp_0(S,P).


%% mpred_post1_sp_0( ?S, ?P) is semidet.
%
% PFC post Secondary Helper sp  Primary Helper.
%
mpred_post1_sp_0(S,P) :-
  %= db old_ain_db_to_head(P,P2),
  % mpred_remove_old_version(P),
  must(once(old_ain_support(P,S))),
  mpred_post1_sp_1(S,P).


%% mpred_post1_sp_1( ?S, ?P) is semidet.
%
% PFC post Secondary Helper sp  Secondary Helper.
%
mpred_post1_sp_1(S,P):- P\==true,
  mpred_unique_u(P),
  must(import_to_user(P)),
  must(assert_u(P)),!,
  must(mpred_trace_add(P,S)),
  !,
  must(mpred_enqueue(P,S)),
  !.

mpred_post1_sp_1(_,_). % already added
mpred_post1_sp_1(S,P) :-  mpred_warn("mpred_post1(~p,~p) failed",[P,S]).
*/

% ======================= 
% prolog system database
% ======================= 
/*
assert_prologsys(X):- attvar_op(assert,X).
asserta_prologsys(X):- attvar_op(asserta,X).
assertz_prologsys(X):-attvar_op(assertz,X).

clause_prologsys(H,B):-clause_i(H,B).
clause_prologsys(H,B,Ref):-clause_i(H,B,Ref).
*/

%% call_prologsys( ?X) is semidet.
%
% Call Prologsys.
%
call_prologsys(X):-call_u(X).




/*
%=
%= old_ain_db_to_head(+P,-NewP) talkes a fact P or a conditioned fact
%= (P:-C) and adds the Db context.
%=


%% old_ain_db_to_head( ?P, ?NewP) is semidet.
%
% Assert If New Database Converted To Head.
%
old_ain_db_to_head(P,NewP) :-
  mpred_current_db(Db),
  (Db=true        -> NewP = P;
   P=(Head:-Body) -> NewP = (Head :- (Db,Body));
   otherwise      -> NewP = (P :- Db)).


% mpred_unique_u(X) is true if there is no assertion X in the prolog db.


%% mpred_unique_u( ?P) is semidet.
%
% PFC Unique For User Code.
%
mpred_unique_u((Head:-Tail)) :-
  !,
  \+ clause_u(Head,Tail).
mpred_unique_u(P) :-
  !,
  \+ clause_u(P,true).



%% mpred_unique_i( ?P) is semidet.
%
% PFC Unique For Internal Interface.
%
mpred_unique_i((Head:-Tail)) :-
  !,
  \+ clause_i(Head,Tail).
mpred_unique_i(P) :-
  !,
  \+ clause_i(P,true).

% mpred_enqueue(P,S) :- !,get_user_tbox(TBOX),ainz_i(qu(TBOX,P,S),S).


%% mpred_enqueue(+P,+S) is det.
%
%  Enqueue P with support S
%
mpred_enqueue(P,S) :-
   (get_search_mode(Mode,P,S),get_user_tbox(TBOX))
    -> (Mode=direct  -> must(mpred_fwd(P,S)) ;
	Mode=depth   -> aina_i(qu(TBOX,P,S),S) ;
	Mode=breadth -> ainz_i(qu(TBOX,P,S),S) ;
	% else
          otherwise           -> mpred_warn("Unrecognized sm mode: ~p", Mode))
     ; mpred_warn("No sm mode").

get_search_mode(Mode,_P,_S):- t_l:mpred_search_mode(Mode),!.
get_search_mode(Mode,_P,_S):- Mode=direct,!.
get_search_mode(Mode,_P,_S):- Mode=breadth,!.
get_search_mode(Mode,_P,_S):- must(mreq(sm(Mode))),!.


%% mpred_remove_old_version( :TermIdentifier) is semidet.
%
% if there is a rule of the form Identifier ::: Rule then delete it.
%
mpred_remove_old_version((Identifier::::Body)) :-
  % this should never happen.
  is_ftVar(identifier),
  !,
  mpred_warn("variable used as an  rule name in ~p :::: ~p",
          [Identifier,Body]).


mpred_remove_old_version((Identifier::::Body)) :-
  is_ftNonvar(Identifier),
  clause_u((Identifier::::OldBody),_),
  \+(Body=OldBody),
  mpred_withdraw((Identifier::::OldBody)),
  !.
mpred_remove_old_version(_).
*/


/*
Old version
if_missing_mask(Q,N,R,dif:dif(Was,NEW)):- 
 must((is_ftNonvar(Q),acyclic_term(Q),acyclic_term(R),functor(Q,F,A),functor(R,F,A))),
  (singleValuedInArg(F,N) -> 
    (arg(N,Q,Was),replace_arg(Q,N,NEW,R));
    ((arg(N,Q,Was),is_ftNonvar(Was)) -> replace_arg(Q,N,NEW,R);
        (N=A,arg(N,Q,Was),replace_arg(Q,N,NEW,R)))).
*/







/*
%=
%=
%= mpred_fwd(X) forward chains from a fact or a list of facts X.
%=
% mpred_fwd(+P) forward chains for a multiple facts.


%% mpred_fwd( ?P) is semidet.
%
% PFC Forward Repropigated.
%
mpred_fwd(P):- get_source_ref(UU), mpred_fwd(P,UU).

%% mpred_fwd( ?P, ?S) is semidet.
%
% PFC Forward Repropigated.
%
mpred_fwd([H|T],S) :- !, mpred_fwd1(H,S), mpred_fwd(T,S).
mpred_fwd([],_) :- !.
mpred_fwd(P,S) :- copy_term(P:S,P0:S0),mpred_fwd1(P0,S0),!.

%=
% mpred_fwd1(+P) forward chains for a single fact.

%% mpred_fwd1( ?Fact, ?Sup) is semidet.
%
% PFC Forward Repropigated Secondary Helper.
%
mpred_fwd1(Fact,Sup) :- gripe_time(24.80,mpred_fwd2(Fact,Sup)),!.


unnumbervars_equals(A,B):- =(A,BO),!,BO=B.
% unnumbervars_equals(A,B):-unnumbervars(A,B).

%% mpred_fwd2( ?Fact, ?Sup) is semidet.
%
% PFC Forward Repropigated Extended Helper.
%
mpred_fwd2(Fact,Sup) :- fixed_negations(Fact,M),!,mpred_fwd2(M,Sup).
mpred_fwd2(Fact,Sup) :- cyclic_term(Fact;Sup),writeq(mpred_fwd2_cyclic_term(Fact;Sup)),!,trace_or_throw(mpred_fwd2_cyclic_term(Fact;Sup)).
mpred_fwd2(Fact0,_Sup):-
  once(must(old_ain_rule_if_rule(Fact0))),
  unnumbervars_equals(Fact0,Fact),  
  copy_term(Fact,F),
  % check positive triggers
  once(must(old_fcpt(TBOX,Fact,F))),
  % check negative triggers
  once(must(old_fcnt(Fact,F))).


%=
%= old_ain_rule_if_rule(P) does some special, built in forward chaining if P is
%= a rule.
%=

% old_ain_rule_if_rule(Fact) :- cyclic_break(Fact),is_mpred_action(Fact),(ground(Fact)->must(once(Fact));doall(show_if_debug(must(Fact)))),fail.
% old_ain_rule_if_rule(Fact) :- cyclic_break(Fact),is_mpred_action(Fact),(ground(Fact)->must(once(Fact));doall(show_if_debug(must(Fact)))),!.

%% old_ain_rule_if_rule( ?Fact) is semidet.
%
% Assert If New Rule If Rule.
%
old_ain_rule_if_rule(Fact) :- fixed_negations(Fact,M),!,old_ain_rule_if_rule(M).
old_ain_rule_if_rule(Fact) :- cyclic_break(Fact),is_mpred_action(Fact),
    doall(show_if_debug(call_u(req(Fact)))),!.
old_ain_rule_if_rule(Fact):- must(old_ain_rule0(Fact)),!.


%% old_ain_rule0( :TermP) is semidet.
%
% Assert If New Rule Primary Helper.
%
old_ain_rule0((P==>Q)) :-
  !,
  old_process_rule(P,Q,(P==>Q)).

old_ain_rule0((Name::::P==>Q)) :-
  !,
  old_process_rule(P,Q,(Name::::P==>Q)).

old_ain_rule0((P<==>Q)) :-
  !,
  old_process_rule(P,Q,(P<==>Q)),
  old_process_rule(Q,P,(P<==>Q)).

old_ain_rule0((Name::::P<==>Q)) :-
  !,
  old_process_rule(P,Q,((Name::::P<==>Q))),
  old_process_rule(Q,P,((Name::::P<==>Q))).

old_ain_rule0(('<-'(P,Q))) :-
  !,
  mpred_define_bc_rule(P,Q,('<-'(P,Q))).

old_ain_rule0(_).


%% old_fcpt(TBOX, ?Fact, ?F) is semidet.
%
% Fcpt.
%
old_fcpt(TBOX,Fact,F):- old_fcpt0(Fact,F)*->fail;nop(mpred_trace_msg(no_pt(TBOX,Fact,F))).
old_fcpt(TBOX,_,_).


%% old_fcpt0( ?Fact, ?F) is semidet.
%
% Fcpt Primary Helper.
%
old_fcpt0(Fact,F) :- 
  lookup_u(pt(TBOX,F,Body)),
  (mpred_eval_lhs(Body,(Fact,pt(TBOX,F,Body)))
    *-> mpred_trace_msg('Using',pt(TBOX,F,Body));
      (mpred_trace_msg('Skipped',pt(TBOX,F,Body)),fail)).
  

old_fcpt0(Fact,F) :- use_presently,
  lookup_u(pt(TBOX,presently(F),Body)),
  pp_item('Found presently ',pt(TBOX,F,Body)),
  mpred_eval_lhs(Body,(presently(Fact),pt(TBOX,presently(F),Body))).


%% old_fcnt( ?Fact, ?F) is semidet.
%
% Fcnt.
%
old_fcnt(Fact,F):- old_fcnt0(Fact,F)*->fail;nop(mpred_trace_msg(no_spft_nt(Fact,F))).
old_fcnt(_,_).


%% old_fcnt0( ?Fact, ?F) is semidet.
%
% Fcnt Primary Helper.
%
old_fcnt0(_Fact,F) :- 
  lookup_u(nt(TBOX,F,Condition,Body)),
  spft(TBOX,REMOVE,GU,nt(TBOX,F,Condition,Body),_Why),
   (call_u(Condition) *-> 
   (mpred_trace_msg('Using ~'(REMOVE),nt(TBOX,F,Condition,Body)),
      mpred_withdraw(REMOVE,(GU,nt(TBOX,F,Condition,Body))),fail);
      (mpred_trace_msg('Skipped ~'(REMOVE),nt(TBOX,F,Condition,Body)),fail)).

%=
%= mpred_define_bc_rule(+Head,+Body,+Parent_rule) - defines a backward
%= chaining rule and adds the corresponding bt triggers to the database.
%=


%% mpred_define_bc_rule( ?Head, ?Body, ?Parent_rule) is semidet.
%
% PFC Define Backchaining Rule.
%
mpred_define_bc_rule(Head,Body,Parent_rule) :-
  (\+ mpred_literal(Head)),
  mpred_warn("Malformed backward chaining rule.  ~p not atomic.",[(Head:-Body)]),
  mpred_warn("rule: ~p",[Parent_rule]),
 % !,
  dtrace(mpred_define_bc_rule(Head,Body,Parent_rule)),
  fail.

mpred_define_bc_rule(Head,Body,Parent_rule) :- 
 get_user_tbox(TBOX),
  (copy_term_and_varnames(Parent_rule,Parent_ruleCopy),
  attvar_op(assert_if_new,(Head:-mpred_bc_only(Head))),
  must(import_to_user(Head)),
  build_rhs(Head,Head,Rhs),
  old_foreachl_do(mpred_nf(Body,Lhs),
       (build_trigger(Parent_ruleCopy,Lhs,rhs(Rhs),Trigger),
       % can be mpred_post_sp(bt(TBOX,Head,Trigger),(Parent_ruleCopy,U))
         ((get_source_ref1(U),old_ain_fast(bt(TBOX,Head,Trigger),(Parent_ruleCopy,U))))))).
        
*/
/*

%=
%=
%= eval something on the LHS of a rule.
%=
%mpred_eval_lhs(P,S):- contains_ftVar(P),unnumbervars_equals(mpred_eval_lhs(P,S),mpred_eval_lhs(P0,S0)),P\=@=P0,!,mpred_eval_lhs(P0,S0).
%mpred_eval_lhs(P,S):- contains_ftVar(P),trace_or_throw(contains_ftVar_mpred_eval_lhs(P,S)).

%% mpred_eval_lhs( ?P, ?S) is semidet.
%
% PFC Eval Left-hand-side.
%
mpred_eval_lhs(P,S):-
  unnumbervars_equals(+(P,S),+(P0,S0)),
    mpred_eval_lhs0(P0,S0).


%% mpred_eval_lhs0( ?X, ?Support) is semidet.
%
% PFC Eval Left-hand-side Primary Helper.
%
mpred_eval_lhs0((Test->Body),Support) :-
  !,
  % (call_prologsys(Test) -> mpred_eval_lhs(Body,Support)),
   ((no_repeats(call_prologsys(Test)) , 
       (mpred_eval_lhs(Body,Support))) *-> true ; (!,fail)).

mpred_eval_lhs0(rhs(X),Support) :-
   cyclic_break(X),
  !,
  on_x_rtrace(mpred_eval_rhs_0(+,X,Support)),
  !.

mpred_eval_lhs0(X,Support) :-
  is_ftCompound(X),
  cyclic_break((X)),  
  mpred_db_type(X,trigger),
  !,
  doall(show_call(old_ain_trigger(X,Support))),
  !.

%mpred_eval_lhs0(snip(X),Support) :-
%  snip(Support),
%  mpred_eval_lhs(X,Support).

mpred_eval_lhs0(X,Why) :-
  mpred_warn("Unrecognized item found in trigger body, namely ~p.",[mpred_eval_lhs0(X,Why)]),!.

%=
%= eval something on the RHS of a rule.
%=


%% mpred_eval_rhs_0( ?DIR, :TermARG2, ?VALUE3) is semidet.
%
% PFC eval Right-Hand-Side  Primary Helper.
%
mpred_eval_rhs_0(_DIR,[],_) :- !.
mpred_eval_rhs_0(DIR,[Head|Tail],Support) :-
  mpred_eval_rhs1(DIR,Head,Support),
  mpred_eval_rhs_0(DIR,Tail,Support).



%% mpred_eval_rhs1( +DIR, ?X, ?Support) is semidet.
%
% PFC Eval Right-hand-side Secondary Helper.
%
mpred_eval_rhs1(+,{Action},Support) :-
 % evaluable Prolog code.
 !,
 old_fc_eval_action(Action,Support).

mpred_eval_rhs1(+,mpred_action(Action),Support) :-
 % evaluable Prolog code.
 !,
 old_fc_eval_action(Action,Support).

mpred_eval_rhs1(+,P,_Support) :-
 % predicate to remove.
 mpred_negation(P,N),
 !,
 doall(mpred_withdraw(N)),!.

mpred_eval_rhs1(DIR,[X|Xrest],Support) :-
 % embedded sublist.
 !,
 mpred_eval_rhs_0(DIR,[X|Xrest],Support).

mpred_eval_rhs1(+,added(Assertion),Support) :-
 % an assertion to be added.
 mpred_ain(Assertion,Support),!.

mpred_eval_rhs1(+,Assertion,Support) :-
 % an assertion to be added.
 mpred_post1(Assertion,Support),!.

mpred_eval_rhs1(DIR,X,_) :-
  mpred_warn("Malformed rhs of a rule: ~p",[DIR:X]).


%=
%= evaluate an action found on the rhs of a rule.
%=


%% old_fc_eval_action( ?Action, ?Support) is semidet.
%
% Forward Chaining Eval Action.


/*
%% undoable( ?A) is semidet.
%
% Undoable.
%
undoable(A) :- req(mpred_do_and_undo_method(A,_)).

%=
%=
%= defining fc rules
%=

%= mpred_nf(+In,-Out) maps the LHR of a pfc rule In to one normal form
%= Out.  It also does certain optimizations.  Backtracking into this
%= predicate will produce additional clauses.



%% mpred_nf( ?LHS, ?List) is semidet.
%
% PFC Normal Form.
%
mpred_nf(LHS,List) :-
  must(mpred_nf1(LHS,List2)),
  mpred_nf_negations(List2,List).


%= mpred_nf1(+In,-Out) maps the LHR of a pfc rule In to one normal form
%= Out.  Backtracking into this predicate will produce additional clauses.

% handle a variable.


%% mpred_nf1( ?NegTerm, ?NF) is semidet.
%
% PFC Normal Form Secondary Helper.
%
mpred_nf1(P,[P]) :- is_ftVar(P), !.

% these next three rules are here for upward compatibility and will go
% away eventually when the P/Condition form is no longer used anywhere.

mpred_nf1(P/Cond,[(\+Q)/Cond]) :- fail, mpred_negated_literal(P,Q), !.  % DMILES does not undersand why this is wron gand the next is correct here
mpred_nf1(P/Cond,[(\+P)/Cond]) :- mpred_negated_literal(P,_), !.

mpred_nf1(P/Cond,[P/Cond]) :-  mpred_literal(P), !.

mpred_nf1((P/Cond),O) :-!,mpred_nf1((P,{Cond}),O).

mpred_nf1({P},[{P}]) :-!.

%= handle a negated form

mpred_nf1(NegTerm,NF) :-
  mpred_negation(NegTerm,Term),
  !,
  mpred_nf1_negation(Term,NF).

mpred_nf1(-((P,Q)),NF) :-
 mpred_nf1(-P,NP),
 mpred_nf1(-Q,NQ),
 !,
 mpred_nf1(((NP/Q);(NQ/P)),NF).

%= disjunction.

mpred_nf1((P;Q),NF) :-
  !,
  (mpred_nf1(P,NF) ;   mpred_nf1(Q,NF)).


%= conjunction.

mpred_nf1((P,Q),NF) :-
  !,
  mpred_nf1(P,NF1),
  mpred_nf1(Q,NF2),
  append(NF1,NF2,NF).

%= handle a random atom.

mpred_nf1(P,[P]) :-
  mpred_literal(P),
  !.

%=% shouln't we have something to catch the rest as errors?
mpred_nf1(Term,[Term]) :-
  mpred_warn("mpred_nf doesn't know how to normalize ~p",[Term]),!,fail.

*/


%
old_fc_eval_action(Action,Support) :-
  call_prologsys(Action),
  (undoable(Action)
     -> old_ain_actiontrace(Action,Support)
      ; true).
*/

%=
%=
%=
/*
trigger_trigger(Trigger,Body,_Support) :-
 trigger_trigger1(Trigger,Body).
trigger_trigger(_,_,_).


trigger_trigger1(presently(Trigger),Body) :- use_presently,
  is_ftNonvar(Trigger),!,
  copy_term_and_varnames(Trigger,TriggerCopy),
  no_repeats(call_u(Trigger)),
  mpred_eval_lhs(Body,(presently(Trigger),pt(TBOX,presently(TriggerCopy),Body))),
  fail.

trigger_trigger1(Trigger,Body) :-
  copy_term_and_varnames(Trigger,TriggerCopy),
  no_repeats(mpred_call_only_facts(Trigger)),
  mpred_eval_lhs(Body,(Trigger,pt(TBOX,TriggerCopy,Body))),
  fail.
*/

/*

%% call_u( ?X) is semidet.
%
% Call For User Code.
%
call_u(X):- mpred_call_only_facts(X).

%% call_u( ?Why, ?X) is semidet.
%
% call_u(Why,F) is true iff F is a fact is true
%
call_u(Why,X):- show_call(why,(nop(Why),mpred_call_only_facts(X))).

%=
%= not_cond(Why,F) is true iff F is a fact is not true
%=
% not_cond(_Why,X):- show_success(why,mpred_call_0(~(X))).

%% not_cond( ?Why, ?X) is semidet.
%
% Not Cond.
%
not_cond(_Why,X):- \+ X.

*/

/*
%= mpred_nf1_negation(P,NF) is true if NF is the normal form of \+P.

%% mpred_nf1_negation( ?P, ?P) is semidet.
%
% PFC Normal Form Secondary Helper Negation.
%
mpred_nf1_negation((P/Cond),[(\+(P))/Cond]) :- !.

mpred_nf1_negation((P;Q),NF) :-
  !,
  mpred_nf1_negation(P,NFp),
  mpred_nf1_negation(Q,NFq),
  append(NFp,NFq,NF).

mpred_nf1_negation((P,Q),NF) :-
  % this code is not correct! tmpred_wff.
  !,
  mpred_nf1_negation(P,NF)
  ;
  (mpred_nf1(P,Pnf),
   mpred_nf1_negation(Q,Qnf),
   append(Pnf,Qnf,NF)).

mpred_nf1_negation(P,[\+P]).


%= mpred_nf_negations(List2,List) sweeps through List2 to produce List,
%= changing -{...} to {\+...}
%=% ? is this still needed? tmpred_wff 3/16/90


%% mpred_nf_negations( :TermX, :TermX) is semidet.
%
% PFC Normal Form Negations.
%
mpred_nf_negations(X,X) :- !.  % I think not! tmpred_wff 3/27/90

mpred_nf_negations([],[]).

mpred_nf_negations([H1|T1],[H2|T2]) :-
  mpred_nf_negation(H1,H2),
  mpred_nf_negations(T1,T2).


%% mpred_nf_negation( ?X, ?X) is semidet.
%
% PFC Normal Form Negation.
%
mpred_nf_negation(Form,{\+ X}) :-
  is_ftNonvar(Form),
  Form=(-({X})),
  !.
mpred_nf_negation(Form,{\+ X}) :-
  is_ftNonvar(Form),
  Form=(~({X})),
  !.
mpred_nf_negation(X,X).
*/
/*

%=
%= build_rhs(Sup,+Conjunction,-Rhs)
%=


%% build_rhs( ?Sup, :TermX, :TermX) is semidet.
%
% Build Right-hand-side.
%

build_rhs(_Sup,X,[X]) :-
  is_ftVar(X),
  !.
build_rhs(_Sup,~(X),[~(X)]) :-
  is_ftVar(X),
  !.

build_rhs(Sup,call(A),Rest) :- !, build_rhs(Sup,(A),Rest).
build_rhs(Sup,call_u(A),Rest) :- !, build_rhs(Sup,(A),Rest).

build_rhs(Sup,(A,B),[A2|Rest]) :-
  !,
  mpred_compile_rhsTerm(Sup,A,A2),
  build_rhs(Sup,B,Rest).

build_rhs(Sup,X,[X2]) :-
   mpred_compile_rhsTerm(Sup,X,X2).



%% mpred_compile_rhsTerm( ?Sup, :TermP, :TermP) is semidet.
%
% PFC Compile Right-hand-side Term.
%
mpred_compile_rhsTerm(_Sup,P,P):-is_ftVar(P),!.
mpred_compile_rhsTerm(Sup,(P/C),((P0:-C0))) :- !,mpred_compile_rhsTerm(Sup,P,P0),build_code_test(Sup,C,C0),!.
mpred_compile_rhsTerm(Sup,I,O):-to_addable_form_wte(mpred_compile_rhsTerm,I,O), must(\+ \+ mpred_mark_as(Sup,p,O,pfcRHS)),!.

*/


/*
%% mpred_positive_literal( ?X) is semidet.
%
% PFC Positive Literal.
%
mpred_positive_literal(X) :- is_ftNonvar(X),
  get_functor(X,F,_),
  \+ mpred_connective(F).


%% mpred_connective( ?VALUE1) is semidet.
%
% PFC Connective.
%
mpred_connective(';').
mpred_connective(',').
mpred_connective('/').
mpred_connective('|').
mpred_connective(('==>')).
mpred_connective(('<-')).
mpred_connective('<==>').

mpred_connective('-').
mpred_connective('-').
mpred_connective('\\+').
*/
/*
%% old_process_rule( ?Lhs, ?Rhs, ?Parent_rule) is semidet.
%
% Process Rule.
%
old_process_rule(Lhs,Rhs,Parent_rule) :- 
  copy_term_and_varnames(Parent_rule,Parent_ruleCopy),
  build_rhs((Parent_ruleCopy),Rhs,Rhs2),
   cyclic_break((Lhs,Rhs,Rhs2,Parent_ruleCopy)),
  old_foreachl_do(mpred_nf(Lhs,Lhs2),
   old_build_rule(Lhs2,rhs(Rhs2),(Parent_ruleCopy,u))).


%% old_build_rule( ?Lhs, ?Rhs, ?Support) is semidet.
%
% Build Rule.
%
old_build_rule(Lhs,Rhs,Support) :-
  build_trigger(Support,Lhs,Rhs,Trigger),
   mpred_mark_as(Support,p,Lhs,pfcLHS),
   cyclic_break((Lhs,Rhs,Support,Trigger)),
  mpred_eval_lhs(Trigger,Support).


%% build_trigger( ?Support, :TermARG2, ?Consequent, :TermConsequentO) is semidet.
%
% Build Trigger.
%
build_trigger(Support,[],Consequent,ConsequentO):- 
      build_consequent(Support,Consequent,ConsequentO).

build_trigger(Support,[V|Triggers],Consequent,pt(TBOX,V,X)) :- get_user_tbox(TBOX),
  is_ftVar(V),
  !,
  build_trigger(Support,Triggers,Consequent,X).

build_trigger(Support,[added(T)|Triggers],Consequent,pt(TBOX,T,X)) :- get_user_tbox(TBOX),
  !,
  build_code_test(Support,ground(T),Test2),
  build_trigger(Support,[{Test2}|Triggers],Consequent,X).

build_trigger(Support,[(T1/Test)|Triggers],Consequent,nt(TBOX,T2,Test2,X)) :- get_user_tbox(TBOX),
  is_ftNonvar(T1),mpred_negation(T1,T2),
  !,
  build_neg_test(Support,T2,Test,Test2),
  build_trigger(Support,Triggers,Consequent,X).

build_trigger(Support,[(T1)|Triggers],Consequent,nt(TBOX,T2,Test,X)) :- get_user_tbox(TBOX),
  mpred_negation(T1,T2),
  !,
  build_neg_test(Support,T2,true,Test),
  build_trigger(Support,Triggers,Consequent,X).

build_trigger(Support,[{Test}|Triggers],Consequent,(Test->X)) :-
  !,
  build_trigger(Support,Triggers,Consequent,X).

build_trigger(Support,[T/Test|Triggers],Consequent,pt(TBOX,T,X)) :- get_user_tbox(TBOX),
  !,
  build_code_test(Support,Test,Test2),
  build_trigger(Support,[{Test2}|Triggers],Consequent,X).


%build_trigger(Support,[snip|Triggers],Consequent,snip(X)) :-
%  !,
%  build_trigger(Support,Triggers,Consequent,X).

build_trigger(Support,[T|Triggers],Consequent,pt(TBOX,T,X)) :- get_user_tbox(TBOX),
  !,
  build_trigger(Support,Triggers,Consequent,X).

%=
%= build_neg_test(Support,+,+,-).
%=
%= builds the test used in a negative trigger (nt/4).  This test is a
%= conjunction of the check than no matching facts are in the db and any
%= additional test specified in the rule attached to this - term.
%=


%% build_neg_test( ?Support, ?T, ?Testin, ?Testout) is semidet.
%
% Build Negated Test.
%
build_neg_test(Support,T,Testin,Testout) :-  % must(sanity(is_ftNonvar(T))),
  build_code_test(Support,Testin,Testmid),
  conjoin((call_u(T)),Testmid,Testout).


%= this just strips away any currly brackets.


%% build_code_test( ?Support, ?Test, ?TestO) is semidet.
%
% Build Code Test.
%
build_code_test(_Support,Test,TestO):-is_ftVar(Test),!,must(is_ftNonvar(Test)),TestO=call_u(Test).
build_code_test(Support,{Test},TestO) :- !,build_code_test(Support,Test,TestO).
build_code_test(Support,Test,TestO):- code_sentence_op(Test),Test=..[F|TestL],must_maplist(build_code_test(Support),TestL,TestLO),TestO=..[F|TestLO],!.
build_code_test(Support,Test,Test):- must(mpred_mark_as(Support,p,Test,pfcCallCode)),!.
build_code_test(_,Test,Test).


%% code_sentence_op( :TermVar) is semidet.
%
% Code Sentence Oper..
%
code_sentence_op(Var):-is_ftVar(Var),!,fail.
code_sentence_op(rhs(_)).
code_sentence_op(~(_)).
code_sentence_op(-(_)).
code_sentence_op(-(_)).
code_sentence_op(\+(_)).
code_sentence_op(call_u(_)).
code_sentence_op(call_u(_,_)).
code_sentence_op(Test):-predicate_property(Test,meta_predicate(PP)),predicate_property(Test,built_in),  \+ (( arg(_,PP,N), N\=0)).


%% all_closed( ?C) is semidet.
%
% All Closed.
%
all_closed(C):- \+is_ftCompound(C)->true;(functor(C,_,A),A>1,\+((arg(_,C,Arg),is_ftVar(Arg)))),!.

%=


%% build_consequent( ?VALUE1, ?Test, ?Test) is semidet.
%
% Build Consequent.
%
build_consequent(_      ,Test,Test):- is_ftVar(Test),!.
build_consequent(_      ,Test,TestO):-is_ftVar(Test),!,TestO=added(Test).
build_consequent(Support,rhs(Test),rhs(TestO)) :- !,build_consequent(Support,Test,TestO).
build_consequent(Support,Test,TestO):- code_sentence_op(Test),Test=..[F|TestL],
   maplist(build_consequent(Support),TestL,TestLO),TestO=..[F|TestLO],!.
build_consequent(Support,Test,Test):-must(mpred_mark_as(Support,p,Test,pfcCreates)),!.
build_consequent(_ ,Test,Test).

%= simple typeing for pfc objects


%% mpred_db_type( ?VALUE1, ?Type) is semidet.
%
% PFC Database Type.
%
mpred_db_type(('<-'(_,_)),Type) :- !, Type=rule.
mpred_db_type(('<==>'(_,_)),Type) :- !, Type=rule.
mpred_db_type(('==>'(_,_)),Type) :- !, Type=rule.
mpred_db_type((':-'(_,_)),Type) :- !, Type=rule.
mpred_db_type(pk(_ABOX,_,_,_),Type) :- !, Type=trigger.
mpred_db_type(pt(TBOX,_ABOX,_,_),Type) :- !, Type=trigger.
mpred_db_type(nt(_ABOX,_,_,_),Type) :- !,  Type=trigger.
mpred_db_type(bt(_ABOX,_,_),Type) :- !,  Type=trigger.
mpred_db_type(mpred_action(_),Type) :- !, Type=action.
mpred_db_type((('::::'(_,X))),Type) :- is_ftNonvar(X),!, mpred_db_type(X,Type).
mpred_db_type(_,fact) :-
  %= if it''s not one of the above, it must be a fact!
  !.



%% retract_t( ?Trigger) is semidet.
%
% Retract Trigger Stucture.
%
retract_t(Trigger) :- arg(1,Trigger,TBOX),retract_i(spft(TBOX,Trigger,_,_,_)),ignore(retract_i(Trigger)).



%% old_ain_ts( ?P, ?Support) is semidet.
%
% Assert If New True Structures.
%
old_ain_ts(P,Support) :- 
  (mpred_clause_i(P) ; (assert_u(P))),
  !,
  old_ain_support(P,Support).
*/
/*

old_ain_t(P,Support) :- 
  (mpred_clause_i(P) ; (assert_u(P),old_ain_trigger(P,Support))),
  !,
  old_ain_support(P,Support).

*/

/*

%% aina_i( ?P, ?Support) is semidet.
%
% Aina For Internal Interface.
%
aina_i(P,Support) :-
  (mpred_clause_i(P) ; asserta_i(P)),
  !,
  old_ain_support(P,Support).



%% ainz_i( ?P, ?Support) is semidet.
%
% Ainz For Internal Interface.
%
ainz_i(P,Support) :-  
  (mpred_clause_i(P) ; assertz_i(P)),
  !,
  old_ain_support(P,Support).



%% mpred_clause_i( ?Head) is semidet.
%
% PFC Clause For Internal Interface.
%
mpred_clause_i((Head :- Body)) :-
  !,
  copy_term_and_varnames(Head,Head_copy),
  copy_term_and_varnames(Body,Body_copy),
  clause_i(Head,Body),
  variant(Head,Head_copy),
  variant(Body,Body_copy).

mpred_clause_i(Head) :-
  % find a unit clause_db identical to Head by finding one which unifies,
  % and then checking to see if it is identical
  copy_term_and_varnames(Head,Head_copy),
  clause_i(Head_copy,true),
  variant(Head,Head_copy).








%=
%=
%= predicates for manipulating support relationships
%=


% user:portray(C):-is_ftCompound(C),C=spft(TBOX,_,_,_,_),pp_item('',C).

%= mpred_had_support(+Fact,+Support)

%% mpred_had_support( ?P, :TermFact) is semidet.
%
% PFC Had Support.
%
mpred_had_support(P,(Fact,Trigger)) :- 
 get_user_tbox(TBOX),
 ( clause_asserted_local(spft(TBOX,P,Fact,Trigger,_OldWhy)) -> 
    true ; fail).

/*
%= old_ain_support(+Fact,+Support)


%% old_ain_support( ?P, ?FT) is semidet.
%
% Assert If New Support.
%
old_ain_support(P,(Fact,Trigger)) :- 
get_user_tbox(TBOX),
 (( clause_asserted_local(spft(TBOX,P,Fact,Trigger,_OldWhy)) ->
    true ; 
    (current_why(Why), 
      ( % get_clause_vars(P),get_clause_vars(Fact),get_clause_vars(Trigger),
        get_clause_vars(spft(TBOX,P,Fact,Trigger,Why)),
      attvar_op(assertz,(spft(TBOX,P,Fact,Trigger,Why))))))),!.  % was assert_u
*/
/*
old_ain_support(P,(Fact,Trigger)) :-
  NEWSUPPORT = spft(TBOX,NewP,NewFact,NewTrigger,NewWhy),
 copy_term_and_varnames(spft(TBOX,P,Fact,Trigger,Why,OldWhy),NEWSUPPORT),
 ( clause_asserted_local(spft(TBOX,P,Fact,Trigger,OldWhy)) ->
    true ; 
    (current_why(NewWhy),attvar_op(assertz,(NEWSUPPORT)))),!. 
*/
/*
old_ain_support(P,FT) :- trace_or_throw(failed_old_ain_support(P,FT)).

%% mpred_get_support( ?P, :TermFact) is semidet.
%
% PFC Get Support.
%
mpred_get_support(not(P),(Fact,Trigger)) :- is_ftNonvar(P),!, mpred_get_support(~(P),(Fact,Trigger)).
mpred_get_support(P,(Fact,Trigger)) :-
  get_user_tbox(TBOX),
    (spft(TBOX,P,Fact,Trigger,_)*->true;(is_ftNonvar(P),mpred_get_support_neg(P,(Fact,Trigger)))).

%% mpred_get_support_neg( :TermP, ?S) is semidet.
%
% PFC Get Support Negated.
%
mpred_get_support_neg(\+ (P),S) :- !, is_ftNonvar(P), mpred_get_support(~(P),S).
mpred_get_support_neg(- (P),S) :- !, is_ftNonvar(P), mpred_get_support(~(P),S).
% dont mpred_get_support_neg(\+ ~(P),(Fact,Trigger)) :- sp ftY((P),Fact,Trigger).

%% mpred_support_db_rem( ?WhyIn, ?P, ?S) is semidet.
%
% There were three of these to try to efficiently handle the cases
% where some of the arguments are not bound but at least one is.
%
*/
/*
mpred_support_db_rem(WhyIn,P,S):- P \= ~(_), mpred_trace_msg('Removing',mpred_support_db_rem(WhyIn,P,S)),fail.
mpred_support_db_rem(WhyIn,P,(Fact,Trigger)) :- is_ftVar(P),!,
  get_user_tbox(TBOX),
  copy_term_and_varnames(mpred_support_db_rem(mpred_support_db_rem,P,(Fact,Trigger)) ,TheWhy),
  SPFC = spft(TBOX,RP,RFact,RTrigger,_RWhy),
  clause_i(spft(TBOX,P,Fact,Trigger,_),true,Ref),
  ((clause_i(SPFC,true,Ref),
     ( spftV(RP,RFact,RTrigger) =@= spftV(P,Fact,Trigger) -> 
        erase_w_attvars(clause(SPFC,true,Ref),Ref); 
       (mpred_trace_msg(<=(TheWhy,-SPFC)),nop(mpred_retract_or_warn_i(spftVVVVVVV(P,Fact,Trigger))),nop(trace))),
   (is_ftVar(P)->trace_or_throw(is_ftVar(P));remove_if_unsupported_verbose(WhyIn,local,P)))).
mpred_support_db_rem(Why,(\+ N) , S):- mpred_support_db_rem(Why,~(N),S).
mpred_support_db_rem(_Why,P,(Fact,Trigger)):-get_user_tbox(TBOX),mpred_retract_or_warn_i(spft(TBOX,P,Fact,Trigger,_)).
*/
/*
% TODO not called yet
mpred_collect_supporters_list(Tripples) :-
  bagof(Tripple, mpred_support_relation(Tripple), Tripples),
  !.
mpred_collect_supporters_list([]).
*/
/* UNUSED TODAY
% TODO not called yet
mpred_support_relation((P,F,T)) :- spft(TBOX,P,F,T,_).

% TODO not called yet
mpred_make_supporters_list((P,S1,S2)) :-
  % was old_ain_support(P,(S1,S2),_),
  old_ain_support(P,(S1,S2)),
  (old_ain_db_type(P); true),
  !.
*/
%% old_foreachl_do( ?Binder, ?Body) is semidet.
%
% Foreachl Do.
%
old_foreachl_do(Binder,Body) :- Binder,old_pfcl_do(Body),fail.
old_foreachl_do(_,_).

% old_pfcl_do(X) executesf X once and always succeeds.

%% old_pfcl_do( ?X) is semidet.
%
% Pfcl Do.
%
old_pfcl_do(X) :- X,!.
old_pfcl_do(_).


%= mpred_union(L1,L2,L3) - true if set L3 is the result of appending sets
%= L1 and L2 where sets are represented as simple lists.


%% mpred_union( :TermARG1, ?L, :TermL) is semidet.
%
% PFC Union.
%
mpred_union([],L,L).
mpred_union([Head|Tail],L,Tail2) :-
  memberchk(Head,L),
  !,
  mpred_union(Tail,L,Tail2).
mpred_union([Head|Tail],L,[Head|Tail2]) :-
  mpred_union(Tail,L,Tail2).
*/

% mpred_database_term(P/A) is true iff P/A is something that pfc adds to
% the database and should not be present in an empty pfc database

/*
%% mpred_database_term( :PRED3VALUE1) is semidet.
%
% PFC Database Term.
%
mpred_database_term(spft/5).
mpred_database_term(pk/4).
mpred_database_term(pt/3).  % was 3
mpred_database_term(bt/3).  % was 3
mpred_database_term(nt/4). % was 4
mpred_database_term('<-'/2).
mpred_database_term('==>'/2).
mpred_database_term('<==>'/2).
mpred_database_term(qu/3).

% :- forall(mpred_database_term(T),shared_multifile(T)).


% removes all forward chaining rules and old_justifications from db.


%% mpred_reset is semidet.
%
% PFC Reset.
%
mpred_reset :-
 get_user_tbox(TBOX),
  (clause_i(spft(TBOX,P,F,Trigger,Why),BB),BB),
  mpred_retract_or_warn_i(P),
  mpred_retract_or_warn_i(spft(TBOX,P,F,Trigger,Why)),
  fail.
mpred_reset :-
  mpred_database_item(T),
  mpred_error("Pfc database not empty after mpred_reset, e.g., ~p.",[T]).
mpred_reset.

% true if there is some pfc crud still in the database.

%% mpred_database_item( ?Term) is semidet.
%
% PFC Database Item.
%
mpred_database_item(Term) :-
  mpred_database_term(P/A),
  functor(Term,P,A),
  clause_u(Term,_).


%% mpred_retract_or_warn_i( ?X) is semidet.
%
% PFC Retract Or Warn For Internal Interface.
%
mpred_retract_or_warn_i(X) :- retract_i(X),mpred_trace_msg("Success retract: ~p.",[X]),!.
mpred_retract_or_warn_i(X) :- get_user_tbox(TBOX), \+ \+ X =spft(TBOX,~(_),_,_,_),!.
mpred_retract_or_warn_i(X) :- ground(X),mpred_trace_msg("Couldn't retract ~p.",[X]),!.
mpred_retract_or_warn_i(_).

*/
% ======================= mpred_file('pfcdebug').	% debugging aids (e.g. tracing).
%   File   : pfcdebug.pl
%   Author : Tim Finin, finin@prc.unisys.com
%   Author :  Dave Matuszek, dave@prc.unisys.com
%   Updated:
%   Purpose: provides predicates for examining the database and debugginh
%   for Pfc.
/*
:- dynamic mpred_is_spying/2.
:- thread_local mpred_is_tracing/1.
:- dynamic mpred_warnings/1.
*/
/*
%% is_disabled_clause( ?C) is semidet.
%
% If Is A Disabled Clause.
%
is_disabled_clause(C):-req(is_edited_clause(C,_,New)),memberchk((disabled),New).

%= mpred_fact(P) is true if fact P was asserted into the database via mpred_ain.


%% mpred_fact( ?P) is semidet.
%
% PFC Fact.
%
mpred_fact(P) :- mpred_fact(P,true).

%= mpred_fact(P,C) is true if fact P was asserted into the database via
%= assert and condition C is satisfied.  For example, we might do:
%=
%=  mpred_fact(X,mpred_user_fact(X))
%=



%% mpred_user_fact( ?X) is semidet.
%
% PFC User Fact.
%
mpred_user_fact(X):-get_user_tbox(TBOX),no_repeats(spft(TBOX,X,U,U,_)).


%% mpred_fact( ?P, ?PrologCond) is semidet.
%
% PFC Fact.
%
mpred_fact(P,PrologCond) :-
  mpred_get_support(P,_),is_ftNonvar(P),
  once(mpred_db_type(P,F)),F=fact,
  call_prologsys(PrologCond).

%= mpred_facts(-ListofPfcFacts) returns a list of facts added.


%% mpred_facts( ?L) is semidet.
%
% PFC Facts.
%
mpred_facts(L) :- mpred_facts(_,true,L).


%% mpred_facts( ?P, ?L) is semidet.
%
% PFC Facts.
%
mpred_facts(P,L) :- mpred_facts(P,true,L).

%= mpred_facts(Pattern,Condition,-ListofPfcFacts) returns a list of facts added.


%% mpred_facts( ?P, ?C, ?L) is semidet.
%
% PFC Facts.
%
mpred_facts(P,C,L) :- setof(P,mpred_fact(P,C),L).


%% old_brake( ?X) is semidet.
%
% Brake.
%
old_brake(X) :-  X, break.
*/
%=
%=
%= predicates providing a simple tracing facility
%=
/*
NOT NEEDED ANYMORE
mpred_trace_add(P) :-
  % this is here for upward compat. - should go away eventually.
  mpred_trace_add(P,(o,o)).
*/
/*
mpred_trace_add(bt(TBOX,Head,Body)) :-
  % hack for now - never trace triggers.
  !.
mpred_trace_add(pt(TBOX,Head,Body)) :-
  % hack for now - never trace triggers.
  !.
mpred_trace_add(nt(TBOX,Head,Condition,Body)) :-
  % hack for now - never trace triggers.
  !.
*/

%% mpred_trace_add( ?P, ?S) is semidet.
%
% PFC Trace add.
%
mpred_trace_add(P,S) :-
   mpred_trace_add_print(P,S),
   mpred_trace_break(P,S).


/*
%% mpred_trace_add_print( ?P, ?S) is semidet.
%
% PFC Trace add print.
%
mpred_trace_add_print(P,S):- (\+ \+ mpred_trace_add_print_0(P,S)).

%% mpred_trace_add_print_0( ?P, ?S) is semidet.
%
% PFC Trace add print  Primary Helper.
%
mpred_trace_add_print_0(P,S) :-
  get_mpred_is_tracing(P),
  !,
  must(S=(F,T)),
  (F==T
       -> mpred_trace_msg("Adding (~p) ~p ",[F,P])
        ; (((mpred_trace_msg("Adding (:) ~p    <-------- -n (~p <-TF-> ~p)",[P,(T),(F)]))))).

mpred_trace_add_print_0(_,_).



%% mpred_trace_break( ?P, ?S) is semidet.
%
% PFC Trace break.
%
mpred_trace_break(P,_S) :-
  mpred_is_spying(P,add) ->
   ((\+ \+ wdmsg("Breaking on mpred_ain(~p)",[P])),
    break)
   ; true.
*/
/*
mpred_trace_rem(Why,bt(TBOX,Head,Body)) :-
  % hack for now - never trace triggers.
  !.
mpred_trace_rem(Why,pt(TBOX,Head,Body)) :-
  % hack for now - never trace triggers.
  !.
mpred_trace_rem(Why,nt(TBOX,Head,Condition,Body)) :-
  % hack for now - never trace triggers.
  !.
*/

/*
%% mpred_trace_rem( ?Why, ?P) is semidet.
%
% PFC Trace Remove/Erase.
%
mpred_trace_rem(Why,P) :-
  ((get_mpred_is_tracing(P);get_mpred_is_tracing(Why))
     -> (mpred_trace_msg('Removing (~p) ~p.',[Why,P]))
      ; true),
  ((mpred_is_spying(P,rem);mpred_is_spying(P,Why))
     -> (in_cmt(wdmsg("Breaking on remove(~p,~p)",[Why,P])), break)
   ; true),!.



%% mpred_no_spy_all is semidet.
%
% PFC No Spy All.
%
mpred_no_spy_all :- mpred_no_spy, retractall_u(mpred_is_tracing_exec).

%% mpred_no_trace_all is semidet.
%
% PFC no  Trace all.
%
mpred_no_trace_all :-  retractall_u(mpred_is_tracing_exec).

%% mpred_spy_all is semidet.
%
% PFC Spy All.
%
mpred_spy_all :- assert_u(mpred_is_tracing_exec).

%% mpred_trace_exec is semidet.
%
% PFC Trace exec.
%
mpred_trace_exec :- assert_u(mpred_is_tracing_exec),set_prolog_flag(gc,false).

%% mpred_notrace_exec is semidet.
%
% PFC No Trace Exec.
%
mpred_notrace_exec :- retractall_u(mpred_is_tracing_exec).

%% mpred_trace is semidet.
%
% PFC Trace.
%
mpred_trace :- mpred_trace(_).
lmconf:module_local_init:-mpred_no_trace_all.


%% mpred_trace( ?Form) is semidet.
%
% PFC Trace.
%
mpred_trace(Form) :-
  assert_u(mpred_is_tracing(Form)).


%% mpred_trace( ?Form, ?Condition) is semidet.
%
% PFC Trace.
%
mpred_trace(Form,Condition) :-
  assert_u((mpred_is_tracing(Form) :- Condition)).


%% mpred_spy( ?Form) is semidet.
%
% PFC Spy.
%
mpred_spy(Form) :- mpred_spy(Form,[add,rem],true).


%% mpred_spy( ?Form, ?Modes) is semidet.
%
% PFC Spy.
%
mpred_spy(Form,Modes) :- mpred_spy(Form,Modes,true).


%% mpred_spy( ?Form, ?Mode, ?Condition) is semidet.
%
% PFC Spy.
%
mpred_spy(Form,[add,rem],Condition) :-
  !,
  mpred_spy1(Form,add,Condition),
  mpred_spy1(Form,rem,Condition).

mpred_spy(Form,Mode,Condition) :-
  mpred_spy1(Form,Mode,Condition).


%% mpred_spy1( ?Form, ?Mode, ?Condition) is semidet.
%
% PFC Spy Secondary Helper.
%
mpred_spy1(Form,Mode,Condition) :-
  assert_u((mpred_is_spying(Form,Mode) :- Condition)).


%% mpred_no_spy is semidet.
%
% PFC No Spy.
%
mpred_no_spy :- mpred_no_spy(_,_,_).


%% mpred_no_spy( ?Form) is semidet.
%
% PFC No Spy.
%
mpred_no_spy(Form) :- mpred_no_spy(Form,_,_).


%% mpred_no_spy( ?Form, ?Mode, ?Condition) is semidet.
%
% PFC No Spy.
%
mpred_no_spy(Form,Mode,Condition) :-
  clause_i(mpred_is_spying(Form,Mode), Condition, Ref),
  erase_w_attvars(clause_i(mpred_is_spying(Form,Mode), Condition, Ref),Ref),
  fail.
mpred_no_spy(_,_,_).


%% mpred_no_trace is semidet.
%
% PFC no  Trace.
%
mpred_no_trace :- mpred_untrace.

%% mpred_untrace is semidet.
%
% PFC Un Trace.
%
mpred_untrace :- mpred_untrace(_).

%% mpred_untrace( ?Form) is semidet.
%
% PFC Un Trace.
%
mpred_untrace(Form) :- retractall_u(mpred_is_tracing(Form)).

% needed:  mpred_trace_rule(Name)  ...


% if the correct flag is set, trace exection of Pfc

%% mpred_trace_msg( ?Msg) is semidet.
%
% PFC Trace msg.
%
mpred_trace_msg(Msg) :- mpred_trace_msg('~p.',[Msg]),!.

*/

%% mmsg( ?Msg, ?Args) is semidet.
%
% Module Message.
%
mmsg(Msg,Args):- is_list(Args) -> wdmsg(Msg, Args) ; pp_item(Msg, Args).

:- was_dynamic(mpred_hide_msg/1).

%% mpred_hide_msg( ?VALUE1) is semidet.
%
% PFC Hide Msg.
%
mpred_hide_msg('Adding For Later').
mpred_hide_msg('Skipped Trigger').
mpred_hide_msg('Had Support').

/*

% mpred_trace_msg(Msg,Args) :- !, mmsg(Msg,Args).
% mpred_trace_msg(Msg,_Args) :- mpred_hide_msg(Msg),!.

%% mpred_trace_msg( ?Msg, ?Args) is semidet.
%
% PFC Trace msg.
%
mpred_trace_msg(Msg,Args) :- ignore((mpred_is_tracing_exec, !, mmsg(Msg,Args))),!.




%% mpred_watch is semidet.
%
% PFC Watch.
%
mpred_watch :- assert_u(mpred_is_tracing_exec).


%% mpred_no_watch is semidet.
%
% PFC No Watch.
%
mpred_no_watch :-  retractall_u(mpred_is_tracing_exec).


%% mpred_error( ?Msg) is semidet.
%
% PFC Error.
%
mpred_error(Msg) :-  mpred_error(Msg,[]).


%% mpred_error( ?Msg, ?Args) is semidet.
%
% PFC Error.
%
mpred_error(Msg,Args) :-
 ignore((in_cmt(( wdmsg("ERROR/Pfc: ",[]),wdmsg(Msg,Args))))),!.


%=
%= These control whether or not warnings are printed at all.
%=   mpred_warn.
%=   nmpred_warn.
%=
%= These print a warning message if the flag mpred_warnings is set.
%=   mpred_warn(+Message)
%=   mpred_warn(+Message,+ListOfArguments)
%=


%% mpred_warn is semidet.
%
% PFC Warn.
%
mpred_warn :-
  retractall_u(mpred_warnings(_)),
  assert_u(mpred_warnings(true)).

%% nmpred_warn is semidet.
%
% Nompred Warn.
%
nmpred_warn :-
  retractall_u(mpred_warnings(_)),
  assert_u(mpred_warnings(false)).


%% mpred_warn( ?Msg) is semidet.
%
% PFC Warn.
%
mpred_warn(Msg) :-  mpred_warn(Msg,[]).

*/


lmconf:module_local_init:-mpred_warn.

/*
%% mpred_warn( ?Msg, ?Args) is semidet.
%
% PFC Warn.
%
mpred_warn(Msg,Args) :-
  gethostname(ubuntu),!,
 ignore((
  sformat(S, Msg,Args),
  show_source_location,
  wdmsg(pfc(warn(S))))),!.

mpred_warn(Msg,Args) :-
 ignore((
 (mpred_warnings(true); \+ mpred_is_silient),
  !,
  sformat(S, Msg,Args),
  show_source_location,
  wdmsg(pfc(warn(S))))),!.


%=
%= mpred_warnings/0 sets flag to cause pfc warning messages to print.
%= mpred_no_warnings/0 sets flag to cause pfc warning messages not to print.
%=


%% mpred_warnings is semidet.
%
% PFC Warnings.
%
mpred_warnings :-
  retractall_u(mpred_warnings(_)),
  assert_u(mpred_warnings(true)).


%% mpred_no_warnings is semidet.
%
% PFC No Warnings.
%
mpred_no_warnings :-
  retractall_u(mpred_warnings(_)).
*/

% ======================= mpred_file('pfcjust').	% predicates to manipulate old_justifications.


%   File   : pfcjust.pl
%   Author : Tim Finin, finin@prc.unisys.com
%   Author :  Dave Matuszek, dave@prc.unisys.com
%   Updated:
%   Purpose: predicates for accessing Pfc old_justifications.
%   Status: more or less working.
%   Bugs:

%= *** predicates for exploring supports of a fact *****

/*
:- use_module(library(lists)).


%% justification( ?F, ?J) is semidet.
%
% Justification.
%
justification(F,J) :- supporters_list(F,J).


%% old_justifications( ?F, ?Js) is semidet.
%
% Justifications.
%
old_justifications(F,Js) :- bagof(J,justification(F,J),Js).


%% baseable( ?P, ?L) is semidet.
% - is true iff L is a list of "baseable" facts which, taken
% together, allows us to deduce P.  A baseable fact is an mpred_axiom (a fact
% added by the user or a raw Prolog fact (i.e. one w/o any support))
% or an mpred_assumption.
baseable(F,[F]) :- (mpred_axiom(F) ; mpred_assumption(F)),!.
baseable(F,L) :-
  % i.e. (reduce 'append (map 'baseable (justification f)))
  justification(F,Js),
  baseable_list(Js,L).




%% baseable_list( ?L1, ?L2) is semidet.
% baseable_list(L1,L2) is true if list L2 represents the union of all of the
% facts on which some conclusion in list L1 is based.
baseable_list([],[]).
baseable_list([X|Rest],L) :-
  baseable(X,Bx),
  baseable_list(Rest,Br),  
  mpred_union(Bx,Br,L).
	


%% mpred_axiom( ?F) is semidet.
%
% PFC Axiom.
%
mpred_axiom(F) :-
  %mpred_get_support(F,UU);
  %mpred_get_support(F,(g,g));
  mpred_get_support(F,(OTHER,OTHER)).

%= an mpred_assumption is a failed action, i.e. were assuming that our failure to
%= prove P is a proof of not(P)


%% mpred_assumption( ?P) is semidet.
%
% Assumption.
%
mpred_assumption(P) :- is_ftNonvar(P),mpred_negation(P,_).

%= mpred_assumptions(X,As) if As is a set of mpred_assumptions which underly X.


%% mpred_assumptions( ?X, ?L) is semidet.
%
% Assumptions.
%
mpred_assumptions(X,[X]) :- mpred_assumption(X).
mpred_assumptions(X,[]) :- mpred_axiom(X).
mpred_assumptions(X,L) :-
  justification(X,Js),
  mpred_assumptions1(Js,L).


%% mpred_assumptions1( :TermX, ?L) is semidet.
%
% Assumptions Secondary Helper.
%
mpred_assumptions1([],[]).
mpred_assumptions1([X|Rest],L) :-
  mpred_assumptions(X,Bx),
  mpred_assumptions1(Rest,Br),
  mpred_union(Bx,Br,L).


%= pfcProofTree(P,T) the proof tree for P is T where a proof tree is
%= of the form
%=
%=     [P , J1, J2, ;;; Jn]         each Ji is an independent P justifier.
%=          ^                         and has the form of
%=          [J11, J12,... J1n]      a list of proof trees.


% mpred_child(P,Q) is true iff P is an immediate justifier for Q.
% mode: mpred_child(+,?)


%% mpred_child( ?P, ?Q) is semidet.
%
% PFC Child.
%
mpred_child(P,Q) :-
  mpred_get_support(Q,(P,_)).

mpred_child(P,Q) :-
  mpred_get_support(Q,(_,Trig)),
  mpred_db_type(Trig,trigger),
  mpred_child(P,Trig).


%% mpred_children( ?P, ?L) is semidet.
%
% PFC Children.
%
mpred_children(P,L) :- bagof(C,mpred_child(P,C),L).

% mpred_descendant(P,Q) is true iff P is a justifier for Q.


%% mpred_descendant( ?P, ?Q) is semidet.
%
% PFC Descendant.
%
mpred_descendant(P,Q) :-
   mpred_descendant1(P,Q,[]).


%% mpred_descendant1( ?P, ?Q, ?Seen) is semidet.
%
% PFC Descendant Secondary Helper.
%
mpred_descendant1(P,Q,Seen) :-
  mpred_child(X,Q),
  (\+ member(X,Seen)),
  (P=X ; mpred_descendant1(P,X,[X|Seen])).


%% mpred_descendants( ?P, ?L) is semidet.
%
% PFC Descendants.
%
mpred_descendants(P,L) :-
  bagof(Q,mpred_descendant1(P,Q,[]),L).

*/
/*
%add_reprop(_,_):-!.

%% add_reprop( ?Trig, :TermVar) is semidet.
%
% Add Reprop.
%
add_reprop(_Trig,Var):- is_ftVar(Var), !. % trace_or_throw(var_add_reprop(Trig,Var)).
add_reprop(_Trig,~(Var)):- is_ftVar(Var),!.
% CREATES ERROR!!!  add_reprop(_Trig,~(_Var)):-!.
add_reprop(_Trig,~(repropagate(Var))):- \+ is_ftVar(Var),!.
add_reprop(_Trig,repropagate(~(Var))):- \+ is_ftVar(Var),!.
add_reprop(_Trig,repropagate(Var)):- \+ is_ftVar(Var),!.
% add_reprop(_Trig,_):-!.
add_reprop(Trig,(H:-B)):- trace_or_throw(bad_add_reprop(Trig,(H:-B))).

% instant 
add_reprop(Trig ,Trigger):- fail, !, w_tl(t_l:current_why_source(Trig),  repropagate(Trigger)).

% settings
add_reprop( Trig ,Trigger):- fail,
  w_tl(t_l:current_why_source(Trig),
    (
     mpred_fwd(repropagate(Trigger),Trig))),!.

% delayed
add_reprop( Trig ,Trigger):- 
  w_tl(t_l:current_why_source(Trig),
    (get_user_tbox(TBOX),
     show_call(attvar_op(assertz_if_new,(qu(TBOX,repropagate(Trigger),(Trig,g))))))).
*/





%=
%= a fact is well founded if it is supported by the user
%= or by a set of facts and a rules, all of which are well founded.
%=


%% well_founded( ?Fact, ?How) is semidet.
%
% Well Founded.
%
well_founded(Fact,How) :- mpred_wff(Fact,[],How).


%% mpred_wff( ?F, ?VALUE2, :TermHow) is semidet.
%
% PFC Well-formed Formula.
%
mpred_wff(F,_,How) :-
  % supported by user (mpred_axiom) or an "absent" fact (mpred_assumption).
  ((mpred_axiom(F),How =mpred_axiom(F) ); (mpred_assumption(F),How=mpred_assumption(F))),
  !.

mpred_wff(F,Descendants,wff(Supporters)) :-
  % first make sure we aren''t in a loop.
  (\+ memberchk(F,Descendants)),
  % find a justification.
  supporters_list(F,Supporters),
  % all of whose members are well founded.
  mpred_wfflist(Supporters,[F|Descendants]),
  !.

%= mpred_wfflist(L) simply maps mpred_wff over the list.

%% mpred_wfflist( :TermX, ?L) is semidet.
%
% PFC Wfflist.
%
mpred_wfflist([],_).
mpred_wfflist([X|Rest],L) :-
  mpred_wff(X,L,_How),
  mpred_wfflist(Rest,L).

/*

% supporters_list(+F,-ListofSupporters) where ListOfSupports is a list of the
% supports for one justification for fact F -- i.e. a list of facts which,
% together allow one to deduce F.  One of the facts will typically be a rule.
% The supports for a user-defined fact are: [u].


%% supporters_list( ?F, :TermFact) is semidet.
%
% Supports Functor (list Version).
%
supporters_list(F,[Fact|MoreFacts]) :-
  mpred_get_support_precanonical_plus_more(F,(Fact,Trigger)),
  must(trigger_supporters_list(Trigger,MoreFacts)).
*/
