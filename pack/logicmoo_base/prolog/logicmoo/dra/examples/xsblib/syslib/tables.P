/* File:      tables.P
** Author(s): Terry Swift, Prasad Rao, Kostis Sagonas, Ernie Johnson
** Contact:   xsb-contact@cs.sunysb.edu
** 
** Copyright (C) The Research Foundation of SUNY, 1993-1998
** 
** XSB is free software; you can redistribute it and/or modify it under the
** terms of the GNU Library General Public License as published by the Free
** Software Foundation; either version 2 of the License, or (at your option)
** any later version.
** 
** XSB is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
** FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for
** more details.
** 
** You should have received a copy of the GNU Library General Public License
** along with XSB; if not, write to the Free Software Foundation,
** Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
**
** $Id: tables.P,v 1.55 2009/09/07 21:09:46 tswift Exp $
** 
*/


/*----------------------------------------------------------------------*/
/* NOTE: This file HAS TO be compiled with the "sysmod" option.         */
/*----------------------------------------------------------------------*/

:- compiler_options([sysmod,optimize,xpp_on,spec_off]).

#include "builtin.h"
#include "table_status_defs.h"
#include "table_inspection_defs.h"
#include "heap_defs_xsb.h"
#include "psc_defs.h"

/*----------------------------------------------------------------------*/

/* Change Evaluation Method for Tabled Predicate
   --------------------------------------------- */
use_variant_tabling(CommaList) :-
	set_eval_method_for_comma(CommaList,VARIANT_EVAL_METHOD).

use_subsumptive_tabling(CommaList) :-
	set_eval_method_for_comma(CommaList,SUBSUMPTIVE_EVAL_METHOD).

set_eval_method_for_comma((PS1,PS2),EvalMethod) :-
	!, set_eval_method_for_comma(PS1,EvalMethod),
	set_eval_method_for_comma(PS2,EvalMethod).
set_eval_method_for_comma(PredSpec,EvalMethod) :-
	set_tabled_eval_for_pred(PredSpec,EvalMethod).

/*
 * Setting of the evaluation method will fail if calls exist in the
 * Call Trie.
 */
set_tabled_eval_for_pred(PredSpec,Method) :-
	( PredSpec = P/N -> functor(Term,P,N); Term = PredSpec ),
	( set_tabled_eval(Term,Method), fail; true ).

set_tabled_eval(Predicate,EvalMethod) :-
	set_tabled_eval(Predicate,EvalMethod).

/* Here, if a predicate is static, and non-tabled we throw an error,
   otherwise a no-op */
add_table(Spec) :-
	mpa_to_skel(Spec,Call),
	term_psc(Call,Psc),
	((psc_type(Psc, Type),Type =:= T_PRED) -> /* static and loaded */
	    ((psc_tabled(Psc, Tabled),Tabled \== 0) ->
		true
	      ; permission_error(table,static_code,Spec,(table)/1) )
	  ; psc_set_tabled(Psc,1)).  %% set it as tabled

retract_table(Spec) :-
	mpa_to_skel(Spec,Call),
	term_psc(Call,Psc),
	psc_set_tabled(Psc,0).  %% set it as non-tabled
	
/* Mode can be INCREMENTAL, NONINCREMENTAL, or OPAQUE */
add_incr_table(Spec,Mode) :-
	mpa_to_skel(Spec,Call),
	term_psc(Call,Psc),	
	(predicate_has_tables(Psc) ->
	   permission_error(add_incremental_tabling,predicate_with_tables,Spec,(table)/1) 
	 ; psc_set_incr(Psc,Mode)).

/*----------------------------------------------------------------------*/

/*
 * To obtain info about both subsumptive and variant predicates.
 * See the file ../emu/builtin.c for a description of the valid
 * combinations of values for PredType, CallType, and AnsSetStatus.
 */

table_state(Call, PredType, CallType, AnsSetStatus) :-
%    writeln(table_state_called(table_state(Call, PredType, CallType, AnsSetStatus))),
	(Call = M:Goal -> term_new_mod(M,Goal,NewGoal) ; Call = NewGoal),
	table_status(NewGoal, PredTypeCode, CallTypeCode, AnsSetStatusCode,_SF),
	predicate_type_code(PredTypeCode, PredType),
	call_type_code(CallTypeCode, CallType),
	answer_set_status_code(AnsSetStatusCode, AnsSetStatus).

table_status(_Call, _PredType, _CallType, _AnsSetStatus,_SubgoalFrame) :-
	'_$builtin'(TABLE_STATUS).

predicate_type_code(UNTABLED_PREDICATE,      undefined).
predicate_type_code(VARIANT_EVAL_METHOD,     variant).
predicate_type_code(SUBSUMPTIVE_EVAL_METHOD, subsumptive).

call_type_code(UNDEFINED_CALL, undefined).
call_type_code(PRODUCER_CALL,  producer).
call_type_code(SUBSUMED_CALL,  subsumed).
call_type_code(NO_CALL_ENTRY,  no_entry).

answer_set_status_code(INCR_NEEDS_REEVAL,  incremental_needs_reeval).
answer_set_status_code(UNDEFINED_ANSWER_SET,  undefined).
answer_set_status_code(COMPLETED_ANSWER_SET,  complete).
answer_set_status_code(INCOMPLETE_ANSWER_SET, incomplete).

/*----------------------------------------------------------------------*/
/*
 * Builtins for supporting negation and suspensions.
 */

get_ptcp(PTCP) :- get_ptcp(PTCP).

is_incomplete(_ProducerSubgoalFrame,_PTCP) :- '_$builtin'(IS_INCOMPLETE).

slg_not(ProducerSF) :- slg_not(ProducerSF).

%lrd_success(ProducerSF,Subgoal) :- lrd_success(ProducerSF,Subgoal).

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

tfindall(T, Call, Result) :-
	table_state(Call,PredType,_CallType,AnsSetStatus),
	( PredType \== undefined ->
	  ( AnsSetStatus == complete ->
	      findall(T,Call,Result)
          ; (AnsSetStatus == undefined ; AnsSetStatus == incremental_needs_reeval) ->
	      ( call(Call), fail ; tfindall(T,Call,Result) )
	  ; AnsSetStatus == incomplete ->
	      table_error('tfindall/3 is in a possible loop.  Cannot evaluate non-stratified tfindall/3')  
/*	      get_ptcp(PTCP),
	      get_producer_call(Call,ProdSF,_CallAT),
	      is_incomplete(ProdSF,PTCP),
	      findall(T,Call,Result)
*/	  )
	; abort(['Illegal (untabled?) subgoal to tfindall/3: ', Call])
	).

:- export 't not'/1.
't not'(Goal):- tnot(Goal).

/* Need to Handle module calls (not sure if done properly before) */
/* need to refactor to distinguish completed from non-completed with call-entry */
%:- import writeln/1 from standard.
tnot(Subgoal) :-
	table_inspection_function(TNOT_SETUP,Subgoal,PredType,CallType,AnsSetStatus,SF,PTCP),
%	writeln(table_inspection_function(TNOT_SETUP,Subgoal,PredType,CallType,AnsSetStatus,SF,PTCP)),
%	table_status(Subgoal,PredType,CallType,AnsSetStatus,SF),
	(PredType == VARIANT_EVAL_METHOD -> 
	    t_not_variant(Subgoal,AnsSetStatus,SF,PTCP)
	 ;  % PredType == SUBSUMPTIVE_EVAL_METHOD ->
	      (CallType == NO_CALL_ENTRY -> 
		  (AnsSetStatus == COMPLETED_ANSWER_SET -> 
		      t_not_subsumptive_no_sf_comp(Subgoal)
		    ; t_not_subsumptive_no_sf_incomp(Subgoal) )
	        ; (AnsSetStatus == COMPLETED_ANSWER_SET -> % has call entry
  	  	      t_not_subsumptive_sf_comp(Subgoal,SF,AnsSetStatus)
		    ; t_not_subsumptive_sf_incomp(Subgoal,SF,AnsSetStatus) ) ) ).

t_not_variant(Subgoal,AnsSetStatus,SF,PTCP):- 
%	writeln(t_not_variant(Subgoal,AnsSetStatus,SF,PTCP)),
%	    get_ptcp(PTCP),
	    ( AnsSetStatus < 0 ->  % i.e. UNDEFINED_ANSWER_SET or INCR_NEEDS_REEVAL
	        (tcall(Subgoal), fail 
	          ;  get_producer_call(Subgoal,ProducerSF,_AnswerTmplt),
		     is_incomplete(ProducerSF,PTCP),
		     slg_not(ProducerSF) 
		 )
          ;  %get_producer_call(Subgoal,ProducerSF,_AnswerTmplt),
	     is_incomplete(SF,PTCP),slg_not(SF) ).

% needs to be optimized!
t_not_subsumptive_sf_comp(Subgoal,SF,_):- 
%	mywriteln(t_not_subsumptive_sf_comp(Subgoal)),
	get_producer_call(Subgoal,ProducerSF,AnswerTmplt),
	(get_returns(ProducerSF,AnswerTmplt, RetLeaf) -> 
	    table_inspection_function(CALL_SUBS_SLG_NOT,ProducerSF,RetLeaf,1,SF)
	  ; table_inspection_function(CALL_SUBS_SLG_NOT,ProducerSF,RetLeaf,0,SF) ).

t_not_subsumptive_sf_incomp(Subgoal,ConsumerSF,AnsSetStatus) :-
	get_ptcp(PTCP),
%	mywriteln(t_not_subsumptive_sf_incomp(Subgoal,ConsumerSF,PTCP,AnsSetStatus)),
        ( AnsSetStatus == UNDEFINED_ANSWER_SET ->
	    (   tcall(Subgoal), fail 
	      ; t_not_subsumptive_sf_incomp_1(Subgoal,ConsumerSF,PTCP) )
          ; t_not_subsumptive_sf_incomp_1(Subgoal,ConsumerSF,PTCP)  ).

/* Succeed if no answers; SLG_NOT_CREATE_SF fails if unconditional
   answer: otherwise it creates a new SF and delays negatively */
t_not_subsumptive_no_sf_comp(Subgoal):- 
%	mywriteln(t_not_subsumptive_no_sf_comp(Subgoal)),
	get_producer_call(Subgoal,ProducerSF,Answertmplt),
	(get_returns(ProducerSF,Answertmplt, RetLeaf) -> 
	    table_inspection_function(CALL_SUBS_SLG_NOT,ProducerSF,RetLeaf,1,0)
	  ; table_inspection_function(CALL_SUBS_SLG_NOT,ProducerSF,RetLeaf,0,0) ).

/*
%t_not_subsumptive_no_sf_incomp(Subgoal) :-
%	writeln(t_not_subsumptive_no_sf_incomp(Subgoal)),
%	get_ptcp(PTCP),
%        (   tcall(Subgoal), fail 
%          ; table_status(Subgoal,_PredType,_CallType,_AnsSetStatus,ConsumerSF),
%	    get_producer_call(Subgoal,ProducerSF,_Answertmplt),
%	    is_incomplete(ProducerSF,PTCP),
%	    slg_not(ConsumerSF) ).
*/

t_not_subsumptive_no_sf_incomp(Subgoal) :-
%	mywriteln(t_not_subsumptive_no_sf_incomp(Subgoal)),
	get_ptcp(PTCP),
        (   tcall(Subgoal), fail 
          ; %table_status(Subgoal,_PredType,_CallType,_AnsSetStatus,ConsumerSF),
%	table_state(Subgoal, PredType1, CallType1, AnsSetStatus1),
%	mywriteln(table_state(Subgoal, PredType1, CallType1, AnsSetStatus1)),
	table_status(Subgoal,_PredType,_CallType,_AnsSetStatus,ConsumerSF),
	get_producer_call(Subgoal,ProducerSF,Answertmplt),
	    is_incomplete(ProducerSF,PTCP),
	    (get_returns(ProducerSF,Answertmplt, RetLeaf) -> 
%		mywriteln(slgnot_with_return(Subgoal)),
		table_inspection_function(CALL_SUBS_SLG_NOT,ProducerSF,RetLeaf,1,ConsumerSF)
	    ;	%mywriteln(slgnot_without_return(Subgoal)),
	        table_inspection_function(CALL_SUBS_SLG_NOT,ProducerSF,RetLeaf,0,ConsumerSF) ) ).

t_not_subsumptive_sf_incomp_1(Subgoal,ConsumerSF,PTCP):- 
%	writeln(t_not_subsumptive_1(Subgoal,ConsumerSF,PTCP)),
	get_producer_call(Subgoal,ProducerSF,_Answertmplt),
	is_incomplete(ProducerSF,PTCP),
	((var(ConsumerSF) ; ConsumerSF == 0) -> 
	    slg_not(ProducerSF) 
	  ; slg_not(ConsumerSF)).


/*
't not'(Subgoal) :-
	table_state(Subgoal,PredType,CallType,AnsSetStatus),
	( PredType \== undefined ->
	    get_ptcp(PTCP),
	    ( AnsSetStatus == undefined ->
	        ( tcall(Subgoal), fail ; t_not(Subgoal,PredType,PTCP) )
	    ; t_not(Subgoal,PredType,PTCP)
	    )
	; abort(['Illegal (untabled?) subgoal to ''t not''/1: ',Subgoal])
	).

t_not(Subgoal,PredType,PTCP) :-
	get_producer_call(Subgoal,ProducerSF,AnswerTmplt),
	is_incomplete(ProducerSF,PTCP),
	( PredType == variant
	  -> slg_not(ProducerSF)
	  ;  fail_if(trie_get_return(ProducerSF,AnswerTmplt)),
	     lrd_success(ProducerSF,Subgoal)
	 ).
*/

/*
:- import writeln/1 from standard.
writeit(0).
%writeit(1).
mywriteln(Term):- writeit(If),(If =:= 1 -> writeln(Term); true).
*/

u_not(Goal) :-
	(ground_and_acyclic(Goal) ->
	   tnot(Goal)
	 ; check_cyclic(Goal,'u_not/1',1),
	   floundered(Goal)).

:- import floundered_undefined/1 from xsbbrat.
:- table floundered/1 as variant, opaque.
floundered(_Goal):- floundered_undefined(a).

:- table tunnumcall/1.
:- use_variant_tabling tunnumcall(_).

%% skolemized tnot.  Variables temporarily changed to ground and tnot 
%% call is made.  Should give existential semantics to nonground negative
%% calls.  That is
%%	...:- sk_not(p(X)),...
%% is like
%%	... :- tnot(pp),...
%%	pp :- p(X).
%% where pp is a new proposition.

:- export not_exists(Goal).

not_exists(Goal):- sk_not(Goal).

sk_not(Goal) :-
	check_cyclic(Goal,'sk_not/1',1),
	copy_term(Goal,Goal1),
	numbervars(Goal1,0,_,[attvar(bind)]), 
	%% is now ground, so no check necessary
	tnot(tunnumcall(Goal1)).

tunnumcall(GGoal) :-
	unnumbervars(GGoal,VGoal),
	call(VGoal).

% we've got true and fail -- why not this?
:- table undefined/0.
undefined:- tnot(undefined).

/*----------------------------------------------------------------------*/
/* Predicates to retrieve information out of tables.                    */
/*----------------------------------------------------------------------*/

/*
 * get_call(+CallTerm, -TableEntryHandle, -ReturnTemplate)
 *   Performs an interpretive traversal of a Call Trie in searching
 *   for a VARIANT of CallTerm.  If the call is present, then a
 *   reference to the subgoal frame is returned as a handle to the
 *   call's table entry, and the Answer Template is constructed as a
 *   ret/n term in ReturnTemplate.
 * 
 * corresponds to TRIE_GET_CALL builtin
 */

get_call(CallTerm, TableEntryHandle, ReturnTemplate) :-
	get_call(CallTerm, TableEntryHandle, ReturnTemplate).


/*
 * get_producer_call(+CallTerm, -TableEntryHandle, -ReturnTemplate)
 *   Performs an interpretive traversal of a Call Trie, using the
 *   tabling strategy of the given predicate, in searching for CallTerm.
 *   Under both tabling strategies, a producer entry is identified --
 *   i.e., a subgoal which maintains its own answer set.  If such a call
 *   is present, then a reference to the subgoal frame is returned as a
 *   handle to the producer's table entry, and the Answer Template of
 *   CallTerm with respect to this producer is constructed as a ret/n
 *   term in ReturnTemplate.
 */

get_producer_call(CallTerm, ProducerTableEntry, ReturnTemplate) :-
	get_producer_call(CallTerm, ProducerTableEntry, ReturnTemplate).


/*
 * get_calls(#CallTerm, -TableEntryHandle, -ReturnTemplate)
 *   Backtrackable predicate for selecting calls which UNIFY with
 *   CallTerm.  Selections are made via a trie-code-directed traversal
 *   of the Call Trie.  Each successful unification returns a subgoal
 *   frame reference which serves as a handle to the call's table
 *   entry.  Additionally, a return template for the resulting
 *   (unified) call is constructed in the third argument as a ret/n
 *   term.
 *   There is some complication with the inlining of builtins which
 *   perform trie-code-directed traversals.  Hence get_calls/1 is not
 *   inlined and we explicitly invoke the builtin call.
 */


'_$$get_calls'(CallTerm,Handle,Template) :-
	get_calls(CallTerm),
	get_lastnode_cs_retskel(CallTerm, _Leaf, Handle, Template).

/* 
 * the argument to the following findall is folded into the
 * predicate above so that get_lastnode_cs_retskel is inlined,
 * thus avoiding a GC between get_calls & get_lastnode_cs_retskel

The semantics of get_calls can be understood as follows: You can
assume that each call is stored in an "asserted" predicate, called
get_calls/3 in the form:

get_calls(Call,Ptr,VarsInCall)

Then a call to get_calls simply retrieves from this "stored" table as
usual.

For example, if a call of p(1,X,Y,X) were made to a tabled predicate
p/4, then there would be a fact in get_calls of:

get_calls(p(1,X,Y,X),12345,ret(X,Y)).

Now if we invoke get_calls(p(A,1,B,C),_,RET), it will succeed with
A=1, C=1, and RET=ret(1,B).

Not that if RET is most-general, then no variables in the current call
were instantiated and so it subsumes the call in the table.

 */


get_calls(CallTerm, Handle, Template) :-
%   writeln(get_calls(CallTerm, Handle, Template)),
	(CallTerm = M:Goal -> term_new_mod(M,Goal,NewGoal) ; CallTerm = NewGoal),
	findall('_$get_calls'(NewGoal,Handle,Template),
		'_$$get_calls'(NewGoal,Handle,Template),
		List),
%writeln(get_calls_1(CallTerm, List)),
	member('_$get_calls'(NewGoal,Handle,Template),List).


get_calls(_CallTerm) :- '_$builtin'(TRIE_UNIFY_CALL).


/*
 * get_calls_for_table(+PredSpec,?Call)
 *   The predicate information of PredSpec is used to identify the table
 *   from which all calls are enumerated through backtracking and
 *   unified with Call.  PredSpec can be the usual p/n form, or given as
 *   a term: p(t1,...,tn).
 */

get_calls_for_table(PredSpec,Call) :-
	( PredSpec = P/N
	 ->	functor(Call,P,N)
	 ; (PredSpec = M:Goal -> term_new_mod(M,Goal,PredSpec1) ; PredSpec = PredSpec1),
	   term_psc(PredSpec1,PSC),
	   term_new(PSC,Call)
	        %% functor(PredSpec,P,N), functor(Call,P,N) ),
	),
	get_calls(Call, _CallStr, _RetSkel).



/*
 * get_returns(+TableEntryHandle,#ReturnTemplate)
 * get_returns(+TableEntryHandle,#ReturnTemplate,-ReturnHandle)
 *   Backtrackable predicate for selecting returns which UNIFY with
 *   ReturnTemplate.  Selections are made via a trie-code-directed
 *   traversal of the Answer Trie (representation of the answer set)
 *   of the given table entry (subgoal frame reference).  For each
 *   successful unification, a handle to the return (as an answer trie
 *   node reference) is copied into the third argument.
 *   There is some complication with the inlining of builtins which
 *   perform trie-code-directed traversals.  Hence trie_get_return/2
 *   is not inlined and we explicitly invoke the builtin call.
 * 
 *   Note that trie_get_return will not affect the delay list (a C
 *   variable, delay_it, is set to ensure this).
 */

get_returns(TableEntry, ReturnTemplate) :-
	findall('_$get_returns'(TableEntry,ReturnTemplate),
		trie_get_return(TableEntry,ReturnTemplate),
		ReturnsList),
	% As ReturnTemplate may contain attributed variables (from the
	% call), which may have been changed in the answer, directly
	% calling member/2 may trigger attv interrupts.  To avoid this,
	% we need to change all attributed variables in ReturnTemplate
	% to free regular variables.
	change_attv_to_var(ReturnTemplate),
	member('_$get_returns'(TableEntry,ReturnTemplate),ReturnsList).


:- dynamic '_$return'/1.
:- index('_$return'/1,trie).

get_unifiable_returns(TableEntry,Skel, Leaf) :-
	\+ \+ (get_unifiable_returns_1(TableEntry, Skel, ReturnList),
	       ReturnList \== [],
	       t_assert_2('_$return'(ReturnList),_)),
	system_retract_fact('_$return'(ReturnList)),
%	    change_attv_to_var(ReturnTemplate),
	member('_$get_returns'(TableEntry,Leaf),ReturnList).
	
get_unifiable_returns_1(TableEntry, Skel, ReturnsList):- 
	findall('_$get_returns'(TableEntry,RetLeaf),
		'_$$get_returns'(TableEntry,Skel,RetLeaf),
		ReturnsList).

'_$$get_returns'(TableEntry,RetTmplt,RetLeaf) :-
	trie_get_return(TableEntry,RetTmplt),
	get_lastnode_cs_retskel(_,RetLeaf,_,_).
	
get_returns(TableEntry, RetTmplt, RetLeaf) :-
	findall('_$get_returns'(TableEntry,RetTmplt,RetLeaf),
		'_$$get_returns'(TableEntry,RetTmplt,RetLeaf),
		ReturnsList),
	member('_$get_returns'(TableEntry,RetTmplt,RetLeaf),ReturnsList).

/*
 * change_attv_to_var(+ReturnTemplate)
 *   Changes all the attributed variables in ReturnTemplate (ret/n) to
 *   regular variables.
 */
 
change_attv_to_var(ReturnTemplate) :-
	ReturnTemplate =.. [ret|Vars],
	change_attv_to_var1(Vars).

change_attv_to_var1([]).
change_attv_to_var1([V|Vs]) :-
	(is_attv(V)
	 ->	delete_attributes(V)
	 ;	true
	),
	change_attv_to_var1(Vs).	


trie_get_return(_TableEntryHandle,_ReturnTemplate) :-
	'_$builtin'(TRIE_GET_RETURN).


get_lastnode_cs_retskel(CallTerm, LastNode, SubgoalPtr, RetSkel) :-
	get_lastnode_cs_retskel(CallTerm, LastNode, SubgoalPtr, RetSkel).


/*
 * get_returns_for_call(+CallTerm,?AnswerTerm)
 *   Succeeds whenever CallTerm is a subgoal in the table and AnswerTerm
 *   unifies with one of its answers.  Backtracks through all unifying
 *   answers of CallTerm.
 */

get_returns_for_call(CallTerm,AnswerTerm) :-
	copy_term(CallTerm,Call),
	get_call(Call,SF,Return),	% vars of 'Call' are put into 'Return'
	get_returns(SF,Return),		% instantiate vars of 'Return', and
	AnswerTerm = Call.		%   hence of 'Call' as well


/*
 * get_residual(#CallTerm,?DelayList)
 */

get_residual(CallSkel, DelayList) :-
	get_calls(CallSkel, S, R),
	get_returns_and_dls(S, R, DLs),
	( DLs == [] -> DelayList = []
	; DLs = [DL] -> DelayList = DL
	; member(DelayList, DLs)
	).

variant_get_residual(CallSkel, DelayList) :-
	get_call(CallSkel, S, R),
	get_returns_and_dls(S, R, DLs),
	( DLs == [] -> DelayList = []
	; DLs = [DL] -> DelayList = DL
	; member(DelayList, DLs)
	).

'_$$get_returns_and_dls'(CallStr,RetSkel,DLs) :-
	trie_get_return(CallStr,RetSkel),
	get_lastnode_cs_retskel(_,Leaf,_,_),
	get_delay_lists(Leaf,DLs).
	
get_returns_and_dls(CallStr, RetSkel, DLs) :-
	'_$$get_returns_and_dls'(CallStr,RetSkel,DLs).
/*	findall('_$get_returns_and_dls'(CallStr,RetSkel,DLs),
		'_$$get_returns_and_dls'(CallStr,RetSkel,DLs),
		List),
	member('_$get_returns_and_dls'(CallStr,RetSkel,DLs),List).*/

get_delay_lists(Leaf, DLs) :- get_delay_lists(Leaf, DLs).

%------------

get_returns_and_tvs(TableEntry, ReturnTemplate,TV) :-
	findall('_$$get_returns_and_tvs'(TableEntry,ReturnTemplate,TV),
	        '_$$get_returns_and_tvs'(TableEntry,ReturnTemplate,TV),
	      	ReturnsList),
	% As ReturnTemplate may contain attributed variables (from the
	% call), which may have been changed in the answer, directly
	% calling member/2 may trigger attv interrupts.  To avoid this,
	% we need to change all attributed variables in ReturnTemplate
	% to free regular variables.
	change_attv_to_var(ReturnTemplate),
	member('_$$get_returns_and_tvs'(TableEntry,ReturnTemplate,TV),ReturnsList).

'_$$get_returns_and_tvs'(CallStr,RetSkel,TV) :-
	trie_get_return(CallStr,RetSkel),
	get_lastnode_cs_retskel(_,Leaf,_,_),
	is_conditional_answer(Leaf,IsCond),
	(IsCond = 1 -> TV = u ; TV = t).
	
'_$$get_returns_and_tvs'(CallStr,RetSkel,Leaf,TV) :-
	trie_get_return(CallStr,RetSkel),
	get_lastnode_cs_retskel(_,Leaf,_,_),
	is_conditional_answer(Leaf,IsCond),
	(IsCond = 1 -> TV = u ; TV = t).
	
is_conditional_answer(Leaf,IsCond):-
	table_inspection_function(IS_CONDITIONAL_ANSWER,Leaf,IsCond,_,_).

/*----------------------------------------------------------------------*/
/* Predicates to remove information from tables.			*/
/*----------------------------------------------------------------------*/

:- import reinitialize_undefineds/0 from xsbbrat.
%:- import current_prolog_flag/2 from curr_sym.
abolish_all_tables :- 
	   abolish_table_info,
	   reinitialize_undefineds.

abolish_table_pred(Spec,Options) :-
	check_nonvar(Spec,abolish_table_pred/2,1),
	(Spec = M:Goal -> 
	    (Goal = F/A -> functor(TermIn,F,A) ; TermIn = Goal),
	    term_new_mod(M,TermIn,Term)
	  ; (Spec = F/A -> functor(Term,F,A) ; Term = Spec)),
	check_abolish_options_list(Options,ActionType,abolish_table_pred/2),
	abolish_table_pred_bi(Term,ActionType).

abolish_table_pred(Spec) :- abolish_table_pred(Spec,[]).

/*
abolish_table_pred(Spec) :-
	check_nonvar(Spec,abolish_table_pred/1,1),
	(Spec = M:Goal -> 
	    (Goal = F/A -> functor(TermIn,F,A) ; TermIn = Goal),
	    term_new_mod(M,TermIn,Term)
	  ; (Spec = F/A -> functor(Term,F,A) ; Term = Spec)),
	abolish_table_pred_bi(Term,ABOLISH_TABLES_DEFAULT).
*/

abolish_table_pred_bi(_TIF,_Action) :-
	'_$builtin'(ABOLISH_TABLE_PREDICATE).

:- dynamic invalidate_table_for/2.
invalidate_tables_for(DynSkel,Mode) :-
	invalidate_table_for(DynSkel,Mode),
	fail.
invalidate_tables_for(_DynSkel,_).

abolish_module_tables(_Predicate) :-
	'_$builtin'(ABOLISH_MODULE_TABLES).

abolish_table_subgoals(Call,Options) :-
	check_abolish_options_list(Options,ActionType,abolish_table_subgoals/2),
	abolish_table_subgoals_internal(Call,ActionType).
abolish_table_subgoals(Call) :-
	abolish_table_subgoals_internal(Call,ABOLISH_TABLES_DEFAULT).

abolish_table_subgoal(Call,Options) :-
	check_abolish_options_list(Options,ActionType,abolish_table_subgoalb/2),
	abolish_table_subgoal_internal(Call,ActionType).
abolish_table_subgoal(Call) :-
	abolish_table_subgoal_internal(Call,ABOLISH_TABLES_DEFAULT).

check_abolish_options_list(Options,_ActionType,Pred):- 
	check_nonvar(Options,Pred,2),
	fail.
check_abolish_options_list([],ActionType,_Pred):- !,
	(var(ActionType) -> ActionType = ABOLISH_TABLES_DEFAULT ; true).
check_abolish_options_list([Option|_Rest],ActionType,Pred):- !,
	check_nonvar(Option,Pred,2),
	(Option = abolish_tables_transitively -> 
	    ActionType = ABOLISH_TABLES_TRANSITIVELY
	  ; (Option = abolish_tables_singly -> 
	       ActionType = ABOLISH_TABLES_SINGLY
	     ; domain_error([abolish_tables,transitively,
	                    abolish_tables_singly],Option,Pred,2,'') ) ).
check_abolish_options_list(Culprit,_ActionType,Pred):- 
	type_error(list,Culprit,Pred,2).

/* TLS: Action on call subsumption is to delete producer for consumer
   calls. get_calls/3 automatically finds all producers, so there is
   no action we need to take for consumer calls.

   Note that if tables are abolished transitively, a check needs to be
   made to determine whether the pointer to the unifying call still exists. */
abolish_table_subgoals_internal(Call,Action) :-
    check_cyclic(Call,'abolish_table_subgoals/1',1), 
    (Call = M:Goal -> term_new_mod(M,Goal,NewGoal) ; Call = NewGoal),
    current_prolog_flag(table_gc_action,GCAction),
    get_calls(NewGoal,Handle,_Template), 
    (GCAction = abolish_tables_transitively ->
      check_if_subgoal_still_exists(NewGoal,Handle) 
    ; true),
    table_state(Handle,_PredType,CallType,AnsSetStatus), 
    CallType \== subsumed, 
    ( AnsSetStatus == undefined -> 
      table_error(['abolishing undefined tabled call ',Call]) 
    ; AnsSetStatus == incomplete ->
      table_error(['abolishing incomplete tabled call ',Call])
    ; abolish_table_subgoal_bi(Handle,Action) ),
    fail.
abolish_table_subgoals_internal(_Call,_Action).

:- export check_if_subgoal_still_exists/2.
check_if_subgoal_still_exists(NewGoal,Handle):- 
      '_$$get_calls'(NewGoal,Handle1,_Template),
      Handle1 = Handle,
      !.

%---------
abolish_table_subgoal_internal(Call,Action) :-
    check_cyclic(Call,'abolish_table_subgoal/1',1), 
    (Call = M:Goal -> term_new_mod(M,Goal,NewGoal) ; Call = NewGoal),
    get_call(NewGoal,Handle,_Template), 
    table_state(Handle,_PredType,CallType,AnsSetStatus), 
    CallType \== subsumed, 
    ( AnsSetStatus == undefined -> 
      table_error(['abolishing undefined tabled call ',Call]) 
    ; AnsSetStatus == incomplete ->
      table_error(['abolishing incomplete tabled call ',Call])
    ; abolish_table_subgoal_bi(Handle,Action) ),!.
abolish_table_subgoal_internal(_Call,_Action).

abolish_table_subgoal_bi(_Handle,_Action) :-
	'_$builtin'(ABOLISH_TABLE_CALL).

abolish_nonincremental_tables(Option):- 
     ((Option = on_incomplete(X) ; Option = [on_incomplete(X)]) -> 
       (X = skip -> C_action = SKIP_ON_INCOMPLETE
        ; (X = error -> C_action = ERROR_ON_INCOMPLETE
           ; domain_error([skip,' error'],Option,abolish_nonincremental_tables,1,'') ) )
           ; domain_error([on_incomplete/1],Option,abolish_nonincremental_tables,1,'') ),
       table_inspection_function(ABOLISH_NONINCREMENTAL_TABLES,C_action,_Two,_Three,_Four).

:- export abolish_nonincremental_tables.
abolish_nonincremental_tables:- 
       table_inspection_function(ABOLISH_NONINCREMENTAL_TABLES,ERROR_ON_INCOMPLETE,_Two,_Three,_Four).

%:- export abolish_incremental_call_single/1.
%abolish_incremental_call_single(CallTerm):- 
%    get_call(CallTerm, Handle, _ReturnTemplate),
%    table_inspection_function(ABOLISH_INCREMENTAL_CALL_SINGLE,Handle,_Two,_Three,_Four).
    
/*
 * delete_return(+TableEntryHandle,+ReturnHandle)
 *   Deletes the return, referenced as a leaf of an answer trie, from
 *   the answer set in the table entry, referenced as a subgoal frame
 *   pointer.
 */

delete_return(TableEntryHandle,ReturnHandle) :-
	trie_delete_return(TableEntryHandle,ReturnHandle,ANSWER_SUBSUMPTION).

delete_return(SubgoalFrame,AnswerTrieLeaf,Type) :-
	trie_delete_return(SubgoalFrame,AnswerTrieLeaf,Type).

trie_delete_return(_SubgoalFrame,_AnswerTrieLeaf,_Type) :-
	'_$builtin'(TRIE_DELETE_RETURN).


/*----------------------------------------------------------------------*/
/* trie assert related predicates - I am not sure they are still needed */
/* probably kept just for backwards compatibility - Kostis.             */
/*----------------------------------------------------------------------*/

trie_dynamic(X) :- dynamic(X), add_trie_index(X).
trie_assert(Term) :- t_assert(Term, _Flag).
trie_assert(Term,Flag) :- t_assert(Term,Flag).
trie_retract(X) :- retract(X).
trie_retract_nr(X) :- retract_nr(X).
trie_retract_all(X) :- retractall(X).


/*======================================================================*/
/* builtins to get (and change) trie nodes - they belong somewhere else */
/*======================================================================*/

force_answer_true(Goal) :-
	findall(Leaf,get_leaves(Goal,Leaf),Leaves),
	(Leaves == []
	 ->	permission_error('True forcing','a false goal',Goal,(table)/1)
	 ;	(member(Leaf,Leaves),
		 force_truth_value(Leaf,'true'),
		 fail
		 ;
		 true
		)
	).

force_answer_false(Goal) :-
	findall(p(Leaf,DLs),get_leaves_and_dls(Goal,Leaf,DLs),Leaves),
	(member(p(Leaf,DLs),Leaves),
	 (DLs == []
	  ->	 permission_error('False forcing','a true goal',Goal,(table)/1)
	  ;	 force_truth_value(Leaf,'false'),
		 fail
		 ;
		 true
		)
	).

get_leaves(Goal,Leaf) :-
	get_calls(Goal,CallStr,RetSkel),
	trie_get_return(CallStr,RetSkel),
	get_lastnode_cs_retskel(_,Leaf,_,_).

get_leaves_and_dls(Goal,Leaf,DLs) :-
	get_calls(Goal,CallStr,RetSkel),
	trie_get_return(CallStr,RetSkel),
	get_lastnode_cs_retskel(_,Leaf,_,_),
	get_delay_lists(Leaf,DLs).

force_truth_value(AnsLeafNode,TruthValue) :-
	force_truth_value(AnsLeafNode,TruthValue).

predicate_has_tables(Psc):-
	table_inspection_function(GET_PRED_CALLTRIE_PTR,Psc,Ptr,_,_),
%	writeln(ptr(Ptr)),
	Ptr \== 0.

get_current_scc(SubgoalFrame,Number):-
	table_inspection_function(GET_CURRENT_SCC,SubgoalFrame,Number,_,_).

get_callsto_number(SubgoalFrame,Number):- 
	table_inspection_function(GET_CALLSTO_NUMBER,SubgoalFrame,Number,_,_).

get_answer_number(SubgoalFrame,Number):- 
	table_inspection_function(GET_ANSWER_NUMBER,SubgoalFrame,Number,_,_).

/* Purely for testing */
:- export subg_get_visitors_number/1.
:- import writeln/1 from standard.
subg_get_visitors_number(Subg):- 
	get_call(Subg, SubgoalFrame,_),
	get_visitors_number(SubgoalFrame,Number),
	writeln(visitors_nbr(Subg,Number)),
	fail.
subg_get_visitors_number(_Subg).

get_visitors_number(SubgoalFrame,Number):- 
	table_inspection_function(GET_VISITORS_NUMBER,SubgoalFrame,Number,_,_).

early_complete_on_nth(SubgoalFrame,Number):- 
	table_inspection_function(EARLY_COMPLETE_ON_NTH,SubgoalFrame,Number,_,_).

early_complete_on_delta(SubgoalFrame,New,Old,Epsilon):- 
	(New - Old < Epsilon ->
	    table_inspection_function(EARLY_COMPLETE,SubgoalFrame,_,_,_)
	 ;  true).

print_incomplete_tables:- 
	table_inspection_function(PRINT_COMPLETION_STACK,-1,_,_,_).

print_incomplete_tables(Stream):- 
	check_open_stream_or_alias(Stream,print_incomplete_tables/1,1,output,Stream1),
	table_inspection_function(PRINT_COMPLETION_STACK,Stream1,_,_,_).

get_scc_dumpfile(F):- 
	table_inspection_function(GET_SCC_DUMPFILE,F,_,_,_).

check_variant(Term):- 
	table_inspection_function(CHECK_VARIANT,Term,0,_,_).

check_variant(Term,DontCares):- 
	table_inspection_function(CHECK_VARIANT,Term,DontCares,_,_).

:- export set_tif_property/3, get_tif_property/3.

get_tif_property(Term,Property,Value):- 
	tif_translate(Property,Prop),
	table_inspection_function(GET_TIF_PROPERTY,Term,Prop,Value,_).

set_tif_property(Term,Property,Value):- 
	tif_translate(Property,Prop),
	table_inspection_function(SET_TIF_PROPERTY,Term,Prop,Value,_).

tif_translate(subgoal_depth,SUBGOAL_DEPTH).
tif_translate(answer_depth,ANSWER_DEPTH).
tif_translate(intern,INTERNING_GROUND).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Forest Logging
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
:- import ensure_loaded/1 from consult.

log_all_forest_start :-
	start_forest_view(userout).

log_all_forest_start(Options):- 
	check_log_forest_options(Options,File),
	start_forest_view(File).

%% it is defined to stop log forest, since we have no Call passed in
%% it is necessary in order to stop it
log_all_forest_end :-
	stop_forest_view.

log_forest(Call):- 
	start_forest_view(userout),
	call(Call),
	stop_forest_view.

log_forest(Call,Options):- 
	check_log_forest_options(Options,File),
	start_forest_view(File),
	call(Call),
	stop_forest_view.

check_log_forest_options(Options,_File):- 
	check_nonvar(Options,log_forest/2,2),
	fail.
check_log_forest_options([],File):-
	(var(File) -> File = userout ; true).
check_log_forest_options([Option|_Rest],File):- !,
	check_nonvar(Option,log_forest/2,2),
	(Option = file(LogFile) -> File = LogFile
	     ; domain_error([file/1],Option,log_forest/2,2,'') ).
check_log_forest_options(Culprit,_File):- 
	type_error(list,Culprit,log_forest/2,2).

start_forest_view(File):-
	table_inspection_function(START_FOREST_VIEW,File,_,_,_),
	set_prolog_flag(backtrace_on_error,off),
	set_prolog_flag(ctrace,on).

stop_forest_view:-
	table_inspection_function(STOP_FOREST_VIEW,_,_,_,_),
	set_prolog_flag(ctrace,off),
	set_prolog_flag(backtrace_on_error,on).

set_forest_logging_for_pred(PredSpec,Val):- 
 	  (PredSpec = Mod:PredSpec1  -> 
             (PredSpec1 = F/A -> functor(TermIn,F,A) ; TermIn = PredSpec1),
	     term_new_mod(Mod,TermIn,Term)
	  ; 
          (PredSpec = F/A -> functor(Term,F,A) ; Term = PredSpec)),
          term_psc(Term,PSC),
	  (Val = on -> Num = 0
	   ; Val = off -> Num = 1
	   ; domain_error((on,off),Val,set_forest_logging_for_pred/2,1) ),
          table_inspection_function(SET_FOREST_LOGGING_FOR_PRED,PSC,Num,_,_),
	  !.
set_forest_logging_for_pred(PredSpec,_Val):- 
	type_error(predicate_or_term_indicator,PredSpec,set_forest_logging_for_pred/2,1).

load_forest_log(File):- 
	ensure_loaded(term_abstract),
	dynamic(pus_smpl/4), 	dynamic(puc_smpl/5), 
	dynamic(ns_smpl/3),	dynamic(nf_smpl/3),
	dynamic(cmp/3),
	dynamic(del/3),
	dynamic(nc/4),
	dynamic(ar/4),	dynamic(dar/4),
	dynamic(na/3),	dynamic(nda/4),
	index(tc/4,[*(1),*(2)]),
	index(nc/4,[*(1),*(2)]),
	index(na/3,[2]),
	index(nda/4,[2]),
	index(ar/4,[2,3]),
	index(dar/4,[2,3]),
	index(ta/2,[1,2]),
%	index(cmp/3,[*(1),2]),
	index(cmp/3,trie),
	load_dync(File,a).

:- import tc/4, cmp/3, nc/4, del/3  from usermod.
:- import ns_smpl/3, nf_smpl/3, pus_smpl/4, puc_smpl/5 from usermod.
:- import na/3, nda/4 from usermod.

forest_log_overview:- 
	total_subgoals(TotSubg),total_sccs(TotSCCs),
	format("There were ~1D subgoals in ~1D (completed) SCCs.~n",[TotSubg,TotSCCs]),
	count_ecs(Len),
	format("   ~1D subgoals were early-completed.~n",[Len]),
	total_noncompleted_subgoals(NonComp),
	format("   ~1D subgoals were not completed in the log.~n",[NonComp]),
	count_pos_calls(Calls,New,Incomplete,Completed),
	format("   There were a total of ~1D positive tabled subgoal calls:~n",[Calls]),
	format("      ~1D were calls to new subgoals~n",[New]),
	format("      ~1D were calls to incomplete subgoals~n",[Incomplete]),
	format("      ~1D were calls to complete subgoals~n",[Completed]),
	count_neg_calls(NCalls,NNew,NIncomplete,NCompleted),
	format("   There were a total of ~1D negative tabled subgoal calls:~n",[NCalls]),
	format("      ~1D were calls to new subgoals~n",[NNew]),
	format("      ~1D were calls to incomplete subgoals~n",[NIncomplete]),
	format("      ~1D were calls to complete subgoals~n",[NCompleted]),
	count_delays_and_simpls(NDelays,NSimpl),
	format("There were a total of ~1D negative delays~n",[NDelays]),
	format("There were a total of ~1D simplifications~n",[NSimpl]),
	count_answers(NU,NC),
	format("There were a total of ~1D unconditional answers derived:~n",[NU]),
	format("There were a total of ~1D conditional answers derived:~n",[NC]),
	nl,
	report_sccs.

:- export forest_log_overview_1/1.
forest_log_overview_1(CondLen):-
	findall(1,unsimplified(_A,_B), Conds),
	length(Conds,CondLen).

three_valued_sccs(L):-
	setof(Scc,B^S^S1^Ct^(unsimplified(B,S),cmp(S1,Scc,Ct),variant(S,S1)),L).

unsimplified(_Binding,Subgoal):- 
	del(Subgoald,_caller,_DelCtr),
	nda([],Subgoal,_Delays,Ctr),
	variant(Subgoald,Subgoal),
	\+ (	na([],Subgoal1,Ctr1),
		Ctr1 > Ctr,
%		variant(Binding,Binding1),
		variant(Subgoal,Subgoal1) ).

count_pos_calls(Calls,New,Incomplete,Complete):- 
	findall(1,tc(_,_,_,_),CallList),length(CallList,Calls),
	findall(1,tc(_,_,new,_),NewList),length(NewList,New),
	findall(1,tc(_,_,incmp,_),IncmpList),length(IncmpList,Incomplete),
	findall(1,tc(_,_,cmp,_),CmpList),length(CmpList,Complete).

count_neg_calls(Calls,New,Incomplete,Complete):- 
	findall(1,nc(_,_,_,_),CallList),length(CallList,Calls),
	findall(1,nc(_,_,new,_),NewList),length(NewList,New),
	findall(1,nc(_,_,incmp,_),IncmpList),length(IncmpList,Incomplete),
	findall(1,nc(_,_,cmp,_),CmpList),length(CmpList,Complete).

count_ecs(Len):- 
	findall(1,cmp(_,ec,_),L),
	length(L,Len).

total_sccs(N):-
	setof(SCC,Term^Ctr^(cmp(Term,SCC,Ctr),SCC \= ec),SCClist),!,
	length(SCClist,N).
total_sccs(0).

total_subgoals(N):-
	setof(Ctr,Term^SCC^(cmp(Term,SCC,Ctr),SCC \= ec),Goallist),
	length(Goallist,N),!.
total_subgoals(0).

total_noncompleted_subgoals(N):- 
	cmp_defined,
	setof(Ctr1,S1^S2^_SCC^_Ctr2^((tc(S1,S2,new,Ctr1) ; nc(S1,S2,new,Ctr1)),
	                 \+ check_variant(cmp(S1,_SCC,_Ctr2),2)),GoalList),!,
	length(GoalList,N).
total_noncompleted_subgoals(N):- 
	\+ cmp(_,_,_),
	setof(Ctr1,S1^S2^((tc(S1,S2,new,Ctr1) ; nc(S1,S2,new,Ctr1))),GoalList),
	length(GoalList,N).
total_noncompleted_subgoals(0).

cmp_defined:- cmp(_,_,_),!.

count_delays_and_simpls(LenD,LenS):- 
	findall(1,del(_,_,_),LD),	length(LD,LenD),
	findall(1,some_simplification(_) ,LS),
	length(LS,LenS).

some_simplification(Ctr):- ns_smpl(_,_,Ctr).
some_simplification(Ctr):- nf_smpl(_,_,Ctr).
some_simplification(Ctr):- pus_smpl(_,_,_,Ctr) .
some_simplification(Ctr):- puc_smpl(_,_,_,_,Ctr).

count_answers(LenU,LenC):- 
	findall(1,na(_,_,_),LU),
	length(LU,LenU),
	findall(1,nda(_,_,_,_) ,LC),
	length(LC,LenC).

%----------------

report_sccs:- 
	setof(scc(Len,SCC),get_scc_length(SCC,Len),SCCs),
	bagof(SCC,member(scc(Len,SCC),SCCs),LenList),
	length(LenList,Length),
	write('Number of SCCs with '),write(Len),write(' subgoals is '),writeln(Length),
%	writeln(scc(Len,Length)),
	fail.
report_sccs.

get_scc_length(SCC,Len):- 
	bagof(Goal,Ctr^(cmp(Goal,SCC,Ctr),SCC \== ec),Goals),
	length(Goals,Len).
%	writeln(scc(SCC,Len)),
%	fail.

%----------------

analyze_an_scc(Scc,File):-
	count_subgoals_in_scc(Scc,Subgoals),
	count_backlinks_in_scc(Scc,Links,Ninks),
	TotLinks is Subgoals+Links+Ninks-1,
	Density is (Subgoals+Links)/Subgoals,
	format("There are ~1D subgoals and ~1D links (average of ~f edges per subgoal) within the SCC~n",
		[Subgoals,TotLinks,Density]),
	count_delays(Scc,Delays),
	format("There are ~1D negative edges resulting in ~1D delays and 0 simplifications~n",
		[Ninks,Delays]),
	nl,count_preds(Scc),
	nl,report_links(Scc,File).

count_delays(Scc,Len):- 
	findall(1,scc_has_delay(Scc),List),
	length(List,Len).

scc_has_delay(Scc):- 
	del(_Called,Caller,_Ctr),
	check_variant(cmp(Caller,Scc,_Ctr1),1).

analyze_an_scc(Scc,File,Abstraction):-
	count_subgoals_in_scc(Scc,Subgoals),
	count_backlinks_in_scc(Scc,Links,Ninks),
	Density is (Subgoals+Links)/Subgoals,
	format("There are ~1D subgoals and ~1D links (average of ~f edges per subgoal) within the SCC~n",
		[Subgoals,Links,Density]),
	format("There are ~1D negative edges resulting in 0 delays and 0 simplifications~n",
		[Ninks]),
	nl,count_preds(Scc,Abstraction),
	nl,report_links(Scc,File,Abstraction).

count_subgoals_in_scc(Scc,Num):-
	findall(1,cmp(_T,Scc,_),Ones),
	length(Ones,Num).

count_backlinks_in_scc(SCC,Lnum,Nnum):-
	findall(1,backlink_in_scc(_,SCC),Links),
	findall(1,negbacklink_in_scc(_,SCC),Ninks),
	length(Links,Lnum),
	length(Ninks,Nnum).

backlink_in_scc(T1,Scc):- 
	(tc(T1,_T2,incmp,_) ; nc(T1,_T2,incmp,_)),check_variant(cmp(T1,Scc,_),1).
negbacklink_in_scc(T1,Scc):- 
	nc(T1,_T2,State,_),State \== cmp, check_variant(cmp(T1,Scc,_),1).

%----------------

count_preds(S):- 
	setof(pred(C,P),count_preds_1(S,P,C),Preds),
	member(pred(C,P),Preds),
	format("There are ~1D subgoals in the SCC for the predicate ",[C]),
	P = F/A,
	write(F),write('/'),writeln(A),
%	writeln(Thre are pred(P,C)),
	fail.
count_preds(_).

count_preds(S,Abstraction):- 
	setof(pred(C,P),count_preds_1(S,P,C,Abstraction),Preds),
	member(pred(C,P),Preds),
	format("There are ~1D subgoals in the SCC for the predicate ~q~n",[C,P]),
	fail.
count_preds(_,_).

count_preds_1(S,F/A,C):- 
	bagof(F1/A1,Term^Ctr^(cmp(Term,S,Ctr), 
  	             get_functor(Term,F/A),
		     F1 = F,A1 = A),
	        Fs),
	length(Fs,C).

count_preds_1(S,New,C,Abstraction):- 
	bagof(New1,Term^Ctr^(cmp(Term,S,Ctr), 
	                     abstract_term(Term,New,Abstraction),
	                     New = New1),
	      As),
	length(As,C).

abstract_term(Term,Abs,Abstraction):-
	copy_term(Abstraction,Abstraction1),
	arg(1,Abstraction1,Term),
	call_c(usermod:Abstraction1),
	arg(2,Abstraction1,Abs).

%----------------

report_links(S,File):-
	bagof(Link,count_links_1(S,Link),List),
	parsort(List,[asc(1),asc(2)],0,List1),
	count_occs(List1,Occs),
	report_links_1(Occs,File).

report_links(S,File,Abstraction):-
	bagof(Link,count_links_1(S,Link,Abstraction),List),
	parsort(List,[asc(1),asc(2)],0,List1),
	count_occs(List1,Occs),
	report_links_1(Occs,File).

report_links_1(Occs,File):-
	tell(File),
	(  member((From,To)-Count,Occs),
	   write('Calls from '),write(From),write(' to '),write(To),
	   format(" : ~1D~n",[Count]),
	   fail
	 ; 
	   true),
	told.

count_links_1(S,(F1/A1,F2/A2)):- 
	(tc(T1,T2,State,_Ctr),State \= cmp ; nc(T1,T2,State,_Ctr),State \= cmp),
	check_variant(cmp(T1,S,_),1),
	check_variant(cmp(T2,S,_),1),
	get_functor(T1,F1/A1),
	get_functor(T2,F2/A2).

count_links_1(S,(Abstr1,Abstr2),Abstraction):- 
	(tc(T1,T2,State,_Ctr),State \= cmp ; nc(T1,T2,State,_Ctr),State \= cmp),
	check_variant(cmp(T1,S,_),1),
	check_variant(cmp(T2,S,_),1),
	copy_term(Abstraction,Abstraction1),
	copy_term(Abstraction,Abstraction2),
	abstract_term(T1,Abstr1,Abstraction1),
	abstract_term(T2,Abstr2,Abstraction2).
/*
	arg(1,Abstraction1,T1),
	call_c(usermod:Abstraction1),
	arg(2,Abstraction1,Abstr1),
	arg(1,Abstraction2,T2),
	call_c(usermod:Abstraction2),
	arg(2,Abstraction2,Abstr2).
*/


count_occs(L,[H-Occs|Rest]):-
	count_occs_1(L,Rem,H,Occs),
	(Rem = [] -> 
		Rest = []
	     ;  count_occs(Rem,Rest)).
	
count_occs_1(L,Rem,H,Occs):-
	L = [H|T],
	count_occs_2(T,H,Rem,1,Occs).

count_occs_2([],_H,[],Occs,Occs):- !.
count_occs_2([H|T],H,Rem,OccsIn,Occs):-!,
	OccsMid is OccsIn + 1,
	count_occs_2(T,H,Rem,OccsMid,Occs).
count_occs_2(L,_H,L,Occs,Occs).

%----------------
% Including some very simple flora translations.

get_functor(T,F/Outarg):-
        functor(T, '_$_$_flora''mod''main''tblflapply',_Arg),!,
	term_arg(T,1,F),
	term_arg(T,2,App),
%	arg(1,T,F),
%	arg(2,T,App),
	nonvar(App),functor(App,_,Outarg).
get_functor(T,F/Arg):-
        functor(T,F,Arg).

%--------------------------------------------------------------------------------
:- export get_residual_sccs/3.
get_residual_sccs(Call,Answer,Scc):-
	get_answer_leaf(Call,Answer,AnsLeaf),
	get_residual_sccs_1(AnsLeaf,Scc_1),
	process_sccs(Scc_1,Scc).

:- export get_residual_sccs/5.
get_residual_sccs(Call,Answer,Scc,Deps,Signs):-
	get_answer_leaf(Call,Answer,AnsLeaf),
	get_residual_sccs_1(AnsLeaf,Scc_1),
	process_sccs(Scc_1,Scc),
	get_scc_dependency_structure(Scc_1,Deps,Signs).

%---------------

get_residual_sccs_1(AnsLeaf,Scc):-
	abolish_table_pred(trans_ans_depends_ptr(_,_)),
%	setof(P,(trans_ans_depends_ptr(AnsLeaf,P) ; P = AnsLeaf),Ptrs),
	setof(P,trans_ans_depends_ptr(AnsLeaf,P),Ptrs),
%	writeln(ptrs(Ptrs)),
	table_inspection_function(GET_RESIDUAL_SCCS, Ptrs, Scc,_,_).

/*
process_sccs([],[]).
process_sccs([ret(Subgoal,Ptr,Comp)|T],[ret(Subgoal,Ans,Comp)|T1]):- 
        (Ptr == 0 -> 
	    Ans = Ptr
	 ; process_scc_node(Subgoal,Ptr,Ans)),
	 process_sccs(T,T1).
*/

process_sccs([],[]).
process_sccs([ret(Subgoal,Ptr,Comp)|T],[ret(Subgoal,Ans,Comp)|T1]):- 
        (Ptr == 0 -> 
	    Ans = Ptr
%	 ; true),
	 ; process_scc_node(Subgoal,Ptr,Ans)),
	 process_sccs(T,T1).

%------

get_scc_dependency_structure(List,Depends,Signs):- 
%	writeln(list(List)),
	partition_list(List,PartList),
%	writeln(pl(PartList)),
	scc_depends(PartList,Depends,[],Signs).

partition_list(List,PartList):- 
%	setof(ret(Index,Ans),Subgoal^member(ret(Subgoal,Ans,Index),List),Parts),
	reverse_partition(List,Parts_dup),
	sort(Parts_dup,Parts),
	partition_list_1(Parts,PartList).

reverse_partition([],[]).
reverse_partition([ret(_S,A,I)|T],[ret(I,A)|T1]):- 
	reverse_partition(T,T1).

partition_list_1([],[]).
partition_list_1([ret(N,S)|IRest],[List|ORest]):-
	partition_list_2([ret(N,S)|IRest],N,List,IRest1),
	partition_list_1(IRest1,ORest).
	
partition_list_2([],_N,[],[]).
partition_list_2([ret(N,S)|R],N,[ret(N,S)|NR],RestOut):- !,
	partition_list_2(R,N,NR,RestOut).
partition_list_2([ret(M,S)|R],_N,[],[ret(M,S)|R]).

scc_depends([Scc],In,In,[sign(Comp,Sign)]):- 
	scc_self_depends(Scc,Comp,Sign),!.
scc_depends([SCC|Rest],In,Out,[Sign|R]):- 
	scc_depends_1(Rest,SCC,In,Mid,Sign),
%	writeln(scc_depends(Rest,Mid,Out)),
	scc_depends(Rest,Mid,Out,R).

scc_depends_1([],Scc,In,In,sign(Comp,Sign)):- 
	scc_self_depends(Scc,Comp,Sign),!.
scc_depends_1([Scc1|R],Scc2,In,Out,Sign):-
	(scc_depends_2(Scc1,Scc2,Depends) -> 
	    In = [Depends|Mid1] 
	  ; (scc_depends_2(Scc2,Scc1,Depends1) -> In = [Depends1|Mid1] ; In = Mid1) ),
	scc_depends_1(R,Scc2,Mid1,Out,Sign).

scc_depends_2(SCC1,SCC2,depends(Comp1,Comp2)):-
	member(ret(Comp1,AnsPtr),SCC1),
%	writeln(ret(Comp1,AnsPtr)),
	AnsPtr \== 0,  % TLS: fix
	table_inspection_function(IMMED_ANS_DEPENDS_PTRLIST, AnsPtr, PtrList,_,_),
	member(ret(AnsPtr1,_),PtrList),
	member(ret(Comp2,AnsPtr1),SCC2).

scc_self_depends(SCC,Comp,neg):- 
	member(ret(Comp,AnsPtr),SCC),
%	writeln(ret(Comp,AnsPtr)),
	AnsPtr \== 0,  % TLS: fix
	table_inspection_function(IMMED_ANS_DEPENDS_PTRLIST, AnsPtr, PtrList,_,_),
	member(ret(AnsPtr1,IS_SUBGOAL_FRAME),PtrList),
	member(ret(_Comp,AnsPtr1),SCC),
	!.
scc_self_depends(SCC,Comp,no_neg):-
	member(ret(Comp,_AnsPtr),SCC),!.

%---------------

process_scc_node(Goal,Leaf,G):-
	copy_term(Goal,G),
	get_call(G,SF,Template),
	get_returns(SF,Template,L),
	L = Leaf.

:- export get_answer_dependencies/3.
get_answer_dependencies(Call,Answer,Ptr):-
	get_answer_leaf(Call,Answer,AnsLeaf),
%	immed_ans_depends_ptr(AnsLeaf,Ptr).
	trans_ans_depends_ptr(AnsLeaf,Ptr).

:- export trans_ans_depends_ptr/2.
:- import (table)/1 from standard.
:- table trans_ans_depends_ptr/2 as variant.
trans_ans_depends_ptr(CallPtr1,CallPtr2):-
	immed_ans_depends_ptr(CallPtr1,CallPtr2).
trans_ans_depends_ptr(CallPtr1,CallPtr2):-
	trans_ans_depends_ptr(CallPtr1,CallPtr3),
	immed_ans_depends_ptr(CallPtr3,CallPtr2).

:- export immed_ans_depends_ptr/2.	
immed_ans_depends_ptr(Ptr,Ptr2):-
	table_inspection_function(IMMED_ANS_DEPENDS_PTRLIST, Ptr, PtrList,_,_),
	member(ret(Ptr2,_),PtrList).		

get_answer_leaf(Call,Answer,AnsLeaf):-
	copy_term(Call,Call1),
	get_call(Call1,SF,Return),	
	get_returns(SF,Return,AnsLeaf),
%	writeln((Call,Call1)),
	Answer = Call1.

%--------------------------

:- export explain_u_val/3,explain_u_val/7.
:- import brat_undefined/0 from xsbbrat.

explain_u_val(Subgoal,Ans,Type):-
	get_residual_sccs(Subgoal,Ans,Sccs,Deps,Signs),
%	writeln(scc(Subgoal,Ans,Sccs,Deps,Signs)),
	subgoal_scc_member(Sccs,Subgoal,Index),
	explain_u_val(Subgoal,Ans,Sccs,Deps,Signs,Index,Type).

explain_u_val(_Subgoal,_Ans,Sccs,_Deps,_Signs,_Index,unsafe_negation):-
	memberchk(ret(floundered_undefined(_),_,_),Sccs).
explain_u_val(_Subgoal,_Ans,Sccs,_Deps,_Signs,_Index,radial_restraint):-
	memberchk(ret(brat_undefined,_,_),Sccs).
explain_u_val(_Subgoal,_Ans,_Sccs,_Deps,Signs,Index,negative_loops(cycle)):-
	memberchk(sign(Index,neg),Signs).
explain_u_val(_Subgoal,_Ans,_Sccs,_Deps,Signs,Index,negative_loops(dependent)):-
	memberchk(sign(I,neg),Signs),I \== Index.

:- import variant/2 from subsumes.
subgoal_scc_member([],_Subgoal,-1). % -- want to succeed with non-matching index.
subgoal_scc_member([ret(S,_,Index)|_],Subgoal,Index):- 
	variant(S,Subgoal),!.
subgoal_scc_member([_|R],Subgoal,Index):- 
	subgoal_scc_member(R,Subgoal,Index).

/* Deprecated (but maintained for backwards compatability) */

abolish_table_call(Term,Options) :-
	abolish_table_subgoals(Term,Options).
abolish_table_call(Term) :-
	abolish_table_subgoals(Term).

%------------------------------------------------------------------------------
end_of_file.

:- export explain_u_val/4.
:- import brat_undefined/0 from xsbbrat.
explain_u_val(Call,Answer,Reason,Type):-
	get_answer_leaf(Call,Answer,AnswerLeaf),
%	brat_undefined,
	get_answer_leaf(brat_undefined,brat_undefined,BratLeaf),
	writeln(bl(BratLeaf)),
	floundered_undefined(a),
	get_answer_leaf(floundered_undefined(a),floundered_undefined(a),FlounderedLeaf),
	writeln(fl(FlounderedLeaf)),
	(trans_ans_depends_ptr(AnswerLeaf,_),fail ; true),
	get_call(trans_ans_depends_ptr(AnswerLeaf,_),SF,_Return),	
	explain_u_val_1(SF,BratLeaf,FlounderedLeaf,AnswerLeaf,Reason,Type).

explain_u_val_1(SF,BratLeaf,_FlounderedLeaf,_AnswerLeaf,bounded_rationality,_Type):- 
	get_returns(SF,ret(BratLeaf),_AnsLeaf).
explain_u_val_1(SF,_BratLeaf,FlounderedLeaf,_AnswerLeaf,floundered,_Type):- 
	get_returns(SF,ret(FlounderedLeaf),_AnsLeaf).
%explain_u_val_1(SF,BratLeaf,FlounderedLeaf,AnswerLeaf,negative_loops,Type):- 

/* ---------------------- end of file tables.P ------------------------ */
/* 07/05/01  -- work area for functions under development */

find_components(Call):- 
	get_call(Call,CallStr,Return),	% vars of 'Call' are put into 'Return'
	trie_get_return(CallStr,Return),
	get_lastnode_cs_retskel(_,Leaf,_,_),
	table_inspection_function(FIND_COMPONENTS,Leaf,_,_,_).

find_forward_dependencies(Call):- 
	get_call(Call,CallStr,Return),	% vars of 'Call' are put into 'Return'
	trie_get_return(CallStr,Return),
	get_lastnode_cs_retskel(_,Leaf,_,_),
	table_inspection_function(FIND_FORWARD_DEPENDENCIES,Leaf,_,_,_).

find_answers(Pred):- 
	table_inspection_function(FIND_ANSWERS,Pred,_,_,_).

print_ls :- table_inspection_function(PRINT_LS,_,_,_,_).
print_tr :- table_inspection_function(PRINT_TR,_,_,_,_).
print_heap(X,Y) :- table_inspection_function(PRINT_HEAP,X,Y,_,_).
print_cp(_Title) :-table_inspection_function(PRINT_CP,Title,_,_,_).
print_regs :- table_inspection_function(PRINT_REGS,_,_,_,_).
print_all_stacks :- table_inspection_function(PRINT_ALL_STACKS,_,_,_,_).

/* Right now, experimental for aggregs.P */
	

:- dynamic '_$return'/1.
:- index('_$return'/1,trie).


get_unifiable_returns(TableEntry,Skel, Leaf) :-
	\+ \+ (get_unifiable_returns_1(TableEntry, Skel, ReturnList),
	       ReturnList \== [],
	       t_assert_2('_$return'(ReturnList),_)),
	system_retract_fact('_$return'(ReturnList)),
%	    change_attv_to_var(ReturnTemplate),
	member('_$get_returns'(TableEntry,Leaf),ReturnList).
	
get_unifiable_returns_1(TableEntry, Skel, ReturnsList):- 
	findall('_$get_returns'(TableEntry,RetLeaf),
		'_$$get_returns'(TableEntry,Skel,RetLeaf),
		ReturnsList).


/*
 * For [temporary] backward compatibility, redefine table_state/2 in
 * terms of the newer table_state/4.
 */

table_state(Call, State) :-
	table_state(Call, PredType, _CallType, AnsSetStatus),
	(PredType == variant
         -> ( AnsSetStatus == undefined
             -> State = no_call_yet
	     ;  State = AnsSetStatus )
	 ; PredType == undefined -> State = undef
        )
