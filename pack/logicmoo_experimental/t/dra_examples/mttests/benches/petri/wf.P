/* CPN tools. */

p19_gen(1).
p19_gen(2).
p19_gen(3).

t31_gen(4).

cond1(1).
cond1(3).

t33_cond(2).

recurse(X):- atomic(X),!.
recurse(o(X,_)):- atomic(X),!.
recurse(o(o(X,_),_)):- atomic(X),!.

t69_cutoff(2).

:- dynamic structloop/0.
structloop_cond:- structloop -> retractall(structloop) ; assert(structloop).

/* simple and multi merge are the same from CEPN perspective.  Also,
  CPNs automatically provide for 
     11) Implicit termination automatically
     12) mult. instances  w.o. synch

% Not on first pass:
  23) transient trigger
  24) persistent trigger
% 39) Critical Section: Not modelling threads on first pass
%     (i.e. vacuously true) 
% 41) Thread Split
% 42) Thread Merge
*/
:- index(rule/5,2).

/* Object and instance convention:

   Im assuming that an object (workflow instance) has an integer
   identifier N, and that subinstances are of the form o(N,M) where M
   is either a new integer instance identifier, or is a subinstance.
   E.g. if 1 is an instance, o(1,1) is the first subinstance of 1,
   o(1,o(1,2)) the second s.i. of the first s.i. of 1 and so on.
   Below, I sometimes write the patterns with instances and sometimes
   with subinstances.  Note that if there are a finite number of
   instances each of which have a finite number of subinstances, our
   model will be finite.

   Of course, actual instances in a HWF would be less abstract, but
   the idea of reflecting subinstance relations in the term structure
   is certainly doable.
*/

rule(t1,init(X),[],[p1(X)],dyn([],[])).
rule(t2,p1(X),[],[p2(X)],dyn([],[])).           % 4) exclusive choice
rule(t3,p1(X),[],[p3(X)],dyn([],[])).

rule(t4,p2(X),[],[p4(X),p5(X)],dyn([],[])).        % 2) parallel split, branch 1
rule(t5,p4(X),[],[p6(X)],dyn([],[])).
rule(t6,p5(X),[],[p7(X)],dyn([],[])).
rule(t7,p6(X),[p7(X)],[p8(X)],dyn([],[])).         % 3) synchronization, branch 1

rule(t8,p3(X),[],[p9(X),p10(X)],dyn([],[])).       % 2) parallel split, branch 2
rule(t9,p9(X),[],[p11(X)],dyn([],[])).
rule(t10,p10(X),[],[p12(X)],dyn([],[])).
rule(t11,p11(X),[p12(X)],[p13(X)],dyn([],[])).     % 3) synchronization, branch 2
rule(t14,p8(X),[],[p14(X)],dyn([],[])).            % simple/multi merge
rule(t13,p13(X),[],[p14(X)],dyn([],[])).

rule(t15,p14(X),[],[p1(X)],dyn([],[])).       % 10) arbitrary cycle

% 13) mult. instances  w. design knowl 
rule(t16,p14(X),[],[p15(o(X,p14_1)),p15(o(X,p14_2)),p15(o(X,p14_3))],dyn([],[])).
rule(t17,p15(X),[],[p16(X)],dyn([],[])).
rule(t18,p16(o(X,p14_1)),[p16(o(X,p14_2)),p16(o(X,p14_3))],[p17(X)],dyn([],[])).

%Sequential Version.
% 14) mult. instances  w. run time knowledge
/* Here, t20 indicates that when there is a token X in p18, it will be
   removed and the dynamic effect insert(p19(o(X,I)),p19_gen(I)) will
   be applied.  This effect will add subinstances of X, denoted as
   o(X,I) to p19.  Bindings for I are generated by p19_gen(I) which,
   in this simple example,  generates I = 1,2,3.

   In this model Im trying to abstractly capture a situation in which
   we dont know how many, or what, subinstances of X will be created.
   It requires run-time kowledge, reflected in the call to p19_gen/1.
   In a real WF, p19_gen/1 would be a call to a DB or ontology.
*/
rule(t19,p17(X),[],[p18(X)],dyn([],[])).
rule(t20,p18(X),[],[],dyn([],[insert(p19(o(X,I)),p19_gen(I))])).

% 7) structured synchronizing merge -- once all instances get to p20,
%    delete them and go to p21.

/* Here, the second argument concession indicates that one instance of
   X has reached p20.  It doesnt matter which one, as all of the X
   subinstances will be deleted.  However, there is another condition,
   modeled as a dynamic constraint that there are no tokens in p19
   that unify with o(X,_) -- i.e. anything in p19 is an instance of
   some other object.  So if the input (second-argument) concession
   holds and the constraint holds and the output concession holds,
   then the rule can fire placing X in p21 but also getting rid of any
   token in p20 that unifies with o(X,_) */

rule(t21,p19(X),[],[p20(X)],dyn([],[])).
rule(t22,p20(o(X,_)),[],[p21(X)],dyn([doesnt_contain(constr(p19(o(X,_)),true))],
	                             [delete(p20(o(X,_)))])).

% 9) structured discriminator w. reset.  

/* Rule t23 and t24 are simple setups.  t25 allows the first instance
   of X in p23 to go to p24.  "First" is checked by the dynamic
   constraint that the net doesnt contain a token X in p23r (for p23
   reset).  If there is an o(X,_) token in p23, but p23r has an X
   token then simply remove the o(X,_Y) token from p23.  The reason I
   used contains(constr(p23r(X),true) is because I want p23r(X) to
   persist after the rule fires.  Had I put p23r(X) in the output
   concession (arg 4) it would be automatically removed via the
   semantics of elementary color nets.  

   Finally, when we arrive at the situation where there is an X token
   in p23r, but there is no longer an X token in p22 we can reset p23
   -- by removing X from p23r.  And I found what looks like a bug -- I
   should have checked for no X token in p23 as well as in p22.

   In this whole affair, Ive understood that the structured
   discriminator applies to a branching that involves p22 and p23 --
   this is obtained as static information.
*/

rule(t23,p21(X),[],[p22(o(X,1)),p22(o(X,2)),p22(o(X,3))],dyn([],[])).
rule(t24,p22(X),[],[p23(X)],dyn([],[])).
rule(t25,p23(o(X,_Y)),[],[p24(X),p23r(X)],dyn([doesnt_contain(constr(p23r(X),true))],[])).
rule(t25a,p23(o(X,_Y)),[],[],dyn([contains(constr(p23r(X),true))],[])).
rule(t25b,p23r(X),[],[],dyn([doesnt_contain(constr(p22(o(X,_)),true))],[])).

% 6) multi choice + synchronized merge
/* The synchronized merge of t28 is similar to that of t22.  The "new"
   thing here is the multi-choice of t26.  Im being a little lazy
   here, but Ill change it.  In multi-choice, rather than adding
   instances determined at run-time to static places (as with t20) we
   need to move the X token to a number of places.  This is indicated
   by the dynamic insert that adds p25(1,X) and p25(3,X) for cond1(1)
   and cond1(3).  It would be better to have renamed this as p25_1(X)
   and p25_3(X), and Ill do so.
*/

rule(t26,p24(X),[],[p25(1,X)],dyn([],[insert(p25(C,X),cond1(C))])).
rule(t27,p25(C,X),[],[p26(C,X)],dyn([],[])).
rule(t28,p26(_,X),[],[p27(X)],dyn([doesnt_contain(constr(p25(_,X),true))],[delete(p26(_,_))])).
 
% 15) mult. instances  w.o. run time knowledge (+ synchronized merge)
/* I could probably redo this one.  WCP 15 differs from WCP 14 in that
   the instances in 14 are created all at the same time, while in 15
   "it is possible for additional instances to be initiated".
   However, this synchronizing merge is strong enough to handle either
   case, as it always checks for instances throughout the subnet of
   interest.  */
rule(t29,p27(X),[],[],dyn([],[insert(p28(o(X,I)),p19_gen(I))])).
rule(t30,p28(X),[],[p29(X)],dyn([],[])).
rule(t31,p28(o(X,I)),[],[p29(o(X,I))],dyn([],[insert(p28(o(X,J)),t31_gen(J))])).
rule(t32,p29(o(X,_I)),[],[p30(X)],dyn([doesnt_contain(constr(p28(_),true))],[delete(p29(_))])).

% 16) Deferred choice
/* Like multi-choice, except exclusive.  So rather than a dynamic call
   to tell you which set of places to put the token in, you can simply
   decide based on whether the dynamic predicate is tre of false. */

rule(t33,p30(X),[],[p31(X)],dyn([condition(t33_cond(1))],[])).
rule(t34,p30(X),[],[p32(X)],dyn([condition(\+ t33_cond(1))],[])).

% 17) Interleaved parallel routing -- numerous instances above.  
% The CPN diagram on pg. 35 appears incorrect (althought I dont know what
% arc labels () and c mean).  Can be done with simple nets.

% 18) Milestone -- 36 may or may not be reachable, depending on
% whether p33m is consumed by t38 or by t37
rule(t35,p32(X),[],[p33(X),p34(X)],dyn([],[])).
rule(t36,p33(X),[],[p33m(X)],dyn([],[])).
rule(t37,p33m(X),[],[p33m1(X)],dyn([],[])).
rule(t38,p33m(X),[p34(X)],[p33m1(X),p35(X)],dyn([],[])).
rule(t39,p33m1(X),[p35(X)],[p36(X)],dyn([],[])).

% 19) Cancel Activity
/* Given the dynamic effect "delete", cancellation is relatively
  simple.  Here Im modeling an activity as a a marking.  the "dummy"
  is for testing, just to make sure I only cancel activities for X. */
rule(t40,p36(X),[],[p37(X),p38(X),p37(dummy)],dyn([],[])).
rule(t40,p38(X),[],[p39(X)],dyn([],[delete(p37(X))])).

% 20) Cancel Case
/* Here a case is a set of instances for an object within a set of
   places.  This is handled by deletes.  I think that there is a bug
   here, and the deletes should have been
   delete(p40(o(X,_))),delete(p41(o(X,_))), but the general mechanism
   works fine. */
rule(t41,p39(X),[],[],dyn([],[insert(p40(o(X,J)),p19_gen(J))])).
rule(t42,p40(X),[],[p41(X)],dyn([],[])).
rule(t43,p40(X),[],[p42(X)],dyn([],[delete(p40(_)),delete(p41(_))])).

%21) Structured Loop
/* Here I've set up structloop and structloop_cond to go around the
   loop exactly once.  But the point is that if you have dynamic
   conditions, a structured loop is easy. */
rule(t44,p42(X),[],[p43(X)],dyn([condition(\+ structloop)],[])).
rule(t45,p42(X),[],[p44(X)],dyn([condition(structloop_cond)],[])).
rule(t46,p43(X),[],[p42(X)],dyn([],[])).

%22) Recursion
/* Here I'm modelling recursion by allowing subinstances to be made of
   arbitrary depth.  Note that it is in this case that we may lose the
   bounded term depth property. */
rule(t47,p44(X),[],[p44(o(X,1)),p45(X)],dyn([condition(recurse(X))],[])).
rule(t48,p44(o(X,1)),[],[p45(o(X,1)),p45a(o(X,1))],dyn([condition(\+ recurse(o(X,1)))],[])).
rule(t49,p45(o(X,1)),[p45a(o(X,1))],[p45a(X)],dyn([],[])).
rule(t50,p45(X),[p45a(X)],[p46(X)],dyn([condition(atomic(X))],[])).

% 25) Cancel Region -- essentailly the same as Cancel Case
% 26) Cancel Multiple Instances  -- essentailly the same as Cancel Case

% 27) Complete Multiple Instances
/* Completion differs from cancellation in that all instances that
   are "cancelled" are marked as complete.  So we use the delete as
   with cancel, but we also insert a pcomplete(o(X,I)) for each o(X,I)
   in p47 or p48. */
rule(t51,p46(X),[],[],dyn([],[insert(p47(o(X,I)),p19_gen(I))])).
rule(t52,p47(X),[],[p48(X)],dyn([],[])).
rule(t53,p48(o(X,_I)),[],[p49(X)],dyn([],
	                              [insert(pcomplete(o(X,I)),exists(p47(o(X,I)))),
				       insert(pcomplete(o(X,I)),exists(p48(o(X,I)))),
				       delete(p47(o(X,_))),delete(p48(o(X,_)))])).

% 28) Blocking Discriminator
/* This is like a structured discriminator except that it blocks any
   more instances of X from entering a region after the first X has
   reached the discriminator.  This is handled by the p49b blocker,
   which prevents rule t54 from firing as soon as the discriminator,
   t56 is hit.  t56a and t56b are the standard structured
   discriminator rules, although p49b(X) is added to t56b, ensuring
   that when the discriminator is reset, the blocker is removed. */
rule(t54,p49(X),[],[p50(o(X,1)),p50(o(X,2)),p50(o(X,3))],dyn([doesnt_contain(constr(p49b(X),true))],[])).
rule(t55,p50(X),[],[p51(x)],dyn([],[])).
rule(t56,p51(o(X,_Y)),[],[p49b(X),p51r(X),p52(X)],dyn([doesnt_contain(constr(p51r(X),true))],[])).
rule(t56a,p51(o(X,_Y)),[],[],dyn([contains(constr(p51r(X),true))],[])).
rule(t56b,p49b(X),[p51r(X)],[],dyn([doesnt_contain(constr(p50(o(X,_)),true)),
                                    doesnt_contain(constr(p51(o(X,_)),true))],[])).

% 29) Cancelling Discriminator
% perhaps should be used with blocking as well?
/* When this discriminator is reached by a subinstance, it cancels all
   the other subinstances that have not yet reached it.  From our
   point of view its not that different from the cancellation patterns
   -- the difference seems to be one of intent rather than
  implementation */
rule(t57,p52(X),[],[p53(o(X,1)),p53(o(X,2)),p53(o(X,3))],dyn([],[])).
rule(t58,p53(X),[],[p54(X)],dyn([],[])).
rule(t59,p54(o(X,_Y)),[],[p55(X)],dyn([],[delete(p53(o(X,_))),delete(p54(o(X,_)))])).

% 30) Structured Partial Join (M of N)
% This example is actually more closely related to 34 in that I'm
% using instances.  Could be rewritten to use different branches
% (i.e. have t60 create p56, p57 and p58 instead of instances.
/* Similar to our discriminators, but here we have to make sure that M
  of N instances have reached the discriminator (where M is static).
  The only difference here is the "contains_at_least" condition in
  t62.  */
rule(t60,p55(X),[],[p56(o(X,1)),p56(o(X,2)),p56(o(X,3))],dyn([],[])).
rule(t61,p56(X),[],[p57(X)],dyn([],[])).
rule(t62,p57(o(X,_Y)),[],[p58(X),p58r(X)],dyn([contains_at_least(p57(o(X,_)),2)],
	                                      [delete(p57(o(X,_)))])).
rule(t63a,p57(o(X,_Y)),[],[],dyn([contains(constr(p58r(X),true))],[])).
rule(t63b,p58r(X),[],[],dyn([doesnt_contain(constr(p56(o(X,_)),true)),
                             doesnt_contain(constr(p57(o(X,_)),true))],[])).

% 31) Blocking Partial Join 
% combination of blocker (28) and structured partial join (30)

% 32) Cancelling Partial Join 
% combination of cancelling (29) and structured partial join (30)

% 33) Generalized AND Join
% Working a little differently in that all tokens are unique, and
% based on ENs.
/* Here the idea is that when a group of tokens reaches a place, we
  can fire a rule, and when subsequent groups reach the place, the
  rule may be fired again.  This can be done with simple unification,
  but it could also be one by dynamic conditions *.
rule(t64,p58(X),[],[p59(o(X,o(1,1))),p59(o(X,o(2,1))),p59(o(X,o(3,1))),
	            p59(o(X,o(1,2))),p59(o(X,o(2,2))),p59(o(X,o(3,2)))],dyn([],[])).
rule(t65,p59(o(X,o(1,_))),[p59(o(X,o(2,_))),p59(o(X,o(3,_)))],[p60(X)],dyn([],[])).
rule(t66,p60(X),[],[p61(X)],dyn([],[])).

% 34) Static Partial Join for Multiple Instances
% 35) Cancelling Partial Join for Multiple Instances

% 36) Dynamic Partial Join for Multiple Instances
/* Like 30, but here the M in M of N is dynamic -- and modeled by
   t68_cutoff.  This is actually a discriminating DBJwMI */
rule(t67,p62(X),[],[p63(o(X,1)),p63(o(X,2)),p63(o(X,3))],dyn([],[])).
rule(t68,p63(X),[],[p64(X)],dyn([],[])).
rule(t69,p64(o(X,_Y)),[],[p65(X),p65r(X)],dyn([contains_at_least(p64(o(X,_)),t69_cutoff(_))],
	                                      [delete(p64(o(X,_)))])).
rule(t69a,p64(o(X,_Y)),[],[],dyn([contains(constr(p65r(X),true))],[])).
rule(t69b,p65r(X),[],[],dyn([doesnt_contain(constr(p63(o(X,_)),true)),
                             doesnt_contain(constr(p64(o(X,_)),true))],[])).

/* Need to model */
% 37) Acyclic Synchronizing Merge
% 38) General Synchronizing Merge


% 40) Interleaved Routing
% 43) Explicit Termination -- Same mechanism as completing multiple
% instances.

end_of_file.

Here is a documented version of wf.P.  In going through things I found
a few small bugs and remembered that I ran out of stea before wcp 37
and 38.  But things still seem correct.

I don't know if you want to talk about this with the group or
separately (or at all).  I should be fairly open tomorrow.

Terry

