Todo list:

* modulo goalgen
** en field_grid.pl predicado distance_between(Cell1,Cell2,Distance), calcula la
distancia menor entre las dos celdas. Hay que implementarlo bien
porque calcula varias distancias. Una alternativa podría ser utilizar
búsqueda.
** Hacer que busque un meta cercana al objetivo final (meter goles).
Si el robot esta llevando la pelota, hacer que la lleve al arco
Si el robot no esta llevando la pelota, hacer que la vaya a buscar.

find_new_goals(Goal):-
	current_perceptions(P),
	hasball(P),
	%dar una meta a distancia DB del robot hacia el arco.

find_new_goals(Goal):-
	current_perceptions(P),
	%dar una meta a distancia DB del robot hacia la pelota.
	


hasball(P) :-
	member(carrying(_,_),P).





*  B 40  3  Call: continuous_pop:remove_flaw(plan([act(654,move(kula,cell(25,19),cell(24,18))),act(632,move(kula,cell(24,18),cell(23,17))),act(442,move(kula,cell(23,17),cell(22,16))),act(3,move(kula,cell(22,16),cell(21,15))),act(2,move(kula,cell(21,15),cell(20,15))),act(1,move(kula,cell(...),cell(...))),act(finish,end),act(...)],[start<finish,1<finish,start<1,2<finish,2<1,start<2,3<finish,... < ...|...],[cl(start,waiting_at(kula,cell(25,19)),654),cl(654,waiting_at(kula,cell(24,18)),632),cl(632,waiting_at(kula,cell(23,17)),442),cl(442,waiting_at(kula,cell(22,16)),3),cl(3,waiting_at(kula,cell(21,15)),2),cl(2,waiting_at(kula,cell(...)),1),cl(1,waiting_at(...),finish)],[goal(valid_move(cell(25,19),cell(24,18)),654)],[]),6,_6833,_6834) ? s
 B 40  3  Fail: continuous_pop:remove_flaw(plan([act(654,move(kula,cell(25,19),cell(24,18))),act(632,move(kula,cell(24,18),cell(23,17))),act(442,move(kula,cell(23,17),cell(22,16))),act(3,move(kula,cell(22,16),cell(21,15))),act(2,move(kula,cell(21,15),cell(20,15))),act(1,move(kula,cell(...),cell(...))),act(finish,end),act(...)],[start<finish,1<finish,start<1,2<finish,2<1,start<2,3<finish,... < ...|...],[cl(start,waiting_at(kula,cell(25,19)),654),cl(654,waiting_at(kula,cell(24,18)),632),cl(632,waiting_at(kula,cell(23,17)),442),cl(442,waiting_at(kula,cell(22,16)),3),cl(3,waiting_at(kula,cell(21,15)),2),cl(2,waiting_at(kula,cell(...)),1),cl(1,waiting_at(...),finish)],[goal(valid_move(cell(25,19),cell(24,18)),654)],[]),6,_6833,_6834) ? 

* TODO en azul.pl initialplan me esta andando mal, porque planifica con la
representacion vieja de la cancha, de 3x3.
Habría que ejecutar :
	update_effects(P1),
	retract_fact(perception(P1)),

para que actualize los holds(X,init).

** DONE Por ahora los pongo en la representacion soccer_strips, primero calcular
la posicion inicial de la pelota y de kula mediante ejecucion de
field_grid y logViewer,
y luego poner esos hechos en soccer_strips.pl
** TODO El plan inicial seguramente va a fallar, habría que buscar alguna alternativa
para que no falle. ¿Y si yo armo un plan inicial mas corto? 
¿y si en generacion de metas pongo niveles de metas? es decir la meta
suprema o con menor prioridad debería ser meteer el gol, llamemosle
target.
Pero para cumplirla, antes debería moverme cerca de la pelota, luego,
tomar la pelota, luego llevarla cerca del arco, y luego patear al
arco.
Podría poner todas esas metas en orden, o bien ponerle un peso segun
prioridad, y que las de menor peso se tengan que cumplir primero.
*** From pref-icaps05.pdf
Abstract: In classical planning, the planner is given a concrete goal; it
returns a plan for it or a failure message. In the latter case,
the user can either quit or modify the goal. For many appli-
cations, it is more convenient to let the user provide a more
elaborate specication consisting of constraints and prefer-
ences over possible goal states. Then, let the system dis-
cover a plan for the most desirable among the feasible goal
states. 


Otra manera, es que si plan inicial falla, que siga con otra
alternativa del predicado juego que no tenga en cuenta el plan inicial, pero que
siempre este ejecutando update_effects, y así en cada ciclo, intente
armar un plan inicial. (Para esto el predicado juego no debería tener
el bucle repeat.. fail, sino que deberí llamarse recursivamente).



*** La alternativa que utilicé, fue meter una serie de metas para poder tener 
planes de longitud 6. Tengo que debuguear el continuous porque en
algun momento se traba esperando una nueva accion (o bien una nueva
percepcion).
O está fallando perceptions.pl al calcular las nuevas percepciones o
está fallando el planificador en algún momento. 
**** VER cpop.log para debuguear con esas percepciones.
* Me da la impresion de que en el bucle repeat .. fail
 envia dos veces cuando es noop, porque llega al fail y prueba la otra
 alternativa que es 
	   (Action == noop,
	    ListaVelocidadesAux = ListaVelocidades
	   ;
	    get_planned_player(N),
	    insert_action_to_strategy(Lv,Rv,N,ListaVelocidadesAux,ListaVelocidades)
	   ),

tiene exito, insertando 0,0 en la estrategia. Eso seguramente causa
que el robot se frene, es decir primero ejecuta la estrategia reactiva
pero en el ciclo inmediatamente posterior se frena.

** Tal vez debería hacer llamar recursivamente a juego en vez de repeat
.. fail.

* Ver que hacemos con el limite de profundidad del plan, ya con limite 6, 
tarda bastante en resolverlo, y para la representacion que tenemos de
23x28,
si tuviese que hacer un plan largo no podría.

** Por ahora tengo varias metas que me garantizan planes cortos de 6 acciones.

* DONE Ver que pasa cuando falla el plan
**  B 57  3  Fail: continuous_pop:remove_flaw(plan([act(5,grabBall(kula,ball,cell(2,2))),act(4,move(kula,cell(2,2),cell(1,2))),act(2,kick(kula,ball,cell(1,2),oppGoal)),act(finish,end),act(start,init)],[start<finish,2<finish,start<2,4<finish,4<2,start<4,5<finish,... < ...|...],[cl(start,waiting_at(kula,cell(2,2)),5),cl(start,waiting_at(ball,cell(2,2)),5),cl(start,waiting_at(kula,cell(2,2)),4),cl(5,carrying(kula,ball),2),cl(4,waiting_at(kula,cell(1,2)),2),cl(2,waiting_at(ball,oppGoal),finish)],[],[]),7,_3518,_3519) ? l
    utilizar trycpop con breakpoint en remove_flaw, debuguear pop.pl
    tambien, el predicado solve_open_preconditions, que es el que
    falla.
    Parece que como no hay plan posible, falla, y se pudre todo.
*** DONE La mejor solución, creo que sería implementar un
    módulo para buscar nuevas metas, es decir que cuando no encuentra
    plan, lo descarta, busca nuevas metas, busca un plan inicial, y
    denuevp ejecuta el bucle del planificador continuo.
    La idea es dejar un módulo muy sencillo, que incluso para
    simplificarlo me de siempre la misma meta. Si luego necesita
    extenderse con mas inteligencia, eso lo dejamos abierto como
    trabajo a futuro.

* [#A] http://www.removingalldoubt.com/CategoryView.aspx/Prolog
  http://starbase.trincoll.edu/~ram/cpsc352/notes/prolog/knightstour.html

           -- REGTYPE: table/1:
               A table is a list of rows, each row must contain the
               same number of elements, otherwise the table wouldn't
               be regular and an exception will be thrown by the
               library. The rows list may not be empty.
                    table([X]) :-
                            row(X) .
                    table([X|Xs]) :-
                            row(X),
                            table(Xs) .


 
* DONE Hacer que la grilla del campo sea con cuadros mas chicos.
  Ideal sería hacerlas de tamaño igual a la longitud del robot.



* TODO arreglar para que pop entienda relaciones de prolog
198  6  Call: pop:verifystatic([neighbor(cell(_16754,_16755),cell(5,3))]) ?
   199  7  Call: basiccontrol:,(internals:rt_module_exp(neighbor(cell(_16754,_16755),cell(5,3)),goal,pop,-,true,_17068),hiord_rt:call(_17068)) ? 
{ERROR: illegal arithmetic expression}
{ERROR: illegal arithmetic expression}
{ERROR: illegal arithmetic expression}
{ERROR: illegal arithmetic expression}
{ERROR: illegal arithmetic expression}
{ERROR: illegal arithmetic expression}
{ERROR: illegal arithmetic expression}
{ERROR: illegal arithmetic expression}
   199  7  Fail: basiccontrol:,(internals:rt_module_exp(neighbor(cell(_16754,_16755),cell(5,3)),goal,pop,-,true,_17068),hiord_rt:call(_17068)) ? a


** Lo arregle haciendo que neigbor se resuelva con fd (dominios finitos),
entonces no quedan variables libres del lado izquierdo del predicado.

** Otra opcion sería, en select dejar pasar el operador << y
y ponerlo en inequality_constraits(DIC) como lo hace con \=, haciendo
que neighbor deje variables libres(sin fd), y luego las unifique pop.
(cambiando inequality_constrits por otro predicado que se llame sólo
constratis o algo así).

 

* hacer que representacion en strips acepte relaciones estáticas,
   (ver slides_planing_relations.pdf)
  o bien que adjacent sea inferido, idem con in_reach (+ - X
  casilleros)
  Agregue un predicado en dentro se select para verificar relaciones
  estáticas, con predicados prolog normales.


* TODO field_grid.pl hacer que oppGoal y ownGoal, sean relativos al equipo elegido.
  Ahora asume que oppGoal es el arco bajo, y ownGoal es el arco alto.
* Debuguear el siguiente error
**  B 57  3  Fail: continuous_pop:remove_flaw(plan([act(5,grabBall(kula,ball,cell(2,2))),act(4,move(kula,cell(2,2),cell(1,2))),act(2,kick(kula,ball,cell(1,2),oppGoal)),act(finish,end),act(start,init)],[start<finish,2<finish,start<2,4<finish,4<2,start<4,5<finish,... < ...|...],[cl(start,waiting_at(kula,cell(2,2)),5),cl(start,waiting_at(ball,cell(2,2)),5),cl(start,waiting_at(kula,cell(2,2)),4),cl(5,carrying(kula,ball),2),cl(4,waiting_at(kula,cell(1,2)),2),cl(2,waiting_at(ball,oppGoal),finish)],[],[]),7,_3518,_3519) ? l
    utilizar trycpop con breakpoint en remove_flaw, debuguear pop.pl
    tambien, el predicado solve_open_preconditions, que es el que
    falla.
    Parece que como no hay plan posible, falla, y se pudre todo.

*** buscar plan para perceptions
[waiting_at(kiñe,cell(4,2)),waiting_at(epu,cell(3,1)),waiting_at(kula,cell(2,2)),waiting_at(meli,cell(2,1)),waiting_at(kechu,cell(2,3)),waiting_at(ball,cell(1,2))]

*** modulo perceptions no tiene en cuenta oppGoal MAL!!

*** Analizar que sucede si el plan falla,
    
**** Una opcion es devolver el mismo plan y la accion noop.
**** Otra es devolver, un plan vacio, como si se hubiesen alcanzado las metas
**** Otra es ejecutar nuevamente solve, para obtener un plan pop con las nuevas percepciones.
     No se si sirve, porque me parece que es lo mismo, no hay plan
     para esas percepciones. Hacer prueba con las percepciones de
     arriba y pop clasico.



** Buscar otra meta para futbol de robots que no tenga en cuenta la pelota, a lo mejor ya intentarlo con varios robots.
** Buscar otro ejemplo con el simulador para mover un robot de acuerdo a un plan.
** Se cuelga cuando cambia la percepcion de la pelota. Probar.Debuguear.
** DONE 388  7  Call: continuous_pop:remove_flaw(plan([act(2,kick(kula,ball,cell(1,2),oppGoal)),act(finish,end),act(start,init)],[start<finish,2<finish,start<2],[cl(start,carrying(kula,ball),2),cl(2,waiting_at(ball,oppGoal),finish)],[goal(waiting_at(kula,cell(1,2)),2)],[_4768\=_4769]),7,_35237,_35238) ? s

***    408  8  Call: pop:solve_open_preconditions(plan([act(2,kick(kula,ball,cell(1,2),oppGoal)),act(finish,end),act(start,init)],[start<finish,2<finish,start<2],[cl(start,carrying(kula,ball),2),cl(2,waiting_at(ball,oppGoal),finish)],[goal(waiting_at(kula,cell(1,2)),2)],[_4768\=_4769]),plan(_26449,_26450,_26451,_26452,[_4768\=_4769]),7) ? s
{ERROR: Memory allocation failed [in Realloc()]}
{ Execution aborted }

Me parece que se debe al caso que agregue de select cuando la agenda
esta vacía.
Habría que verificar que el siguiente predicado ande bien para cuando
la agenda este vacía y devuelva el plan.

solve_open_preconditions(Plan,Plan,_):-
   agenda(Plan,[]),
   inequality_constraints(Plan,DIC),
   all_constraints_satisfied(DIC).



** DONE Agregue predicado jugador en execute action para ver si anda ahora. Debug!!!
** DONE 19  4  Call: actions:execute_action(move(kula,cell(3,3),cell(2,3)),_1051,_1052) ?
{ERROR (/usr/local/bin/ciaosh-1.13, goal 1, thread b7dd86b0/-1210218832): illegal arithmetic expression}
{ERROR (/usr/local/bin/ciaosh-1.13, goal 1, thread b7dd86b0/-1210218832): illegal arithmetic expression}
   19  4  Fail:
   actions:execute_action(move(kula,cell(3,3),cell(2,3)),_1051,_1052)
   ? a

* LPDoc en los nuevos predicados.
   Falta LPDoc en los predicados de los módulos configuration,
   video_parser, command_server.


* TODO Refactorizar configuration.pl en varios módulos
  Cada módulo que utiliza a configuration.pl
   (:-use_module(configuration)) implica que el predicado start (:-
   initialization(start)) se ejecuta una vez por cada uno de esos
   módulos.
    - ¿Esto es así?
    - ¿No deberíamos dividir en varios modulos de configuracion,
       por ejemplo configuration-server, configuration-enviroment y
       configuration-team? 
** Algunas alternativas para que no se haga assert del mismo hecho varias veces.

*** hacer retract_all_facts de cada predicado data antes de assert
*** dividir en varios módulos de configuracion, como se sugirió más arriba.

* Optimizar asignacion_rol y asignacion_robot en estrategia.pl
   Estos predicados hacen uso de informacion repetida que ya se podría
   obtener de configuration.pl, o no ser que se quiera tener cambios
   de asignaciones dinámicas.



* Permitir asignacion de roles dinámicas.
   Al pasar los roles al archivo de configuración config.xml estos
   pasan a ser estáticos durante la ejecución puesto que la
   configuracion se lee una vez al iniciar.
   Se podría sobrescribir el hecho asertado con set_fact.



