/* soapC.cpp
   Generated by the gSOAP Stub and Skeleton Compiler for C and C++ 2.1.6b
   Copyright (C) 2001-2002 Robert A. van Engelen, Florida State University.
   All rights reserved.
*/
#include "soapH.h"

SOAP_FMAC1 void SOAP_FMAC2 soap_serializeheader(struct soap *soap)
{
	soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->is_in_header = 1;
		soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL);
		soap->is_in_header = 0;
	}
}

SOAP_FMAC1 int SOAP_FMAC2 soap_getheader(struct soap *soap)
{
	soap->is_in_header = 1;
	soap->header = soap_get_SOAP_ENV__Header(soap, NULL, "SOAP-ENV:Header", NULL);
	soap->is_in_header = 0;
	return soap->header == NULL;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serializefault(struct soap *soap)
{
	soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_putfault(struct soap *soap)
{
	soap_out_SOAP_ENV__Fault(soap, "SOAP-ENV:Fault", 0, soap->fault, NULL);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC1 const char ** SOAP_FMAC2 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC1 const char ** SOAP_FMAC2 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC1 const char ** SOAP_FMAC2 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	return (const char**)&soap->fault->detail;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_getindependent(struct soap *soap)
{
	for (;;)
	{	if (soap_peek_element(soap) || !*soap->id)
			break;
		switch (soap_lookup_type(soap, soap->id))
		{
		case SOAP_byte:
			soap_in_byte(soap, NULL, NULL, "");
			break;
		case SOAP_int:
			soap_in_int(soap, NULL, NULL, "");
			break;
		case SOAP_float:
			soap_in_float(soap, NULL, NULL, "");
			break;
		case SOAP_SOAP_ENV__Fault:
			soap_in_SOAP_ENV__Fault(soap, NULL, NULL, "");
			break;
		case SOAP_SOAP_ENV__Header:
			soap_in_SOAP_ENV__Header(soap, NULL, NULL, "");
			break;
		case SOAP_ns__getQuote:
			soap_in_ns__getQuote(soap, NULL, NULL, "ns:getQuote");
			break;
		case SOAP_ns__getQuoteResponse:
			soap_in_ns__getQuoteResponse(soap, NULL, NULL, "ns:getQuoteResponse");
			break;
		case SOAP_string:
			soap_in_string(soap, NULL, NULL, "");
			break;
		default:
			soap_in_ns__getQuote(soap, NULL, NULL, "ns:getQuote");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_ns__getQuoteResponse(soap, NULL, NULL, "ns:getQuoteResponse");
			if (soap->error)
			{	soap->peeked = 1;
				soap_ignore_element(soap);
			}
		}
		if (soap->error)
			break;
	}
	if (soap->error == SOAP_NO_TAG)
		soap->error = SOAP_OK;
	return soap->error;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->enable_embedding || soap->disable_href)
		return;
	for (i = 0; i < SOAP_PTRHASH; i++)
		for (pp = soap->pht[i]; pp; pp = pp->next)
			if (soap->counting ? pp->mark1 == 2 : pp->mark2 == 2)
				switch (pp->type & 0x3FF)
				{
				case SOAP_byte:
					soap_out_byte(soap, "id", pp->id, (const char *)pp->ptr, "");
					break;
				case SOAP_int:
					soap_out_int(soap, "id", pp->id, (const int *)pp->ptr, "");
					break;
				case SOAP_float:
					soap_out_float(soap, "id", pp->id, (const float *)pp->ptr, "");
					break;
				case SOAP_SOAP_ENV__Fault:
					soap_out_SOAP_ENV__Fault(soap, "id", pp->id, (const struct SOAP_ENV__Fault *)pp->ptr, "");
					break;
				case SOAP_SOAP_ENV__Header:
					soap_out_SOAP_ENV__Header(soap, "id", pp->id, (const struct SOAP_ENV__Header *)pp->ptr, "");
					break;
				case SOAP_ns__getQuote:
					soap_out_ns__getQuote(soap, "id", pp->id, (const struct ns__getQuote *)pp->ptr, "ns:getQuote");
					break;
				case SOAP_ns__getQuoteResponse:
					soap_out_ns__getQuoteResponse(soap, "id", pp->id, (const struct ns__getQuoteResponse *)pp->ptr, "ns:getQuoteResponse");
					break;
				case SOAP_string:
					soap_out_string(soap, "id", pp->id, (char**)&pp->ptr, "");
					break;
				}
		
	
}

SOAP_FMAC1 int SOAP_FMAC2 soap_getattachments(struct soap *soap)
{
	if (!soap->dime)
		return SOAP_OK;
	while (soap->dime_flags&SOAP_DIME_CF)
	{	if (soap_getdimehdr(soap))
			return soap->error;
		if (soap_move(soap, soap->dime_size))
			return soap->error = SOAP_EOF;
	}
	if (soap_move(soap, ((soap->dime_size+3)&-4)-soap_tell(soap)))
		return soap->error = SOAP_EOF;
	for (;;)
	{	if (soap_getdime(soap) || !soap->dime_id)
			break;
		switch (soap_lookup_type(soap, soap->dime_id))
		{
		case SOAP_string:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_string, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		default:
			soap->error = SOAP_DIME_ERROR;
		}
		if (soap->error)
			break;
	}
	if (soap->error == SOAP_EOD)
		soap->error = SOAP_OK;
	return soap->error;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_putattachments(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (!soap->dime)
		return;
	soap_send_raw(soap, "\0\0\0", -(int)soap->count&3);
	for (i = 0; i < SOAP_PTRHASH; i++)
		for (pp = soap->pht[i]; pp; pp = pp->next)
			if (pp->mark2 == 3)
				switch (pp->type & 0x3FF)
				{
				}
		
	
}

SOAP_FMAC1 void * SOAP_FMAC2 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType)
{
	switch (t)
	{
	}
	return NULL;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_delete(struct soap *soap, void *p, int t, int n)
{
	switch (t)
	{
	}
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_byte(struct soap *soap, char *a)
{
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_byte(struct soap *soap, char const*a)
{
	soap_reference(soap, a, SOAP_byte);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_byte(struct soap *soap, char *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_byte, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_byte(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_byte(soap, tag, i, a, type);
		}
	else
		soap_out_byte(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	soap_outbyte(soap, tag, id, a, type, SOAP_byte);
}

SOAP_FMAC1 char * SOAP_FMAC2 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * SOAP_FMAC2 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_byte);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_int(struct soap *soap, int *a)
{
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_int(struct soap *soap, int const*a)
{
	soap_reference(soap, a, SOAP_int);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_int(struct soap *soap, int *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_int, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_int(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_int(soap, tag, i, a, type);
		}
	else
		soap_out_int(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	soap_outint(soap, tag, id, a, type, SOAP_int);
}

SOAP_FMAC1 int * SOAP_FMAC2 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 int * SOAP_FMAC2 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_int);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_float(struct soap *soap, float *a)
{
#ifdef SOAP_DEFAULT_float
	*a = SOAP_DEFAULT_float;
#else
	*a = (float)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_float(struct soap *soap, float const*a)
{
	soap_reference(soap, a, SOAP_float);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_float(struct soap *soap, float *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_float, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_float(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_float(soap, tag, i, a, type);
		}
	else
		soap_out_float(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_float(struct soap *soap, const char *tag, int id, const float *a, const char *type)
{
	soap_outfloat(soap, tag, id, a, type, SOAP_float);
}

SOAP_FMAC1 float * SOAP_FMAC2 soap_get_float(struct soap *soap, float *p, const char *tag, const char *type)
{
	if ((p = soap_in_float(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 float * SOAP_FMAC2 soap_in_float(struct soap *soap, const char *tag, float *a, const char *type)
{
	return soap_infloat(soap, tag, a, type, SOAP_float);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault const*a)
{
	if (!soap_reference(soap, a, SOAP_SOAP_ENV__Fault))
		soap_mark_SOAP_ENV__Fault(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	soap_embedded(soap, &a->faultcode, SOAP_string);
	soap_mark_string(soap, &a->faultcode);
	soap_embedded(soap, &a->faultstring, SOAP_string);
	soap_mark_string(soap, &a->faultstring);
	soap_embedded(soap, &a->faultactor, SOAP_string);
	soap_mark_string(soap, &a->faultactor);
	soap_embedded(soap, &a->detail, SOAP_string);
	soap_mark_string(soap, &a->detail);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	soap_default_string(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	soap_default_string(soap, &a->detail);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_SOAP_ENV__Fault, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_SOAP_ENV__Fault(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_SOAP_ENV__Fault(soap, tag, i, a, type);
		}
	else
		soap_out_SOAP_ENV__Fault(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_SOAP_ENV__Fault), type);
	soap_out_string(soap, "faultcode", -1, &a->faultcode, "");
	soap_out_string(soap, "faultstring", -1, &a->faultstring, "");
	soap_out_string(soap, "faultactor", -1, &a->faultactor, "");
	soap_out_string(soap, "detail", -1, &a->detail, "");
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	short soap_flag_faultcode = 1, soap_flag_faultstring = 1, soap_flag_faultactor = 1, soap_flag_detail = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_SOAP_ENV__Fault(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode = 0;
					continue;
				}
			if (soap_flag_faultstring && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "faultstring", &a->faultstring, ""))
				{	soap_flag_faultstring = 0;
					continue;
				}
			if (soap_flag_faultactor && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "faultactor", &a->faultactor, ""))
				{	soap_flag_faultactor = 0;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "detail", &a->detail, ""))
				{	soap_flag_detail = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0), SOAP_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault));
		if (soap->alloced)
			soap_default_SOAP_ENV__Fault(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header const*a)
{
	if (!soap_reference(soap, a, SOAP_SOAP_ENV__Header))
		soap_mark_SOAP_ENV__Header(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	/* transient dummy skipped */
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	/* transient dummy skipped */
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_SOAP_ENV__Header, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_SOAP_ENV__Header(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_SOAP_ENV__Header(soap, tag, i, a, type);
		}
	else
		soap_out_SOAP_ENV__Header(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_SOAP_ENV__Header), type);
	/* transient dummy skipped */
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_SOAP_ENV__Header(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient dummy skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0), SOAP_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header));
		if (soap->alloced)
			soap_default_SOAP_ENV__Header(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_ns__getQuote(struct soap *soap, struct ns__getQuote const*a)
{
	if (!soap_reference(soap, a, SOAP_ns__getQuote))
		soap_mark_ns__getQuote(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_ns__getQuote(struct soap *soap, const struct ns__getQuote *a)
{
	soap_embedded(soap, &a->symbol, SOAP_string);
	soap_mark_string(soap, &a->symbol);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_ns__getQuote(struct soap *soap, struct ns__getQuote *a)
{
	soap_default_string(soap, &a->symbol);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_ns__getQuote(struct soap *soap, struct ns__getQuote *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_ns__getQuote, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_ns__getQuote(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_ns__getQuote(soap, tag, i, a, type);
		}
	else
		soap_out_ns__getQuote(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_ns__getQuote(struct soap *soap, const char *tag, int id, const struct ns__getQuote *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_ns__getQuote), type);
	soap_out_string(soap, "symbol", -1, &a->symbol, "");
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct ns__getQuote * SOAP_FMAC2 soap_get_ns__getQuote(struct soap *soap, struct ns__getQuote *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getQuote(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct ns__getQuote * SOAP_FMAC2 soap_in_ns__getQuote(struct soap *soap, const char *tag, struct ns__getQuote *a, const char *type)
{
	short soap_flag_symbol = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct ns__getQuote *)soap_id_enter(soap, soap->id, a, SOAP_ns__getQuote, sizeof(struct ns__getQuote), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_ns__getQuote(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_symbol && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "symbol", &a->symbol, ""))
				{	soap_flag_symbol = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getQuote *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_ns__getQuote, sizeof(struct ns__getQuote), 0), SOAP_ns__getQuote, sizeof(struct ns__getQuote));
		if (soap->alloced)
			soap_default_ns__getQuote(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_ns__getQuoteResponse(struct soap *soap, struct ns__getQuoteResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_ns__getQuoteResponse))
		soap_mark_ns__getQuoteResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_ns__getQuoteResponse(struct soap *soap, const struct ns__getQuoteResponse *a)
{
	soap_embedded(soap, &a->result, SOAP_float);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_ns__getQuoteResponse(struct soap *soap, struct ns__getQuoteResponse *a)
{
	soap_default_float(soap, &a->result);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_ns__getQuoteResponse(struct soap *soap, struct ns__getQuoteResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_ns__getQuoteResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_ns__getQuoteResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_ns__getQuoteResponse(soap, tag, i, a, type);
		}
	else
		soap_out_ns__getQuoteResponse(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_ns__getQuoteResponse(struct soap *soap, const char *tag, int id, const struct ns__getQuoteResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_ns__getQuoteResponse), type);
	soap_out_float(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct ns__getQuoteResponse * SOAP_FMAC2 soap_get_ns__getQuoteResponse(struct soap *soap, struct ns__getQuoteResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getQuoteResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct ns__getQuoteResponse * SOAP_FMAC2 soap_in_ns__getQuoteResponse(struct soap *soap, const char *tag, struct ns__getQuoteResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct ns__getQuoteResponse *)soap_id_enter(soap, soap->id, a, SOAP_ns__getQuoteResponse, sizeof(struct ns__getQuoteResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_ns__getQuoteResponse(soap, a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "result", &a->result, ""))
				{	soap_flag_result = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getQuoteResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_ns__getQuoteResponse, sizeof(struct ns__getQuoteResponse), 0), SOAP_ns__getQuoteResponse, sizeof(struct ns__getQuoteResponse));
		if (soap->alloced)
			soap_default_ns__getQuoteResponse(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_string(struct soap *soap, char **a)
{
	*a = NULL;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_string);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_string);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_string(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_string, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_string(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_string(soap, tag, i, a, type);
		}
	else
		soap_out_string(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	soap_outstring(soap, tag, id, a, type, SOAP_string);
}

SOAP_FMAC1 char ** SOAP_FMAC2 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * * SOAP_FMAC2 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_string);
}

/* end of soapC.cpp */
