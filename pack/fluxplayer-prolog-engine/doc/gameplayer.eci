:- module(gameplayer).
:- export game_start / 6.
:- export game_play / 4.
:- export game_stop / 3.
:- comment(summary, "contains the basic routines of a general game player to handle start, play, and stop messages").
:- comment(game_play / 4, [summary : "is called after receiving a play message of a match", args : ["MatchID" : "string containing the identifier of the current match", "Moves" : "the moves of the players in the last step", "MsgReceiveTime" : "time when the message was received (in seconds since start of the process)", "MoveString" : "the game description as a list of prolog rules"], amode : game_play(++, ++, ++, -), resat : no, fail_if : "None. Always succeed.", see_also : [game_start / 6, game_stop / 3, gdl_parser : convert_to_gdl_string / 2], desc : html("game_play/4 must return before the play clock times out, i.e., before MsgReceiveTime+PlayClock-{Time for sending messages}. MoveString must be instantiated to a string containing a legal move in gdl format.")]).
:- comment(game_play_timed_part / 2, [summary : "is called after receiving a play message of a match", args : ["CurrentState" : "the current state of the match in form of a list of fluents", "Role" : "the role name of this player"], amode : game_play_timed_part(++, ++), resat : no, fail_if : "None. Always succeed.", see_also : [game_play / 4, match_info : set_current_best_move / 1, compute_best_move : compute_best_move / 2], desc : html("game_play_timed_part/2 calls the search algorithm. game_play_timed_part/2 is called with timeout/3, that means it will be stopped automatically if the play clock is over. The best move found has to be stored using match_info:set_current_best_move/1.")]).
:- comment(game_start / 6, [summary : "is called after receiving the start message of a match", args : ["MatchID" : "string containing the identifier of the current match", "Role" : "the role name of this player", "Rules" : "the game description as a list of prolog rules", "StartClock" : "start clock in seconds", "PlayClock" : "play clock in seconds", "MsgReceiveTime" : "time when the message was received (in seconds since start of the process)"], amode : game_start(++, ++, +, ++, ++, ++), resat : no, fail_if : "None. Always succeed.", see_also : [game_start_timed_part / 2, game_play / 4, game_stop / 3], desc : html("game_start/6 must return before the start clock times out, i.e., before MsgReceiveTime+StartClock-{Time for sending messages}")]).
:- comment(game_start_timed_part / 2, [summary : "is called after receiving the start message of a match", args : ["InitialState" : "the initial state of the match in form of a list of fluents", "Role" : "the role name of this player"], amode : game_start_timed_part(++, ++), resat : no, fail_if : "None. Always succeed.", see_also : [game_start / 6, timeout : timeout / 3], desc : html("game_start_timed_part/2 should contain everything that is to be done within the start clock but that is not crucial for playing the game. game_start_timed_part/2 is called with timeout/3, that means it will be stopped automatically if the start clock is over.")]).
:- comment(game_stop / 3, [summary : "is called after receiving the stop message of a match", args : ["MatchID" : "string containing the identifier of the current match", "Moves" : "the moves of the players in the last step", "MsgReceiveTime" : "time when the message was received (in seconds since start of the process)"], amode : game_stop(++, ++, ++), resat : no, fail_if : "None. Always succeed.", see_also : [game_start / 6, game_play / 4], desc : html("game_stop/3 should contain all code necessary for cleaning up such that the player is ready for the next match.")]).
